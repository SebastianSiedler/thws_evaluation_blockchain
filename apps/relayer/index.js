"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// ../../node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../../node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// ../../node_modules/.pnpm/fastq@1.17.1/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../../node_modules/.pnpm/fastq@1.17.1/node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      if (!(_concurrency >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        get concurrency() {
          return _concurrency;
        },
        set concurrency(value) {
          if (!(value >= 1)) {
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          }
          _concurrency = value;
          if (self2.paused) return;
          for (; queueHead && _running < _concurrency; ) {
            _running++;
            release();
          }
        },
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused) return;
        self2.paused = false;
        if (queueHead === null) {
          _running++;
          release();
          return;
        }
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next && _running <= _concurrency) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, _concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// ../../node_modules/.pnpm/@fastify+error@4.0.0/node_modules/@fastify/error/index.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/@fastify+error@4.0.0/node_modules/@fastify/error/index.js"(exports2, module2) {
    "use strict";
    var { format } = require("node:util");
    function toString4() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    function createError(code, message, statusCode = 500, Base = Error) {
      if (!code) throw new Error("Fastify error code must not be empty");
      if (!message) throw new Error("Fastify error message must not be empty");
      code = code.toUpperCase();
      !statusCode && (statusCode = void 0);
      function FastifyError(...args) {
        if (!new.target) {
          return new FastifyError(...args);
        }
        this.code = code;
        this.name = "FastifyError";
        this.statusCode = statusCode;
        const lastElement = args.length - 1;
        if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
          this.cause = args.pop().cause;
        }
        this.message = format(message, ...args);
        Error.stackTraceLimit !== 0 && Error.captureStackTrace(this, FastifyError);
      }
      FastifyError.prototype = Object.create(Base.prototype, {
        constructor: {
          value: FastifyError,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      FastifyError.prototype[Symbol.toStringTag] = "Error";
      FastifyError.prototype.toString = toString4;
      return FastifyError;
    }
    module2.exports = createError;
    module2.exports.default = createError;
    module2.exports.createError = createError;
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/errors.js"(exports2, module2) {
    "use strict";
    var { createError } = require_error();
    module2.exports = {
      AVV_ERR_EXPOSE_ALREADY_DEFINED: createError(
        "AVV_ERR_EXPOSE_ALREADY_DEFINED",
        "'%s' is already defined, specify an expose option for '%s'"
      ),
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError(
        "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
        "'%s' is already defined"
      ),
      AVV_ERR_CALLBACK_NOT_FN: createError(
        "AVV_ERR_CALLBACK_NOT_FN",
        "Callback for '%s' hook is not a function. Received: '%s'"
      ),
      AVV_ERR_PLUGIN_NOT_VALID: createError(
        "AVV_ERR_PLUGIN_NOT_VALID",
        "Plugin must be a function or a promise. Received: '%s'"
      ),
      AVV_ERR_ROOT_PLG_BOOTED: createError(
        "AVV_ERR_ROOT_PLG_BOOTED",
        "Root plugin has already booted"
      ),
      AVV_ERR_PARENT_PLG_LOADED: createError(
        "AVV_ERR_PARENT_PLG_LOADED",
        "Impossible to load '%s' plugin because the parent '%s' was already loaded"
      ),
      AVV_ERR_READY_TIMEOUT: createError(
        "AVV_ERR_READY_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError(
        "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      )
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/symbols.js"(exports2, module2) {
    "use strict";
    var kAvvio = Symbol("avvio.Boot");
    var kIsOnCloseHandler = Symbol("isOnCloseHandler");
    var kThenifyDoNotWrap = Symbol("avvio.ThenifyDoNotWrap");
    var kUntrackNode = Symbol("avvio.TimeTree.untrackNode");
    var kTrackNode = Symbol("avvio.TimeTree.trackNode");
    var kGetParent = Symbol("avvio.TimeTree.getParent");
    var kGetNode = Symbol("avvio.TimeTree.getNode");
    var kAddNode = Symbol("avvio.TimeTree.addNode");
    var kPluginMeta = Symbol.for("plugin-meta");
    module2.exports = {
      kAvvio,
      kIsOnCloseHandler,
      kThenifyDoNotWrap,
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode,
      kPluginMeta
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/time-tree.js
var require_time_tree = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/time-tree.js"(exports2, module2) {
    "use strict";
    var {
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode
    } = require_symbols();
    var TimeTree = class {
      constructor() {
        this.root = null;
        this.tableId = /* @__PURE__ */ new Map();
        this.tableLabel = /* @__PURE__ */ new Map();
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kTrackNode](node) {
        this.tableId.set(node.id, node);
        if (this.tableLabel.has(node.label)) {
          this.tableLabel.get(node.label).push(node);
        } else {
          this.tableLabel.set(node.label, [node]);
        }
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kUntrackNode](node) {
        this.tableId.delete(node.id);
        const labelNode = this.tableLabel.get(node.label);
        labelNode.pop();
        if (labelNode.length === 0) {
          this.tableLabel.delete(node.label);
        }
      }
      /**
       * @param {string} parent
       * @returns {TimeTreeNode}
       */
      [kGetParent](parent) {
        if (parent === null) {
          return null;
        } else if (this.tableLabel.has(parent)) {
          const parentNode = this.tableLabel.get(parent);
          return parentNode[parentNode.length - 1];
        } else {
          return null;
        }
      }
      /**
       *
       * @param {string} nodeId
       * @returns {TimeTreeNode}
       */
      [kGetNode](nodeId) {
        return this.tableId.get(nodeId);
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number} start
       * @returns {TimeTreeNode["id"]}
       */
      [kAddNode](parent, label, start2) {
        const parentNode = this[kGetParent](parent);
        const isRoot = parentNode === null;
        if (isRoot) {
          this.root = {
            parent: null,
            id: "root",
            label,
            nodes: [],
            start: start2,
            stop: null,
            diff: -1
          };
          this[kTrackNode](this.root);
          return this.root.id;
        }
        const nodeId = `${label}-${Math.random()}`;
        const childNode = {
          parent,
          id: nodeId,
          label,
          nodes: [],
          start: start2,
          stop: null,
          diff: -1
        };
        parentNode.nodes.push(childNode);
        this[kTrackNode](childNode);
        return nodeId;
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number|undefined} start
       * @returns {TimeTreeNode["id"]}
       */
      start(parent, label, start2 = Date.now()) {
        return this[kAddNode](parent, label, start2);
      }
      /**
       * @param {string} nodeId
       * @param {number|undefined} stop
       */
      stop(nodeId, stop = Date.now()) {
        const node = this[kGetNode](nodeId);
        if (node) {
          node.stop = stop;
          node.diff = node.stop - node.start || 0;
          this[kUntrackNode](node);
        }
      }
      /**
       * @returns {TimeTreeNode}
       */
      toJSON() {
        return Object.assign({}, this.root);
      }
      /**
       * @returns {string}
       */
      prettyPrint() {
        return prettyPrintTimeTree(this.toJSON());
      }
    };
    function prettyPrintTimeTree(obj, prefix = "") {
      let result = prefix;
      const nodesCount = obj.nodes.length;
      const lastIndex = nodesCount - 1;
      result += `${obj.label} ${obj.diff} ms
`;
      for (let i = 0; i < nodesCount; ++i) {
        const node = obj.nodes[i];
        const prefix_ = prefix + (i === lastIndex ? "  " : "\u2502 ");
        result += prefix;
        result += i === lastIndex ? "\u2514\u2500" : "\u251C\u2500";
        result += node.nodes.length === 0 ? "\u2500 " : "\u252C ";
        result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
      }
      return result;
    }
    module2.exports = {
      TimeTree
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/debug.js"(exports2, module2) {
    "use strict";
    var { debuglog } = require("node:util");
    var debug = debuglog("avvio");
    module2.exports = {
      debug
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/create-promise.js
var require_create_promise = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/create-promise.js"(exports2, module2) {
    "use strict";
    function createPromise() {
      const obj = {
        resolve: null,
        reject: null,
        promise: null
      };
      obj.promise = new Promise((resolve, reject) => {
        obj.resolve = resolve;
        obj.reject = reject;
      });
      return obj;
    }
    module2.exports = {
      createPromise
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/get-plugin-name.js
var require_get_plugin_name = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/get-plugin-name.js"(exports2, module2) {
    "use strict";
    var { kPluginMeta } = require_symbols();
    function getPluginName(plugin, options) {
      if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
        return plugin[kPluginMeta].name;
      }
      if (options && options.name) {
        return options.name;
      }
      if (plugin.name) {
        return plugin.name;
      } else {
        return plugin.toString().split("\n").slice(0, 2).map((s2) => s2.trim()).join(" -- ");
      }
    }
    module2.exports = {
      getPluginName
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-promise-like.js
var require_is_promise_like = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-promise-like.js"(exports2, module2) {
    "use strict";
    function isPromiseLike(maybePromiseLike) {
      return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
    }
    module2.exports = {
      isPromiseLike
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/plugin.js
var require_plugin = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/plugin.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("node:events");
    var { inherits } = require("node:util");
    var { debug } = require_debug();
    var { createPromise } = require_create_promise();
    var { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = require_errors();
    var { getPluginName } = require_get_plugin_name();
    var { isPromiseLike } = require_is_promise_like();
    function Plugin(queue, func, options, isAfter, timeout) {
      this.queue = queue;
      this.func = func;
      this.options = options;
      this.isAfter = isAfter;
      this.timeout = timeout;
      this.started = false;
      this.name = getPluginName(func, options);
      this.queue.pause();
      this._error = null;
      this.loaded = false;
      this._promise = null;
      this.startTime = null;
    }
    inherits(Plugin, EventEmitter);
    Plugin.prototype.exec = function(server, callback) {
      debug("exec", this.name);
      this.server = server;
      const func = this.func;
      const name = this.name;
      let completed = false;
      this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
      let timer = null;
      const done = (execErr) => {
        if (completed) {
          debug("loading complete", name);
          return;
        }
        this._error = execErr;
        if (execErr) {
          debug("exec errored", name);
        } else {
          debug("exec completed", name);
        }
        completed = true;
        if (timer) {
          clearTimeout(timer);
        }
        callback(execErr);
      };
      if (this.timeout > 0) {
        debug("setting up timeout", name, this.timeout);
        timer = setTimeout(function() {
          debug("timed out", name);
          timer = null;
          const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
          readyTimeoutErr.fn = func;
          done(readyTimeoutErr);
        }, this.timeout);
      }
      this.started = true;
      this.startTime = Date.now();
      this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
      const maybePromiseLike = func(this.server, this.options, done);
      if (isPromiseLike(maybePromiseLike)) {
        debug("exec: resolving promise", name);
        maybePromiseLike.then(
          () => process.nextTick(done),
          (e2) => process.nextTick(done, e2)
        );
      } else if (func.length < 3) {
        done();
      }
    };
    Plugin.prototype.loadedSoFar = function() {
      debug("loadedSoFar", this.name);
      if (this.loaded) {
        return Promise.resolve();
      }
      const setup = () => {
        this.server.after((afterErr, callback) => {
          this._error = afterErr;
          this.queue.pause();
          if (this._promise) {
            if (afterErr) {
              debug("rejecting promise", this.name, afterErr);
              this._promise.reject(afterErr);
            } else {
              debug("resolving promise", this.name);
              this._promise.resolve();
            }
            this._promise = null;
          }
          process.nextTick(callback, afterErr);
        });
        this.queue.resume();
      };
      let res;
      if (!this._promise) {
        this._promise = createPromise();
        res = this._promise.promise;
        if (!this.server) {
          this.on("start", setup);
        } else {
          setup();
        }
      } else {
        res = Promise.resolve();
      }
      return res;
    };
    Plugin.prototype.enqueue = function(plugin, callback) {
      debug("enqueue", this.name, plugin.name);
      this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
      this.queue.push(plugin, callback);
    };
    Plugin.prototype.finish = function(err, callback) {
      debug("finish", this.name, err);
      const done = () => {
        if (this.loaded) {
          return;
        }
        debug("loaded", this.name);
        this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
        this.loaded = true;
        callback(err);
      };
      if (err) {
        if (this._promise) {
          this._promise.reject(err);
          this._promise = null;
        }
        done();
        return;
      }
      const check = () => {
        debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
        if (this.queue.length() === 0 && this.queue.running() === 0) {
          if (this._promise) {
            const wrap = () => {
              debug("wrap");
              queueMicrotask(check);
            };
            this._promise.resolve();
            this._promise.promise.then(wrap, wrap);
            this._promise = null;
          } else {
            done();
          }
        } else {
          debug("delayed", this.name);
          this.queue.drain = () => {
            debug("drain", this.name);
            this.queue.drain = noop;
            queueMicrotask(check);
          };
        }
      };
      queueMicrotask(check);
      this.queue.resume();
    };
    function noop() {
    }
    module2.exports = {
      Plugin
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/validate-plugin.js
var require_validate_plugin = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/validate-plugin.js"(exports2, module2) {
    "use strict";
    var { AVV_ERR_PLUGIN_NOT_VALID } = require_errors();
    function validatePlugin(maybePlugin) {
      if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
        if (Array.isArray(maybePlugin)) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("array");
        } else if (maybePlugin === null) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("null");
        } else {
          throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
        }
      }
    }
    module2.exports = {
      validatePlugin
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-bundled-or-typescript-plugin.js
var require_is_bundled_or_typescript_plugin = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/is-bundled-or-typescript-plugin.js"(exports2, module2) {
    "use strict";
    function isBundledOrTypescriptPlugin(maybeBundledOrTypescriptPlugin) {
      return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
    }
    module2.exports = {
      isBundledOrTypescriptPlugin
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/thenify.js
var require_thenify = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/thenify.js"(exports2, module2) {
    "use strict";
    var { debug } = require_debug();
    var { kThenifyDoNotWrap } = require_symbols();
    function thenify() {
      if (this.booted) {
        debug("thenify returning undefined because we are already booted");
        return;
      }
      if (this[kThenifyDoNotWrap]) {
        this[kThenifyDoNotWrap] = false;
        return;
      }
      debug("thenify");
      return (resolve, reject) => {
        const p = this._loadRegistered();
        return p.then(() => {
          this[kThenifyDoNotWrap] = true;
          return resolve(this._server);
        }, reject);
      };
    }
    module2.exports = {
      thenify
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/execute-with-thenable.js
var require_execute_with_thenable = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/lib/execute-with-thenable.js"(exports2, module2) {
    "use strict";
    var { isPromiseLike } = require_is_promise_like();
    var { kAvvio } = require_symbols();
    function executeWithThenable(func, args, callback) {
      const result = func.apply(func, args);
      if (isPromiseLike(result) && !result[kAvvio]) {
        result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
      } else if (callback) {
        process.nextTick(callback);
      }
    }
    module2.exports = {
      executeWithThenable
    };
  }
});

// ../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/boot.js
var require_boot = __commonJS({
  "../../node_modules/.pnpm/avvio@9.1.0/node_modules/avvio/boot.js"(exports2, module2) {
    "use strict";
    var fastq = require_queue();
    var EE = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var {
      AVV_ERR_EXPOSE_ALREADY_DEFINED,
      AVV_ERR_CALLBACK_NOT_FN,
      AVV_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_READY_TIMEOUT,
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
    } = require_errors();
    var {
      kAvvio,
      kIsOnCloseHandler
    } = require_symbols();
    var { TimeTree } = require_time_tree();
    var { Plugin } = require_plugin();
    var { debug } = require_debug();
    var { validatePlugin } = require_validate_plugin();
    var { isBundledOrTypescriptPlugin } = require_is_bundled_or_typescript_plugin();
    var { isPromiseLike } = require_is_promise_like();
    var { thenify } = require_thenify();
    var { executeWithThenable } = require_execute_with_thenable();
    function Boot(server, opts, done) {
      if (typeof server === "function" && arguments.length === 1) {
        done = server;
        opts = {};
        server = null;
      }
      if (typeof opts === "function") {
        done = opts;
        opts = {};
      }
      opts = opts || {};
      opts.autostart = opts.autostart !== false;
      opts.timeout = Number(opts.timeout) || 0;
      opts.expose = opts.expose || {};
      if (!new.target) {
        return new Boot(server, opts, done);
      }
      this._server = server || this;
      this._opts = opts;
      if (server) {
        this._expose();
      }
      this._current = [];
      this._error = null;
      this._lastUsed = null;
      this.setMaxListeners(0);
      if (done) {
        this.once("start", done);
      }
      this.started = false;
      this.booted = false;
      this.pluginTree = new TimeTree();
      this._readyQ = fastq(this, callWithCbOrNextTick, 1);
      this._readyQ.pause();
      this._readyQ.drain = () => {
        this.emit("start");
        this._readyQ.drain = noop;
      };
      this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
      this._closeQ.pause();
      this._closeQ.drain = () => {
        this.emit("close");
        this._closeQ.drain = noop;
      };
      this._doStart = null;
      const instance = this;
      this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server2, opts2, done2) {
        instance._doStart = done2;
        opts2.autostart && instance.start();
      }, opts, false, 0);
      this._trackPluginLoading(this._root);
      this._loadPlugin(this._root, (err) => {
        debug("root plugin ready");
        try {
          this.emit("preReady");
          this._root = null;
        } catch (preReadyError) {
          err = err || this._error || preReadyError;
        }
        if (err) {
          this._error = err;
          if (this._readyQ.length() === 0) {
            throw err;
          }
        } else {
          this.booted = true;
        }
        this._readyQ.resume();
      });
    }
    inherits(Boot, EE);
    Boot.prototype.start = function() {
      this.started = true;
      process.nextTick(this._doStart);
      return this;
    };
    Boot.prototype.override = function(server, func, opts) {
      return server;
    };
    Boot.prototype[kAvvio] = true;
    Boot.prototype.use = function(plugin, opts) {
      this._lastUsed = this._addPlugin(plugin, opts, false);
      return this;
    };
    Boot.prototype._loadRegistered = function() {
      const plugin = this._current[0];
      const weNeedToStart = !this.started && !this.booted;
      if (weNeedToStart) {
        process.nextTick(() => this._root.queue.resume());
      }
      if (!plugin) {
        return Promise.resolve();
      }
      return plugin.loadedSoFar();
    };
    Object.defineProperty(Boot.prototype, "then", { get: thenify });
    Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
      if (isBundledOrTypescriptPlugin(pluginFn)) {
        pluginFn = pluginFn.default;
      }
      validatePlugin(pluginFn);
      opts = opts || {};
      if (this.booted) {
        throw new AVV_ERR_ROOT_PLG_BOOTED();
      }
      const current = this._current[0];
      let timeout = this._opts.timeout;
      if (!current.loaded && current.timeout > 0) {
        const delta = Date.now() - current.startTime;
        timeout = current.timeout - (delta + 3);
      }
      const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
      this._trackPluginLoading(plugin);
      if (current.loaded) {
        throw new Error(plugin.name, current.name);
      }
      current.enqueue(plugin, (err) => {
        err && (this._error = err);
      });
      return plugin;
    };
    Boot.prototype._expose = function _expose() {
      const instance = this;
      const server = instance._server;
      const {
        use: useKey = "use",
        after: afterKey = "after",
        ready: readyKey = "ready",
        onClose: onCloseKey = "onClose",
        close: closeKey = "close"
      } = this._opts.expose;
      if (server[useKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
      }
      server[useKey] = function(fn, opts) {
        instance.use(fn, opts);
        return this;
      };
      if (server[afterKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
      }
      server[afterKey] = function(func) {
        if (typeof func !== "function") {
          return instance._loadRegistered();
        }
        instance.after(encapsulateThreeParam(func, this));
        return this;
      };
      if (server[readyKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
      }
      server[readyKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
        }
        return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
      };
      if (server[onCloseKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
      }
      server[onCloseKey] = function(func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
        }
        instance.onClose(encapsulateTwoParam(func, this));
        return this;
      };
      if (server[closeKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
      }
      server[closeKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
        }
        if (func) {
          instance.close(encapsulateThreeParam(func, this));
          return this;
        }
        return instance.close();
      };
      if (server.then) {
        throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
      }
      Object.defineProperty(server, "then", { get: thenify.bind(instance) });
      server[kAvvio] = true;
    };
    Boot.prototype.after = function(func) {
      if (!func) {
        return this._loadRegistered();
      }
      this._addPlugin(_after.bind(this), {}, true);
      function _after(s2, opts, done) {
        callWithCbOrNextTick.call(this, func, done);
      }
      return this;
    };
    Boot.prototype.onClose = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
      }
      func[kIsOnCloseHandler] = true;
      this._closeQ.unshift(func, (err) => {
        err && (this._error = err);
      });
      return this;
    };
    Boot.prototype.close = function(func) {
      let promise;
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
        }
      } else {
        promise = new Promise(function(resolve, reject) {
          func = function(err) {
            if (err) {
              return reject(err);
            }
            resolve();
          };
        });
      }
      this.ready(() => {
        this._error = null;
        this._closeQ.push(func);
        process.nextTick(this._closeQ.resume.bind(this._closeQ));
      });
      return promise;
    };
    Boot.prototype.ready = function(func) {
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
        }
        this._readyQ.push(func);
        queueMicrotask(this.start.bind(this));
        return;
      }
      return new Promise((resolve, reject) => {
        this._readyQ.push(readyPromiseCB);
        this.start();
        const relativeContext = this._current[0].server;
        function readyPromiseCB(err, context, done) {
          if (err) {
            reject(err);
          } else {
            resolve(relativeContext);
          }
          process.nextTick(done);
        }
      });
    };
    Boot.prototype._trackPluginLoading = function(plugin) {
      const parentName = this._current[0]?.name || null;
      plugin.once("start", (serverName, funcName, time) => {
        const nodeId = this.pluginTree.start(parentName || null, funcName, time);
        plugin.once("loaded", (serverName2, funcName2, time2) => {
          this.pluginTree.stop(nodeId, time2);
        });
      });
    };
    Boot.prototype.prettyPrint = function() {
      return this.pluginTree.prettyPrint();
    };
    Boot.prototype.toJSON = function() {
      return this.pluginTree.toJSON();
    };
    Boot.prototype._loadPlugin = function(plugin, callback) {
      const instance = this;
      if (isPromiseLike(plugin.func)) {
        plugin.func.then((fn) => {
          if (typeof fn.default === "function") {
            fn = fn.default;
          }
          plugin.func = fn;
          this._loadPlugin(plugin, callback);
        }, callback);
        return;
      }
      const last = instance._current[0];
      instance._current.unshift(plugin);
      if (instance._error && !plugin.isAfter) {
        debug("skipping loading of plugin as instance errored and it is not an after", plugin.name);
        process.nextTick(execCallback);
        return;
      }
      let server = last && last.server || instance._server;
      if (!plugin.isAfter) {
        try {
          server = instance.override(server, plugin.func, plugin.options);
        } catch (overrideErr) {
          debug("override errored", plugin.name);
          return execCallback(overrideErr);
        }
      }
      plugin.exec(server, execCallback);
      function execCallback(err) {
        plugin.finish(err, (err2) => {
          instance._current.shift();
          callback(err2);
        });
      }
    };
    Boot.prototype._loadPluginNextTick = function(plugin, callback) {
      process.nextTick(this._loadPlugin.bind(this), plugin, callback);
    };
    function noop() {
    }
    function callWithCbOrNextTick(func, cb) {
      const context = this._server;
      const err = this._error;
      this._error = null;
      if (func.length === 0) {
        this._error = err;
        executeWithThenable(func, [], cb);
      } else if (func.length === 1) {
        executeWithThenable(func, [err], cb);
      } else {
        if (this._opts.timeout === 0) {
          const wrapCb = (err2) => {
            this._error = err2;
            cb(this._error);
          };
          if (func.length === 2) {
            func(err, wrapCb);
          } else {
            func(err, context, wrapCb);
          }
        } else {
          timeoutCall.call(this, func, err, context, cb);
        }
      }
    }
    function timeoutCall(func, rootErr, context, cb) {
      const name = func.unwrappedName ?? func.name;
      debug("setting up ready timeout", name, this._opts.timeout);
      let timer = setTimeout(() => {
        debug("timed out", name);
        timer = null;
        const toutErr = new AVV_ERR_READY_TIMEOUT(name);
        toutErr.fn = func;
        this._error = toutErr;
        cb(toutErr);
      }, this._opts.timeout);
      if (func.length === 2) {
        func(rootErr, timeoutCb.bind(this));
      } else {
        func(rootErr, context, timeoutCb.bind(this));
      }
      function timeoutCb(err) {
        if (timer) {
          clearTimeout(timer);
          this._error = err;
          cb(this._error);
        } else {
        }
      }
    }
    function closeWithCbOrNextTick(func, cb) {
      const context = this._server;
      const isOnCloseHandler = func[kIsOnCloseHandler];
      if (func.length === 0 || func.length === 1) {
        let promise;
        if (isOnCloseHandler) {
          promise = func(context);
        } else {
          promise = func(this._error);
        }
        if (promise && typeof promise.then === "function") {
          debug("resolving close/onClose promise");
          promise.then(
            () => process.nextTick(cb),
            (e2) => process.nextTick(cb, e2)
          );
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, cb);
        }
      } else {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, context, cb);
        }
      }
    }
    function encapsulateTwoParam(func, that) {
      return _encapsulateTwoParam.bind(that);
      function _encapsulateTwoParam(context, cb) {
        let res;
        if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 1) {
          res = func(this);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else {
          func(this, cb);
        }
      }
    }
    function encapsulateThreeParam(func, that) {
      const wrapped = _encapsulateThreeParam.bind(that);
      wrapped.unwrappedName = func.name;
      return wrapped;
      function _encapsulateThreeParam(err, cb) {
        let res;
        if (!func) {
          process.nextTick(cb);
        } else if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb, err);
            }, cb);
          } else {
            process.nextTick(cb, err);
          }
        } else if (func.length === 1) {
          res = func(err);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 2) {
          func(err, cb);
        } else {
          func(err, this, cb);
        }
      }
    }
    module2.exports = Boot;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/symbols.js
var require_symbols2 = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/symbols.js"(exports2, module2) {
    "use strict";
    var keys = {
      kAvvioBoot: Symbol("fastify.avvioBoot"),
      kChildren: Symbol("fastify.children"),
      kServerBindings: Symbol("fastify.serverBindings"),
      kBodyLimit: Symbol("fastify.bodyLimit"),
      kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
      kRoutePrefix: Symbol("fastify.routePrefix"),
      kLogLevel: Symbol("fastify.logLevel"),
      kLogSerializers: Symbol("fastify.logSerializers"),
      kHooks: Symbol("fastify.hooks"),
      kContentTypeParser: Symbol("fastify.contentTypeParser"),
      kState: Symbol("fastify.state"),
      kOptions: Symbol("fastify.options"),
      kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
      kPluginNameChain: Symbol("fastify.pluginNameChain"),
      kRouteContext: Symbol("fastify.context"),
      kGenReqId: Symbol("fastify.genReqId"),
      // Schema
      kSchemaController: Symbol("fastify.schemaController"),
      kSchemaHeaders: Symbol("headers-schema"),
      kSchemaParams: Symbol("params-schema"),
      kSchemaQuerystring: Symbol("querystring-schema"),
      kSchemaBody: Symbol("body-schema"),
      kSchemaResponse: Symbol("response-schema"),
      kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
      kSchemaVisited: Symbol("fastify.schemas.visited"),
      // Request
      kRequest: Symbol("fastify.Request"),
      kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
      kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
      kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
      kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
      // 404
      kFourOhFour: Symbol("fastify.404"),
      kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
      kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
      kFourOhFourContext: Symbol("fastify.404ContextKey"),
      kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
      // Reply
      kReply: Symbol("fastify.Reply"),
      kReplySerializer: Symbol("fastify.reply.serializer"),
      kReplyIsError: Symbol("fastify.reply.isError"),
      kReplyHeaders: Symbol("fastify.reply.headers"),
      kReplyTrailers: Symbol("fastify.reply.trailers"),
      kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
      kReplyHijacked: Symbol("fastify.reply.hijacked"),
      kReplyStartTime: Symbol("fastify.reply.startTime"),
      kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
      kReplyEndTime: Symbol("fastify.reply.endTime"),
      kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
      kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
      kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
      kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
      // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
      kTestInternals: Symbol("fastify.testInternals"),
      kErrorHandler: Symbol("fastify.errorHandler"),
      kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
      kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
      kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
      kRouteByFastify: Symbol("fastify.routeByFastify")
    };
    module2.exports = keys;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/errors.js
var require_errors2 = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/errors.js"(exports2, module2) {
    "use strict";
    var createError = require_error();
    var codes3 = {
      /**
       * Basic
       */
      FST_ERR_NOT_FOUND: createError(
        "FST_ERR_NOT_FOUND",
        "Not Found",
        404
      ),
      FST_ERR_OPTIONS_NOT_OBJ: createError(
        "FST_ERR_OPTIONS_NOT_OBJ",
        "Options must be an object",
        500,
        TypeError
      ),
      FST_ERR_QSP_NOT_FN: createError(
        "FST_ERR_QSP_NOT_FN",
        "querystringParser option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError(
        "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
        "schemaController.bucket option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError(
        "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
        "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
        "ajv.customOptions option should be an object, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
        "ajv.plugins option should be an array, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_VALIDATION: createError(
        "FST_ERR_VALIDATION",
        "%s",
        400
      ),
      FST_ERR_LISTEN_OPTIONS_INVALID: createError(
        "FST_ERR_LISTEN_OPTIONS_INVALID",
        "Invalid listen options: '%s'",
        500,
        TypeError
      ),
      FST_ERR_ERROR_HANDLER_NOT_FN: createError(
        "FST_ERR_ERROR_HANDLER_NOT_FN",
        "Error Handler must be a function",
        500,
        TypeError
      ),
      /**
       * ContentTypeParser
      */
      FST_ERR_CTP_ALREADY_PRESENT: createError(
        "FST_ERR_CTP_ALREADY_PRESENT",
        "Content type parser '%s' already present."
      ),
      FST_ERR_CTP_INVALID_TYPE: createError(
        "FST_ERR_CTP_INVALID_TYPE",
        "The content type should be a string or a RegExp",
        500,
        TypeError
      ),
      FST_ERR_CTP_EMPTY_TYPE: createError(
        "FST_ERR_CTP_EMPTY_TYPE",
        "The content type cannot be an empty string",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_HANDLER: createError(
        "FST_ERR_CTP_INVALID_HANDLER",
        "The content type handler should be a function",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_PARSE_TYPE: createError(
        "FST_ERR_CTP_INVALID_PARSE_TYPE",
        "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
        500,
        TypeError
      ),
      FST_ERR_CTP_BODY_TOO_LARGE: createError(
        "FST_ERR_CTP_BODY_TOO_LARGE",
        "Request body is too large",
        413,
        RangeError
      ),
      FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(
        "FST_ERR_CTP_INVALID_MEDIA_TYPE",
        "Unsupported Media Type: %s",
        415
      ),
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(
        "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
        "Request body size did not match Content-Length",
        400,
        RangeError
      ),
      FST_ERR_CTP_EMPTY_JSON_BODY: createError(
        "FST_ERR_CTP_EMPTY_JSON_BODY",
        "Body cannot be empty when content-type is set to 'application/json'",
        400
      ),
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError(
        "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
        'Cannot call "%s" when fastify instance is already started!',
        400
      ),
      /**
       * decorate
      */
      FST_ERR_DEC_ALREADY_PRESENT: createError(
        "FST_ERR_DEC_ALREADY_PRESENT",
        "The decorator '%s' has already been added!"
      ),
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(
        "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
        "The dependencies of decorator '%s' must be of type Array.",
        500,
        TypeError
      ),
      FST_ERR_DEC_MISSING_DEPENDENCY: createError(
        "FST_ERR_DEC_MISSING_DEPENDENCY",
        "The decorator is missing dependency '%s'."
      ),
      FST_ERR_DEC_AFTER_START: createError(
        "FST_ERR_DEC_AFTER_START",
        "The decorator '%s' has been added after start!"
      ),
      FST_ERR_DEC_REFERENCE_TYPE: createError(
        "FST_ERR_DEC_REFERENCE_TYPE",
        "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
      ),
      /**
       * hooks
      */
      FST_ERR_HOOK_INVALID_TYPE: createError(
        "FST_ERR_HOOK_INVALID_TYPE",
        "The hook name must be a string",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_HANDLER: createError(
        "FST_ERR_HOOK_INVALID_HANDLER",
        "%s hook should be a function, instead got %s",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError(
        "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
        "Async function has too many arguments. Async hooks should not use the 'done' argument.",
        500,
        TypeError
      ),
      FST_ERR_HOOK_NOT_SUPPORTED: createError(
        "FST_ERR_HOOK_NOT_SUPPORTED",
        "%s hook not supported!",
        500,
        TypeError
      ),
      /**
       * Middlewares
       */
      FST_ERR_MISSING_MIDDLEWARE: createError(
        "FST_ERR_MISSING_MIDDLEWARE",
        "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
        500
      ),
      FST_ERR_HOOK_TIMEOUT: createError(
        "FST_ERR_HOOK_TIMEOUT",
        "A callback for '%s' hook timed out. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      /**
       * logger
      */
      FST_ERR_LOG_INVALID_DESTINATION: createError(
        "FST_ERR_LOG_INVALID_DESTINATION",
        "Cannot specify both logger.stream and logger.file options"
      ),
      FST_ERR_LOG_INVALID_LOGGER: createError(
        "FST_ERR_LOG_INVALID_LOGGER",
        "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError(
        "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
        "loggerInstance only accepts a logger instance.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError(
        "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
        "logger options only accepts a configuration object.",
        500,
        TypeError
      ),
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError(
        "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
        "You cannot provide both logger and loggerInstance. Please provide only one.",
        500,
        TypeError
      ),
      /**
       * reply
      */
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(
        "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
        "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
        500,
        TypeError
      ),
      FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError(
        "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
        "Response.body is already consumed."
      ),
      FST_ERR_REP_ALREADY_SENT: createError(
        "FST_ERR_REP_ALREADY_SENT",
        'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
      ),
      FST_ERR_REP_SENT_VALUE: createError(
        "FST_ERR_REP_SENT_VALUE",
        "The only possible value for reply.sent is true.",
        500,
        TypeError
      ),
      FST_ERR_SEND_INSIDE_ONERR: createError(
        "FST_ERR_SEND_INSIDE_ONERR",
        "You cannot use `send` inside the `onError` hook"
      ),
      FST_ERR_SEND_UNDEFINED_ERR: createError(
        "FST_ERR_SEND_UNDEFINED_ERR",
        "Undefined error has occurred"
      ),
      FST_ERR_BAD_STATUS_CODE: createError(
        "FST_ERR_BAD_STATUS_CODE",
        "Called reply with an invalid status code: %s"
      ),
      FST_ERR_BAD_TRAILER_NAME: createError(
        "FST_ERR_BAD_TRAILER_NAME",
        "Called reply.trailer with an invalid header name: %s"
      ),
      FST_ERR_BAD_TRAILER_VALUE: createError(
        "FST_ERR_BAD_TRAILER_VALUE",
        "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
      ),
      FST_ERR_FAILED_ERROR_SERIALIZATION: createError(
        "FST_ERR_FAILED_ERROR_SERIALIZATION",
        "Failed to serialize an error. Error: %s. Original error: %s"
      ),
      FST_ERR_MISSING_SERIALIZATION_FN: createError(
        "FST_ERR_MISSING_SERIALIZATION_FN",
        'Missing serialization function. Key "%s"'
      ),
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError(
        "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
        'Missing serialization function. Key "%s:%s"'
      ),
      FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError(
        "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
        'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
      ),
      /**
       * schemas
      */
      FST_ERR_SCH_MISSING_ID: createError(
        "FST_ERR_SCH_MISSING_ID",
        "Missing schema $id property"
      ),
      FST_ERR_SCH_ALREADY_PRESENT: createError(
        "FST_ERR_SCH_ALREADY_PRESENT",
        "Schema with id '%s' already declared!"
      ),
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError(
        "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
        "Schema is missing for the content type '%s'"
      ),
      FST_ERR_SCH_DUPLICATE: createError(
        "FST_ERR_SCH_DUPLICATE",
        "Schema with '%s' already present!"
      ),
      FST_ERR_SCH_VALIDATION_BUILD: createError(
        "FST_ERR_SCH_VALIDATION_BUILD",
        "Failed building the validation schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_SERIALIZATION_BUILD: createError(
        "FST_ERR_SCH_SERIALIZATION_BUILD",
        "Failed building the serialization schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError(
        "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
        'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
      ),
      /**
       * http2
       */
      FST_ERR_HTTP2_INVALID_VERSION: createError(
        "FST_ERR_HTTP2_INVALID_VERSION",
        "HTTP2 is available only from node >= 8.8.1"
      ),
      /**
       * initialConfig
       */
      FST_ERR_INIT_OPTS_INVALID: createError(
        "FST_ERR_INIT_OPTS_INVALID",
        "Invalid initialization options: '%s'"
      ),
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError(
        "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
        "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
      ),
      /**
       * router
       */
      FST_ERR_DUPLICATED_ROUTE: createError(
        "FST_ERR_DUPLICATED_ROUTE",
        "Method '%s' already declared for route '%s'"
      ),
      FST_ERR_BAD_URL: createError(
        "FST_ERR_BAD_URL",
        "'%s' is not a valid url component",
        400,
        URIError
      ),
      FST_ERR_ASYNC_CONSTRAINT: createError(
        "FST_ERR_ASYNC_CONSTRAINT",
        "Unexpected error from async constraint",
        500
      ),
      FST_ERR_INVALID_URL: createError(
        "FST_ERR_INVALID_URL",
        "URL must be a string. Received '%s'",
        400,
        TypeError
      ),
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError(
        "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
        'Options for "%s:%s" route must be an object',
        500,
        TypeError
      ),
      FST_ERR_ROUTE_DUPLICATED_HANDLER: createError(
        "FST_ERR_ROUTE_DUPLICATED_HANDLER",
        'Duplicate handler for "%s:%s" route is not allowed!',
        500
      ),
      FST_ERR_ROUTE_HANDLER_NOT_FN: createError(
        "FST_ERR_ROUTE_HANDLER_NOT_FN",
        "Error Handler for %s:%s route, if defined, must be a function",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_MISSING_HANDLER: createError(
        "FST_ERR_ROUTE_MISSING_HANDLER",
        'Missing handler function for "%s:%s" route.',
        500
      ),
      FST_ERR_ROUTE_METHOD_INVALID: createError(
        "FST_ERR_ROUTE_METHOD_INVALID",
        "Provided method is invalid!",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError(
        "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
        "%s method is not supported.",
        500
      ),
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError(
        "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
        "Body validation schema for %s:%s route is not supported!",
        500
      ),
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError(
        "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
        "'bodyLimit' option must be an integer > 0. Got '%s'",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_REWRITE_NOT_STR: createError(
        "FST_ERR_ROUTE_REWRITE_NOT_STR",
        'Rewrite url for "%s" needs to be of type "string" but received "%s"',
        500,
        TypeError
      ),
      /**
       *  again listen when close server
       */
      FST_ERR_REOPENED_CLOSE_SERVER: createError(
        "FST_ERR_REOPENED_CLOSE_SERVER",
        "Fastify has already been closed and cannot be reopened"
      ),
      FST_ERR_REOPENED_SERVER: createError(
        "FST_ERR_REOPENED_SERVER",
        "Fastify is already listening"
      ),
      FST_ERR_INSTANCE_ALREADY_LISTENING: createError(
        "FST_ERR_INSTANCE_ALREADY_LISTENING",
        "Fastify instance is already listening. %s"
      ),
      /**
       * plugin
       */
      FST_ERR_PLUGIN_VERSION_MISMATCH: createError(
        "FST_ERR_PLUGIN_VERSION_MISMATCH",
        "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
      ),
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError(
        "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
        "The decorator '%s'%s is not present in %s"
      ),
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError(
        "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
        "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
        500,
        TypeError
      ),
      /**
       *  Avvio Errors
       */
      FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError(
        "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
        "fastify-plugin: %s",
        500,
        TypeError
      ),
      FST_ERR_PLUGIN_NOT_VALID: createError(
        "FST_ERR_PLUGIN_NOT_VALID",
        "fastify-plugin: %s"
      ),
      FST_ERR_ROOT_PLG_BOOTED: createError(
        "FST_ERR_ROOT_PLG_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PARENT_PLUGIN_BOOTED: createError(
        "FST_ERR_PARENT_PLUGIN_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PLUGIN_TIMEOUT: createError(
        "FST_ERR_PLUGIN_TIMEOUT",
        "fastify-plugin: %s"
      )
    };
    function appendStackTrace(oldErr, newErr) {
      newErr.cause = oldErr;
      return newErr;
    }
    module2.exports = codes3;
    module2.exports.appendStackTrace = appendStackTrace;
    module2.exports.AVVIO_ERRORS_MAP = {
      AVV_ERR_CALLBACK_NOT_FN: codes3.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
      AVV_ERR_PLUGIN_NOT_VALID: codes3.FST_ERR_PLUGIN_NOT_VALID,
      AVV_ERR_ROOT_PLG_BOOTED: codes3.FST_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_PARENT_PLG_LOADED: codes3.FST_ERR_PARENT_PLUGIN_BOOTED,
      AVV_ERR_READY_TIMEOUT: codes3.FST_ERR_PLUGIN_TIMEOUT,
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes3.FST_ERR_PLUGIN_TIMEOUT
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/hooks.js
var require_hooks = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/hooks.js"(exports2, module2) {
    "use strict";
    var applicationHooks = [
      "onRoute",
      "onRegister",
      "onReady",
      "onListen",
      "preClose",
      "onClose"
    ];
    var lifecycleHooks = [
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError",
      "onRequestAbort"
    ];
    var supportedHooks = lifecycleHooks.concat(applicationHooks);
    var {
      FST_ERR_HOOK_INVALID_TYPE,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_SEND_UNDEFINED_ERR,
      FST_ERR_HOOK_TIMEOUT,
      FST_ERR_HOOK_NOT_SUPPORTED,
      AVVIO_ERRORS_MAP,
      appendStackTrace
    } = require_errors2();
    var {
      kChildren,
      kHooks,
      kRequestPayloadStream
    } = require_symbols2();
    function Hooks() {
      this.onRequest = [];
      this.preParsing = [];
      this.preValidation = [];
      this.preSerialization = [];
      this.preHandler = [];
      this.onResponse = [];
      this.onSend = [];
      this.onError = [];
      this.onRoute = [];
      this.onRegister = [];
      this.onReady = [];
      this.onListen = [];
      this.onTimeout = [];
      this.onRequestAbort = [];
      this.preClose = [];
    }
    Hooks.prototype = /* @__PURE__ */ Object.create(null);
    Hooks.prototype.validate = function(hook, fn) {
      if (typeof hook !== "string") throw new FST_ERR_HOOK_INVALID_TYPE();
      if (Array.isArray(this[hook]) === false) {
        throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
      }
      if (typeof fn !== "function") throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
    };
    Hooks.prototype.add = function(hook, fn) {
      this.validate(hook, fn);
      this[hook].push(fn);
    };
    function buildHooks(h) {
      const hooks = new Hooks();
      hooks.onRequest = h.onRequest.slice();
      hooks.preParsing = h.preParsing.slice();
      hooks.preValidation = h.preValidation.slice();
      hooks.preSerialization = h.preSerialization.slice();
      hooks.preHandler = h.preHandler.slice();
      hooks.onSend = h.onSend.slice();
      hooks.onResponse = h.onResponse.slice();
      hooks.onError = h.onError.slice();
      hooks.onRoute = h.onRoute.slice();
      hooks.onRegister = h.onRegister.slice();
      hooks.onTimeout = h.onTimeout.slice();
      hooks.onRequestAbort = h.onRequestAbort.slice();
      hooks.onReady = [];
      hooks.onListen = [];
      hooks.preClose = [];
      return hooks;
    }
    function hookRunnerApplication(hookName, boot, server, cb) {
      const hooks = server[kHooks][hookName];
      let i = 0;
      let c2 = 0;
      next();
      function exit(err) {
        if (err) {
          if (err.code === "AVV_ERR_READY_TIMEOUT") {
            err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName));
          } else {
            err = AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          }
          cb(err);
          return;
        }
        cb();
      }
      function next(err) {
        if (err) {
          exit(err);
          return;
        }
        if (i === hooks.length && c2 === server[kChildren].length) {
          if (i === 0 && c2 === 0) {
            exit();
          } else {
            boot(function manageTimeout(err2, done) {
              exit(err2);
              done(err2);
            });
          }
          return;
        }
        if (i === hooks.length && c2 < server[kChildren].length) {
          const child = server[kChildren][c2++];
          hookRunnerApplication(hookName, boot, child, next);
          return;
        }
        boot(wrap(hooks[i++], server));
        next();
      }
      function wrap(fn, server2) {
        return function(err, done) {
          if (err) {
            done(err);
            return;
          }
          if (fn.length === 1) {
            try {
              fn.call(server2, done);
            } catch (error) {
              done(error);
            }
            return;
          }
          try {
            const ret = fn.call(server2);
            if (ret && typeof ret.then === "function") {
              ret.then(done, done);
              return;
            }
          } catch (error) {
            err = error;
          }
          done(err);
        };
      }
    }
    function onListenHookRunner(server) {
      const hooks = server[kHooks].onListen;
      const hooksLen = hooks.length;
      let i = 0;
      let c2 = 0;
      next();
      function next(err) {
        err && server.log.error(err);
        if (i === hooksLen) {
          while (c2 < server[kChildren].length) {
            const child = server[kChildren][c2++];
            onListenHookRunner(child);
          }
          return;
        }
        wrap(hooks[i++], server, next);
      }
      async function wrap(fn, server2, done) {
        if (fn.length === 1) {
          try {
            fn.call(server2, done);
          } catch (e2) {
            done(e2);
          }
          return;
        }
        try {
          const ret = fn.call(server2);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
          done();
        } catch (error) {
          done(error);
        }
      }
    }
    function hookRunnerGenerator(iterator) {
      return function hookRunner(functions, request, reply, cb) {
        let i = 0;
        function next(err) {
          if (err || i === functions.length) {
            cb(err, request, reply);
            return;
          }
          let result;
          try {
            result = iterator(functions[i++], request, reply, next);
          } catch (error) {
            cb(error, request, reply);
            return;
          }
          if (result && typeof result.then === "function") {
            result.then(handleResolve, handleReject);
          }
        }
        function handleResolve() {
          next();
        }
        function handleReject(err) {
          if (!err) {
            err = new FST_ERR_SEND_UNDEFINED_ERR();
          }
          cb(err, request, reply);
        }
        next();
      };
    }
    function onResponseHookIterator(fn, request, reply, next) {
      return fn(request, reply, next);
    }
    var onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
    var preValidationHookRunner = hookRunnerGenerator(hookIterator);
    var preHandlerHookRunner = hookRunnerGenerator(hookIterator);
    var onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
    var onRequestHookRunner = hookRunnerGenerator(hookIterator);
    function onSendHookRunner(functions, request, reply, payload, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (err) {
          cb(err, request, reply, payload);
          return;
        }
        if (newPayload !== void 0) {
          payload = newPayload;
        }
        if (i === functions.length) {
          cb(null, request, reply, payload);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, payload, next);
        } catch (error) {
          cb(error, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply, payload);
      }
      next();
    }
    var preSerializationHookRunner = onSendHookRunner;
    function preParsingHookRunner(functions, request, reply, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (reply.sent) {
          return;
        }
        if (newPayload !== void 0) {
          request[kRequestPayloadStream] = newPayload;
        }
        if (err || i === functions.length) {
          cb(err, request, reply);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, request[kRequestPayloadStream], next);
        } catch (error) {
          cb(error, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply);
      }
      next();
    }
    function onRequestAbortHookRunner(functions, request, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request);
          return;
        }
        let result;
        try {
          result = functions[i++](request, next);
        } catch (error) {
          cb(error, request);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request);
      }
      next();
    }
    function hookIterator(fn, request, reply, next) {
      if (reply.sent === true) return void 0;
      return fn(request, reply, next);
    }
    module2.exports = {
      Hooks,
      buildHooks,
      hookRunnerGenerator,
      preParsingHookRunner,
      onResponseHookRunner,
      onSendHookRunner,
      preSerializationHookRunner,
      onRequestAbortHookRunner,
      hookIterator,
      hookRunnerApplication,
      onListenHookRunner,
      preHandlerHookRunner,
      preValidationHookRunner,
      onRequestHookRunner,
      onTimeoutHookRunner,
      lifecycleHooks,
      supportedHooks
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/server.js
var require_server = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/server.js"(exports2, module2) {
    "use strict";
    var http3 = require("node:http");
    var https3 = require("node:https");
    var dns = require("node:dns");
    var os2 = require("node:os");
    var { kState, kOptions, kServerBindings } = require_symbols2();
    var { onListenHookRunner } = require_hooks();
    var {
      FST_ERR_HTTP2_INVALID_VERSION,
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_REOPENED_SERVER,
      FST_ERR_LISTEN_OPTIONS_INVALID
    } = require_errors2();
    module2.exports.createServer = createServer;
    function defaultResolveServerListeningText(address) {
      return `Server listening at ${address}`;
    }
    function createServer(options, httpHandler) {
      const server = getServerInstance(options, httpHandler);
      function listen(listenOptions = { port: 0, host: "localhost" }, cb = void 0) {
        if (typeof cb === "function") {
          listenOptions.cb = cb;
        }
        if (listenOptions.signal) {
          if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
            throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
          }
          if (listenOptions.signal.aborted) {
            this.close();
          } else {
            const onAborted = () => {
              this.close();
            };
            listenOptions.signal.addEventListener("abort", onAborted, { once: true });
          }
        }
        let host;
        if (listenOptions.path == null) {
          host = listenOptions.host ?? "localhost";
        } else {
          host = listenOptions.host;
        }
        if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
          listenOptions.host = host;
        }
        if (host === "localhost") {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
              this[kState].listening = true;
              cb(null, address);
              onListenHookRunner(this);
            });
          };
        } else {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            this[kState].listening = true;
            cb(null, address);
            onListenHookRunner(this);
          };
        }
        if (cb === void 0) {
          const listening = listenPromise.call(this, server, listenOptions);
          return listening.then((address) => {
            return new Promise((resolve, reject) => {
              if (host === "localhost") {
                multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
                  this[kState].listening = true;
                  resolve(address);
                  onListenHookRunner(this);
                });
              } else {
                resolve(address);
                onListenHookRunner(this);
              }
            });
          });
        }
        this.ready(listenCallback.call(this, server, listenOptions));
      }
      return { server, listen };
    }
    function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
      this[kState].listening = false;
      dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
        if (dnsErr) {
          onListen();
          return;
        }
        const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
        let binding = 0;
        let bound = 0;
        if (!isMainServerListening) {
          const primaryAddress = mainServer.address();
          for (const adr of addresses) {
            if (adr.address !== primaryAddress.address) {
              binding++;
              const secondaryOpts = Object.assign({}, listenOptions, {
                host: adr.address,
                port: primaryAddress.port,
                cb: (_ignoreErr) => {
                  bound++;
                  if (!_ignoreErr) {
                    this[kServerBindings].push(secondaryServer);
                  }
                  if (bound === binding) {
                    onListen();
                  }
                }
              });
              const secondaryServer = getServerInstance(serverOpts, httpHandler);
              const closeSecondary = () => {
                secondaryServer.close(() => {
                });
                if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
                  secondaryServer.closeAllConnections();
                }
              };
              secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
              mainServer.on("unref", closeSecondary);
              mainServer.on("close", closeSecondary);
              mainServer.on("error", closeSecondary);
              this[kState].listening = false;
              listenCallback.call(this, secondaryServer, secondaryOpts)();
            }
          }
        }
        if (binding === 0) {
          onListen();
          return;
        }
        const originUnref = mainServer.unref;
        mainServer.unref = function() {
          originUnref.call(mainServer);
          mainServer.emit("unref");
        };
      });
    }
    function listenCallback(server, listenOptions) {
      const wrap = (err) => {
        server.removeListener("error", wrap);
        server.removeListener("listening", wrap);
        if (!err) {
          const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
          listenOptions.cb(null, address);
        } else {
          this[kState].listening = false;
          listenOptions.cb(err, null);
        }
      };
      return (err) => {
        if (err != null) return listenOptions.cb(err);
        if (this[kState].listening && this[kState].closing) {
          return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null);
        } else if (this[kState].listening) {
          return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null);
        }
        server.once("error", wrap);
        if (!this[kState].closing) {
          server.once("listening", wrap);
          server.listen(listenOptions);
          this[kState].listening = true;
        }
      };
    }
    function listenPromise(server, listenOptions) {
      if (this[kState].listening && this[kState].closing) {
        return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER());
      } else if (this[kState].listening) {
        return Promise.reject(new FST_ERR_REOPENED_SERVER());
      }
      return this.ready().then(() => {
        let errEventHandler;
        let listeningEventHandler;
        function cleanup() {
          server.removeListener("error", errEventHandler);
          server.removeListener("listening", listeningEventHandler);
        }
        const errEvent = new Promise((resolve, reject) => {
          errEventHandler = (err) => {
            cleanup();
            this[kState].listening = false;
            reject(err);
          };
          server.once("error", errEventHandler);
        });
        const listeningEvent = new Promise((resolve, reject) => {
          listeningEventHandler = () => {
            cleanup();
            this[kState].listening = true;
            resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
          };
          server.once("listening", listeningEventHandler);
        });
        server.listen(listenOptions);
        return Promise.race([
          errEvent,
          // e.g invalid port range error is always emitted before the server listening
          listeningEvent
        ]);
      });
    }
    function getServerInstance(options, httpHandler) {
      let server = null;
      const httpsOptions = options.https === true ? {} : options.https;
      if (options.serverFactory) {
        server = options.serverFactory(httpHandler, options);
      } else if (options.http2) {
        if (typeof httpsOptions === "object") {
          server = http22().createSecureServer(httpsOptions, httpHandler);
        } else {
          server = http22().createServer(httpHandler);
        }
        server.on("session", sessionTimeout(options.http2SessionTimeout));
      } else {
        if (httpsOptions) {
          server = https3.createServer(httpsOptions, httpHandler);
        } else {
          server = http3.createServer(options.http, httpHandler);
        }
        server.keepAliveTimeout = options.keepAliveTimeout;
        server.requestTimeout = options.requestTimeout;
        if (options.maxRequestsPerSocket > 0) {
          server.maxRequestsPerSocket = options.maxRequestsPerSocket;
        }
      }
      if (!options.serverFactory) {
        server.setTimeout(options.connectionTimeout);
      }
      return server;
    }
    function getAddresses(address) {
      if (address.address === "0.0.0.0") {
        return Object.values(os2.networkInterfaces()).flatMap((iface) => {
          return iface.filter((iface2) => iface2.family === "IPv4");
        }).sort((iface) => {
          return iface.internal ? -1 : 1;
        }).map((iface) => {
          return iface.address;
        });
      }
      return [address.address];
    }
    function logServerAddress(server, listenTextResolver) {
      let addresses;
      const isUnixSocket = typeof server.address() === "string";
      if (!isUnixSocket) {
        if (server.address().address.indexOf(":") === -1) {
          addresses = getAddresses(server.address()).map((address) => address + ":" + server.address().port);
        } else {
          addresses = ["[" + server.address().address + "]:" + server.address().port];
        }
        addresses = addresses.map((address) => "http" + (this[kOptions].https ? "s" : "") + "://" + address);
      } else {
        addresses = [server.address()];
      }
      for (const address of addresses) {
        this.log.info(listenTextResolver(address));
      }
      return addresses[0];
    }
    function http22() {
      try {
        return require("node:http2");
      } catch (err) {
        throw new FST_ERR_HTTP2_INVALID_VERSION();
      }
    }
    function sessionTimeout(timeout) {
      return function(session) {
        session.setTimeout(timeout, close);
      };
    }
    function close() {
      this.close();
    }
  }
});

// ../../node_modules/.pnpm/process-warning@4.0.0/node_modules/process-warning/index.js
var require_process_warning = __commonJS({
  "../../node_modules/.pnpm/process-warning@4.0.0/node_modules/process-warning/index.js"(exports2, module2) {
    "use strict";
    var { format } = require("node:util");
    function createDeprecation(params) {
      return createWarning({ ...params, name: "DeprecationWarning" });
    }
    function createWarning({ name, code, message, unlimited = false } = {}) {
      if (!name) throw new Error("Warning name must not be empty");
      if (!code) throw new Error("Warning code must not be empty");
      if (!message) throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      let warningContainer = {
        [name]: function(a2, b3, c2) {
          if (warning.emitted === true && warning.unlimited !== true) {
            return;
          }
          warning.emitted = true;
          process.emitWarning(warning.format(a2, b3, c2), warning.name, warning.code);
        }
      };
      if (unlimited) {
        warningContainer = {
          [name]: function(a2, b3, c2) {
            warning.emitted = true;
            process.emitWarning(warning.format(a2, b3, c2), warning.name, warning.code);
          }
        };
      }
      const warning = warningContainer[name];
      warning.emitted = false;
      warning.message = message;
      warning.unlimited = unlimited;
      warning.code = code;
      warning.format = function(a2, b3, c2) {
        let formatted;
        if (a2 && b3 && c2) {
          formatted = format(message, a2, b3, c2);
        } else if (a2 && b3) {
          formatted = format(message, a2, b3);
        } else if (a2) {
          formatted = format(message, a2);
        } else {
          formatted = message;
        }
        return formatted;
      };
      return warning;
    }
    var out = { createWarning, createDeprecation };
    module2.exports = out;
    module2.exports.default = out;
    module2.exports.processWarning = out;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/warnings.js"(exports2, module2) {
    "use strict";
    var { createWarning } = require_process_warning();
    var FSTWRN001 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN001",
      message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
      unlimited: true
    });
    var FSTSEC001 = createWarning({
      name: "FastifySecurity",
      code: "FSTSEC001",
      message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
      unlimited: true
    });
    module2.exports = {
      FSTWRN001,
      FSTSEC001
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/validation.js"(exports2, module2) {
    "use strict";
    var {
      kSchemaHeaders: headersSchema,
      kSchemaParams: paramsSchema,
      kSchemaQuerystring: querystringSchema,
      kSchemaBody: bodySchema,
      kSchemaResponse: responseSchema
    } = require_symbols2();
    var scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
    var {
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
    } = require_errors2();
    var { FSTWRN001 } = require_warnings();
    function compileSchemasForSerialization(context, compile) {
      if (!context.schema || !context.schema.response) {
        return;
      }
      const { method, url } = context.config || {};
      context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
        const schema = context.schema.response[statusCode];
        statusCode = statusCode.toLowerCase();
        if (!scChecker.test(statusCode)) {
          throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX();
        }
        if (schema.content) {
          const contentTypesSchemas = {};
          for (const mediaName of Object.keys(schema.content)) {
            const contentSchema = schema.content[mediaName].schema;
            contentTypesSchemas[mediaName] = compile({
              schema: contentSchema,
              url,
              method,
              httpStatus: statusCode,
              contentType: mediaName
            });
          }
          acc[statusCode] = contentTypesSchemas;
        } else {
          acc[statusCode] = compile({
            schema,
            url,
            method,
            httpStatus: statusCode
          });
        }
        return acc;
      }, {});
    }
    function compileSchemasForValidation(context, compile, isCustom) {
      const { schema } = context;
      if (!schema) {
        return;
      }
      const { method, url } = context.config || {};
      const headers = schema.headers;
      if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
        context[headersSchema] = compile({ schema: headers, method, url, httpPart: "headers" });
      } else if (headers) {
        const headersSchemaLowerCase = {};
        Object.keys(headers).forEach((k) => {
          headersSchemaLowerCase[k] = headers[k];
        });
        if (headersSchemaLowerCase.required instanceof Array) {
          headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
        }
        if (headers.properties) {
          headersSchemaLowerCase.properties = {};
          Object.keys(headers.properties).forEach((k) => {
            headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
          });
        }
        context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
      } else if (Object.hasOwn(schema, "headers")) {
        FSTWRN001("headers", method, url);
      }
      if (schema.body) {
        const contentProperty = schema.body.content;
        if (contentProperty) {
          const contentTypeSchemas = {};
          for (const contentType of Object.keys(contentProperty)) {
            const contentSchema = contentProperty[contentType].schema;
            contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url, httpPart: "body", contentType });
          }
          context[bodySchema] = contentTypeSchemas;
        } else {
          context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: "body" });
        }
      } else if (Object.hasOwn(schema, "body")) {
        FSTWRN001("body", method, url);
      }
      if (schema.querystring) {
        context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: "querystring" });
      } else if (Object.hasOwn(schema, "querystring")) {
        FSTWRN001("querystring", method, url);
      }
      if (schema.params) {
        context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: "params" });
      } else if (Object.hasOwn(schema, "params")) {
        FSTWRN001("params", method, url);
      }
    }
    function validateParam(validatorFunction, request, paramName) {
      const isUndefined = request[paramName] === void 0;
      const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);
      if (ret?.then) {
        return ret.then((res) => {
          return answer(res);
        }).catch((err) => {
          return err;
        });
      }
      return answer(ret);
      function answer(ret2) {
        if (ret2 === false) return validatorFunction.errors;
        if (ret2 && ret2.error) return ret2.error;
        if (ret2 && ret2.value) request[paramName] = ret2.value;
        return false;
      }
    }
    function validate(context, request, execution) {
      const runExecution = execution === void 0;
      if (runExecution || !execution.skipParams) {
        const params = validateParam(context[paramsSchema], request, "params");
        if (params) {
          if (typeof params.then !== "function") {
            return wrapValidationError(params, "params", context.schemaErrorFormatter);
          } else {
            return validateAsyncParams(params, context, request);
          }
        }
      }
      if (runExecution || !execution.skipBody) {
        let validatorFunction = null;
        if (typeof context[bodySchema] === "function") {
          validatorFunction = context[bodySchema];
        } else if (context[bodySchema]) {
          const contentType = request.headers["content-type"]?.split(";", 1)[0];
          const contentSchema = context[bodySchema][contentType];
          if (contentSchema) {
            validatorFunction = contentSchema;
          }
        }
        const body = validateParam(validatorFunction, request, "body");
        if (body) {
          if (typeof body.then !== "function") {
            return wrapValidationError(body, "body", context.schemaErrorFormatter);
          } else {
            return validateAsyncBody(body, context, request);
          }
        }
      }
      if (runExecution || !execution.skipQuery) {
        const query = validateParam(context[querystringSchema], request, "query");
        if (query) {
          if (typeof query.then !== "function") {
            return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
          } else {
            return validateAsyncQuery(query, context, request);
          }
        }
      }
      const headers = validateParam(context[headersSchema], request, "headers");
      if (headers) {
        if (typeof headers.then !== "function") {
          return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
        } else {
          return validateAsyncHeaders(headers, context, request);
        }
      }
      return false;
    }
    function validateAsyncParams(validatePromise, context, request) {
      return validatePromise.then((paramsResult) => {
        if (paramsResult) {
          return wrapValidationError(paramsResult, "params", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true });
      });
    }
    function validateAsyncBody(validatePromise, context, request) {
      return validatePromise.then((bodyResult) => {
        if (bodyResult) {
          return wrapValidationError(bodyResult, "body", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true });
      });
    }
    function validateAsyncQuery(validatePromise, context, request) {
      return validatePromise.then((queryResult) => {
        if (queryResult) {
          return wrapValidationError(queryResult, "querystring", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true });
      });
    }
    function validateAsyncHeaders(validatePromise, context, request) {
      return validatePromise.then((headersResult) => {
        if (headersResult) {
          return wrapValidationError(headersResult, "headers", context.schemaErrorFormatter);
        }
        return false;
      });
    }
    function wrapValidationError(result, dataVar, schemaErrorFormatter) {
      if (result instanceof Error) {
        result.statusCode = result.statusCode || 400;
        result.code = result.code || "FST_ERR_VALIDATION";
        result.validationContext = result.validationContext || dataVar;
        return result;
      }
      const error = schemaErrorFormatter(result, dataVar);
      error.statusCode = error.statusCode || 400;
      error.code = error.code || "FST_ERR_VALIDATION";
      error.validation = result;
      error.validationContext = dataVar;
      return error;
    }
    module2.exports = {
      symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
      compileSchemasForValidation,
      compileSchemasForSerialization,
      validate
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/wrapThenable.js"(exports2, module2) {
    "use strict";
    var {
      kReplyIsError,
      kReplyHijacked
    } = require_symbols2();
    var diagnostics = require("node:diagnostics_channel");
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function wrapThenable(thenable, reply, store) {
      if (store) store.async = true;
      thenable.then(function(payload) {
        if (reply[kReplyHijacked] === true) {
          return;
        }
        if (store) {
          channels.asyncStart.publish(store);
        }
        try {
          if (payload !== void 0 || reply.sent === false && reply.raw.headersSent === false && reply.request.raw.aborted === false) {
            try {
              reply.send(payload);
            } catch (err) {
              reply[kReplyIsError] = true;
              reply.send(err);
            }
          }
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      }, function(err) {
        if (store) {
          store.error = err;
          channels.error.publish(store);
          channels.asyncStart.publish(store);
        }
        try {
          if (reply.sent === true) {
            reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
            return;
          }
          reply[kReplyIsError] = true;
          reply.send(err);
        } catch (err2) {
          reply.send(err2);
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      });
    }
    module2.exports = wrapThenable;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/handleRequest.js"(exports2, module2) {
    "use strict";
    var diagnostics = require("node:diagnostics_channel");
    var { validate: validateSchema } = require_validation();
    var { preValidationHookRunner, preHandlerHookRunner } = require_hooks();
    var wrapThenable = require_wrapThenable();
    var {
      kReplyIsError,
      kRouteContext,
      kFourOhFourContext,
      kSupportedHTTPMethods
    } = require_symbols2();
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function handleRequest(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const method = request.raw.method;
      const headers = request.headers;
      const context = request[kRouteContext];
      if (this[kSupportedHTTPMethods].bodyless.has(method)) {
        handler(request, reply);
        return;
      }
      if (this[kSupportedHTTPMethods].bodywith.has(method)) {
        const contentType = headers["content-type"];
        const contentLength = headers["content-length"];
        const transferEncoding = headers["transfer-encoding"];
        if (contentType === void 0) {
          if ((contentLength === void 0 || contentLength === "0") && transferEncoding === void 0) {
            handler(request, reply);
          } else {
            context.contentTypeParser.run("", handler, request, reply);
          }
        } else {
          if (contentLength === void 0 && transferEncoding === void 0 && method === "OPTIONS") {
            handler(request, reply);
            return;
          }
          context.contentTypeParser.run(contentType, handler, request, reply);
        }
        return;
      }
      handler(request, reply);
    }
    function handler(request, reply) {
      try {
        if (request[kRouteContext].preValidation !== null) {
          preValidationHookRunner(
            request[kRouteContext].preValidation,
            request,
            reply,
            preValidationCallback
          );
        } else {
          preValidationCallback(null, request, reply);
        }
      } catch (err) {
        preValidationCallback(err, request, reply);
      }
    }
    function preValidationCallback(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const validationErr = validateSchema(reply[kRouteContext], request);
      const isAsync2 = validationErr && typeof validationErr.then === "function" || false;
      if (isAsync2) {
        const cb = validationCompleted.bind(null, request, reply);
        validationErr.then(cb, cb);
      } else {
        validationCompleted(request, reply, validationErr);
      }
    }
    function validationCompleted(request, reply, validationErr) {
      if (validationErr) {
        if (reply[kRouteContext].attachValidation === false) {
          reply.send(validationErr);
          return;
        }
        reply.request.validationError = validationErr;
      }
      if (request[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          request[kRouteContext].preHandler,
          request,
          reply,
          preHandlerCallback
        );
      } else {
        preHandlerCallback(null, request, reply);
      }
    }
    function preHandlerCallback(err, request, reply) {
      if (reply.sent) return;
      const context = request[kRouteContext];
      if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
        preHandlerCallbackInner(err, request, reply);
      } else {
        const store = {
          request,
          reply,
          async: false,
          route: {
            url: context.config.url,
            method: context.config.method
          }
        };
        channels.start.runStores(store, preHandlerCallbackInner, void 0, err, request, reply, store);
      }
    }
    function preHandlerCallbackInner(err, request, reply, store) {
      const context = request[kRouteContext];
      try {
        if (err != null) {
          reply[kReplyIsError] = true;
          reply.send(err);
          if (store) {
            store.error = err;
            channels.error.publish(store);
          }
          return;
        }
        let result;
        try {
          result = context.handler(request, reply);
        } catch (err2) {
          if (store) {
            store.error = err2;
            channels.error.publish(store);
          }
          reply[kReplyIsError] = true;
          reply.send(err2);
          return;
        }
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply, store);
          } else {
            reply.send(result);
          }
        }
      } finally {
        if (store) channels.end.publish(store);
      }
    }
    module2.exports = handleRequest;
    module2.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
  }
});

// ../../node_modules/.pnpm/abstract-logging@2.0.1/node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS({
  "../../node_modules/.pnpm/abstract-logging@2.0.1/node_modules/abstract-logging/index.js"(exports2, module2) {
    "use strict";
    function noop() {
    }
    var proto = {
      fatal: noop,
      error: noop,
      warn: noop,
      info: noop,
      debug: noop,
      trace: noop
    };
    Object.defineProperty(module2, "exports", {
      get() {
        return Object.create(proto);
      }
    });
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString4 } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString4 } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s2) => `fast-redact \u2013 Invalid path (${s2})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s2) => {
          if (typeof s2 !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s2)) throw Error();
            const expr = (s2[0] === "[" ? "" : ".") + s2.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e2) {
            throw Error(ERR_INVALID_PATH(s2));
          }
        });
      };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path} != null`;
        else existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length = keys.length;
      for (var i = 0; i < length; i++) {
        const k = keys[i];
        target[k] = values[i];
      }
    }
    function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [...path] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i = 0; i < instructions.length; i++) {
        const { target, path, value } = instructions[i];
        let current = target;
        for (let i2 = path.length - 1; i2 > 0; i2--) {
          current = current[path[i2]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n3;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n3 = o[k];
      if (typeof n3 !== "object") return;
      while (n3 != null && ++i < afterPathLen) {
        depth += 1;
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n3 === "object" && k in n3)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n3);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n3[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i;
              ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                  store.push(rv);
                  n3[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n3[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n3, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
            store.push(rv);
            n3[k] = nv;
          }
          n3 = n3[k];
        }
        if (typeof n3 !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get(o, p) {
      var i = -1;
      var l = p.length;
      var n3 = o;
      while (n3 != null && ++i < l) {
        n3 = n3[p[i]];
      }
      return n3;
    }
    function iterateNthLevel(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n3[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n3, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path, value, target };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder2 = [{ secret, censor, compileRestore }];
      if (serialize !== false) builder2.push({ serialize });
      if (wcLen > 0) builder2.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder2);
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.5.0/node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    var validator = require_validator();
    var parse = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o) => o;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/symbols.js
var require_symbols3 = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols3();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s2) => `pino \u2013 redact paths array contains an invalid path (${s2})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k, ...path]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// ../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f2, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f2 === "object" && f2 !== null) {
        var len = args.length + offset;
        if (len === 1) return f2;
        var objects = new Array(len);
        objects[0] = ss(f2);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f2 !== "string") {
        return f2;
      }
      var argLen = args.length;
      if (argLen === 0) return f2;
      var str = "";
      var a2 = 1 - offset;
      var lastPos = -1;
      var flen = f2 && f2.length || 0;
      for (var i = 0; i < flen; ) {
        if (f2.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f2.charCodeAt(i + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a2 >= argLen)
                break;
              if (args[a2] == null) break;
              if (lastPos < i)
                str += f2.slice(lastPos, i);
              str += Number(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a2 >= argLen)
                break;
              if (args[a2] == null) break;
              if (lastPos < i)
                str += f2.slice(lastPos, i);
              str += Math.floor(Number(args[a2]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a2 >= argLen)
                break;
              if (args[a2] === void 0) break;
              if (lastPos < i)
                str += f2.slice(lastPos, i);
              var type = typeof args[a2];
              if (type === "string") {
                str += "'" + args[a2] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a2].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a2 >= argLen)
                break;
              if (lastPos < i)
                str += f2.slice(lastPos, i);
              str += String(args[a2]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f2.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a2--;
              break;
          }
          ++a2;
        }
        ++i;
      }
      if (lastPos === -1)
        return f2;
      else if (lastPos < flen) {
        str += f2.slice(lastPos);
      }
      return str;
    }
  }
});

// ../../node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "../../node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep2 = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep2;
    } else {
      let sleep2 = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep2;
    }
  }
});

// ../../node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "../../node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var EventEmitter = require("events");
    var inherits = require("util").inherits;
    var path = require("path");
    var sleep2 = require_atomic_sleep();
    var assert4 = require("assert");
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
    var kCopyBuffer = major >= 22 && minor >= 7;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs2.mkdirSync(path.dirname(file), { recursive: true });
          const fd = fs2.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs2.mkdir(path.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs2.open(file, flags, mode, fileOpened);
        });
      } else {
        fs2.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir: mkdir2, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this._periodicFlush = periodicFlush || 0;
      this._periodicFlushTimer = void 0;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir2 || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write2;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n3) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep2(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n3);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n3);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n4 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n4);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs2.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
      if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
      }
    }
    function releaseWritingBuf(writingBuf, len, n3) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n3) {
        n3 = Buffer.from(writingBuf).subarray(0, n3).toString().length;
      }
      len = Math.max(len - n3, 0);
      writingBuf = writingBuf.slice(n3);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write2(data4) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data4.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data4);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data4.length > this.maxWrite) {
        bufs.push("" + data4);
      } else {
        bufs[bufs.length - 1] += data4;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data4) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data4.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data4);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data4.length > this.maxWrite) {
        bufs.push([data4]);
        lens.push(data4.length);
      } else {
        bufs[bufs.length - 1].push(data4);
        lens[lens.length - 1] += data4.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          try {
            fs2.fsync(this.fd, (err) => {
              this._flushPending = false;
              cb(err);
            });
          } catch (err) {
            cb(err);
          }
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs2.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n3 = fs2.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n3);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep2(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs2.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n3 = fs2.writeSync(this.fd, buf);
          buf = buf.subarray(n3);
          this._len = Math.max(this._len - n3, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep2(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs2.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs2.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        if (kCopyBuffer) {
          this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs2.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      if (sonic._periodicFlushTimer !== void 0) {
        clearInterval(sonic._periodicFlushTimer);
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      assert4(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
      try {
        fs2.fsync(sonic.fd, closeWrapped);
      } catch {
      }
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs2.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// ../../node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "../../node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "3.1.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^4.0.1",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        build: "tsc --noEmit",
        test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*",
          "test/syntax-error.mjs"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait3(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check(1);
    }
    module2.exports = { wait: wait3, waitDiff };
  }
});

// ../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "../../node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version: version4 } = require_package();
    var { EventEmitter } = require("events");
    var { Worker: Worker2 } = require("worker_threads");
    var { join } = require("path");
    var { pathToFileURL } = require("url");
    var { wait: wait3 } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = require("buffer");
    var assert4 = require("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
      const worker = new Worker2(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version4
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert4(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write2(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write2(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data4) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data4.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data4;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait3(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write2(stream, data4, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data4);
      stream[kImpl].data.write(data4, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write2(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write2(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = require("module");
    var getCallers = require_caller();
    var { join, isAbsolute, sep } = require("node:path");
    var sleep2 = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts, sync) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep2(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
      const options = {
        ...fullOptions.options
      };
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.targets = targets.filter((dest) => dest.target).map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
        options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
          return dest.pipeline.map((t) => {
            return {
              ...t,
              level: dest.level,
              // duplicate the pipeline `level` property defined in the upper level
              target: fixTarget(t.target)
            };
          });
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.pipelines = [pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        })];
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker, sync);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols3();
    var { isMainThread } = require("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o, ...n3) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          let formatParams;
          if (msg === null && n3.length === 0) {
            formatParams = [null];
          } else {
            msg = n3.shift();
            formatParams = n3;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o === void 0 ? n3.shift() : o;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n3, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify6 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data4 = this[lsCacheSym][num] + time;
      data4 = data4 + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify6)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify6)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data4 + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data4 + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data4 = instance[chindingsSym];
      const stringify6 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify6)(value, stringifySafe);
          if (value === void 0) continue;
          data4 += ',"' + key + '":' + value;
        }
      }
      return data4;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions5) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions5, opts);
        opts.serializers = Object.assign({}, defaultOptions5.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions5.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify5(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify6 = stringifySafeFn || this[stringifySafeSym];
          return stringify6(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify: stringify5,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols3();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e2) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
      o[DEFAULT_LEVELS[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = '{"level":' + Number(k);
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = { version: "9.5.0" };
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("node:events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym
    } = require_symbols3();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify: stringify5
    } = require_tools();
    var {
      version: version4
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version4,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n3) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write2,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify5);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify5;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write2(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s2 = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s2);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// ../../node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "../../node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify5 = configure();
    stringify5.configure = configure;
    stringify5.stringify = stringify5;
    stringify5.default = stringify5;
    exports2.stringify = stringify5;
    exports2.configure = configure;
    module2.exports = stringify5;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number2) {
      if (number2 === 1) {
        return "1 item";
      }
      return `${number2} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify6(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify6;
    }
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i) => {
          streamLevels[i] = opts.levels[i];
        });
      }
      const res = {
        write: write2,
        add: add2,
        emit: emit3,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add2, res);
      } else {
        add2.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write2(data4) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
          dest = streams[i];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data4);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit3(...args) {
        for (const { stream } of this.streams) {
          if (typeof stream.emit === "function") {
            stream.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add2(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i = 0; i < streams.length; i++) {
          streams[i] = {
            level,
            stream: this.streams[i].stream
          };
        }
        return {
          write: write2,
          add: add2,
          minLevel: level,
          streams,
          clone,
          emit: emit3,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a2, b3) {
      return a2.level - b3.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i, dedupe) {
      return dedupe ? i - 1 : i + 1;
    }
    function checkLoopVar(i, length, dedupe) {
      return dedupe ? i >= 0 : i < length;
    }
    module2.exports = multistream;
  }
});

// ../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/pino.js
var require_pino = __commonJS({
  "../../node_modules/.pnpm/pino@9.5.0/node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os2 = require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols3();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify: stringify5,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version: version4 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os2.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions5 = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number2) {
          return { level: number2 };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize2 = createArgsNormalizer(defaultOptions5);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize2(instance, caller(), ...args);
      if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify5.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify5,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream.emit === "function") {
        stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify5,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version4;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/logger-pino.js
var require_logger_pino = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/logger-pino.js"(exports2, module2) {
    "use strict";
    var pino = require_pino();
    var { serializersSym } = pino.symbols;
    var {
      FST_ERR_LOG_INVALID_DESTINATION
    } = require_errors2();
    function createPinoLogger(opts) {
      if (opts.stream && opts.file) {
        throw new FST_ERR_LOG_INVALID_DESTINATION();
      } else if (opts.file) {
        opts.stream = pino.destination(opts.file);
        delete opts.file;
      }
      const prevLogger = opts.logger;
      const prevGenReqId = opts.genReqId;
      let logger = null;
      if (prevLogger) {
        opts.logger = void 0;
        opts.genReqId = void 0;
        if (prevLogger[serializersSym]) {
          opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
        }
        logger = prevLogger.child({}, opts);
        opts.logger = prevLogger;
        opts.genReqId = prevGenReqId;
      } else {
        logger = pino(opts, opts.stream);
      }
      return logger;
    }
    var serializers = {
      req: function asReqValue(req) {
        return {
          method: req.method,
          url: req.url,
          version: req.headers && req.headers["accept-version"],
          host: req.host,
          remoteAddress: req.ip,
          remotePort: req.socket ? req.socket.remotePort : void 0
        };
      },
      err: pino.stdSerializers.err,
      res: function asResValue(reply) {
        return {
          statusCode: reply.statusCode
        };
      }
    };
    module2.exports = {
      serializers,
      createPinoLogger
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/logger-factory.js
var require_logger_factory = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/logger-factory.js"(exports2, module2) {
    "use strict";
    var {
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
      FST_ERR_LOG_INVALID_LOGGER_CONFIG,
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
      FST_ERR_LOG_INVALID_LOGGER
    } = require_errors2();
    function createChildLogger(context, logger, req, reqId, loggerOpts) {
      const loggerBindings = {
        [context.requestIdLogLabel]: reqId
      };
      const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);
      if (context.childLoggerFactory !== defaultChildLoggerFactory) {
        validateLogger(child, true);
      }
      return child;
    }
    function defaultChildLoggerFactory(logger, bindings, opts) {
      return logger.child(bindings, opts);
    }
    function validateLogger(logger, strict) {
      const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
      const missingMethods = logger ? methods.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods;
      if (!missingMethods.length) {
        return true;
      } else if (missingMethods.length === methods.length && !strict) {
        return false;
      } else {
        throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
      }
    }
    function createLogger(options) {
      if (options.logger && options.loggerInstance) {
        throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED();
      }
      if (!options.loggerInstance && !options.logger) {
        const nullLogger = require_abstract_logging();
        const logger2 = nullLogger;
        logger2.child = () => logger2;
        return { logger: logger2, hasLogger: false };
      }
      const { createPinoLogger, serializers } = require_logger_pino();
      if (validateLogger(options.loggerInstance)) {
        const logger2 = createPinoLogger({
          logger: options.loggerInstance,
          serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
        });
        return { logger: logger2, hasLogger: true };
      }
      if (validateLogger(options.logger)) {
        throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
      }
      if (options.loggerInstance) {
        throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
      }
      const localLoggerOptions = {};
      if (Object.prototype.toString.call(options.logger) === "[object Object]") {
        Reflect.ownKeys(options.logger).forEach((prop) => {
          Object.defineProperty(localLoggerOptions, prop, {
            value: options.logger[prop],
            writable: true,
            enumerable: true,
            configurable: true
          });
        });
      }
      localLoggerOptions.level = localLoggerOptions.level || "info";
      localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
      options.logger = localLoggerOptions;
      const logger = createPinoLogger(options.logger);
      return { logger, hasLogger: true };
    }
    function now() {
      const ts = process.hrtime();
      return ts[0] * 1e3 + ts[1] / 1e6;
    }
    module2.exports = {
      createChildLogger,
      defaultChildLoggerFactory,
      createLogger,
      validateLogger,
      now
    };
  }
});

// ../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a2, fn) {
        const keys = Object.keys(a2);
        const a22 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a2[k];
          if (typeof cur !== "object" || cur === null) {
            a22[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a22[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a22[k] = copyBuffer(cur);
          } else {
            a22[k] = fn(cur);
          }
        }
        return a22;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a2, fn) {
        const keys = Object.keys(a2);
        const a22 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a2[k];
          if (typeof cur !== "object" || cur === null) {
            a22[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a22[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a22[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a22[k] = refsNew[index];
            } else {
              a22[k] = fn(cur);
            }
          }
        }
        return a22;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/schemas.js"(exports2, module2) {
    "use strict";
    var fastClone = require_rfdc()({ circles: false, proto: true });
    var { kSchemaVisited, kSchemaResponse } = require_symbols2();
    var kFluentSchema = Symbol.for("fluent-schema-object");
    var {
      FST_ERR_SCH_MISSING_ID,
      FST_ERR_SCH_ALREADY_PRESENT,
      FST_ERR_SCH_DUPLICATE,
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA
    } = require_errors2();
    var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
    function Schemas(initStore) {
      this.store = initStore || {};
    }
    Schemas.prototype.add = function(inputSchema) {
      const schema = fastClone(
        inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema
      );
      const id3 = schema.$id;
      if (!id3) {
        throw new FST_ERR_SCH_MISSING_ID();
      }
      if (this.store[id3]) {
        throw new FST_ERR_SCH_ALREADY_PRESENT(id3);
      }
      this.store[id3] = schema;
    };
    Schemas.prototype.getSchemas = function() {
      return Object.assign({}, this.store);
    };
    Schemas.prototype.getSchema = function(schemaId) {
      return this.store[schemaId];
    };
    function isCustomSchemaPrototype(schema) {
      return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
    }
    function normalizeSchema(routeSchemas, serverOptions) {
      if (routeSchemas[kSchemaVisited]) {
        return routeSchemas;
      }
      if (routeSchemas.query) {
        if (routeSchemas.querystring) {
          throw new FST_ERR_SCH_DUPLICATE("querystring");
        }
        routeSchemas.querystring = routeSchemas.query;
      }
      generateFluentSchema(routeSchemas);
      for (const key of SCHEMAS_SOURCE) {
        const schema = routeSchemas[key];
        if (schema && !isCustomSchemaPrototype(schema)) {
          if (key === "body" && schema.content) {
            const contentProperty = schema.content;
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const contentType = keys[i];
              const contentSchema = contentProperty[contentType].schema;
              if (!contentSchema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType);
              }
            }
            continue;
          }
        }
      }
      if (routeSchemas.response) {
        const httpCodes = Object.keys(routeSchemas.response);
        for (const code of httpCodes) {
          if (isCustomSchemaPrototype(routeSchemas.response[code])) {
            continue;
          }
          const contentProperty = routeSchemas.response[code].content;
          if (contentProperty) {
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const mediaName = keys[i];
              if (!contentProperty[mediaName].schema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
              }
            }
          }
        }
      }
      routeSchemas[kSchemaVisited] = true;
      return routeSchemas;
    }
    function generateFluentSchema(schema) {
      for (const key of SCHEMAS_SOURCE) {
        if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
          schema[key] = schema[key].valueOf();
        }
      }
      if (schema.response) {
        const httpCodes = Object.keys(schema.response);
        for (const code of httpCodes) {
          if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
            schema.response[code] = schema.response[code].valueOf();
          }
        }
      }
    }
    function getSchemaSerializer(context, statusCode, contentType) {
      const responseSchemaDef = context[kSchemaResponse];
      if (!responseSchemaDef) {
        return false;
      }
      if (responseSchemaDef[statusCode]) {
        if (responseSchemaDef[statusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[statusCode][mediaName]) {
            return responseSchemaDef[statusCode][mediaName];
          }
          if (responseSchemaDef[statusCode]["*/*"]) {
            return responseSchemaDef[statusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[statusCode];
      }
      const fallbackStatusCode = (statusCode + "")[0] + "xx";
      if (responseSchemaDef[fallbackStatusCode]) {
        if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[fallbackStatusCode][mediaName]) {
            return responseSchemaDef[fallbackStatusCode][mediaName];
          }
          if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
            return responseSchemaDef[fallbackStatusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[fallbackStatusCode];
      }
      if (responseSchemaDef.default) {
        if (responseSchemaDef.default.constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef.default[mediaName]) {
            return responseSchemaDef.default[mediaName];
          }
          if (responseSchemaDef.default["*/*"]) {
            return responseSchemaDef.default["*/*"];
          }
          return false;
        }
        return responseSchemaDef.default;
      }
      return false;
    }
    module2.exports = {
      buildSchemas(initStore) {
        return new Schemas(initStore);
      },
      getSchemaSerializer,
      normalizeSchema
    };
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/serializer.js
var require_serializer = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/serializer.js"(exports2, module2) {
    "use strict";
    var STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    module2.exports = class Serializer {
      constructor(options) {
        switch (options && options.rounding) {
          case "floor":
            this.parseInteger = Math.floor;
            break;
          case "ceil":
            this.parseInteger = Math.ceil;
            break;
          case "round":
            this.parseInteger = Math.round;
            break;
          case "trunc":
          default:
            this.parseInteger = Math.trunc;
            break;
        }
        this._options = options;
      }
      asInteger(i) {
        if (Number.isInteger(i)) {
          return "" + i;
        } else if (typeof i === "bigint") {
          return i.toString();
        }
        const integer = this.parseInteger(i);
        if (integer === Infinity || integer === -Infinity || integer !== integer) {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
        return "" + integer;
      }
      asNumber(i) {
        const num = Number(i);
        if (num !== num) {
          throw new Error(`The value "${i}" cannot be converted to a number.`);
        } else if (num === Infinity || num === -Infinity) {
          return "null";
        } else {
          return "" + num;
        }
      }
      asBoolean(bool) {
        return bool && "true" || "false";
      }
      asDateTime(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + date.toISOString() + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a date-time.`);
      }
      asDate(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a date.`);
      }
      asTime(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a time.`);
      }
      asString(str) {
        const len = str.length;
        if (len < 42) {
          let result = "";
          let last = -1;
          let point = 255;
          for (var i = 0; i < len; i++) {
            point = str.charCodeAt(i);
            if (point === 34 || // '"'
            point === 92) {
              last === -1 && (last = 0);
              result += str.slice(last, i) + "\\";
              last = i;
            } else if (point < 32 || point >= 55296 && point <= 57343) {
              return JSON.stringify(str);
            }
          }
          return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
        } else if (len < 5e3 && STR_ESCAPE.test(str) === false) {
          return '"' + str + '"';
        } else {
          return JSON.stringify(str);
        }
      }
      asUnsafeString(str) {
        return '"' + str + '"';
      }
      getState() {
        return this._options;
      }
      static restoreFromState(state) {
        return new Serializer(state);
      }
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/error-serializer.js
var require_error_serializer = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/error-serializer.js"(exports2, module2) {
    "use strict";
    var Serializer = require_serializer();
    var serializerState = { "mode": "standalone" };
    var serializer = Serializer.restoreFromState(serializerState);
    var validator = null;
    module2.exports = function anonymous(validator2, serializer2) {
      const JSON_STR_BEGIN_OBJECT = "{";
      const JSON_STR_END_OBJECT = "}";
      const JSON_STR_BEGIN_ARRAY = "[";
      const JSON_STR_END_ARRAY = "]";
      const JSON_STR_COMMA = ",";
      const JSON_STR_COLONS = ":";
      const JSON_STR_QUOTE = '"';
      const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
      const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY;
      const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
      const JSON_STR_NULL = "null";
      function anonymous0(input) {
        const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
        if (obj === null) return JSON_STR_EMPTY_OBJECT;
        let value;
        let json = JSON_STR_BEGIN_OBJECT;
        let addComma = false;
        value = obj["statusCode"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"statusCode":';
          json += serializer2.asNumber(value);
        }
        value = obj["code"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"code":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        value = obj["error"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"error":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        value = obj["message"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"message":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        return json + JSON_STR_END_OBJECT;
      }
      const main = anonymous0;
      return main;
    }(validator, serializer);
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/error-handler.js
var require_error_handler = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/error-handler.js"(exports2, module2) {
    "use strict";
    var statusCodes = require("node:http").STATUS_CODES;
    var wrapThenable = require_wrapThenable();
    var {
      kReplyHeaders,
      kReplyNextErrorHandler,
      kReplyIsRunningOnErrorHook,
      kReplyHasStatusCode,
      kRouteContext,
      kDisableRequestLogging
    } = require_symbols2();
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_FAILED_ERROR_SERIALIZATION
    } = require_errors2();
    var { getSchemaSerializer } = require_schemas();
    var serializeError = require_error_serializer();
    var rootErrorHandler = {
      func: defaultErrorHandler,
      toJSON() {
        return this.func.name.toString() + "()";
      }
    };
    function handleError(reply, error, cb) {
      reply[kReplyIsRunningOnErrorHook] = false;
      const context = reply[kRouteContext];
      if (reply[kReplyNextErrorHandler] === false) {
        fallbackErrorHandler(error, reply, function(reply2, payload) {
          try {
            reply2.raw.writeHead(reply2.raw.statusCode, reply2[kReplyHeaders]);
          } catch (error2) {
            if (!reply2.log[kDisableRequestLogging]) {
              reply2.log.warn(
                { req: reply2.request, res: reply2, err: error2 },
                error2 && error2.message
              );
            }
            reply2.raw.writeHead(reply2.raw.statusCode);
          }
          reply2.raw.end(payload);
        });
        return;
      }
      const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;
      reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);
      delete reply[kReplyHeaders]["content-type"];
      delete reply[kReplyHeaders]["content-length"];
      const func = errorHandler.func;
      if (!func) {
        reply[kReplyNextErrorHandler] = false;
        fallbackErrorHandler(error, reply, cb);
        return;
      }
      try {
        const result = func(error, reply.request, reply);
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply);
          } else {
            reply.send(result);
          }
        }
      } catch (err) {
        reply.send(err);
      }
    }
    function defaultErrorHandler(error, request, reply) {
      setErrorHeaders(error, reply);
      if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
        const statusCode = error.statusCode || error.status;
        reply.code(statusCode >= 400 ? statusCode : 500);
      }
      if (reply.statusCode < 500) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.info(
            { res: reply, err: error },
            error && error.message
          );
        }
      } else {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error(
            { req: request, res: reply, err: error },
            error && error.message
          );
        }
      }
      reply.send(error);
    }
    function fallbackErrorHandler(error, reply, cb) {
      const res = reply.raw;
      const statusCode = reply.statusCode;
      reply[kReplyHeaders]["content-type"] = reply[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
      let payload;
      try {
        const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]["content-type"]);
        payload = serializerFn === false ? serializeError({
          error: statusCodes[statusCode + ""],
          code: error.code,
          message: error.message,
          statusCode
        }) : serializerFn(Object.create(error, {
          error: { value: statusCodes[statusCode + ""] },
          message: { value: error.message },
          statusCode: { value: statusCode }
        }));
      } catch (err) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
        }
        reply.code(500);
        payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
      }
      reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      cb(reply, payload);
    }
    function buildErrorHandler(parent = rootErrorHandler, func) {
      if (!func) {
        return parent;
      }
      const errorHandler = Object.create(parent);
      errorHandler.func = func;
      return errorHandler;
    }
    function setErrorHeaders(error, reply) {
      const res = reply.raw;
      let statusCode = res.statusCode;
      statusCode = statusCode >= 400 ? statusCode : 500;
      if (error != null) {
        if (error.headers !== void 0) {
          reply.headers(error.headers);
        }
        if (error.status >= 400) {
          statusCode = error.status;
        } else if (error.statusCode >= 400) {
          statusCode = error.statusCode;
        }
      }
      res.statusCode = statusCode;
    }
    module2.exports = {
      buildErrorHandler,
      handleError
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/reply.js
var require_reply = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/reply.js"(exports2, module2) {
    "use strict";
    var eos = require("node:stream").finished;
    var Readable = require("node:stream").Readable;
    var {
      kFourOhFourContext,
      kReplyErrorHandlerCalled,
      kReplyHijacked,
      kReplyStartTime,
      kReplyEndTime,
      kReplySerializer,
      kReplySerializerDefault,
      kReplyIsError,
      kReplyHeaders,
      kReplyTrailers,
      kReplyHasStatusCode,
      kReplyIsRunningOnErrorHook,
      kReplyNextErrorHandler,
      kDisableRequestLogging,
      kSchemaResponse,
      kReplyCacheSerializeFns,
      kSchemaController,
      kOptions,
      kRouteContext
    } = require_symbols2();
    var {
      onSendHookRunner,
      onResponseHookRunner,
      preHandlerHookRunner,
      preSerializationHookRunner
    } = require_hooks();
    var internals = require_handleRequest()[Symbol.for("internals")];
    var loggerUtils = require_logger_factory();
    var now = loggerUtils.now;
    var { handleError } = require_error_handler();
    var { getSchemaSerializer } = require_schemas();
    var CONTENT_TYPE = {
      JSON: "application/json; charset=utf-8",
      PLAIN: "text/plain; charset=utf-8",
      OCTET: "application/octet-stream"
    };
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_REP_RESPONSE_BODY_CONSUMED,
      FST_ERR_REP_ALREADY_SENT,
      FST_ERR_SEND_INSIDE_ONERR,
      FST_ERR_BAD_STATUS_CODE,
      FST_ERR_BAD_TRAILER_NAME,
      FST_ERR_BAD_TRAILER_VALUE,
      FST_ERR_MISSING_SERIALIZATION_FN,
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN
    } = require_errors2();
    var toString4 = Object.prototype.toString;
    function Reply(res, request, log) {
      this.raw = res;
      this[kReplySerializer] = null;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyIsError] = false;
      this[kReplyIsRunningOnErrorHook] = false;
      this.request = request;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyHasStatusCode] = false;
      this[kReplyStartTime] = void 0;
      this.log = log;
    }
    Reply.props = [];
    Object.defineProperties(Reply.prototype, {
      [kRouteContext]: {
        get() {
          return this.request[kRouteContext];
        }
      },
      elapsedTime: {
        get() {
          if (this[kReplyStartTime] === void 0) {
            return 0;
          }
          return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
        }
      },
      server: {
        get() {
          return this.request[kRouteContext].server;
        }
      },
      sent: {
        enumerable: true,
        get() {
          return (this[kReplyHijacked] || this.raw.writableEnded) === true;
        }
      },
      statusCode: {
        get() {
          return this.raw.statusCode;
        },
        set(value) {
          this.code(value);
        }
      },
      routeOptions: {
        get() {
          return this.request.routeOptions;
        }
      }
    });
    Reply.prototype.writeEarlyHints = function(hints, callback) {
      this.raw.writeEarlyHints(hints, callback);
      return this;
    };
    Reply.prototype.hijack = function() {
      this[kReplyHijacked] = true;
      return this;
    };
    Reply.prototype.send = function(payload) {
      if (this[kReplyIsRunningOnErrorHook] === true) {
        throw new FST_ERR_SEND_INSIDE_ONERR();
      }
      if (this.sent) {
        this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
        return this;
      }
      if (payload instanceof Error || this[kReplyIsError] === true) {
        this[kReplyIsError] = false;
        onErrorHook(this, payload, onSendHook);
        return this;
      }
      if (payload === void 0) {
        onSendHook(this, payload);
        return this;
      }
      const contentType = this.getHeader("content-type");
      const hasContentType = contentType !== void 0;
      if (payload !== null) {
        if (
          // node:stream
          typeof payload.pipe === "function" || // node:stream/web
          typeof payload.getReader === "function" || // Response
          toString4.call(payload) === "[object Response]"
        ) {
          onSendHook(this, payload);
          return this;
        }
        if (payload?.buffer instanceof ArrayBuffer) {
          if (hasContentType === false) {
            this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
          }
          const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
          onSendHook(this, payloadToSend);
          return this;
        }
        if (hasContentType === false && typeof payload === "string") {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
          onSendHook(this, payload);
          return this;
        }
      }
      if (this[kReplySerializer] !== null) {
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        } else {
          payload = this[kReplySerializer](payload);
        }
      } else if (hasContentType === false || contentType.indexOf("json") > -1) {
        if (hasContentType === false) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
        } else {
          if (contentType.indexOf("charset") === -1) {
            const customContentType = contentType.trim();
            if (customContentType.endsWith(";")) {
              this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
            } else {
              this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
            }
          }
        }
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        }
      }
      onSendHook(this, payload);
      return this;
    };
    Reply.prototype.getHeader = function(key) {
      key = key.toLowerCase();
      const res = this.raw;
      let value = this[kReplyHeaders][key];
      if (value === void 0 && res.hasHeader(key)) {
        value = res.getHeader(key);
      }
      return value;
    };
    Reply.prototype.getHeaders = function() {
      return {
        ...this.raw.getHeaders(),
        ...this[kReplyHeaders]
      };
    };
    Reply.prototype.hasHeader = function(key) {
      key = key.toLowerCase();
      return this[kReplyHeaders][key] !== void 0 || this.raw.hasHeader(key);
    };
    Reply.prototype.removeHeader = function(key) {
      delete this[kReplyHeaders][key.toLowerCase()];
      return this;
    };
    Reply.prototype.header = function(key, value = "") {
      key = key.toLowerCase();
      if (this[kReplyHeaders][key] && key === "set-cookie") {
        if (typeof this[kReplyHeaders][key] === "string") {
          this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
        }
        if (Array.isArray(value)) {
          Array.prototype.push.apply(this[kReplyHeaders][key], value);
        } else {
          this[kReplyHeaders][key].push(value);
        }
      } else {
        this[kReplyHeaders][key] = value;
      }
      return this;
    };
    Reply.prototype.headers = function(headers) {
      const keys = Object.keys(headers);
      for (let i = 0; i !== keys.length; ++i) {
        const key = keys[i];
        this.header(key, headers[key]);
      }
      return this;
    };
    var INVALID_TRAILERS = /* @__PURE__ */ new Set([
      "transfer-encoding",
      "content-length",
      "host",
      "cache-control",
      "max-forwards",
      "te",
      "authorization",
      "set-cookie",
      "content-encoding",
      "content-type",
      "content-range",
      "trailer"
    ]);
    Reply.prototype.trailer = function(key, fn) {
      key = key.toLowerCase();
      if (INVALID_TRAILERS.has(key)) {
        throw new FST_ERR_BAD_TRAILER_NAME(key);
      }
      if (typeof fn !== "function") {
        throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
      }
      if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
      this[kReplyTrailers][key] = fn;
      return this;
    };
    Reply.prototype.hasTrailer = function(key) {
      return this[kReplyTrailers]?.[key.toLowerCase()] !== void 0;
    };
    Reply.prototype.removeTrailer = function(key) {
      if (this[kReplyTrailers] === null) return this;
      this[kReplyTrailers][key.toLowerCase()] = void 0;
      return this;
    };
    Reply.prototype.code = function(code) {
      const intValue = Number(code);
      if (isNaN(intValue) || intValue < 100 || intValue > 599) {
        throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
      }
      this.raw.statusCode = intValue;
      this[kReplyHasStatusCode] = true;
      return this;
    };
    Reply.prototype.status = Reply.prototype.code;
    Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
      let serialize2;
      if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
        if (typeof contentType === "string") {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
        }
      } else if (typeof schemaOrStatus === "object") {
        serialize2 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
      }
      return serialize2;
    };
    Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType = null) {
      const { request } = this;
      const { method, url } = request;
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      }
      const serializerCompiler = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
      // nor set
      (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
      const serializeFn = serializerCompiler({
        schema,
        method,
        url,
        httpStatus,
        contentType
      });
      if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
        this[kRouteContext][kReplyCacheSerializeFns] = /* @__PURE__ */ new WeakMap();
      }
      this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
      return serializeFn;
    };
    Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType) {
      const possibleContentType = httpStatus;
      let serialize2;
      httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
      contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
      if (httpStatus != null) {
        if (contentType != null) {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
        }
        if (serialize2 == null) {
          if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
          throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
        }
      } else {
        if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
          serialize2 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
        } else {
          serialize2 = this.compileSerializationSchema(schema, httpStatus, contentType);
        }
      }
      return serialize2(input);
    };
    Reply.prototype.serialize = function(payload) {
      if (this[kReplySerializer] !== null) {
        return this[kReplySerializer](payload);
      } else {
        if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
          return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
        } else {
          return serialize(this[kRouteContext], payload, this.raw.statusCode);
        }
      }
    };
    Reply.prototype.serializer = function(fn) {
      this[kReplySerializer] = fn;
      return this;
    };
    Reply.prototype.type = function(type) {
      this[kReplyHeaders]["content-type"] = type;
      return this;
    };
    Reply.prototype.redirect = function(url, code) {
      if (!code) {
        code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
      }
      return this.header("location", url).code(code).send();
    };
    Reply.prototype.callNotFound = function() {
      notFound(this);
      return this;
    };
    Reply.prototype.then = function(fulfilled, rejected) {
      if (this.sent) {
        fulfilled();
        return;
      }
      eos(this.raw, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          if (rejected) {
            rejected(err);
          } else {
            this.log && this.log.warn("unhandled rejection on reply.then");
          }
        } else {
          fulfilled();
        }
      });
    };
    function preSerializationHook(reply, payload) {
      if (reply[kRouteContext].preSerialization !== null) {
        preSerializationHookRunner(
          reply[kRouteContext].preSerialization,
          reply.request,
          reply,
          payload,
          preSerializationHookEnd
        );
      } else {
        preSerializationHookEnd(null, reply.request, reply, payload);
      }
    }
    function preSerializationHookEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
        return;
      }
      try {
        if (reply[kReplySerializer] !== null) {
          payload = reply[kReplySerializer](payload);
        } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
          payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
        } else {
          payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]["content-type"]);
        }
      } catch (e2) {
        wrapSerializationError(e2, reply);
        onErrorHook(reply, e2);
        return;
      }
      onSendHook(reply, payload);
    }
    function wrapSerializationError(error, reply) {
      error.serialization = reply[kRouteContext].config;
    }
    function onSendHook(reply, payload) {
      if (reply[kRouteContext].onSend !== null) {
        onSendHookRunner(
          reply[kRouteContext].onSend,
          reply.request,
          reply,
          payload,
          wrapOnSendEnd
        );
      } else {
        onSendEnd(reply, payload);
      }
    }
    function wrapOnSendEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
      } else {
        onSendEnd(reply, payload);
      }
    }
    function safeWriteHead(reply, statusCode) {
      const res = reply.raw;
      try {
        res.writeHead(statusCode, reply[kReplyHeaders]);
      } catch (err) {
        if (err.code === "ERR_HTTP_HEADERS_SENT") {
          reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
        }
        throw err;
      }
    }
    function onSendEnd(reply, payload) {
      const res = reply.raw;
      const req = reply.request;
      if (reply[kReplyTrailers] !== null) {
        const trailerHeaders = Object.keys(reply[kReplyTrailers]);
        let header = "";
        for (const trailerName of trailerHeaders) {
          if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
          header += " ";
          header += trailerName;
        }
        reply.header("Transfer-Encoding", "chunked");
        reply.header("Trailer", header.trim());
      }
      if (toString4.call(payload) === "[object Response]") {
        if (typeof payload.status === "number") {
          reply.code(payload.status);
        }
        if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
          for (const [headerName, headerValue] of payload.headers) {
            reply.header(headerName, headerValue);
          }
        }
        if (payload.body !== null) {
          if (payload.bodyUsed) {
            throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED();
          }
        }
        payload = payload.body;
      }
      const statusCode = res.statusCode;
      if (payload === void 0 || payload === null) {
        if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD" && reply[kReplyTrailers] === null) {
          reply[kReplyHeaders]["content-length"] = "0";
        }
        safeWriteHead(reply, statusCode);
        sendTrailer(payload, res, reply);
        return;
      }
      if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
        reply.removeHeader("content-type");
        reply.removeHeader("content-length");
        safeWriteHead(reply, statusCode);
        sendTrailer(void 0, res, reply);
        if (typeof payload.resume === "function") {
          payload.on("error", noop);
          payload.resume();
        }
        return;
      }
      if (typeof payload.pipe === "function") {
        sendStream(payload, res, reply);
        return;
      }
      if (typeof payload.getReader === "function") {
        sendWebStream(payload, res, reply);
        return;
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
      }
      if (reply[kReplyTrailers] === null) {
        const contentLength = reply[kReplyHeaders]["content-length"];
        if (!contentLength || req.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
          reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
        }
      }
      safeWriteHead(reply, statusCode);
      res.write(payload);
      sendTrailer(payload, res, reply);
    }
    function logStreamError(logger, err, res) {
      if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
        if (!logger[kDisableRequestLogging]) {
          logger.info({ res }, "stream closed prematurely");
        }
      } else {
        logger.warn({ err }, "response terminated with an error with headers already sent");
      }
    }
    function sendWebStream(payload, res, reply) {
      const nodeStream = Readable.fromWeb(payload);
      sendStream(nodeStream, res, reply);
    }
    function sendStream(payload, res, reply) {
      let sourceOpen = true;
      let errorLogged = false;
      sendStreamTrailer(payload, res, reply);
      eos(payload, { readable: true, writable: false }, function(err) {
        sourceOpen = false;
        if (err != null) {
          if (res.headersSent || reply.request.raw.aborted === true) {
            if (!errorLogged) {
              errorLogged = true;
              logStreamError(reply.log, err, reply);
            }
            res.destroy();
          } else {
            onErrorHook(reply, err);
          }
        }
      });
      eos(res, function(err) {
        if (sourceOpen) {
          if (err != null && res.headersSent && !errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, res);
          }
          if (typeof payload.destroy === "function") {
            payload.destroy();
          } else if (typeof payload.close === "function") {
            payload.close(noop);
          } else if (typeof payload.abort === "function") {
            payload.abort();
          } else {
            reply.log.warn("stream payload does not end properly");
          }
        }
      });
      if (!res.headersSent) {
        for (const key in reply[kReplyHeaders]) {
          res.setHeader(key, reply[kReplyHeaders][key]);
        }
      } else {
        reply.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
      }
      payload.pipe(res);
    }
    function sendTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) {
        res.end(null, null, null);
        return;
      }
      const trailerHeaders = Object.keys(reply[kReplyTrailers]);
      const trailers = {};
      let handled = 0;
      let skipped = true;
      function send() {
        if (handled === 0) {
          res.addTrailers(trailers);
          res.end(null, null, null);
        }
      }
      for (const trailerName of trailerHeaders) {
        let cb = function(err, value) {
          handled++;
          if (err) reply.log.debug(err);
          else trailers[trailerName] = value;
          process.nextTick(send);
        };
        if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
        skipped = false;
        handled--;
        const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
        if (typeof result === "object" && typeof result.then === "function") {
          result.then((v) => cb(null, v), cb);
        }
      }
      if (skipped) res.end(null, null, null);
    }
    function sendStreamTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) return;
      payload.on("end", () => sendTrailer(null, res, reply));
    }
    function onErrorHook(reply, error, cb) {
      if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
        reply[kReplyIsRunningOnErrorHook] = true;
        onSendHookRunner(
          reply[kRouteContext].onError,
          reply.request,
          reply,
          error,
          () => handleError(reply, error, cb)
        );
      } else {
        handleError(reply, error, cb);
      }
    }
    function setupResponseListeners(reply) {
      reply[kReplyStartTime] = now();
      const onResFinished = (err) => {
        reply[kReplyEndTime] = now();
        reply.raw.removeListener("finish", onResFinished);
        reply.raw.removeListener("error", onResFinished);
        const ctx = reply[kRouteContext];
        if (ctx && ctx.onResponse !== null) {
          onResponseHookRunner(
            ctx.onResponse,
            reply.request,
            reply,
            onResponseCallback
          );
        } else {
          onResponseCallback(err, reply.request, reply);
        }
      };
      reply.raw.on("finish", onResFinished);
      reply.raw.on("error", onResFinished);
    }
    function onResponseCallback(err, request, reply) {
      if (reply.log[kDisableRequestLogging]) {
        return;
      }
      const responseTime = reply.elapsedTime;
      if (err != null) {
        reply.log.error({
          res: reply,
          err,
          responseTime
        }, "request errored");
        return;
      }
      reply.log.info({
        res: reply,
        responseTime
      }, "request completed");
    }
    function buildReply(R) {
      const props = R.props.slice();
      function _Reply(res, request, log) {
        this.raw = res;
        this[kReplyIsError] = false;
        this[kReplyErrorHandlerCalled] = false;
        this[kReplyHijacked] = false;
        this[kReplySerializer] = null;
        this.request = request;
        this[kReplyHeaders] = {};
        this[kReplyTrailers] = null;
        this[kReplyStartTime] = void 0;
        this[kReplyEndTime] = void 0;
        this.log = log;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Reply.prototype, R.prototype);
      Object.setPrototypeOf(_Reply, R);
      _Reply.parent = R;
      _Reply.props = props;
      return _Reply;
    }
    function notFound(reply) {
      if (reply[kRouteContext][kFourOhFourContext] === null) {
        reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
        reply.code(404).send("404 Not Found");
        return;
      }
      reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];
      if (reply[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          reply[kRouteContext].preHandler,
          reply.request,
          reply,
          internals.preHandlerCallback
        );
      } else {
        internals.preHandlerCallback(null, reply.request, reply);
      }
    }
    function serialize(context, data4, statusCode, contentType) {
      const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
      if (fnSerialize) {
        return fnSerialize(data4);
      }
      return JSON.stringify(data4);
    }
    function noop() {
    }
    module2.exports = Reply;
    module2.exports.buildReply = buildReply;
    module2.exports.setupResponseListeners = setupResponseListeners;
  }
});

// ../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js
var require_forwarded = __commonJS({
  "../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js"(exports2, module2) {
    "use strict";
    module2.exports = forwarded;
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
      var socketAddr = getSocketAddr(req);
      var addrs = [socketAddr].concat(proxyAddrs);
      return addrs;
    }
    function getSocketAddr(req) {
      return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
    }
    function parse(header) {
      var end = header.length;
      var list = [];
      var start2 = header.length;
      for (var i = header.length - 1; i >= 0; i--) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start2 === end) {
              start2 = end = i;
            }
            break;
          case 44:
            if (start2 !== end) {
              list.push(header.substring(start2, end));
            }
            start2 = end = i;
            break;
          default:
            start2 = i;
            break;
        }
      }
      if (start2 !== end) {
        list.push(header.substring(start2, end));
      }
      return list;
    }
  }
});

// ../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros3, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros3 = zerotable[octet];
              if (stop && zeros3 !== 0) {
                return null;
              }
              if (zeros3 !== 8) {
                stop = true;
              }
              cidr += zeros3;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string2) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string3) {
          if (string3[0] === "0" && string3[1] !== "x") {
            return parseInt(string3, 8);
          } else {
            return parseInt(string3);
          }
        };
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string2;
          regex = /((^|:)(0(:|$)){2,})/g;
          string2 = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return string2.substring(0, bestMatchIndex) + "::" + string2.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes2, k, len, part, ref;
          bytes2 = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros3, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros3 = zerotable[part];
              if (stop && zeros3 !== 0) {
                return null;
              }
              if (zeros3 !== 16) {
                stop = true;
              }
              cidr += zeros3;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string2, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string2.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts = function() {
          var k, len, ref, results;
          ref = string2.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr.IPv6.parser = function(string2) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string2)) {
          return expandIPv6(string2, 8);
        } else if (match = string2.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr.IPv4.isValid = function(string2) {
        var e2;
        try {
          new this(this.parser(string2));
          return true;
        } catch (error1) {
          e2 = error1;
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function(string2) {
        var addr, e2;
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          e2 = error1;
          return false;
        }
      };
      ipaddr.IPv4.parse = function(string2) {
        var parts;
        parts = this.parser(string2);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function(string2) {
        var addr;
        addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function(string2) {
        var maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string2) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string2) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv6.parseCIDR = function(string2) {
        var maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function(string2) {
        return ipaddr.IPv6.isValid(string2) || ipaddr.IPv4.isValid(string2);
      };
      ipaddr.parse = function(string2) {
        if (ipaddr.IPv6.isValid(string2)) {
          return ipaddr.IPv6.parse(string2);
        } else if (ipaddr.IPv4.isValid(string2)) {
          return ipaddr.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string2) {
        var e2;
        try {
          return ipaddr.IPv6.parseCIDR(string2);
        } catch (error1) {
          e2 = error1;
          try {
            return ipaddr.IPv4.parseCIDR(string2);
          } catch (error12) {
            e2 = error12;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function(bytes2) {
        var length;
        length = bytes2.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes2);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function(string2) {
        var addr;
        addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports2);
  }
});

// ../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    module2.exports = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      var addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i)) continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      var trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      var len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      var pos = note.lastIndexOf("/");
      var str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      var ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      var max = ip.kind() === "ipv6" ? 128 : 32;
      var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr)) return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          var subnet = subnets[i];
          var subnetip = subnet[0];
          var subnetkind = subnetip.kind();
          var subnetrange = subnet[1];
          var trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === "ipv4";
      var subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr)) return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/request.js
var require_request = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/request.js"(exports2, module2) {
    "use strict";
    var proxyAddr = require_proxy_addr();
    var {
      kHasBeenDecorated,
      kSchemaBody,
      kSchemaHeaders,
      kSchemaParams,
      kSchemaQuerystring,
      kSchemaController,
      kOptions,
      kRequestCacheValidateFns,
      kRouteContext,
      kRequestOriginalUrl
    } = require_symbols2();
    var { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION } = require_errors2();
    var HTTP_PART_SYMBOL_MAP = {
      body: kSchemaBody,
      headers: kSchemaHeaders,
      params: kSchemaParams,
      querystring: kSchemaQuerystring,
      query: kSchemaQuerystring
    };
    function Request(id3, params, req, query, log, context) {
      this.id = id3;
      this[kRouteContext] = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log;
      this.body = void 0;
    }
    Request.props = [];
    function getTrustProxyFn(tp) {
      if (typeof tp === "function") {
        return tp;
      }
      if (tp === true) {
        return null;
      }
      if (typeof tp === "number") {
        return function(a2, i) {
          return i < tp;
        };
      }
      if (typeof tp === "string") {
        const values = tp.split(",").map((it) => it.trim());
        return proxyAddr.compile(values);
      }
      return proxyAddr.compile(tp);
    }
    function buildRequest(R, trustProxy) {
      if (trustProxy) {
        return buildRequestWithTrustProxy(R, trustProxy);
      }
      return buildRegularRequest(R);
    }
    function buildRegularRequest(R) {
      const props = R.props.slice();
      function _Request(id3, params, req, query, log, context) {
        this.id = id3;
        this[kRouteContext] = context;
        this.params = params;
        this.raw = req;
        this.query = query;
        this.log = log;
        this.body = void 0;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Request.prototype, R.prototype);
      Object.setPrototypeOf(_Request, R);
      _Request.props = props;
      _Request.parent = R;
      return _Request;
    }
    function getLastEntryInMultiHeaderValue(headerValue) {
      const lastIndex = headerValue.lastIndexOf(",");
      return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
    }
    function buildRequestWithTrustProxy(R, trustProxy) {
      const _Request = buildRegularRequest(R);
      const proxyFn = getTrustProxyFn(trustProxy);
      _Request[kHasBeenDecorated] = true;
      Object.defineProperties(_Request.prototype, {
        ip: {
          get() {
            const addrs = proxyAddr.all(this.raw, proxyFn);
            return addrs[addrs.length - 1];
          }
        },
        ips: {
          get() {
            return proxyAddr.all(this.raw, proxyFn);
          }
        },
        host: {
          get() {
            if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
            }
            let host = this.headers.host ?? this.headers[":authority"];
            if (this.server.server.requireHostHeader === false) host ??= "";
            return host;
          }
        },
        protocol: {
          get() {
            if (this.headers["x-forwarded-proto"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
            }
            if (this.socket) {
              return this.socket.encrypted ? "https" : "http";
            }
          }
        }
      });
      return _Request;
    }
    Object.defineProperties(Request.prototype, {
      server: {
        get() {
          return this[kRouteContext].server;
        }
      },
      url: {
        get() {
          return this.raw.url;
        }
      },
      originalUrl: {
        get() {
          if (!this[kRequestOriginalUrl]) {
            this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
          }
          return this[kRequestOriginalUrl];
        }
      },
      method: {
        get() {
          return this.raw.method;
        }
      },
      routeOptions: {
        get() {
          const context = this[kRouteContext];
          const routeLimit = context._parserOptions.limit;
          const serverLimit = context.server.initialConfig.bodyLimit;
          const version4 = context.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0;
          const options = {
            method: context.config?.method,
            url: context.config?.url,
            bodyLimit: routeLimit || serverLimit,
            attachValidation: context.attachValidation,
            logLevel: context.logLevel,
            exposeHeadRoute: context.exposeHeadRoute,
            prefixTrailingSlash: context.prefixTrailingSlash,
            handler: context.handler,
            version: version4
          };
          Object.defineProperties(options, {
            config: {
              get: () => context.config
            },
            schema: {
              get: () => context.schema
            }
          });
          return Object.freeze(options);
        }
      },
      is404: {
        get() {
          return this[kRouteContext].config?.url === void 0;
        }
      },
      socket: {
        get() {
          return this.raw.socket;
        }
      },
      ip: {
        get() {
          if (this.socket) {
            return this.socket.remoteAddress;
          }
        }
      },
      host: {
        get() {
          let host = this.raw.headers.host ?? this.raw.headers[":authority"];
          if (this.server.server.requireHostHeader === false) host ??= "";
          return host;
        }
      },
      hostname: {
        get() {
          return this.host.split(":", 1)[0];
        }
      },
      port: {
        get() {
          const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHost)) {
            return portFromHost;
          }
          let host = this.headers.host ?? this.headers[":authority"];
          if (this.server.server.requireHostHeader === false) host ??= "";
          const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHeader)) {
            return portFromHeader;
          }
          return null;
        }
      },
      protocol: {
        get() {
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      },
      headers: {
        get() {
          if (this.additionalHeaders) {
            return Object.assign({}, this.raw.headers, this.additionalHeaders);
          }
          return this.raw.headers;
        },
        set(headers) {
          this.additionalHeaders = headers;
        }
      },
      getValidationFunction: {
        value: function(httpPartOrSchema) {
          if (typeof httpPartOrSchema === "string") {
            const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
            return this[kRouteContext][symbol];
          } else if (typeof httpPartOrSchema === "object") {
            return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
          }
        }
      },
      compileValidationSchema: {
        value: function(schema, httpPart = null) {
          const { method, url } = this;
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            return this[kRouteContext][kRequestCacheValidateFns].get(schema);
          }
          const validatorCompiler = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
          // nor set
          (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
          const validateFn = validatorCompiler({
            schema,
            method,
            url,
            httpPart
          });
          if (this[kRouteContext][kRequestCacheValidateFns] == null) {
            this[kRouteContext][kRequestCacheValidateFns] = /* @__PURE__ */ new WeakMap();
          }
          this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
          return validateFn;
        }
      },
      validateInput: {
        value: function(input, schema, httpPart) {
          httpPart = typeof schema === "string" ? schema : httpPart;
          const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
          let validate;
          if (symbol) {
            validate = this[kRouteContext][symbol];
          }
          if (validate == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
            throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
          }
          if (validate == null) {
            if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
              validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
            } else {
              validate = this.compileValidationSchema(schema, httpPart);
            }
          }
          return validate(input);
        }
      }
    });
    module2.exports = Request;
    module2.exports.buildRequest = buildRequest;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/context.js
var require_context = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/context.js"(exports2, module2) {
    "use strict";
    var {
      kFourOhFourContext,
      kReplySerializerDefault,
      kSchemaErrorFormatter,
      kErrorHandler,
      kChildLoggerFactory,
      kOptions,
      kReply,
      kRequest,
      kBodyLimit,
      kLogLevel,
      kContentTypeParser,
      kRouteByFastify,
      kRequestCacheValidateFns,
      kReplyCacheSerializeFns
    } = require_symbols2();
    function Context({
      schema,
      handler,
      config,
      requestIdLogLabel,
      childLoggerFactory,
      errorHandler,
      bodyLimit,
      logLevel,
      logSerializers,
      attachValidation,
      validatorCompiler,
      serializerCompiler,
      replySerializer,
      schemaErrorFormatter,
      exposeHeadRoute,
      prefixTrailingSlash,
      server,
      isFastify
    }) {
      this.schema = schema;
      this.handler = handler;
      this.Reply = server[kReply];
      this.Request = server[kRequest];
      this.contentTypeParser = server[kContentTypeParser];
      this.onRequest = null;
      this.onSend = null;
      this.onError = null;
      this.onTimeout = null;
      this.preHandler = null;
      this.onResponse = null;
      this.preSerialization = null;
      this.onRequestAbort = null;
      this.config = config;
      this.errorHandler = errorHandler || server[kErrorHandler];
      this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
      this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
      this._middie = null;
      this._parserOptions = {
        limit: bodyLimit || server[kBodyLimit]
      };
      this.exposeHeadRoute = exposeHeadRoute;
      this.prefixTrailingSlash = prefixTrailingSlash;
      this.logLevel = logLevel || server[kLogLevel];
      this.logSerializers = logSerializers;
      this[kFourOhFourContext] = null;
      this.attachValidation = attachValidation;
      this[kReplySerializerDefault] = replySerializer;
      this.schemaErrorFormatter = schemaErrorFormatter || server[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
      this[kRouteByFastify] = isFastify;
      this[kRequestCacheValidateFns] = null;
      this[kReplyCacheSerializeFns] = null;
      this.validatorCompiler = validatorCompiler || null;
      this.serializerCompiler = serializerCompiler || null;
      this.server = server;
    }
    function defaultSchemaErrorFormatter(errors, dataVar) {
      let text = "";
      const separator = ", ";
      for (let i = 0; i !== errors.length; ++i) {
        const e2 = errors[i];
        text += dataVar + (e2.instancePath || "") + " " + e2.message + separator;
      }
      return new Error(text.slice(0, -separator.length));
    }
    module2.exports = Context;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/decorate.js"(exports2, module2) {
    "use strict";
    var {
      kReply,
      kRequest,
      kState,
      kHasBeenDecorated
    } = require_symbols2();
    var {
      FST_ERR_DEC_ALREADY_PRESENT,
      FST_ERR_DEC_MISSING_DEPENDENCY,
      FST_ERR_DEC_AFTER_START,
      FST_ERR_DEC_REFERENCE_TYPE,
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE
    } = require_errors2();
    function decorate(instance, name, fn, dependencies) {
      if (Object.hasOwn(instance, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      checkDependencies(instance, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else {
        instance[name] = fn;
      }
    }
    function decorateConstructor(konstructor, name, fn, dependencies) {
      const instance = konstructor.prototype;
      if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      konstructor[kHasBeenDecorated] = true;
      checkDependencies(konstructor, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else if (typeof fn === "function") {
        instance[name] = fn;
      } else {
        konstructor.props.push({ key: name, value: fn });
      }
    }
    function checkReferenceType(name, fn) {
      if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
        throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
      }
    }
    function decorateFastify(name, fn, dependencies) {
      assertNotStarted(this, name);
      decorate(this, name, fn, dependencies);
      return this;
    }
    function checkExistence(instance, name) {
      if (name) {
        return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
      }
      return instance in this;
    }
    function hasKey(fn, name) {
      if (fn.props) {
        return fn.props.find(({ key }) => key === name);
      }
      return false;
    }
    function checkRequestExistence(name) {
      if (name && hasKey(this[kRequest], name)) return true;
      return checkExistence(this[kRequest].prototype, name);
    }
    function checkReplyExistence(name) {
      if (name && hasKey(this[kReply], name)) return true;
      return checkExistence(this[kReply].prototype, name);
    }
    function checkDependencies(instance, name, deps) {
      if (deps === void 0 || deps === null) {
        return;
      }
      if (!Array.isArray(deps)) {
        throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
      }
      for (let i = 0; i !== deps.length; ++i) {
        if (!checkExistence(instance, deps[i])) {
          throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
        }
      }
    }
    function decorateReply(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kReply], name, fn, dependencies);
      return this;
    }
    function decorateRequest(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kRequest], name, fn, dependencies);
      return this;
    }
    function assertNotStarted(instance, name) {
      if (instance[kState].started) {
        throw new FST_ERR_DEC_AFTER_START(name);
      }
    }
    module2.exports = {
      add: decorateFastify,
      exist: checkExistence,
      existRequest: checkRequestExistence,
      existReply: checkReplyExistence,
      dependencies: checkDependencies,
      decorateReply,
      decorateRequest
    };
  }
});

// ../../node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.cjs
var require_toad_cache = __commonJS({
  "../../node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.cjs"(exports2) {
    "use strict";
    var FifoMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const deletedItem = this.items.get(key);
          this.items.delete(key);
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          this.items.delete(key);
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          delete this.items[key];
          this.size--;
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var HitStatisticsRecord = class {
      constructor() {
        this.records = {};
      }
      initForCache(cacheId, currentTimeStamp) {
        this.records[cacheId] = {
          [currentTimeStamp]: {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          }
        };
      }
      resetForCache(cacheId) {
        for (let key of Object.keys(this.records[cacheId])) {
          this.records[cacheId][key] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          };
        }
      }
      getStatistics() {
        return this.records;
      }
    };
    function getTimestamp(date) {
      return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
    }
    var HitStatistics = class {
      constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
        this.cacheId = cacheId;
        this.statisticTtlInHours = statisticTtlInHours;
        this.collectionStart = /* @__PURE__ */ new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records = globalStatisticsRecord || new HitStatisticsRecord();
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
      get currentRecord() {
        if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
          this.records.records[this.cacheId][this.currentTimeStamp] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            sets: 0,
            invalidateOne: 0,
            invalidateAll: 0
          };
        }
        return this.records.records[this.cacheId][this.currentTimeStamp];
      }
      hoursPassed() {
        return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
      }
      addHit() {
        this.archiveIfNeeded();
        this.currentRecord.hits++;
      }
      addFalsyHit() {
        this.archiveIfNeeded();
        this.currentRecord.falsyHits++;
      }
      addEmptyHit() {
        this.archiveIfNeeded();
        this.currentRecord.emptyHits++;
      }
      addMiss() {
        this.archiveIfNeeded();
        this.currentRecord.misses++;
      }
      addEviction() {
        this.archiveIfNeeded();
        this.currentRecord.evictions++;
      }
      setCacheSize(currentSize) {
        this.archiveIfNeeded();
        this.currentRecord.cacheSize = currentSize;
      }
      addExpiration() {
        this.archiveIfNeeded();
        this.currentRecord.expirations++;
      }
      addSet() {
        this.archiveIfNeeded();
        this.currentRecord.sets++;
      }
      addInvalidateOne() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateOne++;
      }
      addInvalidateAll() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateAll++;
      }
      getStatistics() {
        return this.records.getStatistics();
      }
      archiveIfNeeded() {
        if (this.hoursPassed() >= this.statisticTtlInHours) {
          this.collectionStart = /* @__PURE__ */ new Date();
          this.currentTimeStamp = getTimestamp(this.collectionStart);
          this.records.initForCache(this.cacheId, this.currentTimeStamp);
        }
      }
    };
    var LruObjectHitStatistics = class extends LruObject {
      constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
        super(max || 1e3, ttlInMsecs || 0);
        if (!cacheId) {
          throw new Error("Cache id is mandatory");
        }
        this.hitStatistics = new HitStatistics(
          cacheId,
          statisticTtlInHours !== void 0 ? statisticTtlInHours : 24,
          globalStatisticsRecord
        );
      }
      getStatistics() {
        return this.hitStatistics.getStatistics();
      }
      set(key, value) {
        super.set(key, value);
        this.hitStatistics.addSet();
        this.hitStatistics.setCacheSize(this.size);
      }
      evict() {
        super.evict();
        this.hitStatistics.addEviction();
        this.hitStatistics.setCacheSize(this.size);
      }
      delete(key, isExpiration = false) {
        super.delete(key);
        if (!isExpiration) {
          this.hitStatistics.addInvalidateOne();
        }
        this.hitStatistics.setCacheSize(this.size);
      }
      clear() {
        super.clear();
        this.hitStatistics.addInvalidateAll();
        this.hitStatistics.setCacheSize(this.size);
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key, true);
            this.hitStatistics.addExpiration();
            return;
          }
          this.bumpLru(item);
          if (!item.value) {
            this.hitStatistics.addFalsyHit();
          }
          if (item.value === void 0 || item.value === null || item.value === "") {
            this.hitStatistics.addEmptyHit();
          }
          this.hitStatistics.addHit();
          return item.value;
        }
        this.hitStatistics.addMiss();
      }
    };
    var FifoObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const deletedItem = this.items[key];
          delete this.items[key];
          this.size--;
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    exports2.Fifo = FifoObject;
    exports2.FifoMap = FifoMap;
    exports2.FifoObject = FifoObject;
    exports2.HitStatisticsRecord = HitStatisticsRecord;
    exports2.Lru = LruObject;
    exports2.LruHitStatistics = LruObjectHitStatistics;
    exports2.LruMap = LruMap;
    exports2.LruObject = LruObject;
    exports2.LruObjectHitStatistics = LruObjectHitStatistics;
  }
});

// ../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js"(exports2, module2) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module2.exports = parse;
    module2.exports.default = parse;
    module2.exports.parse = parse;
    module2.exports.safeParse = safeParse;
    module2.exports.scan = filter;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/contentTypeParser.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("node:async_hooks");
    var { FifoMap: Fifo } = require_toad_cache();
    var secureJson = require_secure_json_parse();
    var {
      kDefaultJsonParse,
      kContentTypeParser,
      kBodyLimit,
      kRequestPayloadStream,
      kState,
      kTestInternals,
      kReplyIsError,
      kRouteContext
    } = require_symbols2();
    var {
      FST_ERR_CTP_INVALID_TYPE,
      FST_ERR_CTP_EMPTY_TYPE,
      FST_ERR_CTP_ALREADY_PRESENT,
      FST_ERR_CTP_INVALID_HANDLER,
      FST_ERR_CTP_INVALID_PARSE_TYPE,
      FST_ERR_CTP_BODY_TOO_LARGE,
      FST_ERR_CTP_INVALID_MEDIA_TYPE,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH,
      FST_ERR_CTP_EMPTY_JSON_BODY,
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED
    } = require_errors2();
    var { FSTSEC001 } = require_warnings();
    function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
      this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
      this.customParsers = /* @__PURE__ */ new Map();
      this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
      this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
      this.parserList = ["application/json", "text/plain"];
      this.parserRegExpList = [];
      this.cache = new Fifo(100);
    }
    ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
      const contentTypeIsString = typeof contentType === "string";
      if (contentTypeIsString) {
        contentType = contentType.trim().toLowerCase();
        if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
      } else if (!(contentType instanceof RegExp)) {
        throw new FST_ERR_CTP_INVALID_TYPE();
      }
      if (typeof parserFn !== "function") {
        throw new FST_ERR_CTP_INVALID_HANDLER();
      }
      if (this.existingParser(contentType)) {
        throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
      }
      if (opts.parseAs !== void 0) {
        if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
          throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
        }
      }
      const parser = new Parser(
        opts.parseAs === "string",
        opts.parseAs === "buffer",
        opts.bodyLimit,
        parserFn
      );
      if (contentType === "*") {
        this.customParsers.set("", parser);
      } else {
        if (contentTypeIsString) {
          this.parserList.unshift(contentType);
          this.customParsers.set(contentType, parser);
        } else {
          validateRegExp(contentType);
          this.parserRegExpList.unshift(contentType);
          this.customParsers.set(contentType.toString(), parser);
        }
      }
    };
    ContentTypeParser.prototype.hasParser = function(contentType) {
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
      }
      return this.customParsers.has(contentType);
    };
    ContentTypeParser.prototype.existingParser = function(contentType) {
      if (contentType === "application/json" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
      }
      if (contentType === "text/plain" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
      }
      return this.hasParser(contentType);
    };
    ContentTypeParser.prototype.getParser = function(contentType) {
      let parser = this.customParsers.get(contentType);
      if (parser !== void 0) return parser;
      parser = this.cache.get(contentType);
      if (parser !== void 0) return parser;
      const caseInsensitiveContentType = contentType.toLowerCase();
      for (let i = 0; i !== this.parserList.length; ++i) {
        const parserListItem = this.parserList[i];
        if (caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem && (caseInsensitiveContentType.length === parserListItem.length || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32)) {
          parser = this.customParsers.get(parserListItem);
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      for (let j = 0; j !== this.parserRegExpList.length; ++j) {
        const parserRegExp = this.parserRegExpList[j];
        if (parserRegExp.test(contentType)) {
          parser = this.customParsers.get(parserRegExp.toString());
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      return this.customParsers.get("");
    };
    ContentTypeParser.prototype.removeAll = function() {
      this.customParsers = /* @__PURE__ */ new Map();
      this.parserRegExpList = [];
      this.parserList = [];
      this.cache = new Fifo(100);
    };
    ContentTypeParser.prototype.remove = function(contentType) {
      let parsers;
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
        parsers = this.parserList;
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
        parsers = this.parserRegExpList;
      }
      const removed = this.customParsers.delete(contentType);
      const idx = parsers.findIndex((ct) => ct.toString() === contentType);
      if (idx > -1) {
        parsers.splice(idx, 1);
      }
      return removed || idx > -1;
    };
    ContentTypeParser.prototype.run = function(contentType, handler, request, reply) {
      const parser = this.getParser(contentType);
      if (parser === void 0) {
        if (request.is404) {
          handler(request, reply);
        } else {
          reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || void 0));
        }
        return;
      }
      const resource = new AsyncResource("content-type-parser:run", request);
      if (parser.asString === true || parser.asBuffer === true) {
        rawBody(
          request,
          reply,
          reply[kRouteContext]._parserOptions,
          parser,
          done
        );
      } else {
        const result = parser.fn(request, request[kRequestPayloadStream], done);
        if (typeof result?.then === "function") {
          result.then((body) => done(null, body), done);
        }
      }
      function done(error, body) {
        resource.runInAsyncScope(() => {
          resource.emitDestroy();
          if (error) {
            reply[kReplyIsError] = true;
            reply.send(error);
          } else {
            request.body = body;
            handler(request, reply);
          }
        });
      }
    };
    function rawBody(request, reply, options, parser, done) {
      const asString = parser.asString;
      const limit = options.limit === null ? parser.bodyLimit : options.limit;
      const contentLength = Number(request.headers["content-length"]);
      if (contentLength > limit) {
        reply.header("connection", "close");
        reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
        return;
      }
      let receivedLength = 0;
      let body = asString === true ? "" : [];
      const payload = request[kRequestPayloadStream] || request.raw;
      if (asString === true) {
        payload.setEncoding("utf8");
      }
      payload.on("data", onData);
      payload.on("end", onEnd);
      payload.on("error", onEnd);
      payload.resume();
      function onData(chunk) {
        receivedLength += chunk.length;
        const { receivedEncodedLength = 0 } = payload;
        if (receivedLength > limit || receivedEncodedLength > limit) {
          payload.removeListener("data", onData);
          payload.removeListener("end", onEnd);
          payload.removeListener("error", onEnd);
          reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
          return;
        }
        if (asString === true) {
          body += chunk;
        } else {
          body.push(chunk);
        }
      }
      function onEnd(err) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        if (err !== void 0) {
          if (!(typeof err.statusCode === "number" && err.statusCode >= 400)) {
            err.statusCode = 400;
          }
          reply[kReplyIsError] = true;
          reply.code(err.statusCode).send(err);
          return;
        }
        if (asString === true) {
          receivedLength = Buffer.byteLength(body);
        }
        if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
          reply.header("connection", "close");
          reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
          return;
        }
        if (asString === false) {
          body = Buffer.concat(body);
        }
        const result = parser.fn(request, body, done);
        if (result && typeof result.then === "function") {
          result.then((body2) => done(null, body2), done);
        }
      }
    }
    function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
      return defaultJsonParser;
      function defaultJsonParser(req, body, done) {
        if (body === "" || body == null || Buffer.isBuffer(body) && body.length === 0) {
          return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
        }
        let json;
        try {
          json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning });
        } catch (err) {
          err.statusCode = 400;
          return done(err, void 0);
        }
        done(null, json);
      }
    }
    function defaultPlainTextParser(req, body, done) {
      done(null, body);
    }
    function Parser(asString, asBuffer, bodyLimit, fn) {
      this.asString = asString;
      this.asBuffer = asBuffer;
      this.bodyLimit = bodyLimit;
      this.fn = fn;
    }
    function buildContentTypeParser(c2) {
      const contentTypeParser = new ContentTypeParser();
      contentTypeParser[kDefaultJsonParse] = c2[kDefaultJsonParse];
      contentTypeParser.customParsers = new Map(c2.customParsers.entries());
      contentTypeParser.parserList = c2.parserList.slice();
      contentTypeParser.parserRegExpList = c2.parserRegExpList.slice();
      return contentTypeParser;
    }
    function addContentTypeParser(contentType, opts, parser) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
      }
      if (typeof opts === "function") {
        parser = opts;
        opts = {};
      }
      if (!opts) opts = {};
      if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];
      if (Array.isArray(contentType)) {
        contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
      } else {
        this[kContentTypeParser].add(contentType, opts, parser);
      }
      return this;
    }
    function hasContentTypeParser(contentType) {
      return this[kContentTypeParser].hasParser(contentType);
    }
    function removeContentTypeParser(contentType) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
      }
      if (Array.isArray(contentType)) {
        for (const type of contentType) {
          this[kContentTypeParser].remove(type);
        }
      } else {
        this[kContentTypeParser].remove(contentType);
      }
    }
    function removeAllContentTypeParsers() {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
      }
      this[kContentTypeParser].removeAll();
    }
    function validateRegExp(regexp) {
      if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
        FSTSEC001(regexp.source);
      }
    }
    module2.exports = ContentTypeParser;
    module2.exports.helpers = {
      buildContentTypeParser,
      addContentTypeParser,
      hasContentTypeParser,
      removeContentTypeParser,
      removeAllContentTypeParsers
    };
    module2.exports.defaultParsers = {
      getDefaultJsonParser,
      defaultTextParser: defaultPlainTextParser
    };
    module2.exports[kTestInternals] = { rawBody };
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a2, b3) {
      if (a2 === b3) return true;
      if (a2 && b3 && typeof a2 == "object" && typeof b3 == "object") {
        if (a2.constructor !== b3.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b3.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a2[i], b3[i])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b3.source && a2.flags === b3.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b3.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b3.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b3).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a2[key], b3[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b3 !== b3;
    };
  }
});

// ../../node_modules/.pnpm/json-schema-ref-resolver@1.0.1/node_modules/json-schema-ref-resolver/index.js
var require_json_schema_ref_resolver = __commonJS({
  "../../node_modules/.pnpm/json-schema-ref-resolver@1.0.1/node_modules/json-schema-ref-resolver/index.js"(exports2, module2) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var jsonSchemaRefSymbol = Symbol.for("json-schema-ref");
    var RefResolver = class {
      #schemas;
      #derefSchemas;
      #insertRefSymbol;
      #allowEqualDuplicates;
      #cloneSchemaWithoutRefs;
      constructor(opts = {}) {
        this.#schemas = {};
        this.#derefSchemas = {};
        this.#insertRefSymbol = opts.insertRefSymbol ?? false;
        this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
        this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
      }
      addSchema(schema, schemaId) {
        if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
          schemaId = schema.$id;
        } else {
          this.#insertSchemaBySchemaId(schema, schemaId);
        }
        this.#addSchema(schema, schemaId);
      }
      getSchema(schemaId, jsonPointer = "#") {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(
            `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
          );
        }
        if (schema.anchors[jsonPointer] !== void 0) {
          return schema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(schema.schema, jsonPointer);
      }
      hasSchema(schemaId) {
        return this.#schemas[schemaId] !== void 0;
      }
      getSchemaRefs(schemaId) {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        return schema.refs;
      }
      getSchemaDependencies(schemaId, dependencies = {}) {
        const schema = this.#schemas[schemaId];
        for (const ref of schema.refs) {
          const dependencySchemaId = ref.schemaId;
          if (dependencies[dependencySchemaId] !== void 0) continue;
          dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
          this.getSchemaDependencies(dependencySchemaId, dependencies);
        }
        return dependencies;
      }
      derefSchema(schemaId) {
        if (this.#derefSchemas[schemaId] !== void 0) return;
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
          this.#derefSchemas[schemaId] = {
            schema: schema.schema,
            anchors: schema.anchors
          };
        }
        const refs = [];
        this.#addDerefSchema(schema.schema, schemaId, refs);
        const dependencies = this.getSchemaDependencies(schemaId);
        for (const schemaId2 in dependencies) {
          const schema2 = dependencies[schemaId2];
          this.#addDerefSchema(schema2, schemaId2, refs);
        }
        for (const ref of refs) {
          const {
            refSchemaId,
            refJsonPointer
          } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);
          const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
          if (targetSchema === null) {
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
            );
          }
          ref.targetSchema = targetSchema;
          ref.targetSchemaId = refSchemaId;
        }
        for (const ref of refs) {
          this.#resolveRef(ref, refs);
        }
      }
      getDerefSchema(schemaId, jsonPointer = "#") {
        let derefSchema = this.#derefSchemas[schemaId];
        if (derefSchema === void 0) {
          this.derefSchema(schemaId);
          derefSchema = this.#derefSchemas[schemaId];
        }
        if (derefSchema.anchors[jsonPointer] !== void 0) {
          return derefSchema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(derefSchema.schema, jsonPointer);
      }
      #parseSchemaRef(ref, schemaId) {
        const sharpIndex = ref.indexOf("#");
        if (sharpIndex === -1) {
          return { refSchemaId: ref, refJsonPointer: "#" };
        }
        if (sharpIndex === 0) {
          return { refSchemaId: schemaId, refJsonPointer: ref };
        }
        return {
          refSchemaId: ref.slice(0, sharpIndex),
          refJsonPointer: ref.slice(sharpIndex)
        };
      }
      #addSchema(schema, rootSchemaId) {
        const schemaId = schema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
          } else {
            this.#insertSchemaBySchemaId(schema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        const ref = schema.$ref;
        if (ref !== void 0 && typeof ref === "string") {
          const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
          this.#schemas[rootSchemaId].refs.push({
            schemaId: refSchemaId,
            jsonPointer: refJsonPointer
          });
        }
        for (const key in schema) {
          if (typeof schema[key] === "object" && schema[key] !== null) {
            this.#addSchema(schema[key], rootSchemaId);
          }
        }
      }
      #addDerefSchema(schema, rootSchemaId, refs = []) {
        const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
        const schemaId = derefSchema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
          } else {
            this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        if (derefSchema.$ref !== void 0) {
          refs.push({
            ref: derefSchema.$ref,
            sourceSchemaId: rootSchemaId,
            sourceSchema: derefSchema
          });
        }
        for (const key in derefSchema) {
          const value = derefSchema[key];
          if (typeof value === "object" && value !== null) {
            derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, refs);
          }
        }
        return derefSchema;
      }
      #resolveRef(ref, refs) {
        const { sourceSchema, targetSchema } = ref;
        if (!sourceSchema.$ref) return;
        if (this.#insertRefSymbol) {
          sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
        }
        delete sourceSchema.$ref;
        if (targetSchema.$ref) {
          const targetSchemaRef = refs.find((ref2) => ref2.sourceSchema === targetSchema);
          this.#resolveRef(targetSchemaRef, refs);
        }
        for (const key in targetSchema) {
          if (key === "$id") continue;
          if (sourceSchema[key] !== void 0) {
            if (deepEqual(sourceSchema[key], targetSchema[key])) continue;
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Property "${key}" is already exist in schema "${ref.sourceSchemaId}".`
            );
          }
          sourceSchema[key] = targetSchema[key];
        }
        ref.isResolved = true;
      }
      #insertSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#schemas[schemaId];
        if (foundSchema !== void 0) {
          if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return;
          throw new Error(`There is already another schema with id "${schemaId}".`);
        }
        this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
      }
      #insertSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#schemas[schemaId];
        if (anchors[anchor] !== void 0) {
          throw new Error(`There is already another anchor "${anchor}" in a schema "${schemaId}".`);
        }
        anchors[anchor] = schema;
      }
      #insertDerefSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#derefSchemas[schemaId];
        if (foundSchema !== void 0) return;
        this.#derefSchemas[schemaId] = { schema, anchors: {} };
      }
      #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#derefSchemas[schemaId];
        anchors[anchor] = schema;
      }
    };
    function getDataByJSONPointer(data4, jsonPointer) {
      const parts = jsonPointer.split("/");
      let current = data4;
      for (const part of parts) {
        if (part === "" || part === "#") continue;
        if (typeof current !== "object" || current === null) {
          return null;
        }
        current = current[part];
      }
      return current ?? null;
    }
    module2.exports = { RefResolver };
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports2.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c2) => {
          if (c2 instanceof Name)
            names2[c2.str] = (names2[c2.str] || 0) + 1;
          return names2;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b3) {
      if (b3 === '""')
        return a2;
      if (a2 === '""')
        return b3;
      if (typeof a2 == "string") {
        if (b3 instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b3 != "string")
          return `${a2.slice(0, -1)}${b3}"`;
        if (b3[0] === '"')
          return a2.slice(0, -1) + b3.slice(1);
        return;
      }
      if (typeof b3 == "string" && b3[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b3.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify5(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify5;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names2, constants) {
        if (!names2[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names2, constants) {
        if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names2, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names2, constants) {
        this.code = optimizeExpr(this.code, names2, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n3) => code + n3.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n3 = nodes[i].optimizeNodes();
          if (Array.isArray(n3))
            nodes.splice(i, 1, ...n3);
          else if (n3)
            nodes[i] = n3;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names2, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n3 = nodes[i];
          if (n3.optimizeNames(names2, constants))
            continue;
          subtractNames(names2, n3.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names2, n3) => addNames(names2, n3.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names2, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
        if (!(super.optimizeNames(names2, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        addExprNames(names2, this.condition);
        if (this.else)
          addNames(names2, this.else.names);
        return names2;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names2 = addExprNames(super.names, this.from);
        return addExprNames(names2, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names2, constants) {
        var _a, _b;
        super.optimizeNames(names2, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        if (this.catch)
          addNames(names2, this.catch.names);
        if (this.finally)
          addNames(names2, this.finally.names);
        return names2;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n3 = 1) {
        while (n3-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N22) {
        const n3 = this._currNode;
        if (n3 instanceof N1 || N22 && n3 instanceof N22) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n3 = this._currNode;
        if (!(n3 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n3.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names2, from) {
      for (const n3 in from)
        names2[n3] = (names2[n3] || 0) + (from[n3] || 0);
      return names2;
    }
    function addExprNames(names2, from) {
      return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
    }
    function optimizeExpr(expr, names2, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n3) {
        const c2 = constants[n3.str];
        if (c2 === void 0 || names2[n3.str] !== 1)
          return n3;
        delete names2[n3.str];
        return c2;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c2) => c2 instanceof code_1.Name && names2[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names2, from) {
      for (const n3 in from)
        names2[n3] = (names2[n3] || 0) - (from[n3] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash4 = {};
      for (const item of arr)
        hash4[item] = true;
      return hash4;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f2) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f2(x);
      } else {
        f2(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
      return (gen2, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen2, from, to) : mergeToName(gen2, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen2, to, from), from) : mergeValues2(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen2, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen2.if((0, codegen_1._)`${from} === true`, () => gen2.assign(to, true), () => gen2.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen2.assign(to, true);
          } else {
            gen2.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen2, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen2.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen2, from, to) => gen2.if((0, codegen_1._)`${to} !== true`, () => gen2.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen2, items) => gen2.var("items", items)
      })
    };
    function evaluatedPropsToName(gen2, ps) {
      if (ps === true)
        return gen2.var("props", true);
      const props = gen2.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen2, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen2, props, ps) {
      Object.keys(ps).forEach((p) => gen2.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen2, f2) {
      return gen2.scopeValue("func", {
        ref: f2,
        code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names2 = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names2;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js
var require_errors3 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen: gen2, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen2, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen: gen2, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen2, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen2, errsCount) {
      gen2.assign(names_1.default.errors, errsCount);
      gen2.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen2.if(errsCount, () => gen2.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen2.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen: gen2, keyword, schemaValue, data: data4, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen2.name("err");
      gen2.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen2.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen2.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen2.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen2.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen2.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen2.assign((0, codegen_1._)`${err}.data`, data4);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen2, errObj) {
      const err = gen2.const("err", errObj);
      gen2.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen2.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen2.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen: gen2, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen2.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen2.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen2.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen: gen2, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen2.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data: data4, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data4]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen: gen2, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen2.return(names_1.default.data);
      } else {
        gen2.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen2.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen: gen2, schema } = it;
      if (schema === false) {
        gen2.var(valid, false);
        falseSchemaError(it);
      } else {
        gen2.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen: gen2, data: data4 } = it;
      const cxt = {
        gen: gen2,
        keyword: "false schema",
        data: data4,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen: gen2, data: data4, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data4, opts.strictNumbers, DataType.Wrong);
        gen2.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen: gen2, data: data4, opts } = it;
      const dataType = gen2.let("dataType", (0, codegen_1._)`typeof ${data4}`);
      const coerced = gen2.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen2.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data4}) && ${data4}.length == 1`, () => gen2.assign(data4, (0, codegen_1._)`${data4}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data4}`).if(checkDataTypes(types, data4, opts.strictNumbers), () => gen2.assign(coerced, data4)));
      }
      gen2.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen2.else();
      reportTypeError(it);
      gen2.endIf();
      gen2.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen2.assign(data4, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen2.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data4}`).elseIf((0, codegen_1._)`${data4} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen2.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data4} === null
              || (${dataType} == "string" && ${data4} && ${data4} == +${data4})`).assign(coerced, (0, codegen_1._)`+${data4}`);
            return;
          case "integer":
            gen2.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data4} === null
              || (${dataType} === "string" && ${data4} && ${data4} == +${data4} && !(${data4} % 1))`).assign(coerced, (0, codegen_1._)`+${data4}`);
            return;
          case "boolean":
            gen2.elseIf((0, codegen_1._)`${data4} === "false" || ${data4} === 0 || ${data4} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data4} === "true" || ${data4} === 1`).assign(coerced, true);
            return;
          case "null":
            gen2.elseIf((0, codegen_1._)`${data4} === "" || ${data4} === 0 || ${data4} === false`);
            gen2.assign(coerced, null);
            return;
          case "array":
            gen2.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data4} === null`).assign(coerced, (0, codegen_1._)`[${data4}]`);
        }
      }
    }
    function assignParentData({ gen: gen2, parentData, parentDataProperty }, expr) {
      gen2.if((0, codegen_1._)`${parentData} !== undefined`, () => gen2.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data4, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data4} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data4})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data4} && typeof ${data4} == "object" && !Array.isArray(${data4})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data4} % 1) && !isNaN(${data4})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data4} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data4} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data4})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data4, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data4, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data4} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data4} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data4, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen: gen2, data: data4, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen: gen2,
        keyword: "type",
        data: data4,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen: gen2, compositeRule, data: data4, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen2.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen: gen2, data: data4, it } = cxt;
      gen2.if(noPropertyInData(gen2, data4, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen: gen2, data: data4, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen2, data4, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen2) {
      return gen2.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen2, data4, property) {
      return (0, codegen_1._)`${hasPropFunc(gen2)}.call(${data4}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen2, data4, property, ownProperties) {
      const cond = (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen2, data4, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen2, data4, property, ownProperties) {
      const cond = (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen2, data4, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data: data4, it: { gen: gen2, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data4}, ${topSchemaRef}${schemaPath}` : data4;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen2.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen: gen2, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen2.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen2, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen: gen2, data: data4, keyword, it } = cxt;
      const valid = gen2.name("valid");
      if (it.allErrors) {
        const validArr = gen2.let("valid", true);
        validateItems(() => gen2.assign(validArr, false));
        return validArr;
      }
      gen2.var(valid, true);
      validateItems(() => gen2.break());
      return valid;
      function validateItems(notValid) {
        const len = gen2.const("len", (0, codegen_1._)`${data4}.length`);
        gen2.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen2.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen: gen2, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen2.let("valid", false);
      const schValid = gen2.name("_valid");
      gen2.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen2.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen2.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors3();
    function macroKeywordCode(cxt, def) {
      const { gen: gen2, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen2, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen2.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen: gen2, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen2, keyword, validate);
      const valid = gen2.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen2.let("ruleErrs", null);
        gen2.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen2.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it.ValidationError}`, () => gen2.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen2.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen2.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen2.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen2.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen: gen2, data: data4, it } = cxt;
      gen2.if(it.parentData, () => gen2.assign(data4, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen: gen2 } = cxt;
      gen2.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen2.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen2, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen2.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data: data4, dataTypes, propertyName }) {
      if (data4 !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen: gen2 } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen2.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data4 !== void 0) {
        const nextData = data4 instanceof codegen_1.Name ? data4 : gen2.let("data", data4, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// ../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id3 = "", normalize2) {
      if (normalize2 !== false)
        id3 = normalizeId(id3);
      const p = resolver.parse(id3);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id3) {
      return id3 ? id3.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id3) {
      id3 = normalizeId(id3);
      return resolver.resolve(baseId, id3);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors3();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen: gen2, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen2.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen2.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen2, opts);
          gen2.code(body);
        });
      } else {
        gen2.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen2.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen2, opts) {
      gen2.if(names_1.default.valCxt, () => {
        gen2.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen2.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen2.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen2.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen2.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen2.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen2.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen2.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen2.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen2.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen: gen2 } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen2.let(names_1.default.vErrors, null);
        gen2.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen: gen2, validateName } = it;
      it.evaluated = gen2.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen2.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen2.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen2.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen2.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen: gen2, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen2.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen2.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen: gen2, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen2.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen2.scopeValue("root", { ref: schemaEnv.root });
        gen2.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen: gen2, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen2.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen2.return(names_1.default.data), () => gen2.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen2.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen2.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen: gen2, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen2.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen2.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen: gen2, schema, data: data4, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen2.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen2.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen2.if((0, dataType_2.checkDataType)(group.type, data4, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen2.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen2.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen2.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen: gen2, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen2.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen: gen2, schemaCode, schemaType, def } = this;
        gen2.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen2.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen2.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen2.assign(valid, false);
        }
        gen2.else();
      }
      invalid$data() {
        const { gen: gen2, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen2.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen: gen2 } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen2, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen2, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen: gen2 } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen2.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data4;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data4 = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data4 = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data4;
      }
      let expr = data4;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data4 = (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data4}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen2.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen2.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen: gen2,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen2.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen2.optimize(this.opts.code.optimize);
        const validateCode = gen2.toString();
        sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen2._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id3 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id3] || this.schemas[id3];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id3 === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars();
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c2 of input) {
        if (HEX[c2] === void 0) return void 0;
        if (c2 !== "0" && strip === true) strip = false;
        if (!strip) acc += c2;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output2 = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex2 = stringArrayToHexStripped(buffer);
            if (hex2 !== void 0) {
              address.push(hex2);
            } else {
              output2.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output2.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output2.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output2.address = address.join("");
      return output2;
    }
    function normalizeIPv6(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c2 = str[i];
        if (c2 === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c2;
            skip = false;
          }
        } else {
          if (c2 === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c2;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s2 = im[0];
            input = input.slice(s2.length);
            output2.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http3 = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https3 = {
      scheme: "https",
      domainHost: http3.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http: http3,
      https: https3,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s2 = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s2) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data4) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data4);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id3;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id3 = schema[schemaId];
          if (id3 !== void 0 && typeof id3 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id3);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id3 = schemaKeyRef[this.opts.schemaId];
            if (id3) {
              id3 = (0, resolve_1.normalizeId)(id3);
              delete this.schemas[id3];
              delete this.refs[id3];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id3;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id3 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id3 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id3) {
        if (this.schemas[id3] || this.refs[id3]) {
          throw new Error(`schema with key or id "${id3}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts2, options, msg, log = "error") {
      for (const key in checkOpts2) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts2[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen: gen2, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen2.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen2.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen2.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen: gen2 } = cxt;
      return sch.validate ? gen2.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen: gen2, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen2.let("valid");
        gen2.try(() => {
          gen2.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen2.assign(valid, true);
        }, (e2) => {
          gen2.if((0, codegen_1._)`!(${e2} instanceof ${it.ValidationError})`, () => gen2.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen2.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen2.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen2.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen2, schEvaluated.props, it.props);
            }
          } else {
            const props = gen2.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen2, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen2, schEvaluated.items, it.items);
            }
          } else {
            const items = gen2.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen2, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data: data4, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data4} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data4})`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, data: data4, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen2.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data4}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data: data4, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data4}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data4})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data: data4, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data4})`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data: data4, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data4}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, schema, schemaCode, data: data4, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen2.let("missing");
          if (useLoop || $data) {
            const valid = gen2.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen2.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen2.else();
          }
        }
        function loopAllRequired() {
          gen2.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen2.if((0, code_1.noPropertyInData)(gen2, data4, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen2.forOf(missing, schemaCode, () => {
            gen2.assign(valid, (0, code_1.propertyInData)(gen2, data4, missing, opts.ownProperties));
            gen2.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen2.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data: data4, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data4}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, data: data4, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen2.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen2.let("i", (0, codegen_1._)`${data4}.length`);
          const j = gen2.let("j");
          cxt.setParams({ i, j });
          gen2.assign(valid, true);
          gen2.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen2.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen2.const("indices", (0, codegen_1._)`{}`);
          gen2.for((0, codegen_1._)`;${i}--;`, () => {
            gen2.let(item, (0, codegen_1._)`${data4}[${i}]`);
            gen2.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen2.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen2.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen2.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen2.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen2, equal_1.default);
          const outer = gen2.name("outer");
          gen2.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen2.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen2.if((0, codegen_1._)`${eql}(${data4}[${i}], ${data4}[${j}])`, () => {
            cxt.error();
            gen2.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, data: data4, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen2, equal_1.default)}(${data4}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data4}`);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, data: data4, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen2, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen2.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen2.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen2.assign(valid, false);
          gen2.forOf("v", schemaCode, (v) => gen2.if((0, codegen_1._)`${getEql()}(${data4}, ${v})`, () => gen2.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data4}, ${vSchema}[${i}])` : (0, codegen_1._)`${data4} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen: gen2, schema, data: data4, keyword, it } = cxt;
      it.items = true;
      const len = gen2.const("len", (0, codegen_1._)`${data4}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen2.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen2.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen2.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen2.if((0, codegen_1.not)(valid), () => gen2.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen: gen2, parentSchema, data: data4, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen2, schArr.length, it.items);
      }
      const valid = gen2.name("valid");
      const len = gen2.const("len", (0, codegen_1._)`${data4}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen2.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen: gen2, schema, parentSchema, data: data4, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen2.const("len", (0, codegen_1._)`${data4}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen2.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen2.if(valid, () => gen2.break()));
        } else if (min === 0) {
          gen2.let(valid, true);
          if (max !== void 0)
            gen2.if((0, codegen_1._)`${data4}.length > 0`, validateItemsWithCount);
        } else {
          gen2.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen2.name("_valid");
          const count = gen2.let("count", 0);
          validateItems(schValid, () => gen2.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen2.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen2.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen2.if((0, codegen_1._)`${count} >= ${min}`, () => gen2.assign(valid, true).break());
          } else {
            gen2.if((0, codegen_1._)`${count} > ${max}`, () => gen2.assign(valid, false).break());
            if (min === 1)
              gen2.assign(valid, true);
            else
              gen2.if((0, codegen_1._)`${count} >= ${min}`, () => gen2.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen: gen2, data: data4, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen2.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen2, data4, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen2.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen2.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen2.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen: gen2, data: data4, keyword, it } = cxt;
      const valid = gen2.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen2.if(
          (0, code_1.propertyInData)(gen2, data4, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen2.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen: gen2, schema, data: data4, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen2.name("valid");
        gen2.forIn("key", data4, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen2.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen2.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen: gen2, schema, parentSchema, data: data4, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen2.forIn("key", data4, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen2.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen2, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen2.code((0, codegen_1._)`delete ${data4}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen2.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen2.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen2.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen2.if((0, codegen_1.not)(valid), () => gen2.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen: gen2, schema, parentSchema, data: data4, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen2, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen2.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen2.if((0, code_1.propertyInData)(gen2, data4, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen2.else().var(valid, true);
            gen2.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen: gen2, schema, data: data4, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen2.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen2, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen2.var(valid, true);
              validateProperties(pat);
              gen2.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen2.forIn("key", data4, (key) => {
            gen2.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen2.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen2.if((0, codegen_1.not)(valid), () => gen2.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen: gen2, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen2.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen: gen2, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen2.let("valid", false);
        const passing = gen2.let("passing", null);
        const schValid = gen2.name("_valid");
        cxt.setParams({ passing });
        gen2.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen2.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen2.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen2.if(schValid, () => {
              gen2.assign(valid, true);
              gen2.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen: gen2, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen2.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen: gen2, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen2.let("valid", true);
        const schValid = gen2.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen2.let("ifClause");
          cxt.setParams({ ifClause });
          gen2.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen2.if(schValid, validateClause("then"));
        } else {
          gen2.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen2.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen2.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen: gen2, data: data4, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen2.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen2.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen2.let("fType");
          const format = gen2.let("format");
          gen2.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen2.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen2.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data4}) : ${format}(${data4}))` : (0, codegen_1._)`${format}(${data4})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data4}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat2(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat2(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen2.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data4})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data4})` : (0, codegen_1._)`${fmtRef}.test(${data4})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen: gen2, data: data4, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen2.let("valid", false);
        const tag = gen2.const("tag", (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(tagName)}`);
        gen2.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping2 = getMapping();
          gen2.if(false);
          for (const tagValue in mapping2) {
            gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen2.assign(valid, applyTagSchema(mapping2[tagValue]));
          }
          gen2.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen2.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen2.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// ../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars2 = __commonJS({
  "../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars2();
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(\b[01]?\d{1,2}|\b2[0-4]\d|\b25[0-5])(\.([01]?\d{1,2}|2[0-4]\d|25[0-5])){3}$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringToHexStripped(input) {
      let acc = "";
      let strip = true;
      for (const c2 of input) {
        if (c2 !== "0" && strip === true) strip = false;
        if (HEX[c2] === void 0) return void 0;
        if (!strip) acc += c2;
      }
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output2 = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex2 = stringToHexStripped(buffer.join(""));
            if (hex2 !== void 0) {
              address.push(hex2);
            } else {
              output2.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output2.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output2.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringToHexStripped(buffer.join("")));
        }
      }
      output2.address = address.join("");
      return output2;
    }
    function normalizeIPv6(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c2 = str[i];
        if (c2 === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c2;
            skip = false;
          }
        } else {
          if (c2 === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c2;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s2 = im[0];
            input = input.slice(s2.length);
            output2.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringToHexStripped
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/schemes.js
var require_schemes2 = __commonJS({
  "../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http3 = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https3 = {
      scheme: "https",
      domainHost: http3.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http: http3,
      https: https3,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// ../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/index.js
var require_fast_uri2 = __commonJS({
  "../../node_modules/.pnpm/fast-uri@2.4.0/node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils2();
    var SCHEMES = require_schemes2();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            parsed.host = normalizeIPv6(ipv4result.host, { isIPV4: false }).host.toLowerCase();
          } else {
            parsed.host = ipv4result.host;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.userinfo !== void 0) {
            parsed.userinfo = unescape(parsed.userinfo);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURI(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      normalize: normalize2,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// ../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime6(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime6(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime6(strictTimeZone) {
      return function time(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime6(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e2) {
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen: gen2, data: data4, schemaCode, keyword, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen2.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen2.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen2.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data4}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  }
});

// ../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f2 = formats[name];
      if (!f2)
        throw new Error(`Unknown format "${name}"`);
      return f2;
    };
    function addFormats(ajv, list, fs2, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f2 of list)
        ajv.addFormat(f2, fs2[f2]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/validator.js
var require_validator2 = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/validator.js"(exports2, module2) {
    "use strict";
    var Ajv = require_ajv();
    var fastUri = require_fast_uri2();
    var ajvFormats = require_dist();
    var clone = require_rfdc()({ proto: true });
    var Validator = class _Validator {
      constructor(ajvOptions) {
        this.ajv = new Ajv({
          ...ajvOptions,
          strictSchema: false,
          validateSchema: false,
          allowUnionTypes: true,
          uriResolver: fastUri
        });
        ajvFormats(this.ajv);
        this.ajv.addKeyword({
          keyword: "fjs_type",
          type: "object",
          errors: false,
          validate: (type, date) => {
            return date instanceof Date;
          }
        });
        this._ajvSchemas = {};
        this._ajvOptions = ajvOptions || {};
      }
      addSchema(schema, schemaName) {
        let schemaKey = schema.$id || schemaName;
        if (schema.$id !== void 0 && schema.$id[0] === "#") {
          schemaKey = schemaName + schema.$id;
        }
        if (this.ajv.refs[schemaKey] === void 0 && this.ajv.schemas[schemaKey] === void 0) {
          const ajvSchema = clone(schema);
          this.convertSchemaToAjvFormat(ajvSchema);
          this.ajv.addSchema(ajvSchema, schemaKey);
          this._ajvSchemas[schemaKey] = schema;
        }
      }
      validate(schemaRef, data4) {
        return this.ajv.validate(schemaRef, data4);
      }
      // Ajv does not support js date format. In order to properly validate objects containing a date,
      // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
      // (see https://github.com/fastify/fast-json-stringify/pull/441)
      convertSchemaToAjvFormat(schema) {
        if (schema === null) return;
        if (schema.type === "string") {
          schema.fjs_type = "string";
          schema.type = ["string", "object"];
        } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
          schema.fjs_type = "string";
          schema.type.push("object");
        }
        for (const property in schema) {
          if (typeof schema[property] === "object") {
            this.convertSchemaToAjvFormat(schema[property]);
          }
        }
      }
      getState() {
        return {
          ajvOptions: this._ajvOptions,
          ajvSchemas: this._ajvSchemas
        };
      }
      static restoreFromState(state) {
        const validator = new _Validator(state.ajvOptions);
        for (const [id3, ajvSchema] of Object.entries(state.ajvSchemas)) {
          validator.ajv.addSchema(ajvSchema, id3);
        }
        return validator;
      }
    };
    module2.exports = Validator;
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/location.js
var require_location = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/location.js"(exports2, module2) {
    "use strict";
    var Location = class _Location {
      constructor(schema, schemaId, jsonPointer = "#") {
        this.schema = schema;
        this.schemaId = schemaId;
        this.jsonPointer = jsonPointer;
      }
      getPropertyLocation(propertyName) {
        const propertyLocation = new _Location(
          this.schema[propertyName],
          this.schemaId,
          this.jsonPointer + "/" + propertyName
        );
        return propertyLocation;
      }
      getSchemaRef() {
        return this.schemaId + this.jsonPointer;
      }
    };
    module2.exports = Location;
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/schema-validator.js
var require_schema_validator = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/schema-validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "http://json-schema.org/draft-07/schema#", "title": "Core schema meta-schema", "definitions": { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } }, "type": ["object", "boolean"], "properties": { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } }, "default": true };
    var schema20 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
    var formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var formats2 = require_formats().fullFormats.uri;
    var formats6 = require_formats().fullFormats.regex;
    function validate11(data4, { instancePath = "", parentData, parentDataProperty, rootData = data4 } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
        validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
        return false;
      }
      if (errors === _errs1) {
        if (typeof data4 == "number" && isFinite(data4)) {
          if (data4 < 0 || isNaN(data4)) {
            validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
            return false;
          }
        }
      }
      validate11.errors = vErrors;
      return errors === 0;
    }
    var root1 = { validate: validate10 };
    function validate13(data4, { instancePath = "", parentData, parentDataProperty, rootData = data4 } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (Array.isArray(data4)) {
          if (data4.length < 1) {
            validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
            return false;
          } else {
            var valid0 = true;
            const len0 = data4.length;
            for (let i0 = 0; i0 < len0; i0++) {
              const _errs1 = errors;
              if (!root1.validate(data4[i0], { instancePath: instancePath + "/" + i0, parentData: data4, parentDataProperty: i0, rootData })) {
                vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
                errors = vErrors.length;
              }
              var valid0 = _errs1 === errors;
              if (!valid0) {
                break;
              }
            }
          }
        } else {
          validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
          return false;
        }
      }
      validate13.errors = vErrors;
      return errors === 0;
    }
    var func0 = require_equal().default;
    function validate10(data4, { instancePath = "", parentData, parentDataProperty, rootData = data4 } = {}) {
      ;
      let vErrors = null;
      let errors = 0;
      if (!(data4 && typeof data4 == "object" && !Array.isArray(data4)) && typeof data4 !== "boolean") {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
        return false;
      }
      if (errors === 0) {
        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
          if (data4.$id !== void 0) {
            let data0 = data4.$id;
            const _errs1 = errors;
            if (errors === _errs1) {
              if (errors === _errs1) {
                if (typeof data0 === "string") {
                  if (!formats0.test(data0)) {
                    validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data4.$schema !== void 0) {
              let data1 = data4.$schema;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (errors === _errs3) {
                  if (typeof data1 === "string") {
                    if (!formats2(data1)) {
                      validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data4.$ref !== void 0) {
                let data22 = data4.$ref;
                const _errs5 = errors;
                if (errors === _errs5) {
                  if (errors === _errs5) {
                    if (typeof data22 === "string") {
                      if (!formats0.test(data22)) {
                        validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                        return false;
                      }
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                  }
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data4.$comment !== void 0) {
                  const _errs7 = errors;
                  if (typeof data4.$comment !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs7 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data4.title !== void 0) {
                    const _errs9 = errors;
                    if (typeof data4.title !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs9 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data4.description !== void 0) {
                      const _errs11 = errors;
                      if (typeof data4.description !== "string") {
                        validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid0 = _errs11 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data4.readOnly !== void 0) {
                        const _errs13 = errors;
                        if (typeof data4.readOnly !== "boolean") {
                          validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                          return false;
                        }
                        var valid0 = _errs13 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data4.examples !== void 0) {
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (!Array.isArray(data4.examples)) {
                              validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                              return false;
                            }
                          }
                          var valid0 = _errs15 === errors;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data4.multipleOf !== void 0) {
                            let data8 = data4.multipleOf;
                            const _errs17 = errors;
                            if (errors === _errs17) {
                              if (typeof data8 == "number" && isFinite(data8)) {
                                if (data8 <= 0 || isNaN(data8)) {
                                  validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                  return false;
                                }
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                            }
                            var valid0 = _errs17 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data4.maximum !== void 0) {
                              let data9 = data4.maximum;
                              const _errs19 = errors;
                              if (!(typeof data9 == "number" && isFinite(data9))) {
                                validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs19 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data4.exclusiveMaximum !== void 0) {
                                let data10 = data4.exclusiveMaximum;
                                const _errs21 = errors;
                                if (!(typeof data10 == "number" && isFinite(data10))) {
                                  validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs21 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data4.minimum !== void 0) {
                                  let data11 = data4.minimum;
                                  const _errs23 = errors;
                                  if (!(typeof data11 == "number" && isFinite(data11))) {
                                    validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs23 === errors;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data4.exclusiveMinimum !== void 0) {
                                    let data12 = data4.exclusiveMinimum;
                                    const _errs25 = errors;
                                    if (!(typeof data12 == "number" && isFinite(data12))) {
                                      validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                      return false;
                                    }
                                    var valid0 = _errs25 === errors;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data4.maxLength !== void 0) {
                                      let data13 = data4.maxLength;
                                      const _errs27 = errors;
                                      const _errs28 = errors;
                                      if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                        validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                        return false;
                                      }
                                      if (errors === _errs28) {
                                        if (typeof data13 == "number" && isFinite(data13)) {
                                          if (data13 < 0 || isNaN(data13)) {
                                            validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                            return false;
                                          }
                                        }
                                      }
                                      var valid0 = _errs27 === errors;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data4.minLength !== void 0) {
                                        const _errs30 = errors;
                                        if (!validate11(data4.minLength, { instancePath: instancePath + "/minLength", parentData: data4, parentDataProperty: "minLength", rootData })) {
                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                          errors = vErrors.length;
                                        }
                                        var valid0 = _errs30 === errors;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data4.pattern !== void 0) {
                                          let data15 = data4.pattern;
                                          const _errs31 = errors;
                                          if (errors === _errs31) {
                                            if (errors === _errs31) {
                                              if (typeof data15 === "string") {
                                                if (!formats6(data15)) {
                                                  validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }];
                                                  return false;
                                                }
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                          }
                                          var valid0 = _errs31 === errors;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data4.additionalItems !== void 0) {
                                            const _errs33 = errors;
                                            if (!validate10(data4.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data4, parentDataProperty: "additionalItems", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors = vErrors.length;
                                            }
                                            var valid0 = _errs33 === errors;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data4.items !== void 0) {
                                              let data17 = data4.items;
                                              const _errs34 = errors;
                                              const _errs35 = errors;
                                              let valid2 = false;
                                              const _errs36 = errors;
                                              if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data4, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                errors = vErrors.length;
                                              }
                                              var _valid0 = _errs36 === errors;
                                              valid2 = valid2 || _valid0;
                                              if (!valid2) {
                                                const _errs37 = errors;
                                                if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data4, parentDataProperty: "items", rootData })) {
                                                  vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                  errors = vErrors.length;
                                                }
                                                var _valid0 = _errs37 === errors;
                                                valid2 = valid2 || _valid0;
                                              }
                                              if (!valid2) {
                                                const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err0];
                                                } else {
                                                  vErrors.push(err0);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs35;
                                                if (vErrors !== null) {
                                                  if (_errs35) {
                                                    vErrors.length = _errs35;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs34 === errors;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data4.maxItems !== void 0) {
                                                let data18 = data4.maxItems;
                                                const _errs38 = errors;
                                                const _errs39 = errors;
                                                if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                  validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                                if (errors === _errs39) {
                                                  if (typeof data18 == "number" && isFinite(data18)) {
                                                    if (data18 < 0 || isNaN(data18)) {
                                                      validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                      return false;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs38 === errors;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data4.minItems !== void 0) {
                                                  const _errs41 = errors;
                                                  if (!validate11(data4.minItems, { instancePath: instancePath + "/minItems", parentData: data4, parentDataProperty: "minItems", rootData })) {
                                                    vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                    errors = vErrors.length;
                                                  }
                                                  var valid0 = _errs41 === errors;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data4.uniqueItems !== void 0) {
                                                    const _errs42 = errors;
                                                    if (typeof data4.uniqueItems !== "boolean") {
                                                      validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                    var valid0 = _errs42 === errors;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data4.contains !== void 0) {
                                                      const _errs44 = errors;
                                                      if (!validate10(data4.contains, { instancePath: instancePath + "/contains", parentData: data4, parentDataProperty: "contains", rootData })) {
                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                        errors = vErrors.length;
                                                      }
                                                      var valid0 = _errs44 === errors;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data4.maxProperties !== void 0) {
                                                        let data22 = data4.maxProperties;
                                                        const _errs45 = errors;
                                                        const _errs46 = errors;
                                                        if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                          validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                          return false;
                                                        }
                                                        if (errors === _errs46) {
                                                          if (typeof data22 == "number" && isFinite(data22)) {
                                                            if (data22 < 0 || isNaN(data22)) {
                                                              validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                              return false;
                                                            }
                                                          }
                                                        }
                                                        var valid0 = _errs45 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data4.minProperties !== void 0) {
                                                          const _errs48 = errors;
                                                          if (!validate11(data4.minProperties, { instancePath: instancePath + "/minProperties", parentData: data4, parentDataProperty: "minProperties", rootData })) {
                                                            vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                            errors = vErrors.length;
                                                          }
                                                          var valid0 = _errs48 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data4.required !== void 0) {
                                                            let data24 = data4.required;
                                                            const _errs49 = errors;
                                                            const _errs50 = errors;
                                                            if (errors === _errs50) {
                                                              if (Array.isArray(data24)) {
                                                                var valid6 = true;
                                                                const len0 = data24.length;
                                                                for (let i0 = 0; i0 < len0; i0++) {
                                                                  const _errs52 = errors;
                                                                  if (typeof data24[i0] !== "string") {
                                                                    validate10.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                    return false;
                                                                  }
                                                                  var valid6 = _errs52 === errors;
                                                                  if (!valid6) {
                                                                    break;
                                                                  }
                                                                }
                                                                if (valid6) {
                                                                  let i1 = data24.length;
                                                                  let j0;
                                                                  if (i1 > 1) {
                                                                    const indices0 = {};
                                                                    for (; i1--; ) {
                                                                      let item0 = data24[i1];
                                                                      if (typeof item0 !== "string") {
                                                                        continue;
                                                                      }
                                                                      if (typeof indices0[item0] == "number") {
                                                                        j0 = indices0[item0];
                                                                        validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                        return false;
                                                                        break;
                                                                      }
                                                                      indices0[item0] = i1;
                                                                    }
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs49 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data4.additionalProperties !== void 0) {
                                                              const _errs54 = errors;
                                                              if (!validate10(data4.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data4, parentDataProperty: "additionalProperties", rootData })) {
                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                errors = vErrors.length;
                                                              }
                                                              var valid0 = _errs54 === errors;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data4.definitions !== void 0) {
                                                                let data27 = data4.definitions;
                                                                const _errs55 = errors;
                                                                if (errors === _errs55) {
                                                                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                    for (const key0 in data27) {
                                                                      const _errs58 = errors;
                                                                      if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid8 = _errs58 === errors;
                                                                      if (!valid8) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs55 === errors;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data4.properties !== void 0) {
                                                                  let data29 = data4.properties;
                                                                  const _errs59 = errors;
                                                                  if (errors === _errs59) {
                                                                    if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                      for (const key1 in data29) {
                                                                        const _errs62 = errors;
                                                                        if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid9 = _errs62 === errors;
                                                                        if (!valid9) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs59 === errors;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data4.patternProperties !== void 0) {
                                                                    let data31 = data4.patternProperties;
                                                                    const _errs63 = errors;
                                                                    if (errors === _errs63) {
                                                                      if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                        for (const key2 in data31) {
                                                                          const _errs65 = errors;
                                                                          if (errors === _errs65) {
                                                                            if (typeof key2 === "string") {
                                                                              if (!formats6(key2)) {
                                                                                const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: key2 };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err1];
                                                                                } else {
                                                                                  vErrors.push(err1);
                                                                                }
                                                                                errors++;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid10 = _errs65 === errors;
                                                                          if (!valid10) {
                                                                            const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err2];
                                                                            } else {
                                                                              vErrors.push(err2);
                                                                            }
                                                                            errors++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                            break;
                                                                          }
                                                                        }
                                                                        if (valid10) {
                                                                          for (const key3 in data31) {
                                                                            const _errs67 = errors;
                                                                            if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var valid11 = _errs67 === errors;
                                                                            if (!valid11) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs63 === errors;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data4.dependencies !== void 0) {
                                                                      let data33 = data4.dependencies;
                                                                      const _errs68 = errors;
                                                                      if (errors === _errs68) {
                                                                        if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                          for (const key4 in data33) {
                                                                            let data34 = data33[key4];
                                                                            const _errs71 = errors;
                                                                            const _errs72 = errors;
                                                                            let valid13 = false;
                                                                            const _errs73 = errors;
                                                                            if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var _valid1 = _errs73 === errors;
                                                                            valid13 = valid13 || _valid1;
                                                                            if (!valid13) {
                                                                              const _errs74 = errors;
                                                                              const _errs75 = errors;
                                                                              if (errors === _errs75) {
                                                                                if (Array.isArray(data34)) {
                                                                                  var valid15 = true;
                                                                                  const len1 = data34.length;
                                                                                  for (let i2 = 0; i2 < len1; i2++) {
                                                                                    const _errs77 = errors;
                                                                                    if (typeof data34[i2] !== "string") {
                                                                                      const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                      } else {
                                                                                        vErrors.push(err3);
                                                                                      }
                                                                                      errors++;
                                                                                    }
                                                                                    var valid15 = _errs77 === errors;
                                                                                    if (!valid15) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid15) {
                                                                                    let i3 = data34.length;
                                                                                    let j1;
                                                                                    if (i3 > 1) {
                                                                                      const indices1 = {};
                                                                                      for (; i3--; ) {
                                                                                        let item1 = data34[i3];
                                                                                        if (typeof item1 !== "string") {
                                                                                          continue;
                                                                                        }
                                                                                        if (typeof indices1[item1] == "number") {
                                                                                          j1 = indices1[item1];
                                                                                          const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                          if (vErrors === null) {
                                                                                            vErrors = [err4];
                                                                                          } else {
                                                                                            vErrors.push(err4);
                                                                                          }
                                                                                          errors++;
                                                                                          break;
                                                                                        }
                                                                                        indices1[item1] = i3;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err5];
                                                                                  } else {
                                                                                    vErrors.push(err5);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid1 = _errs74 === errors;
                                                                              valid13 = valid13 || _valid1;
                                                                            }
                                                                            if (!valid13) {
                                                                              const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err6];
                                                                              } else {
                                                                                vErrors.push(err6);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs72;
                                                                              if (vErrors !== null) {
                                                                                if (_errs72) {
                                                                                  vErrors.length = _errs72;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid12 = _errs71 === errors;
                                                                            if (!valid12) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      var valid0 = _errs68 === errors;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data4.propertyNames !== void 0) {
                                                                        const _errs79 = errors;
                                                                        if (!validate10(data4.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data4, parentDataProperty: "propertyNames", rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid0 = _errs79 === errors;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data4.enum !== void 0) {
                                                                          let data37 = data4.enum;
                                                                          const _errs80 = errors;
                                                                          if (errors === _errs80) {
                                                                            if (Array.isArray(data37)) {
                                                                              if (data37.length < 1) {
                                                                                validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                                return false;
                                                                              } else {
                                                                                let i4 = data37.length;
                                                                                let j2;
                                                                                if (i4 > 1) {
                                                                                  outer0:
                                                                                    for (; i4--; ) {
                                                                                      for (j2 = i4; j2--; ) {
                                                                                        if (func0(data37[i4], data37[j2])) {
                                                                                          validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                          return false;
                                                                                          break outer0;
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          var valid0 = _errs80 === errors;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data4.type !== void 0) {
                                                                            let data38 = data4.type;
                                                                            const _errs82 = errors;
                                                                            const _errs83 = errors;
                                                                            let valid18 = false;
                                                                            const _errs84 = errors;
                                                                            if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                              const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err7];
                                                                              } else {
                                                                                vErrors.push(err7);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                            var _valid2 = _errs84 === errors;
                                                                            valid18 = valid18 || _valid2;
                                                                            if (!valid18) {
                                                                              const _errs86 = errors;
                                                                              if (errors === _errs86) {
                                                                                if (Array.isArray(data38)) {
                                                                                  if (data38.length < 1) {
                                                                                    const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err8];
                                                                                    } else {
                                                                                      vErrors.push(err8);
                                                                                    }
                                                                                    errors++;
                                                                                  } else {
                                                                                    var valid20 = true;
                                                                                    const len2 = data38.length;
                                                                                    for (let i5 = 0; i5 < len2; i5++) {
                                                                                      let data39 = data38[i5];
                                                                                      const _errs88 = errors;
                                                                                      if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                        const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err9];
                                                                                        } else {
                                                                                          vErrors.push(err9);
                                                                                        }
                                                                                        errors++;
                                                                                      }
                                                                                      var valid20 = _errs88 === errors;
                                                                                      if (!valid20) {
                                                                                        break;
                                                                                      }
                                                                                    }
                                                                                    if (valid20) {
                                                                                      let i6 = data38.length;
                                                                                      let j3;
                                                                                      if (i6 > 1) {
                                                                                        outer1:
                                                                                          for (; i6--; ) {
                                                                                            for (j3 = i6; j3--; ) {
                                                                                              if (func0(data38[i6], data38[j3])) {
                                                                                                const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                                if (vErrors === null) {
                                                                                                  vErrors = [err10];
                                                                                                } else {
                                                                                                  vErrors.push(err10);
                                                                                                }
                                                                                                errors++;
                                                                                                break outer1;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err11];
                                                                                  } else {
                                                                                    vErrors.push(err11);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid2 = _errs86 === errors;
                                                                              valid18 = valid18 || _valid2;
                                                                            }
                                                                            if (!valid18) {
                                                                              const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err12];
                                                                              } else {
                                                                                vErrors.push(err12);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs83;
                                                                              if (vErrors !== null) {
                                                                                if (_errs83) {
                                                                                  vErrors.length = _errs83;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid0 = _errs82 === errors;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data4.format !== void 0) {
                                                                              const _errs90 = errors;
                                                                              if (typeof data4.format !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs90 === errors;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data4.contentMediaType !== void 0) {
                                                                                const _errs92 = errors;
                                                                                if (typeof data4.contentMediaType !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs92 === errors;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data4.contentEncoding !== void 0) {
                                                                                  const _errs94 = errors;
                                                                                  if (typeof data4.contentEncoding !== "string") {
                                                                                    validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                    return false;
                                                                                  }
                                                                                  var valid0 = _errs94 === errors;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data4.if !== void 0) {
                                                                                    const _errs96 = errors;
                                                                                    if (!validate10(data4.if, { instancePath: instancePath + "/if", parentData: data4, parentDataProperty: "if", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs96 === errors;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data4.then !== void 0) {
                                                                                      const _errs97 = errors;
                                                                                      if (!validate10(data4.then, { instancePath: instancePath + "/then", parentData: data4, parentDataProperty: "then", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs97 === errors;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data4.else !== void 0) {
                                                                                        const _errs98 = errors;
                                                                                        if (!validate10(data4.else, { instancePath: instancePath + "/else", parentData: data4, parentDataProperty: "else", rootData })) {
                                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs98 === errors;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data4.allOf !== void 0) {
                                                                                          const _errs99 = errors;
                                                                                          if (!validate13(data4.allOf, { instancePath: instancePath + "/allOf", parentData: data4, parentDataProperty: "allOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs99 === errors;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data4.anyOf !== void 0) {
                                                                                            const _errs100 = errors;
                                                                                            if (!validate13(data4.anyOf, { instancePath: instancePath + "/anyOf", parentData: data4, parentDataProperty: "anyOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs100 === errors;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data4.oneOf !== void 0) {
                                                                                              const _errs101 = errors;
                                                                                              if (!validate13(data4.oneOf, { instancePath: instancePath + "/oneOf", parentData: data4, parentDataProperty: "oneOf", rootData })) {
                                                                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                                errors = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs101 === errors;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                            if (valid0) {
                                                                                              if (data4.not !== void 0) {
                                                                                                const _errs102 = errors;
                                                                                                if (!validate10(data4.not, { instancePath: instancePath + "/not", parentData: data4, parentDataProperty: "not", rootData })) {
                                                                                                  vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                  errors = vErrors.length;
                                                                                                }
                                                                                                var valid0 = _errs102 === errors;
                                                                                              } else {
                                                                                                var valid0 = true;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// ../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/errors.js
var require_errors4 = __commonJS({
  "../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/errors.js"(exports2, module2) {
    "use strict";
    var MergeError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Failed to merge "${keyword}" keyword schemas.`;
        this.schemas = schemas;
      }
    };
    var ResolverNotFoundError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Resolver for "${keyword}" keyword not found.`;
        this.schemas = schemas;
      }
    };
    var InvalidOnConflictOptionError = class extends Error {
      constructor(onConflict) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Invalid "onConflict" option: "${onConflict}".`;
      }
    };
    module2.exports = {
      MergeError,
      ResolverNotFoundError,
      InvalidOnConflictOptionError
    };
  }
});

// ../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/resolvers.js
var require_resolvers = __commonJS({
  "../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/lib/resolvers.js"(exports2, module2) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var { MergeError } = require_errors4();
    function _arraysIntersection(arrays) {
      let intersection = arrays[0];
      for (let i = 1; i < arrays.length; i++) {
        intersection = intersection.filter(
          (value) => arrays[i].includes(value)
        );
      }
      return intersection;
    }
    function arraysIntersection(keyword, values, mergedSchema) {
      const intersection = _arraysIntersection(values);
      if (intersection.length === 0) {
        throw new MergeError(keyword, values);
      }
      mergedSchema[keyword] = intersection;
    }
    function hybridArraysIntersection(keyword, values, mergedSchema) {
      for (let i = 0; i < values.length; i++) {
        if (!Array.isArray(values[i])) {
          values[i] = [values[i]];
        }
      }
      const intersection = _arraysIntersection(values);
      if (intersection.length === 0) {
        throw new MergeError(keyword, values);
      }
      if (intersection.length === 1) {
        mergedSchema[keyword] = intersection[0];
      } else {
        mergedSchema[keyword] = intersection;
      }
    }
    function arraysUnion(keyword, values, mergedSchema) {
      const union = [];
      for (const array of values) {
        for (const value of array) {
          if (!union.includes(value)) {
            union.push(value);
          }
        }
      }
      mergedSchema[keyword] = union;
    }
    function minNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.min(...values);
    }
    function maxNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.max(...values);
    }
    function commonMultiple(keyword, values, mergedSchema) {
      const gcd = (a2, b3) => !b3 ? a2 : gcd(b3, a2 % b3);
      const lcm = (a2, b3) => a2 * b3 / gcd(a2, b3);
      let scale = 1;
      for (const value of values) {
        while (value * scale % 1 !== 0) {
          scale *= 10;
        }
      }
      let multiple = values[0] * scale;
      for (const value of values) {
        multiple = lcm(multiple, value * scale);
      }
      mergedSchema[keyword] = multiple / scale;
    }
    function allEqual(keyword, values, mergedSchema) {
      const firstValue = values[0];
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], firstValue)) {
          throw new MergeError(keyword, values);
        }
      }
      mergedSchema[keyword] = firstValue;
    }
    function skip() {
    }
    function booleanAnd(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === false) {
          mergedSchema[keyword] = false;
          return;
        }
      }
      mergedSchema[keyword] = true;
    }
    function booleanOr(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === true) {
          mergedSchema[keyword] = true;
          return;
        }
      }
      mergedSchema[keyword] = false;
    }
    module2.exports = {
      arraysIntersection,
      hybridArraysIntersection,
      arraysUnion,
      minNumber,
      maxNumber,
      commonMultiple,
      allEqual,
      booleanAnd,
      booleanOr,
      skip
    };
  }
});

// ../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/index.js
var require_merge_json_schemas = __commonJS({
  "../../node_modules/.pnpm/@fastify+merge-json-schemas@0.1.1/node_modules/@fastify/merge-json-schemas/index.js"(exports2, module2) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var resolvers = require_resolvers();
    var errors = require_errors4();
    var keywordsResolvers = {
      $id: resolvers.skip,
      type: resolvers.hybridArraysIntersection,
      enum: resolvers.arraysIntersection,
      minLength: resolvers.maxNumber,
      maxLength: resolvers.minNumber,
      minimum: resolvers.maxNumber,
      maximum: resolvers.minNumber,
      multipleOf: resolvers.commonMultiple,
      exclusiveMinimum: resolvers.maxNumber,
      exclusiveMaximum: resolvers.minNumber,
      minItems: resolvers.maxNumber,
      maxItems: resolvers.minNumber,
      maxProperties: resolvers.minNumber,
      minProperties: resolvers.maxNumber,
      const: resolvers.allEqual,
      default: resolvers.allEqual,
      format: resolvers.allEqual,
      required: resolvers.arraysUnion,
      properties: mergeProperties,
      patternProperties: mergeObjects,
      additionalProperties: mergeSchemasResolver,
      items: mergeItems,
      additionalItems: mergeAdditionalItems,
      definitions: mergeObjects,
      $defs: mergeObjects,
      nullable: resolvers.booleanAnd,
      oneOf: mergeOneOf,
      anyOf: mergeOneOf,
      allOf: resolvers.arraysUnion,
      not: mergeSchemasResolver,
      if: mergeIfThenElseSchemas,
      then: resolvers.skip,
      else: resolvers.skip,
      dependencies: mergeDependencies,
      dependentRequired: mergeDependencies,
      dependentSchemas: mergeObjects,
      propertyNames: mergeSchemasResolver,
      uniqueItems: resolvers.booleanOr,
      contains: mergeSchemasResolver
    };
    function mergeSchemasResolver(keyword, values, mergedSchema, schemas, options) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
    }
    function cartesianProduct(arrays) {
      let result = [[]];
      for (const array of arrays) {
        const temp = [];
        for (const x of result) {
          for (const y of array) {
            temp.push([...x, y]);
          }
        }
        result = temp;
      }
      return result;
    }
    function mergeOneOf(keyword, values, mergedSchema, schemas, options) {
      if (values.length === 1) {
        mergedSchema[keyword] = values[0];
        return;
      }
      const product = cartesianProduct(values);
      const mergedOneOf = [];
      for (const combination of product) {
        try {
          const mergedSchema2 = _mergeSchemas(combination, options);
          if (mergedSchema2 !== void 0) {
            mergedOneOf.push(mergedSchema2);
          }
        } catch (error) {
          if (error instanceof errors.MergeError) continue;
          throw error;
        }
      }
      mergedSchema[keyword] = mergedOneOf;
    }
    function getSchemaForItem(schema, index) {
      const { items, additionalItems } = schema;
      if (Array.isArray(items)) {
        if (index < items.length) {
          return items[index];
        }
        return additionalItems;
      }
      if (items !== void 0) {
        return items;
      }
      return additionalItems;
    }
    function mergeItems(keyword, values, mergedSchema, schemas, options) {
      let maxArrayItemsLength = 0;
      for (const itemsSchema of values) {
        if (Array.isArray(itemsSchema)) {
          maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
        }
      }
      if (maxArrayItemsLength === 0) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedItemsSchemas = [];
      for (let i = 0; i < maxArrayItemsLength; i++) {
        const indexItemSchemas = [];
        for (const schema of schemas) {
          const itemSchema = getSchemaForItem(schema, i);
          if (itemSchema !== void 0) {
            indexItemSchemas.push(itemSchema);
          }
        }
        mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
      }
      mergedSchema[keyword] = mergedItemsSchemas;
    }
    function mergeAdditionalItems(keyword, values, mergedSchema, schemas, options) {
      let hasArrayItems = false;
      for (const schema of schemas) {
        if (Array.isArray(schema.items)) {
          hasArrayItems = true;
          break;
        }
      }
      if (!hasArrayItems) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedAdditionalItemsSchemas = [];
      for (const schema of schemas) {
        let additionalItemsSchema = schema.additionalItems;
        if (additionalItemsSchema === void 0 && !Array.isArray(schema.items)) {
          additionalItemsSchema = schema.items;
        }
        if (additionalItemsSchema !== void 0) {
          mergedAdditionalItemsSchemas.push(additionalItemsSchema);
        }
      }
      mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
    }
    function getSchemaForProperty(schema, propertyName) {
      const { properties, patternProperties, additionalProperties } = schema;
      if (properties?.[propertyName] !== void 0) {
        return properties[propertyName];
      }
      for (const pattern of Object.keys(patternProperties ?? {})) {
        const regexp = new RegExp(pattern);
        if (regexp.test(propertyName)) {
          return patternProperties[pattern];
        }
      }
      return additionalProperties;
    }
    function mergeProperties(keyword, values, mergedSchema, schemas, options) {
      const foundProperties = {};
      for (const currentSchema of schemas) {
        const properties = currentSchema.properties ?? {};
        for (const propertyName of Object.keys(properties)) {
          if (foundProperties[propertyName] !== void 0) continue;
          const propertySchema = properties[propertyName];
          foundProperties[propertyName] = [propertySchema];
          for (const anotherSchema of schemas) {
            if (currentSchema === anotherSchema) continue;
            const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
            if (propertySchema2 !== void 0) {
              foundProperties[propertyName].push(propertySchema2);
            }
          }
        }
      }
      const mergedProperties = {};
      for (const property of Object.keys(foundProperties)) {
        const propertySchemas = foundProperties[property];
        mergedProperties[property] = _mergeSchemas(propertySchemas, options);
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeObjects(keyword, values, mergedSchema, schemas, options) {
      const objectsProperties = {};
      for (const properties of values) {
        for (const propertyName of Object.keys(properties)) {
          if (objectsProperties[propertyName] === void 0) {
            objectsProperties[propertyName] = [];
          }
          objectsProperties[propertyName].push(properties[propertyName]);
        }
      }
      const mergedProperties = {};
      for (const propertyName of Object.keys(objectsProperties)) {
        const propertySchemas = objectsProperties[propertyName];
        const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
        mergedProperties[propertyName] = mergedPropertySchema;
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeIfThenElseSchemas(keyword, values, mergedSchema, schemas, options) {
      for (let i = 0; i < schemas.length; i++) {
        const subSchema = {
          if: schemas[i].if,
          then: schemas[i].then,
          else: schemas[i].else
        };
        if (subSchema.if === void 0) continue;
        if (mergedSchema.if === void 0) {
          mergedSchema.if = subSchema.if;
          if (subSchema.then !== void 0) {
            mergedSchema.then = subSchema.then;
          }
          if (subSchema.else !== void 0) {
            mergedSchema.else = subSchema.else;
          }
          continue;
        }
        if (mergedSchema.then !== void 0) {
          mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
        }
        if (mergedSchema.else !== void 0) {
          mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
        }
      }
    }
    function mergeDependencies(keyword, values, mergedSchema) {
      const mergedDependencies = {};
      for (const dependencies of values) {
        for (const propertyName of Object.keys(dependencies)) {
          if (mergedDependencies[propertyName] === void 0) {
            mergedDependencies[propertyName] = [];
          }
          const mergedPropertyDependencies = mergedDependencies[propertyName];
          for (const propertyDependency of dependencies[propertyName]) {
            if (!mergedPropertyDependencies.includes(propertyDependency)) {
              mergedPropertyDependencies.push(propertyDependency);
            }
          }
        }
      }
      mergedSchema[keyword] = mergedDependencies;
    }
    function _mergeSchemas(schemas, options) {
      if (schemas.length === 0) return {};
      if (schemas.length === 1) return schemas[0];
      const mergedSchema = {};
      const keywords = {};
      let allSchemasAreTrue = true;
      for (const schema of schemas) {
        if (schema === false) return false;
        if (schema === true) continue;
        allSchemasAreTrue = false;
        for (const keyword of Object.keys(schema)) {
          if (keywords[keyword] === void 0) {
            keywords[keyword] = [];
          }
          keywords[keyword].push(schema[keyword]);
        }
      }
      if (allSchemasAreTrue) return true;
      for (const keyword of Object.keys(keywords)) {
        const keywordValues = keywords[keyword];
        const resolver = options.resolvers[keyword] ?? options.defaultResolver;
        resolver(keyword, keywordValues, mergedSchema, schemas, options);
      }
      return mergedSchema;
    }
    function defaultResolver(keyword, values, mergedSchema, schemas, options) {
      const onConflict = options.onConflict ?? "throw";
      if (values.length === 1 || onConflict === "first") {
        mergedSchema[keyword] = values[0];
        return;
      }
      let allValuesEqual = true;
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], values[0])) {
          allValuesEqual = false;
          break;
        }
      }
      if (allValuesEqual) {
        mergedSchema[keyword] = values[0];
        return;
      }
      if (onConflict === "throw") {
        throw new errors.ResolverNotFoundError(keyword, values);
      }
      if (onConflict === "skip") {
        return;
      }
      throw new errors.InvalidOnConflictOptionError(onConflict);
    }
    function mergeSchemas(schemas, options = {}) {
      if (options.defaultResolver === void 0) {
        options.defaultResolver = defaultResolver;
      }
      options.resolvers = { ...keywordsResolvers, ...options.resolvers };
      const mergedSchema = _mergeSchemas(schemas, options);
      return mergedSchema;
    }
    module2.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/merge-schemas.js
var require_merge_schemas = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/merge-schemas.js"(exports2, module2) {
    "use strict";
    var { mergeSchemas: _mergeSchemas } = require_merge_json_schemas();
    function mergeSchemas(schemas) {
      return _mergeSchemas(schemas, { onConflict: "skip" });
    }
    module2.exports = mergeSchemas;
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/standalone.js
var require_standalone = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/lib/standalone.js"(exports2, module2) {
    "use strict";
    function buildStandaloneCode(contextFunc, context, serializer, validator) {
      let ajvDependencyCode = "";
      if (context.validatorSchemasIds.size > 0) {
        ajvDependencyCode += "const Validator = require('fast-json-stringify/lib/validator')\n";
        ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}
`;
        ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
      } else {
        ajvDependencyCode += "const validator = null\n";
      }
      const { schema, ...serializerState } = serializer.getState();
      return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
    }
    module2.exports = buildStandaloneCode;
    module2.exports.dependencies = {
      Serializer: require_serializer(),
      Validator: require_validator2()
    };
  }
});

// ../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/index.js
var require_fast_json_stringify = __commonJS({
  "../../node_modules/.pnpm/fast-json-stringify@6.0.0/node_modules/fast-json-stringify/index.js"(exports2, module2) {
    "use strict";
    var { RefResolver } = require_json_schema_ref_resolver();
    var Serializer = require_serializer();
    var Validator = require_validator2();
    var Location = require_location();
    var validate = require_schema_validator();
    var mergeSchemas = require_merge_schemas();
    var SINGLE_TICK = /'/g;
    var largeArraySize = 2e4;
    var largeArrayMechanism = "default";
    var validRoundingMethods = [
      "floor",
      "ceil",
      "round",
      "trunc"
    ];
    var validLargeArrayMechanisms = [
      "default",
      "json-stringify"
    ];
    var schemaIdCounter = 0;
    function isValidSchema(schema, name) {
      if (!validate(schema)) {
        if (name) {
          name = `"${name}" `;
        } else {
          name = "";
        }
        const first = validate.errors[0];
        const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
        err.errors = isValidSchema.errors;
        throw err;
      }
    }
    function resolveRef(context, location) {
      const ref = location.schema.$ref;
      let hashIndex = ref.indexOf("#");
      if (hashIndex === -1) {
        hashIndex = ref.length;
      }
      const schemaId = ref.slice(0, hashIndex) || location.schemaId;
      const jsonPointer = ref.slice(hashIndex) || "#";
      const schema = context.refResolver.getSchema(schemaId, jsonPointer);
      if (schema === null) {
        throw new Error(`Cannot find reference "${ref}"`);
      }
      const newLocation = new Location(schema, schemaId, jsonPointer);
      if (schema.$ref !== void 0) {
        return resolveRef(context, newLocation);
      }
      return newLocation;
    }
    function getMergedLocation(context, mergedSchemaId) {
      const mergedSchema = context.refResolver.getSchema(mergedSchemaId, "#");
      return new Location(mergedSchema, mergedSchemaId, "#");
    }
    function getSchemaId(schema, rootSchemaId) {
      if (schema.$id && schema.$id.charAt(0) !== "#") {
        return schema.$id;
      }
      return rootSchemaId;
    }
    function build(schema, options) {
      isValidSchema(schema);
      options = options || {};
      const context = {
        functions: [],
        functionsCounter: 0,
        functionsNamesBySchema: /* @__PURE__ */ new Map(),
        options,
        refResolver: new RefResolver(),
        rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
        validatorSchemasIds: /* @__PURE__ */ new Set(),
        mergedSchemasIds: /* @__PURE__ */ new Map()
      };
      const schemaId = getSchemaId(schema, context.rootSchemaId);
      if (!context.refResolver.hasSchema(schemaId)) {
        context.refResolver.addSchema(schema, context.rootSchemaId);
      }
      if (options.schema) {
        for (const key in options.schema) {
          const schema2 = options.schema[key];
          const schemaId2 = getSchemaId(schema2, key);
          if (!context.refResolver.hasSchema(schemaId2)) {
            isValidSchema(schema2, key);
            context.refResolver.addSchema(schema2, key);
          }
        }
      }
      if (options.rounding) {
        if (!validRoundingMethods.includes(options.rounding)) {
          throw new Error(`Unsupported integer rounding method ${options.rounding}`);
        }
      }
      if (options.largeArrayMechanism) {
        if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
          largeArrayMechanism = options.largeArrayMechanism;
        } else {
          throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
        }
      }
      if (options.largeArraySize) {
        if (typeof options.largeArraySize === "string" && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
          largeArraySize = Number.parseInt(options.largeArraySize, 10);
        } else if (typeof options.largeArraySize === "number" && Number.isInteger(options.largeArraySize)) {
          largeArraySize = options.largeArraySize;
        } else if (typeof options.largeArraySize === "bigint") {
          largeArraySize = Number(options.largeArraySize);
        } else {
          throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
        }
      }
      const location = new Location(schema, context.rootSchemaId);
      const code = buildValue(context, location, "input");
      let contextFunctionCode = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
      if (code === "json += anonymous0(input)") {
        contextFunctionCode += `
    ${context.functions.join("\n")}
    const main = anonymous0
    return main
    `;
      } else {
        contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join("\n")}
    return main
    `;
      }
      const serializer = new Serializer(options);
      const validator = new Validator(options.ajv);
      for (const schemaId2 of context.validatorSchemasIds) {
        const schema2 = context.refResolver.getSchema(schemaId2);
        validator.addSchema(schema2, schemaId2);
        const dependencies = context.refResolver.getSchemaDependencies(schemaId2);
        for (const [schemaId3, schema3] of Object.entries(dependencies)) {
          validator.addSchema(schema3, schemaId3);
        }
      }
      if (options.debugMode) {
        options.mode = "debug";
      }
      if (options.mode === "debug") {
        return {
          validator,
          serializer,
          code: `validator
serializer
${contextFunctionCode}`,
          ajv: validator.ajv
        };
      }
      const contextFunc = new Function("validator", "serializer", contextFunctionCode);
      if (options.mode === "standalone") {
        const buildStandaloneCode = require_standalone();
        return buildStandaloneCode(contextFunc, context, serializer, validator);
      }
      return contextFunc(validator, serializer);
    }
    var objectKeywords = [
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "maxProperties",
      "minProperties",
      "dependencies"
    ];
    var arrayKeywords = [
      "items",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "contains"
    ];
    var stringKeywords = [
      "maxLength",
      "minLength",
      "pattern"
    ];
    var numberKeywords = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum"
    ];
    function inferTypeByKeyword(schema) {
      for (var keyword of objectKeywords) {
        if (keyword in schema) return "object";
      }
      for (var keyword of arrayKeywords) {
        if (keyword in schema) return "array";
      }
      for (var keyword of stringKeywords) {
        if (keyword in schema) return "string";
      }
      for (var keyword of numberKeywords) {
        if (keyword in schema) return "number";
      }
      return schema.type;
    }
    function buildExtraObjectPropertiesSerializer(context, location, addComma) {
      const schema = location.schema;
      const propertiesKeys = Object.keys(schema.properties || {});
      let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
      const patternPropertiesLocation = location.getPropertyLocation("patternProperties");
      const patternPropertiesSchema = patternPropertiesLocation.schema;
      if (patternPropertiesSchema !== void 0) {
        for (const propertyKey in patternPropertiesSchema) {
          const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
          code += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, "value")}
          continue
        }
      `;
        }
      }
      const additionalPropertiesLocation = location.getPropertyLocation("additionalProperties");
      const additionalPropertiesSchema = additionalPropertiesLocation.schema;
      if (additionalPropertiesSchema !== void 0) {
        if (additionalPropertiesSchema === true) {
          code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
        } else {
          const propertyLocation = location.getPropertyLocation("additionalProperties");
          code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, "value")}
      `;
        }
      }
      code += `
    }
  `;
      return code;
    }
    function buildInnerObject(context, location) {
      const schema = location.schema;
      const propertiesLocation = location.getPropertyLocation("properties");
      const requiredProperties = schema.required || [];
      const propertiesKeys = Object.keys(schema.properties || {}).sort(
        (key1, key2) => {
          const required1 = requiredProperties.includes(key1);
          const required2 = requiredProperties.includes(key2);
          return required1 === required2 ? 0 : required1 ? -1 : 1;
        }
      );
      const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);
      let code = "let value\n";
      for (const key of requiredProperties) {
        if (!propertiesKeys.includes(key)) {
          const sanitizedKey = JSON.stringify(key);
          code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
        }
      }
      code += "let json = JSON_STR_BEGIN_OBJECT\n";
      let addComma = "";
      if (!hasRequiredProperties) {
        code += "let addComma = false\n";
        addComma = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)";
      }
      for (const key of propertiesKeys) {
        let propertyLocation = propertiesLocation.getPropertyLocation(key);
        if (propertyLocation.schema.$ref) {
          propertyLocation = resolveRef(context, propertyLocation);
        }
        const sanitizedKey = JSON.stringify(key);
        const defaultValue = propertyLocation.schema.default;
        const isRequired = requiredProperties.includes(key);
        code += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context, propertyLocation, "value")}
      }`;
        if (defaultValue !== void 0) {
          code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
        } else if (isRequired) {
          code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
        } else {
          code += "\n";
        }
        if (hasRequiredProperties) {
          addComma = "json += ','";
        }
      }
      if (schema.patternProperties || schema.additionalProperties) {
        code += buildExtraObjectPropertiesSerializer(context, location, addComma);
      }
      code += `
    return json + JSON_STR_END_OBJECT
  `;
      return code;
    }
    function mergeLocations(context, mergedSchemaId, mergedLocations) {
      for (let i = 0; i < mergedLocations.length; i++) {
        const location = mergedLocations[i];
        const schema = location.schema;
        if (schema.$ref) {
          mergedLocations[i] = resolveRef(context, location);
        }
      }
      const mergedSchemas = [];
      for (const location of mergedLocations) {
        const schema = cloneOriginSchema(context, location.schema, location.schemaId);
        delete schema.$id;
        mergedSchemas.push(schema);
      }
      const mergedSchema = mergeSchemas(mergedSchemas);
      const mergedLocation = new Location(mergedSchema, mergedSchemaId);
      context.refResolver.addSchema(mergedSchema, mergedSchemaId);
      return mergedLocation;
    }
    function cloneOriginSchema(context, schema, schemaId) {
      const clonedSchema = Array.isArray(schema) ? [] : {};
      if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
        schemaId = schema.$id;
      }
      const mergedSchemaRef = context.mergedSchemasIds.get(schema);
      if (mergedSchemaRef) {
        context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
      }
      for (const key in schema) {
        let value = schema[key];
        if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
          value = schemaId + value;
        }
        if (typeof value === "object" && value !== null) {
          value = cloneOriginSchema(context, value, schemaId);
        }
        clonedSchema[key] = value;
      }
      return clonedSchema;
    }
    function toJSON(variableName) {
      return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
    }
    function buildObject(context, location) {
      const schema = location.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        return context.functionsNamesBySchema.get(schema);
      }
      const functionName = generateFuncName(context);
      context.functionsNamesBySchema.set(schema, functionName);
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      let functionCode = `
  `;
      const nullable = schema.nullable === true;
      functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON("input")}
      ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_OBJECT" : ""}

      ${buildInnerObject(context, location)}
    }
  `;
      context.functions.push(functionCode);
      return functionName;
    }
    function buildArray(context, location) {
      const schema = location.schema;
      let itemsLocation = location.getPropertyLocation("items");
      itemsLocation.schema = itemsLocation.schema || {};
      if (itemsLocation.schema.$ref) {
        itemsLocation = resolveRef(context, itemsLocation);
      }
      const itemsSchema = itemsLocation.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        return context.functionsNamesBySchema.get(schema);
      }
      const functionName = generateFuncName(context);
      context.functionsNamesBySchema.set(schema, functionName);
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;
      const nullable = schema.nullable === true;
      functionCode += `
    ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_ARRAY" : ""}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
      if (!schema.additionalItems && Array.isArray(itemsSchema)) {
        functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
      }
      if (largeArrayMechanism === "json-stringify") {
        functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
      }
      functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;
      if (Array.isArray(itemsSchema)) {
        for (let i = 0; i < itemsSchema.length; i++) {
          const item = itemsSchema[i];
          functionCode += `value = obj[${i}]`;
          const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), "value");
          functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, `[${i}]`)}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
        }
        if (schema.additionalItems) {
          functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
        }
      } else {
        const code = buildValue(context, itemsLocation, "obj[i]");
        functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        ${code}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
      }
      functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;
      context.functions.push(functionCode);
      return functionName;
    }
    function buildArrayTypeCondition(type, accessor) {
      let condition;
      switch (type) {
        case "null":
          condition = "value === null";
          break;
        case "string":
          condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
          break;
        case "integer":
          condition = "Number.isInteger(value)";
          break;
        case "number":
          condition = "Number.isFinite(value)";
          break;
        case "boolean":
          condition = "typeof value === 'boolean'";
          break;
        case "object":
          condition = "value && typeof value === 'object' && value.constructor === Object";
          break;
        case "array":
          condition = "Array.isArray(value)";
          break;
        default:
          if (Array.isArray(type)) {
            const conditions = type.map((subType) => {
              return buildArrayTypeCondition(subType, accessor);
            });
            condition = `(${conditions.join(" || ")})`;
          }
      }
      return condition;
    }
    function generateFuncName(context) {
      return "anonymous" + context.functionsCounter++;
    }
    function buildMultiTypeSerializer(context, location, input) {
      const schema = location.schema;
      const types = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
      let code = "";
      types.forEach((type, index) => {
        location.schema = { ...location.schema, type };
        const nestedResult = buildSingleTypeSerializer(context, location, input);
        const statement = index === 0 ? "if" : "else if";
        switch (type) {
          case "null":
            code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
            break;
          case "string": {
            code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
            break;
          }
          case "array": {
            code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
            break;
          }
          case "integer": {
            code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
            break;
          }
          default: {
            code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
            break;
          }
        }
      });
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildSingleTypeSerializer(context, location, input) {
      const schema = location.schema;
      switch (schema.type) {
        case "null":
          return "json += JSON_STR_NULL";
        case "string": {
          if (schema.format === "date-time") {
            return `json += serializer.asDateTime(${input})`;
          } else if (schema.format === "date") {
            return `json += serializer.asDate(${input})`;
          } else if (schema.format === "time") {
            return `json += serializer.asTime(${input})`;
          } else if (schema.format === "unsafe") {
            return `json += serializer.asUnsafeString(${input})`;
          } else {
            return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += serializer.asString(${input}.source)
          } else {
            json += serializer.asString(${input}.toString())
          }
        } else {
          json += serializer.asString(${input})
        }
        `;
          }
        }
        case "integer":
          return `json += serializer.asInteger(${input})`;
        case "number":
          return `json += serializer.asNumber(${input})`;
        case "boolean":
          return `json += serializer.asBoolean(${input})`;
        case "object": {
          const funcName = buildObject(context, location);
          return `json += ${funcName}(${input})`;
        }
        case "array": {
          const funcName = buildArray(context, location);
          return `json += ${funcName}(${input})`;
        }
        case void 0:
          return `json += JSON.stringify(${input})`;
        default:
          throw new Error(`${schema.type} unsupported`);
      }
    }
    function buildConstSerializer(location, input) {
      const schema = location.schema;
      const type = schema.type;
      const hasNullType = Array.isArray(type) && type.includes("null");
      let code = "";
      if (hasNullType) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
      if (hasNullType) {
        code += `
      }
    `;
      }
      return code;
    }
    function buildAllOf(context, location, input) {
      const schema = location.schema;
      let mergedSchemaId = context.mergedSchemasIds.get(schema);
      if (mergedSchemaId) {
        const mergedLocation2 = getMergedLocation(context, mergedSchemaId);
        return buildValue(context, mergedLocation2, input);
      }
      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(schema, mergedSchemaId);
      const { allOf, ...schemaWithoutAllOf } = location.schema;
      const locations = [
        new Location(
          schemaWithoutAllOf,
          location.schemaId,
          location.jsonPointer
        )
      ];
      const allOfsLocation = location.getPropertyLocation("allOf");
      for (let i = 0; i < allOf.length; i++) {
        locations.push(allOfsLocation.getPropertyLocation(i));
      }
      const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
      return buildValue(context, mergedLocation, input);
    }
    function buildOneOf(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const schema = location.schema;
      const type = schema.anyOf ? "anyOf" : "oneOf";
      const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;
      const locationWithoutOneOf = new Location(
        schemaWithoutAnyOf,
        location.schemaId,
        location.jsonPointer
      );
      const oneOfsLocation = location.getPropertyLocation(type);
      let code = "";
      for (let index = 0; index < oneOfs.length; index++) {
        const optionLocation = oneOfsLocation.getPropertyLocation(index);
        const optionSchema = optionLocation.schema;
        let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
        let mergedLocation = null;
        if (mergedSchemaId) {
          mergedLocation = getMergedLocation(context, mergedSchemaId);
        } else {
          mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
          context.mergedSchemasIds.set(optionSchema, mergedSchemaId);
          mergedLocation = mergeLocations(context, mergedSchemaId, [
            locationWithoutOneOf,
            optionLocation
          ]);
        }
        const nestedResult = buildValue(context, mergedLocation, input);
        const schemaRef2 = optionLocation.getSchemaRef();
        code += `
      ${index === 0 ? "if" : "else if"}(validator.validate("${schemaRef2}", ${input}))
        ${nestedResult}
    `;
      }
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildIfThenElse(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const {
        if: ifSchema,
        then: thenSchema,
        else: elseSchema,
        ...schemaWithoutIfThenElse
      } = location.schema;
      const rootLocation = new Location(
        schemaWithoutIfThenElse,
        location.schemaId,
        location.jsonPointer
      );
      const ifLocation = location.getPropertyLocation("if");
      const ifSchemaRef = ifLocation.getSchemaRef();
      const thenLocation = location.getPropertyLocation("then");
      let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
      let thenMergedLocation = null;
      if (thenMergedSchemaId) {
        thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
      } else {
        thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
        thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
          rootLocation,
          thenLocation
        ]);
      }
      if (!elseSchema) {
        return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `;
      }
      const elseLocation = location.getPropertyLocation("else");
      let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
      let elseMergedLocation = null;
      if (elseMergedSchemaId) {
        elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
      } else {
        elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
        elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
          rootLocation,
          elseLocation
        ]);
      }
      return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `;
    }
    function buildValue(context, location, input) {
      let schema = location.schema;
      if (typeof schema === "boolean") {
        return `json += JSON.stringify(${input})`;
      }
      if (schema.$ref) {
        location = resolveRef(context, location);
        schema = location.schema;
      }
      if (schema.allOf) {
        return buildAllOf(context, location, input);
      }
      if (schema.anyOf || schema.oneOf) {
        return buildOneOf(context, location, input);
      }
      if (schema.if && schema.then) {
        return buildIfThenElse(context, location, input);
      }
      if (schema.type === void 0) {
        const inferredType = inferTypeByKeyword(schema);
        if (inferredType) {
          schema.type = inferredType;
        }
      }
      let code = "";
      const type = schema.type;
      const nullable = schema.nullable === true;
      if (nullable) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      if (schema.const !== void 0) {
        code += buildConstSerializer(location, input);
      } else if (Array.isArray(type)) {
        code += buildMultiTypeSerializer(context, location, input);
      } else {
        code += buildSingleTypeSerializer(context, location, input);
      }
      if (nullable) {
        code += `
      }
    `;
      }
      return code;
    }
    module2.exports = build;
    module2.exports.default = build;
    module2.exports.build = build;
    module2.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
    module2.exports.restore = function({ code, validator, serializer }) {
      return Function.apply(null, ["validator", "serializer", code]).apply(null, [validator, serializer]);
    };
  }
});

// ../../node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.1/node_modules/@fastify/fast-json-stringify-compiler/standalone.js
var require_standalone2 = __commonJS({
  "../../node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.1/node_modules/@fastify/fast-json-stringify-compiler/standalone.js"(exports2, module2) {
    "use strict";
    var SerializerSelector = require_fast_json_stringify_compiler();
    function StandaloneSerializer(options = { readMode: true }) {
      if (options.readMode === true && typeof options.restoreFunction !== "function") {
        throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
      }
      if (options.readMode !== true && typeof options.storeFunction !== "function") {
        throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = SerializerSelector();
      return function wrapper(externalSchemas, serializerOpts = {}) {
        serializerOpts.mode = "standalone";
        const compiler = factory(externalSchemas, serializerOpts);
        return function(opts) {
          const serializeFuncCode = compiler(opts);
          options.storeFunction(opts, serializeFuncCode);
          return new Function(serializeFuncCode);
        };
      };
    }
    module2.exports = StandaloneSerializer;
    module2.exports.default = StandaloneSerializer;
  }
});

// ../../node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.1/node_modules/@fastify/fast-json-stringify-compiler/index.js
var require_fast_json_stringify_compiler = __commonJS({
  "../../node_modules/.pnpm/@fastify+fast-json-stringify-compiler@5.0.1/node_modules/@fastify/fast-json-stringify-compiler/index.js"(exports2, module2) {
    "use strict";
    var fastJsonStringify = require_fast_json_stringify();
    function SerializerSelector() {
      return function buildSerializerFactory(externalSchemas, serializerOpts) {
        const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
        return responseSchemaCompiler.bind(null, fjsOpts);
      };
    }
    function responseSchemaCompiler(fjsOpts, {
      schema
      /* method, url, httpStatus */
    }) {
      if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
        fjsOpts.schema = { ...fjsOpts.schema };
        delete fjsOpts.schema[schema.$id];
      }
      return fastJsonStringify(schema, fjsOpts);
    }
    module2.exports = SerializerSelector;
    module2.exports.default = SerializerSelector;
    module2.exports.SerializerSelector = SerializerSelector;
    module2.exports.StandaloneSerializer = require_standalone2();
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/metadata.js
var require_metadata2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkMetadata = void 0;
    var util_1 = require_util();
    var def = {
      keyword: "metadata",
      schemaType: "object",
      code(cxt) {
        checkMetadata(cxt);
        const { gen: gen2, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen2.name("valid");
        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
        cxt.ok(valid);
      }
    };
    function checkMetadata({ it, keyword }, metadata) {
      if (it.jtdMetadata !== metadata) {
        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
      }
    }
    exports2.checkMetadata = checkMetadata;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/ref.js
var require_ref2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasRef = void 0;
    var compile_1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var ref_1 = require_ref();
    var metadata_1 = require_metadata2();
    var def = {
      keyword: "ref",
      schemaType: "string",
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen: gen2, data: data4, schema: ref, parentSchema, it } = cxt;
        const { schemaEnv: { root } } = it;
        const valid = gen2.name("valid");
        if (parentSchema.nullable) {
          gen2.var(valid, (0, codegen_1._)`${data4} === null`);
          gen2.if((0, codegen_1.not)(valid), validateJtdRef);
        } else {
          gen2.var(valid, false);
          validateJtdRef();
        }
        cxt.ok(valid);
        function validateJtdRef() {
          var _a;
          const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
          if (!refSchema) {
            throw new ref_error_1.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
          }
          if (hasRef(refSchema) || !it.opts.inlineRefs)
            callValidate(refSchema);
          else
            inlineRefSchema(refSchema);
        }
        function callValidate(schema) {
          const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
          const v = (0, ref_1.getValidate)(cxt, sch);
          const errsCount = gen2.const("_errs", names_1.default.errors);
          (0, ref_1.callRef)(cxt, v, sch, sch.$async);
          gen2.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        }
        function inlineRefSchema(schema) {
          const schName = gen2.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
          cxt.subschema({
            schema,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: `/definitions/${ref}`
          }, valid);
        }
      }
    };
    function hasRef(schema) {
      for (const key in schema) {
        let sch;
        if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    exports2.hasRef = hasRef;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DT_SEPARATOR = /t|\s/i;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function validTimestamp(str, allowDate) {
      const dt = str.split(DT_SEPARATOR);
      return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
    }
    exports2.default = validTimestamp;
    function validDate(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const y = +matches[1];
      const m = +matches[2];
      const d2 = +matches[3];
      return m >= 1 && m <= 12 && d2 >= 1 && (d2 <= DAYS[m] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
      m === 2 && d2 === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
    }
    function validTime(str) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tzH = +(matches[4] || 0);
      const tzM = +(matches[5] || 0);
      return hr <= 23 && min <= 59 && sec <= 59 || // leap second
      hr - tzH === 23 && min - tzM === 59 && sec === 60;
    }
    validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/error.js
var require_error2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typeErrorParams = exports2.typeErrorMessage = exports2.typeError = void 0;
    var codegen_1 = require_codegen();
    function typeError(t) {
      return {
        message: (cxt) => typeErrorMessage(cxt, t),
        params: (cxt) => typeErrorParams(cxt, t)
      };
    }
    exports2.typeError = typeError;
    function typeErrorMessage({ parentSchema }, t) {
      return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
    }
    exports2.typeErrorMessage = typeErrorMessage;
    function typeErrorParams({ parentSchema }, t) {
      return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
    }
    exports2.typeErrorParams = typeErrorParams;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/type.js
var require_type = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intRange = void 0;
    var codegen_1 = require_codegen();
    var timestamp_1 = require_timestamp();
    var util_1 = require_util();
    var metadata_1 = require_metadata2();
    var error_1 = require_error2();
    exports2.intRange = {
      int8: [-128, 127, 3],
      uint8: [0, 255, 3],
      int16: [-32768, 32767, 5],
      uint16: [0, 65535, 5],
      int32: [-2147483648, 2147483647, 10],
      uint32: [0, 4294967295, 10]
    };
    var error = {
      message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
      params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
    };
    function timestampCode(cxt) {
      const { gen: gen2, data: data4, it } = cxt;
      const { timestamp, allowDate } = it.opts;
      if (timestamp === "date")
        return (0, codegen_1._)`${data4} instanceof Date `;
      const vts = (0, util_1.useFunc)(gen2, timestamp_1.default);
      const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
      const validString = (0, codegen_1._)`typeof ${data4} == "string" && ${vts}(${data4}${allowDateArg})`;
      return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data4} instanceof Date`, validString);
    }
    var def = {
      keyword: "type",
      schemaType: "string",
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { data: data4, schema, parentSchema, it } = cxt;
        let cond;
        switch (schema) {
          case "boolean":
          case "string":
            cond = (0, codegen_1._)`typeof ${data4} == ${schema}`;
            break;
          case "timestamp": {
            cond = timestampCode(cxt);
            break;
          }
          case "float32":
          case "float64":
            cond = (0, codegen_1._)`typeof ${data4} == "number"`;
            break;
          default: {
            const sch = schema;
            cond = (0, codegen_1._)`typeof ${data4} == "number" && isFinite(${data4}) && !(${data4} % 1)`;
            if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
              if (sch === "uint32")
                cond = (0, codegen_1._)`${cond} && ${data4} >= 0`;
            } else {
              const [min, max] = exports2.intRange[sch];
              cond = (0, codegen_1._)`${cond} && ${data4} >= ${min} && ${data4} <= ${max}`;
            }
          }
        }
        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data4} === null`, cond) : cond);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/nullable.js
var require_nullable = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/nullable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkNullableObject = exports2.checkNullable = void 0;
    var codegen_1 = require_codegen();
    function checkNullable({ gen: gen2, data: data4, parentSchema }, cond = codegen_1.nil) {
      const valid = gen2.name("valid");
      if (parentSchema.nullable) {
        gen2.let(valid, (0, codegen_1._)`${data4} === null`);
        cond = (0, codegen_1.not)(valid);
      } else {
        gen2.let(valid, false);
      }
      return [valid, cond];
    }
    exports2.checkNullable = checkNullable;
    function checkNullableObject(cxt, cond) {
      const [valid, cond_] = checkNullable(cxt, cond);
      return [valid, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
    }
    exports2.checkNullableObject = checkNullableObject;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/enum.js
var require_enum2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen: gen2, data: data4, schema, schemaValue, parentSchema, it } = cxt;
        if (schema.length === 0)
          throw new Error("enum must have non-empty array");
        if (schema.length !== new Set(schema).size)
          throw new Error("enum items must be unique");
        let valid;
        const isString2 = (0, codegen_1._)`typeof ${data4} == "string"`;
        if (schema.length >= it.opts.loopEnum) {
          let cond;
          [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString2);
          gen2.if(cond, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          valid = (0, codegen_1.and)(isString2, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data4} === ${value}`)));
          if (parentSchema.nullable)
            valid = (0, codegen_1.or)((0, codegen_1._)`${data4} === null`, valid);
        }
        cxt.pass(valid);
        function loopEnum() {
          gen2.forOf("v", schemaValue, (v) => gen2.if((0, codegen_1._)`${valid} = ${data4} === ${v}`, () => gen2.break()));
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/elements.js
var require_elements = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/elements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "elements",
      schemaType: "object",
      error: (0, error_1.typeError)("array"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen: gen2, data: data4, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const [valid] = (0, nullable_1.checkNullable)(cxt);
        gen2.if((0, codegen_1.not)(valid), () => gen2.if((0, codegen_1._)`Array.isArray(${data4})`, () => gen2.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/properties.js
var require_properties2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperties = exports2.error = void 0;
    var code_1 = require_code2();
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var PropError;
    (function(PropError2) {
      PropError2["Additional"] = "additional";
      PropError2["Missing"] = "missing";
    })(PropError || (PropError = {}));
    exports2.error = {
      message: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "properties",
      schemaType: "object",
      error: exports2.error,
      code: validateProperties
    };
    function validateProperties(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen: gen2, data: data4, parentSchema, it } = cxt;
      const { additionalProperties, nullable } = parentSchema;
      if (it.jtdDiscriminator && nullable)
        throw new Error("JTD: nullable inside discriminator mapping");
      if (commonProperties()) {
        throw new Error("JTD: properties and optionalProperties have common members");
      }
      const [allProps, properties] = schemaProperties("properties");
      const [allOptProps, optProperties] = schemaProperties("optionalProperties");
      if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
        return;
      }
      const [valid, cond] = it.jtdDiscriminator === void 0 ? (0, nullable_1.checkNullableObject)(cxt, data4) : [gen2.let("valid", false), true];
      gen2.if(cond, () => gen2.assign(valid, true).block(() => {
        validateProps(properties, "properties", true);
        validateProps(optProperties, "optionalProperties");
        if (!additionalProperties)
          validateAdditional();
      }));
      cxt.pass(valid);
      function commonProperties() {
        const props = parentSchema.properties;
        const optProps = parentSchema.optionalProperties;
        if (!(props && optProps))
          return false;
        for (const p in props) {
          if (Object.prototype.hasOwnProperty.call(optProps, p))
            return true;
        }
        return false;
      }
      function schemaProperties(keyword) {
        const schema = parentSchema[keyword];
        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
          throw new Error(`JTD: discriminator tag used in ${keyword}`);
        }
        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        return [allPs, ps];
      }
      function validateProps(props, keyword, required) {
        const _valid = gen2.var("valid");
        for (const prop of props) {
          gen2.if((0, code_1.propertyInData)(gen2, data4, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
          cxt.ok(_valid);
        }
        function missingProperty(prop) {
          if (required) {
            gen2.assign(_valid, false);
            cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
          } else {
            gen2.assign(_valid, true);
          }
        }
      }
      function applyPropertySchema(prop, keyword, _valid) {
        cxt.subschema({
          keyword,
          schemaProp: prop,
          dataProp: prop
        }, _valid);
      }
      function validateAdditional() {
        gen2.forIn("key", data4, (key) => {
          const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
          const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
          const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
          gen2.if(extra, () => {
            if (it.opts.removeAdditional) {
              gen2.code((0, codegen_1._)`delete ${data4}[${key}]`);
            } else {
              cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
              if (!it.opts.allErrors)
                gen2.break();
            }
          });
        });
      }
      function isAdditional(key, props, keyword, jtdDiscriminator) {
        let additional;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
          additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen2, propsSchema, key));
          if (jtdDiscriminator !== void 0) {
            additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
          }
        } else if (props.length || jtdDiscriminator !== void 0) {
          const ps = jtdDiscriminator === void 0 ? props : [jtdDiscriminator].concat(props);
          additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`));
        } else {
          additional = true;
        }
        return additional;
      }
    }
    exports2.validateProperties = validateProperties;
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
var require_optionalProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var properties_1 = require_properties2();
    var def = {
      keyword: "optionalProperties",
      schemaType: "object",
      error: properties_1.error,
      code(cxt) {
        if (cxt.parentSchema.properties)
          return;
        (0, properties_1.validateProperties)(cxt);
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
var require_discriminator2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/discriminator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var types_1 = require_types();
    var error = {
      message: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "discriminator",
      schemaType: "string",
      implements: ["mapping"],
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen: gen2, data: data4, schema, parentSchema } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data4);
        gen2.if(cond);
        validateDiscriminator();
        gen2.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen2.endIf();
        cxt.ok(valid);
        function validateDiscriminator() {
          const tag = gen2.const("tag", (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(schema)}`);
          gen2.if((0, codegen_1._)`${tag} === undefined`);
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
          gen2.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
          validateMapping(tag);
          gen2.else();
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
          gen2.endIf();
        }
        function validateMapping(tag) {
          gen2.if(false);
          for (const tagValue in parentSchema.mapping) {
            gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen2.assign(valid, applyTagSchema(tagValue));
          }
          gen2.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
          gen2.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen2.name("valid");
          cxt.subschema({
            keyword: "mapping",
            schemaProp,
            jtdDiscriminator: schema
          }, _valid);
          return _valid;
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/values.js
var require_values = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "values",
      schemaType: "object",
      error: (0, error_1.typeError)("object"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen: gen2, data: data4, schema, it } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data4);
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          gen2.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
        } else {
          gen2.if(cond);
          gen2.assign(valid, validateMap());
          gen2.elseIf((0, codegen_1.not)(valid));
          cxt.error();
          gen2.endIf();
        }
        cxt.ok(valid);
        function validateMap() {
          const _valid = gen2.name("valid");
          if (it.allErrors) {
            const validMap = gen2.let("valid", true);
            validateValues(() => gen2.assign(validMap, false));
            return validMap;
          }
          gen2.var(_valid, true);
          validateValues(() => gen2.break());
          return _valid;
          function validateValues(notValid) {
            gen2.forIn("key", data4, (key) => {
              cxt.subschema({
                keyword: "values",
                dataProp: key,
                dataPropType: util_1.Type.Str
              }, _valid);
              gen2.if((0, codegen_1.not)(_valid), notValid);
            });
          }
        }
      }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/union.js
var require_union = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "union",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in union" }
    };
    exports2.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/index.js
var require_jtd = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/jtd/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var enum_1 = require_enum2();
    var elements_1 = require_elements();
    var properties_1 = require_properties2();
    var optionalProperties_1 = require_optionalProperties();
    var discriminator_1 = require_discriminator2();
    var values_1 = require_values();
    var union_1 = require_union();
    var metadata_1 = require_metadata2();
    var jtdVocabulary = [
      "definitions",
      ref_1.default,
      type_1.default,
      enum_1.default,
      elements_1.default,
      properties_1.default,
      optionalProperties_1.default,
      discriminator_1.default,
      values_1.default,
      union_1.default,
      metadata_1.default,
      { keyword: "additionalProperties", schemaType: "boolean" },
      { keyword: "nullable", schemaType: "boolean" }
    ];
    exports2.default = jtdVocabulary;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/jtd-schema.js
var require_jtd_schema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/jtd-schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var shared = (root) => {
      const sch = {
        nullable: { type: "boolean" },
        metadata: {
          optionalProperties: {
            union: { elements: { ref: "schema" } }
          },
          additionalProperties: true
        }
      };
      if (root)
        sch.definitions = { values: { ref: "schema" } };
      return sch;
    };
    var emptyForm = (root) => ({
      optionalProperties: shared(root)
    });
    var refForm = (root) => ({
      properties: {
        ref: { type: "string" }
      },
      optionalProperties: shared(root)
    });
    var typeForm = (root) => ({
      properties: {
        type: {
          enum: [
            "boolean",
            "timestamp",
            "string",
            "float32",
            "float64",
            "int8",
            "uint8",
            "int16",
            "uint16",
            "int32",
            "uint32"
          ]
        }
      },
      optionalProperties: shared(root)
    });
    var enumForm = (root) => ({
      properties: {
        enum: { elements: { type: "string" } }
      },
      optionalProperties: shared(root)
    });
    var elementsForm = (root) => ({
      properties: {
        elements: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var propertiesForm = (root) => ({
      properties: {
        properties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        optionalProperties: { values: { ref: "schema" } },
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var optionalPropertiesForm = (root) => ({
      properties: {
        optionalProperties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var discriminatorForm = (root) => ({
      properties: {
        discriminator: { type: "string" },
        mapping: {
          values: {
            metadata: {
              union: [propertiesForm(false), optionalPropertiesForm(false)]
            }
          }
        }
      },
      optionalProperties: shared(root)
    });
    var valuesForm = (root) => ({
      properties: {
        values: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var schema = (root) => ({
      metadata: {
        union: [
          emptyForm,
          refForm,
          typeForm,
          enumForm,
          elementsForm,
          propertiesForm,
          optionalPropertiesForm,
          discriminatorForm,
          valuesForm
        ].map((s2) => s2(root))
      }
    });
    var jtdMetaSchema = {
      definitions: {
        schema: schema(false)
      },
      ...schema(true)
    };
    exports2.default = jtdMetaSchema;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jtdForms = void 0;
    exports2.jtdForms = [
      "elements",
      "values",
      "discriminator",
      "properties",
      "optionalProperties",
      "enum",
      "type",
      "ref"
    ];
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/quote.js
var require_quote = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/quote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var rxEscapable = (
      // eslint-disable-next-line no-control-regex, no-misleading-character-class
      /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
    );
    var escaped = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    function quote(s2) {
      rxEscapable.lastIndex = 0;
      return '"' + (rxEscapable.test(s2) ? s2.replace(rxEscapable, (a2) => {
        const c2 = escaped[a2];
        return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
      }) : s2) + '"';
    }
    exports2.default = quote;
    quote.code = 'require("ajv/dist/runtime/quote").default';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/serialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var util_1 = require_util();
    var quote_1 = require_quote();
    var genSerialize = {
      elements: serializeElements,
      values: serializeValues,
      discriminator: serializeDiscriminator,
      properties: serializeProperties,
      optionalProperties: serializeProperties,
      enum: serializeString,
      type: serializeType,
      ref: serializeRef
    };
    function compileSerializer(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const serializeName = gen2.scopeName("serialize");
      const cxt = {
        self: this,
        gen: gen2,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.serializeName = serializeName;
        gen2.func(serializeName, names_1.default.data, false, () => {
          gen2.let(names_1.default.json, (0, codegen_1.str)``);
          serializeCode(cxt);
          gen2.return(names_1.default.json);
        });
        gen2.optimize(this.opts.code.optimize);
        const serializeFuncCode = gen2.toString();
        sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
        const serialize = makeSerialize(this.scope.get());
        this.scope.value(serializeName, { ref: serialize });
        sch.serialize = serialize;
      } catch (e2) {
        if (sourceCode)
          this.logger.error("Error compiling serializer, function code:", sourceCode);
        delete sch.serialize;
        delete sch.serializeName;
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports2.default = compileSerializer;
    function serializeCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
    }
    function serializeNullable(cxt, serializeForm) {
      const { gen: gen2, schema, data: data4 } = cxt;
      if (!schema.nullable)
        return serializeForm(cxt);
      gen2.if((0, codegen_1._)`${data4} === undefined || ${data4} === null`, () => gen2.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
    }
    function serializeElements(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      gen2.add(names_1.default.json, (0, codegen_1.str)`[`);
      const first = gen2.let("first", true);
      gen2.forOf("el", data4, (el) => {
        addComma(cxt, first);
        serializeCode({ ...cxt, schema: schema.elements, data: el });
      });
      gen2.add(names_1.default.json, (0, codegen_1.str)`]`);
    }
    function serializeValues(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      gen2.add(names_1.default.json, (0, codegen_1.str)`{`);
      const first = gen2.let("first", true);
      gen2.forIn("key", data4, (key) => serializeKeyValue(cxt, key, schema.values, first));
      gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeKeyValue(cxt, key, schema, first) {
      const { gen: gen2, data: data4 } = cxt;
      addComma(cxt, first);
      serializeString({ ...cxt, data: key });
      gen2.add(names_1.default.json, (0, codegen_1.str)`:`);
      const value = gen2.const("value", (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(key)}`);
      serializeCode({ ...cxt, schema, data: value });
    }
    function serializeDiscriminator(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      const { discriminator } = schema;
      gen2.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);
      const tag = gen2.const("tag", (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(discriminator)}`);
      serializeString({ ...cxt, data: tag });
      gen2.if(false);
      for (const tagValue in schema.mapping) {
        gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        const sch = schema.mapping[tagValue];
        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
      }
      gen2.endIf();
      gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeProperties(cxt) {
      const { gen: gen2 } = cxt;
      gen2.add(names_1.default.json, (0, codegen_1.str)`{`);
      serializeSchemaProperties(cxt);
      gen2.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeSchemaProperties(cxt, discriminator) {
      const { gen: gen2, schema, data: data4 } = cxt;
      const { properties, optionalProperties } = schema;
      const props = keys(properties);
      const optProps = keys(optionalProperties);
      const allProps = allProperties(props.concat(optProps));
      let first = !discriminator;
      let firstProp;
      for (const key of props) {
        if (first)
          first = false;
        else
          gen2.add(names_1.default.json, (0, codegen_1.str)`,`);
        serializeProperty(key, properties[key], keyValue(key));
      }
      if (first)
        firstProp = gen2.let("first", true);
      for (const key of optProps) {
        const value = keyValue(key);
        gen2.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen2, data4, key)), () => {
          addComma(cxt, firstProp);
          serializeProperty(key, optionalProperties[key], value);
        });
      }
      if (schema.additionalProperties) {
        gen2.forIn("key", data4, (key) => gen2.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
      }
      function keys(ps) {
        return ps ? Object.keys(ps) : [];
      }
      function allProperties(ps) {
        if (discriminator)
          ps.push(discriminator);
        if (new Set(ps).size !== ps.length) {
          throw new Error("JTD: properties/optionalProperties/disciminator overlap");
        }
        return ps;
      }
      function keyValue(key) {
        return gen2.const("value", (0, codegen_1._)`${data4}${(0, codegen_1.getProperty)(key)}`);
      }
      function serializeProperty(key, propSchema, value) {
        gen2.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
        serializeCode({ ...cxt, schema: propSchema, data: value });
      }
      function isAdditional(key, ps) {
        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`)) : true;
      }
    }
    function serializeType(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      switch (schema.type) {
        case "boolean":
          gen2.add(names_1.default.json, (0, codegen_1._)`${data4} ? "true" : "false"`);
          break;
        case "string":
          serializeString(cxt);
          break;
        case "timestamp":
          gen2.if((0, codegen_1._)`${data4} instanceof Date`, () => gen2.add(names_1.default.json, (0, codegen_1._)`'"' + ${data4}.toISOString() + '"'`), () => serializeString(cxt));
          break;
        default:
          serializeNumber(cxt);
      }
    }
    function serializeString({ gen: gen2, data: data4 }) {
      gen2.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen2, quote_1.default)}(${data4})`);
    }
    function serializeNumber({ gen: gen2, data: data4 }) {
      gen2.add(names_1.default.json, (0, codegen_1._)`"" + ${data4}`);
    }
    function serializeRef(cxt) {
      const { gen: gen2, self: self2, data: data4, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return serializeCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      gen2.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen2, sch)}(${data4})`);
    }
    function getSerialize(gen2, sch) {
      return sch.serialize ? gen2.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.serialize`;
    }
    function serializeEmpty({ gen: gen2, data: data4 }) {
      gen2.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data4})`);
    }
    function addComma({ gen: gen2 }, first) {
      if (first) {
        gen2.if(first, () => gen2.assign(first, false), () => gen2.add(names_1.default.json, (0, codegen_1.str)`,`));
      } else {
        gen2.add(names_1.default.json, (0, codegen_1.str)`,`);
      }
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/parseJson.js
var require_parseJson = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/parseJson.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseJsonString = exports2.parseJsonNumber = exports2.parseJson = void 0;
    var rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
    function parseJson(s2, pos) {
      let endPos;
      parseJson.message = void 0;
      let matches;
      if (pos)
        s2 = s2.slice(pos);
      try {
        parseJson.position = pos + s2.length;
        return JSON.parse(s2);
      } catch (e2) {
        matches = rxParseJson.exec(e2.message);
        if (!matches) {
          parseJson.message = "unexpected end";
          return void 0;
        }
        endPos = +matches[1];
        const c2 = s2[endPos];
        s2 = s2.slice(0, endPos);
        parseJson.position = pos + endPos;
        try {
          return JSON.parse(s2);
        } catch (e1) {
          parseJson.message = `unexpected token ${c2}`;
          return void 0;
        }
      }
    }
    exports2.parseJson = parseJson;
    parseJson.message = void 0;
    parseJson.position = 0;
    parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
    function parseJsonNumber(s2, pos, maxDigits) {
      let numStr = "";
      let c2;
      parseJsonNumber.message = void 0;
      if (s2[pos] === "-") {
        numStr += "-";
        pos++;
      }
      if (s2[pos] === "0") {
        numStr += "0";
        pos++;
      } else {
        if (!parseDigits(maxDigits)) {
          errorMessage();
          return void 0;
        }
      }
      if (maxDigits) {
        parseJsonNumber.position = pos;
        return +numStr;
      }
      if (s2[pos] === ".") {
        numStr += ".";
        pos++;
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      if (c2 = s2[pos], c2 === "e" || c2 === "E") {
        numStr += "e";
        pos++;
        if (c2 = s2[pos], c2 === "+" || c2 === "-") {
          numStr += c2;
          pos++;
        }
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      parseJsonNumber.position = pos;
      return +numStr;
      function parseDigits(maxLen) {
        let digit = false;
        while (c2 = s2[pos], c2 >= "0" && c2 <= "9" && (maxLen === void 0 || maxLen-- > 0)) {
          digit = true;
          numStr += c2;
          pos++;
        }
        return digit;
      }
      function errorMessage() {
        parseJsonNumber.position = pos;
        parseJsonNumber.message = pos < s2.length ? `unexpected token ${s2[pos]}` : "unexpected end";
      }
    }
    exports2.parseJsonNumber = parseJsonNumber;
    parseJsonNumber.message = void 0;
    parseJsonNumber.position = 0;
    parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
    var escapedChars = {
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var CODE_A = "a".charCodeAt(0);
    var CODE_0 = "0".charCodeAt(0);
    function parseJsonString(s2, pos) {
      let str = "";
      let c2;
      parseJsonString.message = void 0;
      while (true) {
        c2 = s2[pos++];
        if (c2 === '"')
          break;
        if (c2 === "\\") {
          c2 = s2[pos];
          if (c2 in escapedChars) {
            str += escapedChars[c2];
            pos++;
          } else if (c2 === "u") {
            pos++;
            let count = 4;
            let code = 0;
            while (count--) {
              code <<= 4;
              c2 = s2[pos];
              if (c2 === void 0) {
                errorMessage("unexpected end");
                return void 0;
              }
              c2 = c2.toLowerCase();
              if (c2 >= "a" && c2 <= "f") {
                code += c2.charCodeAt(0) - CODE_A + 10;
              } else if (c2 >= "0" && c2 <= "9") {
                code += c2.charCodeAt(0) - CODE_0;
              } else {
                errorMessage(`unexpected token ${c2}`);
                return void 0;
              }
              pos++;
            }
            str += String.fromCharCode(code);
          } else {
            errorMessage(`unexpected token ${c2}`);
            return void 0;
          }
        } else if (c2 === void 0) {
          errorMessage("unexpected end");
          return void 0;
        } else {
          if (c2.charCodeAt(0) >= 32) {
            str += c2;
          } else {
            errorMessage(`unexpected token ${c2}`);
            return void 0;
          }
        }
      }
      parseJsonString.position = pos;
      return str;
      function errorMessage(msg) {
        parseJsonString.position = pos;
        parseJsonString.message = msg;
      }
    }
    exports2.parseJsonString = parseJsonString;
    parseJsonString.message = void 0;
    parseJsonString.position = 0;
    parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/jtd/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var parseJson_1 = require_parseJson();
    var util_1 = require_util();
    var timestamp_1 = require_timestamp();
    var genParse = {
      elements: parseElements,
      values: parseValues,
      discriminator: parseDiscriminator,
      properties: parseProperties,
      optionalProperties: parseProperties,
      enum: parseEnum,
      type: parseType,
      ref: parseRef
    };
    function compileParser(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen2 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const parseName = gen2.scopeName("parse");
      const cxt = {
        self: this,
        gen: gen2,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen2.name("c")
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen2.optimize(this.opts.code.optimize);
        const parseFuncCode = gen2.toString();
        sourceCode = `${gen2.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
        const parse = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse });
        sch.parse = parse;
      } catch (e2) {
        if (sourceCode)
          this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports2.default = compileParser;
    var undef = (0, codegen_1._)`undefined`;
    function parserFunction(cxt) {
      const { gen: gen2, parseName, char } = cxt;
      gen2.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
        gen2.let(names_1.default.data);
        gen2.let(char);
        gen2.assign((0, codegen_1._)`${parseName}.message`, undef);
        gen2.assign((0, codegen_1._)`${parseName}.position`, undef);
        gen2.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
        gen2.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen2.if(names_1.default.jsonPart, () => {
          gen2.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
          gen2.return(names_1.default.data);
        });
        gen2.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen2.return(names_1.default.data));
        jsonSyntaxError(cxt);
      });
    }
    function parseCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      if (form)
        parseNullable(cxt, genParse[form]);
      else
        parseEmpty(cxt);
    }
    var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
    function parseNullable(cxt, parseForm) {
      const { gen: gen2, schema, data: data4 } = cxt;
      if (!schema.nullable)
        return parseForm(cxt);
      tryParseToken(cxt, "null", parseForm, () => gen2.assign(data4, null));
    }
    function parseElements(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      parseToken(cxt, "[");
      const ix = gen2.let("i", 0);
      gen2.assign(data4, (0, codegen_1._)`[]`);
      parseItems(cxt, "]", () => {
        const el = gen2.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el });
        gen2.assign((0, codegen_1._)`${data4}[${ix}++]`, el);
      });
    }
    function parseValues(cxt) {
      const { gen: gen2, schema, data: data4 } = cxt;
      parseToken(cxt, "{");
      gen2.assign(data4, (0, codegen_1._)`{}`);
      parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
    }
    function parseItems(cxt, endToken, block) {
      tryParseItems(cxt, endToken, block);
      parseToken(cxt, endToken);
    }
    function tryParseItems(cxt, endToken, block) {
      const { gen: gen2 } = cxt;
      gen2.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
        block();
        tryParseToken(cxt, ",", () => gen2.break(), hasItem);
      });
      function hasItem() {
        tryParseToken(cxt, endToken, () => {
        }, jsonSyntaxError);
      }
    }
    function parseKeyValue(cxt, schema) {
      const { gen: gen2 } = cxt;
      const key = gen2.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      parsePropertyValue(cxt, key, schema);
    }
    function parseDiscriminator(cxt) {
      const { gen: gen2, data: data4, schema } = cxt;
      const { discriminator, mapping: mapping2 } = schema;
      parseToken(cxt, "{");
      gen2.assign(data4, (0, codegen_1._)`{}`);
      const startPos = gen2.const("pos", names_1.default.jsonPos);
      const value = gen2.let("value");
      const tag = gen2.let("tag");
      tryParseItems(cxt, "}", () => {
        const key = gen2.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen2.if(
          (0, codegen_1._)`${key} === ${discriminator}`,
          () => {
            parseString({ ...cxt, data: tag });
            gen2.assign((0, codegen_1._)`${data4}[${key}]`, tag);
            gen2.break();
          },
          () => parseEmpty({ ...cxt, data: value })
          // can be discarded/skipped
        );
      });
      gen2.assign(names_1.default.jsonPos, startPos);
      gen2.if((0, codegen_1._)`${tag} === undefined`);
      parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
      for (const tagValue in mapping2) {
        gen2.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        parseSchemaProperties({ ...cxt, schema: mapping2[tagValue] }, discriminator);
      }
      gen2.else();
      parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
      gen2.endIf();
    }
    function parseProperties(cxt) {
      const { gen: gen2, data: data4 } = cxt;
      parseToken(cxt, "{");
      gen2.assign(data4, (0, codegen_1._)`{}`);
      parseSchemaProperties(cxt);
    }
    function parseSchemaProperties(cxt, discriminator) {
      const { gen: gen2, schema, data: data4 } = cxt;
      const { properties, optionalProperties, additionalProperties } = schema;
      parseItems(cxt, "}", () => {
        const key = gen2.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen2.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
          gen2.elseIf((0, codegen_1._)`${key} === ${discriminator}`);
          const tag = gen2.let("tag");
          parseString({ ...cxt, data: tag });
        }
        gen2.else();
        if (additionalProperties) {
          parseEmpty({ ...cxt, data: (0, codegen_1._)`${data4}[${key}]` });
        } else {
          parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
        }
        gen2.endIf();
      });
      if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen2);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._)`${hasProp}.call(${data4}, ${p})`));
        gen2.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
      }
    }
    function parseDefinedProperty(cxt, key, schemas = {}) {
      const { gen: gen2 } = cxt;
      for (const prop in schemas) {
        gen2.elseIf((0, codegen_1._)`${key} === ${prop}`);
        parsePropertyValue(cxt, key, schemas[prop]);
      }
    }
    function parsePropertyValue(cxt, key, schema) {
      parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
    }
    function parseType(cxt) {
      const { gen: gen2, schema, data: data4, self: self2 } = cxt;
      switch (schema.type) {
        case "boolean":
          parseBoolean(cxt);
          break;
        case "string":
          parseString(cxt);
          break;
        case "timestamp": {
          parseString(cxt);
          const vts = (0, util_1.useFunc)(gen2, timestamp_1.default);
          const { allowDate, parseDate } = self2.opts;
          const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data4}, true)` : (0, codegen_1._)`!${vts}(${data4})`;
          const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data4} = new Date(${data4}), false)`, (0, codegen_1._)`isNaN(${data4}.valueOf())`) : notValid;
          gen2.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
          break;
        }
        case "float32":
        case "float64":
          parseNumber(cxt);
          break;
        default: {
          const t = schema.type;
          if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
            parseNumber(cxt, 16);
            if (t === "uint32") {
              gen2.if((0, codegen_1._)`${data4} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
            }
          } else {
            const [min, max, maxDigits] = type_1.intRange[t];
            parseNumber(cxt, maxDigits);
            gen2.if((0, codegen_1._)`${data4} < ${min} || ${data4} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        }
      }
    }
    function parseString(cxt) {
      parseToken(cxt, '"');
      parseWith(cxt, parseJson_1.parseJsonString);
    }
    function parseEnum(cxt) {
      const { gen: gen2, data: data4, schema } = cxt;
      const enumSch = schema.enum;
      parseToken(cxt, '"');
      gen2.if(false);
      for (const value of enumSch) {
        const valueStr = JSON.stringify(value).slice(1);
        gen2.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
        gen2.assign(data4, (0, codegen_1.str)`${value}`);
        gen2.add(names_1.default.jsonPos, valueStr.length);
      }
      gen2.else();
      jsonSyntaxError(cxt);
      gen2.endIf();
    }
    function parseNumber(cxt, maxDigits) {
      const { gen: gen2 } = cxt;
      skipWhitespace(cxt);
      gen2.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
    }
    function parseBooleanToken(bool, fail) {
      return (cxt) => {
        const { gen: gen2, data: data4 } = cxt;
        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen2.assign(data4, bool));
      };
    }
    function parseRef(cxt) {
      const { gen: gen2, self: self2, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return parseCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      partialParse(cxt, getParser(gen2, sch), true);
    }
    function getParser(gen2, sch) {
      return sch.parse ? gen2.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen2.scopeValue("wrapper", { ref: sch })}.parse`;
    }
    function parseEmpty(cxt) {
      parseWith(cxt, parseJson_1.parseJson);
    }
    function parseWith(cxt, parseFunc, args) {
      partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
    }
    function partialParse(cxt, parseFunc, args) {
      const { gen: gen2, data: data4 } = cxt;
      gen2.assign(data4, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
      gen2.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
      gen2.if((0, codegen_1._)`${data4} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
    }
    function parseToken(cxt, tok) {
      tryParseToken(cxt, tok, jsonSyntaxError);
    }
    function tryParseToken(cxt, tok, fail, success) {
      const { gen: gen2 } = cxt;
      const n3 = tok.length;
      skipWhitespace(cxt);
      gen2.if((0, codegen_1._)`${jsonSlice(n3)} === ${tok}`, () => {
        gen2.add(names_1.default.jsonPos, n3);
        success === null || success === void 0 ? void 0 : success(cxt);
      }, () => fail(cxt));
    }
    function skipWhitespace({ gen: gen2, char: c2 }) {
      gen2.code((0, codegen_1._)`while((${c2}=${names_1.default.json}[${names_1.default.jsonPos}],${c2}===" "||${c2}==="\\n"||${c2}==="\\r"||${c2}==="\\t"))${names_1.default.jsonPos}++;`);
    }
    function jsonSlice(len) {
      return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
    }
    function jsonSyntaxError(cxt) {
      parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
    }
    function parsingError({ gen: gen2, parseName }, msg) {
      gen2.assign((0, codegen_1._)`${parseName}.message`, msg);
      gen2.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
      gen2.return(undef);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/jtd.js
var require_jtd2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/jtd.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var jtd_1 = require_jtd();
    var jtd_schema_1 = require_jtd_schema();
    var serialize_1 = require_serialize();
    var parse_1 = require_parse2();
    var META_SCHEMA_ID = "JTD-meta-schema";
    var Ajv = class extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          jtd: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        this.addVocabulary(jtd_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
      compileSerializer(schema) {
        const sch = this._addSchema(schema);
        return sch.serialize || this._compileSerializer(sch);
      }
      compileParser(schema) {
        const sch = this._addSchema(schema);
        return sch.parse || this._compileParser(sch);
      }
      _compileSerializer(sch) {
        serialize_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.serialize)
          throw new Error("ajv implementation error");
        return sch.serialize;
      }
      _compileParser(sch) {
        parse_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.parse)
          throw new Error("ajv implementation error");
        return sch.parse;
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// ../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js
var require_default_ajv_options = __commonJS({
  "../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js"(exports2, module2) {
    "use strict";
    var fastUri = require_fast_uri();
    module2.exports = Object.freeze({
      coerceTypes: "array",
      useDefaults: true,
      removeAdditional: true,
      uriResolver: fastUri,
      addUsedSchema: false,
      // Explicitly set allErrors to `false`.
      // When set to `true`, a DoS attack is possible.
      allErrors: false
    });
  }
});

// ../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/validator-compiler.js
var require_validator_compiler = __commonJS({
  "../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/validator-compiler.js"(exports2, module2) {
    "use strict";
    var Ajv = require_ajv().default;
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var ValidatorCompiler = class {
      constructor(externalSchemas, options) {
        if (options.mode === "JTD") {
          this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
        } else {
          this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
        }
        let addFormatPlugin = true;
        if (options.plugins && options.plugins.length > 0) {
          for (const plugin of options.plugins) {
            if (Array.isArray(plugin)) {
              addFormatPlugin = addFormatPlugin && plugin[0].name !== "formatsPlugin";
              plugin[0](this.ajv, plugin[1]);
            } else {
              addFormatPlugin = addFormatPlugin && plugin.name !== "formatsPlugin";
              plugin(this.ajv);
            }
          }
        }
        if (addFormatPlugin) {
          require_dist()(this.ajv);
        }
        options.onCreate?.(this.ajv);
        const sourceSchemas = Object.values(externalSchemas);
        for (const extSchema of sourceSchemas) {
          this.ajv.addSchema(extSchema);
        }
      }
      buildValidatorFunction({
        schema
        /*, method, url, httpPart */
      }) {
        if (schema.$id) {
          const stored = this.ajv.getSchema(schema.$id);
          if (stored) {
            return stored;
          }
        }
        return this.ajv.compile(schema);
      }
    };
    module2.exports = ValidatorCompiler;
  }
});

// ../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js
var require_serializer_compiler = __commonJS({
  "../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js"(exports2, module2) {
    "use strict";
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var SerializerCompiler = class {
      constructor(externalSchemas, options) {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
      }
      buildSerializerFunction({
        schema
        /*, method, url, httpStatus */
      }) {
        return this.ajv.compileSerializer(schema);
      }
    };
    module2.exports = SerializerCompiler;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/standalone/index.js
var require_standalone3 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/standalone/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var scope_1 = require_scope();
    var code_1 = require_code();
    function standaloneCode(ajv, refsOrFunc) {
      if (!ajv.opts.code.source) {
        throw new Error("moduleCode: ajv instance must have code.source option");
      }
      const { _n } = ajv.scope.opts;
      return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? void 0 : ajv.compile(sch.schema));
      function getValidate(id3) {
        const v = ajv.getSchema(id3);
        if (!v)
          throw new Error(`moduleCode: no schema with id ${id3}`);
        return v;
      }
      function funcExportCode(source) {
        const usedValues = {};
        const n3 = source === null || source === void 0 ? void 0 : source.validateName;
        const vCode = validateCode(usedValues, source);
        if (ajv.opts.code.esm) {
          return `"use strict";${_n}export const validate = ${n3};${_n}export default ${n3};${_n}${vCode}`;
        }
        return `"use strict";${_n}module.exports = ${n3};${_n}module.exports.default = ${n3};${_n}${vCode}`;
      }
      function multiExportsCode(schemas, getValidateFunc) {
        var _a;
        const usedValues = {};
        let code = (0, code_1._)`"use strict";`;
        for (const name in schemas) {
          const v = getValidateFunc(schemas[name]);
          if (v) {
            const vCode = validateCode(usedValues, v.source);
            const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
            code = (0, code_1._)`${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
          }
        }
        return `${code}`;
      }
      function validateCode(usedValues, s2) {
        if (!s2)
          throw new Error('moduleCode: function does not have "source" property');
        if (usedState(s2.validateName) === scope_1.UsedValueState.Completed)
          return code_1.nil;
        setUsedState(s2.validateName, scope_1.UsedValueState.Started);
        const scopeCode = ajv.scope.scopeCode(s2.scopeValues, usedValues, refValidateCode);
        const code = new code_1._Code(`${scopeCode}${_n}${s2.validateCode}`);
        return s2.evaluated ? (0, code_1._)`${code}${s2.validateName}.evaluated = ${s2.evaluated};${_n}` : code;
        function refValidateCode(n3) {
          var _a;
          const vRef = (_a = n3.value) === null || _a === void 0 ? void 0 : _a.ref;
          if (n3.prefix === "validate" && typeof vRef == "function") {
            const v = vRef;
            return validateCode(usedValues, v.source);
          } else if ((n3.prefix === "root" || n3.prefix === "wrapper") && typeof vRef == "object") {
            const { validate, validateName } = vRef;
            if (!validateName)
              throw new Error("ajv internal error");
            const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
            const wrapper = (0, code_1._)`${def} ${n3} = {validate: ${validateName}};`;
            if (usedState(validateName) === scope_1.UsedValueState.Started)
              return wrapper;
            const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
            return (0, code_1._)`${wrapper}${_n}${vCode}`;
          }
          return void 0;
        }
        function usedState(name) {
          var _a;
          return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
        }
        function setUsedState(name, state) {
          const { prefix } = name;
          const names2 = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          names2.set(name, state);
        }
      }
    }
    module2.exports = exports2 = standaloneCode;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = standaloneCode;
  }
});

// ../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/standalone.js
var require_standalone4 = __commonJS({
  "../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/standalone.js"(exports2, module2) {
    "use strict";
    var ValidatorSelector = require_ajv_compiler();
    var standaloneCode = require_standalone3().default;
    function StandaloneValidator(options = { readMode: true }) {
      if (options.readMode === true && !options.restoreFunction) {
        throw new Error("You must provide a restoreFunction options when readMode ON");
      }
      if (options.readMode !== true && !options.storeFunction) {
        throw new Error("You must provide a storeFunction options when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = ValidatorSelector();
      return function wrapper(externalSchemas, ajvOptions = {}) {
        if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
          ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
        }
        const compiler = factory(externalSchemas, ajvOptions);
        return function(opts) {
          const validationFunc = compiler(opts);
          const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
          options.storeFunction(opts, schemaValidationCode);
          return validationFunc;
        };
      };
    }
    module2.exports = StandaloneValidator;
  }
});

// ../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS({
  "../../node_modules/.pnpm/@fastify+ajv-compiler@4.0.1/node_modules/@fastify/ajv-compiler/index.js"(exports2, module2) {
    "use strict";
    var AjvReference = Symbol.for("fastify.ajv-compiler.reference");
    var ValidatorCompiler = require_validator_compiler();
    var SerializerCompiler = require_serializer_compiler();
    function AjvCompiler(opts) {
      const validatorPool = /* @__PURE__ */ new Map();
      const serializerPool = /* @__PURE__ */ new Map();
      if (opts && opts.jtdSerializer === true) {
        return function buildSerializerFromPool(externalSchemas, serializerOpts) {
          const uniqueAjvKey = getPoolKey({}, serializerOpts);
          if (serializerPool.has(uniqueAjvKey)) {
            return serializerPool.get(uniqueAjvKey);
          }
          const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
          const ret = compiler.buildSerializerFunction.bind(compiler);
          serializerPool.set(uniqueAjvKey, ret);
          return ret;
        };
      }
      return function buildCompilerFromPool(externalSchemas, options) {
        const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
        if (validatorPool.has(uniqueAjvKey)) {
          return validatorPool.get(uniqueAjvKey);
        }
        const compiler = new ValidatorCompiler(externalSchemas, options);
        const ret = compiler.buildValidatorFunction.bind(compiler);
        validatorPool.set(uniqueAjvKey, ret);
        if (options.customOptions.code !== void 0) {
          ret[AjvReference] = compiler;
        }
        return ret;
      };
    }
    function getPoolKey(externalSchemas, options) {
      const externals = JSON.stringify(externalSchemas);
      const ajvConfig = JSON.stringify(options);
      return `${externals}${ajvConfig}`;
    }
    module2.exports = AjvCompiler;
    module2.exports.default = AjvCompiler;
    module2.exports.AjvCompiler = AjvCompiler;
    module2.exports.AjvReference = AjvReference;
    module2.exports.StandaloneValidator = require_standalone4();
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/schema-controller.js"(exports2, module2) {
    "use strict";
    var { buildSchemas } = require_schemas();
    var SerializerSelector = require_fast_json_stringify_compiler();
    var ValidatorSelector = require_ajv_compiler();
    function buildSchemaController(parentSchemaCtrl, opts) {
      if (parentSchemaCtrl) {
        return new SchemaController(parentSchemaCtrl, opts);
      }
      const compilersFactory = Object.assign({
        buildValidator: null,
        buildSerializer: null
      }, opts?.compilersFactory);
      if (!compilersFactory.buildValidator) {
        compilersFactory.buildValidator = ValidatorSelector();
      }
      if (!compilersFactory.buildSerializer) {
        compilersFactory.buildSerializer = SerializerSelector();
      }
      const option = {
        bucket: opts && opts.bucket || buildSchemas,
        compilersFactory,
        isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
        isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
      };
      return new SchemaController(void 0, option);
    }
    var SchemaController = class {
      constructor(parent, options) {
        this.opts = options || parent?.opts;
        this.addedSchemas = false;
        this.compilersFactory = this.opts.compilersFactory;
        if (parent) {
          this.schemaBucket = this.opts.bucket(parent.getSchemas());
          this.validatorCompiler = parent.getValidatorCompiler();
          this.serializerCompiler = parent.getSerializerCompiler();
          this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
          this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
          this.parent = parent;
        } else {
          this.schemaBucket = this.opts.bucket();
          this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
          this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
        }
      }
      // Bucket interface
      add(schema) {
        this.addedSchemas = true;
        return this.schemaBucket.add(schema);
      }
      getSchema(schemaId) {
        return this.schemaBucket.getSchema(schemaId);
      }
      getSchemas() {
        return this.schemaBucket.getSchemas();
      }
      setValidatorCompiler(validatorCompiler) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildValidator: () => validatorCompiler }
        );
        this.validatorCompiler = validatorCompiler;
        this.isCustomValidatorCompiler = true;
      }
      setSerializerCompiler(serializerCompiler) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildSerializer: () => serializerCompiler }
        );
        this.serializerCompiler = serializerCompiler;
        this.isCustomSerializerCompiler = true;
      }
      getValidatorCompiler() {
        return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
      }
      getSerializerCompiler() {
        return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
      }
      getSerializerBuilder() {
        return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
      }
      getValidatorBuilder() {
        return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
      }
      /**
       * This method will be called when a validator must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupValidator(serverOptions) {
        const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
      }
      /**
       * This method will be called when a serializer must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupSerializer(serverOptions) {
        const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
      }
    };
    SchemaController.buildSchemaController = buildSchemaController;
    module2.exports = SchemaController;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a2, b3) => {
      const anum = numeric.test(a2);
      const bnum = numeric.test(b3);
      if (anum && bnum) {
        a2 = +a2;
        b3 = +b3;
      }
      return a2 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b3 ? -1 : 1;
    };
    var rcompareIdentifiers = (a2, b3) => compareIdentifiers(b3, a2);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version4, options) {
        options = parseOptions(options);
        if (version4 instanceof _SemVer) {
          if (version4.loose === !!options.loose && version4.includePrerelease === !!options.includePrerelease) {
            return version4;
          } else {
            version4 = version4.version;
          }
        } else if (typeof version4 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version4}".`);
        }
        if (version4.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version4, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version4.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version4}`);
        }
        this.raw = version4;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id3) => {
            if (/^[0-9]+$/.test(id3)) {
              const num = +id3;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id3;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a2 = this.prerelease[i];
          const b3 = other.prerelease[i];
          debug("prerelease compare", i, a2, b3);
          if (a2 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b3) {
            continue;
          } else {
            return compareIdentifiers(a2, b3);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a2 = this.build[i];
          const b3 = other.build[i];
          debug("build compare", i, a2, b3);
          if (a2 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b3) {
            continue;
          } else {
            return compareIdentifiers(a2, b3);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version4, options, throwErrors = false) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      try {
        return new SemVer(version4, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse3();
    var valid = (version4, options) => {
      const v = parse(version4, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse3();
    var clean = (version4, options) => {
      const s2 = parse(version4.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    };
    module2.exports = clean;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version4, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version4 instanceof SemVer ? version4.version : version4,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse3();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a2, loose) => new SemVer(a2, loose).major;
    module2.exports = major;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a2, loose) => new SemVer(a2, loose).minor;
    module2.exports = minor;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a2, loose) => new SemVer(a2, loose).patch;
    module2.exports = patch;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse3();
    var prerelease = (version4, options) => {
      const parsed = parse(version4, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a2, b3, loose) => new SemVer(a2, loose).compare(new SemVer(b3, loose));
    module2.exports = compare;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a2, b3, loose) => compare(b3, a2, loose);
    module2.exports = rcompare;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a2, b3) => compare(a2, b3, true);
    module2.exports = compareLoose;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a2, b3, loose) => {
      const versionA = new SemVer(a2, loose);
      const versionB = new SemVer(b3, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a2, b3) => compareBuild(a2, b3, loose));
    module2.exports = sort;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a2, b3) => compareBuild(b3, a2, loose));
    module2.exports = rsort;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt3 = (a2, b3, loose) => compare(a2, b3, loose) > 0;
    module2.exports = gt3;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt2 = (a2, b3, loose) => compare(a2, b3, loose) < 0;
    module2.exports = lt2;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq2 = (a2, b3, loose) => compare(a2, b3, loose) === 0;
    module2.exports = eq2;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq2 = (a2, b3, loose) => compare(a2, b3, loose) !== 0;
    module2.exports = neq2;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a2, b3, loose) => compare(a2, b3, loose) >= 0;
    module2.exports = gte;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a2, b3, loose) => compare(a2, b3, loose) <= 0;
    module2.exports = lte;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq2 = require_eq();
    var neq2 = require_neq();
    var gt3 = require_gt();
    var gte = require_gte();
    var lt2 = require_lt();
    var lte = require_lte();
    var cmp = (a2, op, b3, loose) => {
      switch (op) {
        case "===":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a2 === b3;
        case "!==":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a2 !== b3;
        case "":
        case "=":
        case "==":
          return eq2(a2, b3, loose);
        case "!=":
          return neq2(a2, b3, loose);
        case ">":
          return gt3(a2, b3, loose);
        case ">=":
          return gte(a2, b3, loose);
        case "<":
          return lt2(a2, b3, loose);
        case "<=":
          return lte(a2, b3, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse3();
    var { safeRe: re, t } = require_re();
    var coerce2 = (version4, options) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 === "number") {
        version4 = String(version4);
      }
      if (typeof version4 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version4.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version4)) && (!match || match.index + match[0].length !== version4.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce2;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version4) {
        if (!version4) {
          return false;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version4, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c2) => c2.value === "<0.0.0-0";
    var isAny = (c2) => c2.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id3) => !id3 || id3.toLowerCase() === "x" || id3 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r2 = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r2, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r2 = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r2 = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r2, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version4, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version4)) {
          return false;
        }
      }
      if (version4.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version4.major && allowed.minor === version4.minor && allowed.patch === version4.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r2);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version4) {
        debug("Comparator.test", version4, this.options.loose);
        if (this.semver === ANY || version4 === ANY) {
          return true;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version4, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version4, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version4);
    };
    module2.exports = satisfies;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt3 = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt3(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt3(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt3 = require_gt();
    var lt2 = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version4, range, hilo, options) => {
      version4 = new SemVer(version4, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt3;
          ltefn = lte;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte;
          ltfn = gt3;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version4, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version4, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version4, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version4, range, options) => outside(version4, range, ">", options);
    module2.exports = gtr;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version4, range, options) => outside(version4, range, "<", options);
    module2.exports = ltr;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a2, b3) => compare(a2, b3, options));
      for (const version4 of v) {
        const included = satisfies(version4, range, options);
        if (included) {
          prev = version4;
          if (!first) {
            first = version4;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub2, dom, options = {}) => {
      if (sub2 === dom) {
        return true;
      }
      sub2 = new Range(sub2, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub2.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub2, dom, options) => {
      if (sub2 === dom) {
        return true;
      }
      if (sub2.length === 1 && sub2[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub2 = minimumVersionWithPreRelease;
        } else {
          sub2 = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt3, lt2;
      for (const c2 of sub2) {
        if (c2.operator === ">" || c2.operator === ">=") {
          gt3 = higherGT(gt3, c2, options);
        } else if (c2.operator === "<" || c2.operator === "<=") {
          lt2 = lowerLT(lt2, c2, options);
        } else {
          eqSet.add(c2.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt3 && lt2) {
        gtltComp = compare(gt3.semver, lt2.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt3.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt3 && !satisfies(eq2, String(gt3), options)) {
          return null;
        }
        if (lt2 && !satisfies(eq2, String(lt2), options)) {
          return null;
        }
        for (const c2 of dom) {
          if (!satisfies(eq2, String(c2), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt3 && !options.includePrerelease && gt3.semver.prerelease.length ? gt3.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c2 of dom) {
        hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
        hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
        if (gt3) {
          if (needDomGTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c2.operator === ">" || c2.operator === ">=") {
            higher = higherGT(gt3, c2, options);
            if (higher === c2 && higher !== gt3) {
              return false;
            }
          } else if (gt3.operator === ">=" && !satisfies(gt3.semver, String(c2), options)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c2.operator === "<" || c2.operator === "<=") {
            lower = lowerLT(lt2, c2, options);
            if (lower === c2 && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c2), options)) {
            return false;
          }
        }
        if (!c2.operator && (lt2 || gt3) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt3 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt3 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a2, b3, options) => {
      if (!a2) {
        return b3;
      }
      const comp = compare(a2.semver, b3.semver, options);
      return comp > 0 ? a2 : comp < 0 ? b3 : b3.operator === ">" && a2.operator === ">=" ? b3 : a2;
    };
    var lowerLT = (a2, b3, options) => {
      if (!a2) {
        return b3;
      }
      const comp = compare(a2.semver, b3.semver, options);
      return comp < 0 ? a2 : comp > 0 ? b3 : b3.operator === "<" && a2.operator === "<=" ? b3 : a2;
    };
    module2.exports = subset;
  }
});

// ../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.6.3/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse3();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt3 = require_gt();
    var lt2 = require_lt();
    var eq2 = require_eq();
    var neq2 = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt3,
      lt: lt2,
      eq: eq2,
      neq: neq2,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/pluginUtils.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    var assert4 = require("node:assert");
    var kRegisteredPlugins = Symbol.for("registered-plugin");
    var {
      kTestInternals
    } = require_symbols2();
    var { exist, existReply, existRequest } = require_decorate();
    var {
      FST_ERR_PLUGIN_VERSION_MISMATCH,
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
    } = require_errors2();
    function getMeta(fn) {
      return fn[Symbol.for("plugin-meta")];
    }
    function getPluginName(func) {
      const display = getDisplayName(func);
      if (display) {
        return display;
      }
      const cache = require.cache;
      if (cache) {
        const keys = Object.keys(cache);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (cache[key].exports === func) {
            return key;
          }
        }
      }
      if (func.name) {
        return func.name;
      }
      return null;
    }
    function getFuncPreview(func) {
      return func.toString().split("\n", 2).map((s2) => s2.trim()).join(" -- ");
    }
    function getDisplayName(fn) {
      return fn[Symbol.for("fastify.display-name")];
    }
    function shouldSkipOverride(fn) {
      return !!fn[Symbol.for("skip-override")];
    }
    function checkDependencies(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const dependencies = meta.dependencies;
      if (!dependencies) return;
      assert4(Array.isArray(dependencies), "The dependencies should be an array of strings");
      dependencies.forEach((dependency) => {
        assert4(
          this[kRegisteredPlugins].indexOf(dependency) > -1,
          `The dependency '${dependency}' of plugin '${meta.name}' is not registered`
        );
      });
    }
    function checkDecorators(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const { decorators, name } = meta;
      if (!decorators) return;
      if (decorators.fastify) _checkDecorators(this, "Fastify", decorators.fastify, name);
      if (decorators.reply) _checkDecorators(this, "Reply", decorators.reply, name);
      if (decorators.request) _checkDecorators(this, "Request", decorators.request, name);
    }
    var checks = {
      Fastify: exist,
      Request: existRequest,
      Reply: existReply
    };
    function _checkDecorators(that, instance, decorators, name) {
      assert4(Array.isArray(decorators), "The decorators should be an array of strings");
      decorators.forEach((decorator) => {
        const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
        if (!checks[instance].call(that, decorator)) {
          throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
        }
      });
    }
    function checkVersion(fn) {
      const meta = getMeta(fn);
      if (meta == null || meta?.fastify == null) return;
      const requiredVersion = meta.fastify;
      const fastifyRc = /-(?:rc|pre|alpha).+$/.test(this.version);
      if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
        return;
      }
      if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
        throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version);
      }
    }
    function registerPluginName(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const name = meta.name;
      if (!name) return;
      this[kRegisteredPlugins].push(name);
      return name;
    }
    function checkPluginHealthiness(fn, pluginName) {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
        throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
      }
    }
    function registerPlugin(fn) {
      const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
      checkPluginHealthiness.call(this, fn, pluginName);
      checkVersion.call(this, fn);
      checkDecorators.call(this, fn);
      checkDependencies.call(this, fn);
      return shouldSkipOverride(fn);
    }
    module2.exports = {
      getPluginName,
      getFuncPreview,
      kRegisteredPlugins,
      getDisplayName,
      registerPlugin
    };
    module2.exports[kTestInternals] = {
      shouldSkipOverride,
      getMeta,
      checkDecorators,
      checkDependencies
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/reqIdGenFactory.js"(exports2, module2) {
    "use strict";
    function reqIdGenFactory(requestIdHeader, optGenReqId) {
      const genReqId = optGenReqId || buildDefaultGenReqId();
      if (requestIdHeader) {
        return buildOptionalHeaderReqId(requestIdHeader, genReqId);
      }
      return genReqId;
    }
    function getGenReqId(contextServer, req) {
      return contextServer.genReqId(req);
    }
    function buildDefaultGenReqId() {
      const maxInt = 2147483647;
      let nextReqId = 0;
      return function defaultGenReqId() {
        nextReqId = nextReqId + 1 & maxInt;
        return `req-${nextReqId.toString(36)}`;
      };
    }
    function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
      return function(req) {
        return req.headers[requestIdHeader] || genReqId(req);
      };
    }
    module2.exports = {
      getGenReqId,
      reqIdGenFactory
    };
  }
});

// ../../node_modules/.pnpm/fast-decode-uri-component@1.0.1/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "../../node_modules/.pnpm/fast-decode-uri-component@1.0.1/node_modules/fast-decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      var percentPosition = uri.indexOf("%");
      if (percentPosition === -1) return uri;
      var length = uri.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
            55232 + (codepoint >> 10),
            56320 + (codepoint & 1023)
          );
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c2, shift) {
      var i = HEX[c2];
      return i === void 0 ? 255 : i << shift;
    }
    module2.exports = decodeURIComponent2;
  }
});

// ../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/parse.js
var require_parse4 = __commonJS({
  "../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/parse.js"(exports2, module2) {
    "use strict";
    var fastDecode = require_fast_decode_uri_component();
    var plusRegex = /\+/g;
    var Empty3 = function() {
    };
    Empty3.prototype = /* @__PURE__ */ Object.create(null);
    function parse(input) {
      const result = new Empty3();
      if (typeof input !== "string") {
        return result;
      }
      let inputLength = input.length;
      let key = "";
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let hasBothKeyValuePair = false;
      let c2 = 0;
      for (let i = 0; i < inputLength + 1; i++) {
        c2 = i !== inputLength ? input.charCodeAt(i) : 38;
        if (c2 === 38) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i;
          }
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (keyHasPlus) {
              key = key.replace(plusRegex, " ");
            }
            if (shouldDecodeKey) {
              key = fastDecode(key) || key;
            }
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus) {
                value = value.replace(plusRegex, " ");
              }
              if (shouldDecodeValue) {
                value = fastDecode(value) || value;
              }
            }
            const currentValue = result[key];
            if (currentValue === void 0) {
              result[key] = value;
            } else {
              if (currentValue.pop) {
                currentValue.push(value);
              } else {
                result[key] = [currentValue, value];
              }
            }
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
        } else if (c2 === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c2 === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c2 === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
      }
      return result;
    }
    module2.exports = parse;
  }
});

// ../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS({
  "../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/internals/querystring.js"(exports2, module2) {
    var hexTable = Array.from(
      { length: 256 },
      (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
    );
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 112 - 127
    ]);
    function encodeString(str) {
      const len = str.length;
      if (len === 0) return "";
      let out = "";
      let lastPos = 0;
      let i = 0;
      outer: for (; i < len; i++) {
        let c2 = str.charCodeAt(i);
        while (c2 < 128) {
          if (noEscape[c2] !== 1) {
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c2];
          }
          if (++i === len) break outer;
          c2 = str.charCodeAt(i);
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c2 < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c22 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c2 = 65536 + ((c2 & 1023) << 10 | c22);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      if (lastPos === 0) return str;
      if (lastPos < len) return out + str.slice(lastPos);
      return out;
    }
    module2.exports = { encodeString };
  }
});

// ../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/stringify.js"(exports2, module2) {
    "use strict";
    var { encodeString } = require_querystring();
    function getAsPrimitive(value) {
      const type = typeof value;
      if (type === "string") {
        return encodeString(value);
      } else if (type === "bigint") {
        return value.toString();
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "number" && Number.isFinite(value)) {
        return value < 1e21 ? "" + value : encodeString("" + value);
      }
      return "";
    }
    function stringify5(input) {
      let result = "";
      if (input === null || typeof input !== "object") {
        return result;
      }
      const separator = "&";
      const keys = Object.keys(input);
      const keyLength = keys.length;
      let valueLength = 0;
      for (let i = 0; i < keyLength; i++) {
        const key = keys[i];
        const value = input[key];
        const encodedKey = encodeString(key) + "=";
        if (i) {
          result += separator;
        }
        if (Array.isArray(value)) {
          valueLength = value.length;
          for (let j = 0; j < valueLength; j++) {
            if (j) {
              result += separator;
            }
            result += encodedKey;
            result += getAsPrimitive(value[j]);
          }
        } else {
          result += encodedKey;
          result += getAsPrimitive(value);
        }
      }
      return result;
    }
    module2.exports = stringify5;
  }
});

// ../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/fast-querystring@1.1.2/node_modules/fast-querystring/lib/index.js"(exports2, module2) {
    "use strict";
    var parse = require_parse4();
    var stringify5 = require_stringify();
    var fastQuerystring = {
      parse,
      stringify: stringify5
    };
    module2.exports = fastQuerystring;
    module2.exports.default = fastQuerystring;
    module2.exports.parse = parse;
    module2.exports.stringify = stringify5;
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/tokens.js
var require_tokens = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/types.js
var require_types3 = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var types;
    (function(types2) {
      types2[types2["ROOT"] = 0] = "ROOT";
      types2[types2["GROUP"] = 1] = "GROUP";
      types2[types2["POSITION"] = 2] = "POSITION";
      types2[types2["SET"] = 3] = "SET";
      types2[types2["RANGE"] = 4] = "RANGE";
      types2[types2["REPETITION"] = 5] = "REPETITION";
      types2[types2["REFERENCE"] = 6] = "REFERENCE";
      types2[types2["CHAR"] = 7] = "CHAR";
    })(types = exports2.types || (exports2.types = {}));
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/set-lookup.js
var require_set_lookup = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/set-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/index.js
var require_types4 = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/types/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_tokens(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_set_lookup(), exports2);
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets.js
var require_sets = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anyChar = exports2.notWhitespace = exports2.whitespace = exports2.notInts = exports2.ints = exports2.notWords = exports2.words = void 0;
    var types_1 = require_types4();
    var INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
    var WORDS = () => [
      { type: types_1.types.CHAR, value: 95 },
      { type: types_1.types.RANGE, from: 97, to: 122 },
      { type: types_1.types.RANGE, from: 65, to: 90 },
      { type: types_1.types.RANGE, from: 48, to: 57 }
    ];
    var WHITESPACE = () => [
      { type: types_1.types.CHAR, value: 9 },
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 11 },
      { type: types_1.types.CHAR, value: 12 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 32 },
      { type: types_1.types.CHAR, value: 160 },
      { type: types_1.types.CHAR, value: 5760 },
      { type: types_1.types.RANGE, from: 8192, to: 8202 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 },
      { type: types_1.types.CHAR, value: 8239 },
      { type: types_1.types.CHAR, value: 8287 },
      { type: types_1.types.CHAR, value: 12288 },
      { type: types_1.types.CHAR, value: 65279 }
    ];
    var NOTANYCHAR = () => [
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 }
    ];
    exports2.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
    exports2.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
    exports2.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
    exports2.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
    exports2.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
    exports2.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
    exports2.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenizeClass = exports2.strToChars = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    exports2.strToChars = (str) => {
      const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return str.replace(charsRegex, (s2, b3, lbs, a16, b16, dctrl, eslsh) => {
        if (lbs) {
          return s2;
        }
        let code = b3 ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
          0: 0,
          t: 9,
          n: 10,
          v: 11,
          f: 12,
          r: 13
        }[eslsh];
        let c2 = String.fromCharCode(code);
        return /[[\]{}^$.|?*+()]/.test(c2) ? `\\${c2}` : c2;
      });
    };
    exports2.tokenizeClass = (str, regexpStr) => {
      var _a, _b, _c, _d, _e, _f, _g;
      let tokens = [], rs, c2;
      const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
      while ((rs = regexp.exec(str)) !== null) {
        const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a = rs[1] && sets.words()) !== null && _a !== void 0 ? _a : rs[2] && sets.ints()) !== null && _b !== void 0 ? _b : rs[3] && sets.whitespace()) !== null && _c !== void 0 ? _c : rs[4] && sets.notWords()) !== null && _d !== void 0 ? _d : rs[5] && sets.notInts()) !== null && _e !== void 0 ? _e : rs[6] && sets.notWhitespace()) !== null && _f !== void 0 ? _f : rs[7] && {
          type: types_1.types.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
          to: (c2 = rs[10]).charCodeAt(c2.length - 1)
        }) !== null && _g !== void 0 ? _g : (c2 = rs[16]) && { type: types_1.types.CHAR, value: c2.charCodeAt(0) };
        if (p) {
          tokens.push(p);
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
    };
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/tokenizer.js
var require_tokenizer = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/tokenizer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenizer = void 0;
    var util2 = __importStar(require_util2());
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var captureGroupFirstChar = /^[a-zA-Z_$]$/i;
    var captureGroupChars = /^[a-zA-Z0-9_$]$/i;
    var digit = /\d/;
    exports2.tokenizer = (regexpStr) => {
      let i = 0, c2;
      let start2 = { type: types_1.types.ROOT, stack: [] };
      let lastGroup = start2;
      let last = start2.stack;
      let groupStack = [];
      let referenceQueue = [];
      let groupCount = 0;
      const repeatErr = (col) => {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
      };
      let str = util2.strToChars(regexpStr);
      while (i < str.length) {
        switch (c2 = str[i++]) {
          // Handle escaped characters, inclues a few sets.
          case "\\":
            if (i === str.length) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
            }
            switch (c2 = str[i++]) {
              case "b":
                last.push({ type: types_1.types.POSITION, value: "b" });
                break;
              case "B":
                last.push({ type: types_1.types.POSITION, value: "B" });
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (digit.test(c2)) {
                  let digits = c2;
                  while (i < str.length && digit.test(str[i])) {
                    digits += str[i++];
                  }
                  let value = parseInt(digits, 10);
                  const reference = { type: types_1.types.REFERENCE, value };
                  last.push(reference);
                  referenceQueue.push({ reference, stack: last, index: last.length - 1 });
                } else {
                  last.push({ type: types_1.types.CHAR, value: c2.charCodeAt(0) });
                }
            }
            break;
          // Positionals.
          case "^":
            last.push({ type: types_1.types.POSITION, value: "^" });
            break;
          case "$":
            last.push({ type: types_1.types.POSITION, value: "$" });
            break;
          // Handle custom sets.
          case "[": {
            let not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            let classTokens = util2.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types_1.types.SET,
              set: classTokens[0],
              not
            });
            break;
          }
          // Class of any character except \n.
          case ".":
            last.push(sets.anyChar());
            break;
          // Push group onto stack.
          case "(": {
            let group = {
              type: types_1.types.GROUP,
              stack: [],
              remember: true
            };
            if (str[i] === "?") {
              c2 = str[i + 1];
              i += 2;
              if (c2 === "=") {
                group.followedBy = true;
                group.remember = false;
              } else if (c2 === "!") {
                group.notFollowedBy = true;
                group.remember = false;
              } else if (c2 === "<") {
                let name = "";
                if (captureGroupFirstChar.test(str[i])) {
                  name += str[i];
                  i++;
                } else {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                while (i < str.length && captureGroupChars.test(str[i])) {
                  name += str[i];
                  i++;
                }
                if (!name) {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                if (str[i] !== ">") {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found '${str[i]}' at column ${i + 1}`);
                }
                group.name = name;
                i++;
              } else if (c2 === ":") {
                group.remember = false;
              } else {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c2}' after '?' at column ${i - 1}`);
              }
            } else {
              groupCount += 1;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          }
          // Pop group out of stack.
          case ")":
            if (groupStack.length === 0) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          // Use pipe character to give more choices.
          case "|": {
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            let stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          }
          // Repetition.
          // For every repetition, remove last element from last stack
          // then insert back a RANGE object.
          // This design is chosen because there could be more than
          // one repetition symbols in a regex i.e. `a?+{2,3}`.
          case "{": {
            let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types_1.types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types_1.types.CHAR,
                value: 123
              });
            }
            break;
          }
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          // Default is a character that is not `\[](){}?+*^$`.
          default:
            last.push({
              type: types_1.types.CHAR,
              value: c2.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
      }
      updateReferences(referenceQueue, groupCount);
      return start2;
    };
    function updateReferences(referenceQueue, groupCount) {
      for (const elem of referenceQueue.reverse()) {
        if (groupCount < elem.reference.value) {
          elem.reference.type = types_1.types.CHAR;
          const valueString = elem.reference.value.toString();
          elem.reference.value = parseInt(valueString, 8);
          if (!/^[0-7]+$/.test(valueString)) {
            let i = 0;
            while (valueString[i] !== "8" && valueString[i] !== "9") {
              i += 1;
            }
            if (i === 0) {
              elem.reference.value = valueString.charCodeAt(0);
              i += 1;
            } else {
              elem.reference.value = parseInt(valueString.slice(0, i), 8);
            }
            if (valueString.length > i) {
              const tail = elem.stack.splice(elem.index + 1);
              for (const char of valueString.slice(i)) {
                elem.stack.push({
                  type: types_1.types.CHAR,
                  value: char.charCodeAt(0)
                });
              }
              elem.stack.push(...tail);
            }
          }
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets-lookup.js
var require_sets_lookup = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/sets-lookup.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOTANYCHAR = exports2.WHITESPACE = exports2.WORDS = exports2.INTS = void 0;
    var Sets = __importStar(require_sets());
    var types_1 = require_types4();
    function setToLookup(tokens) {
      let lookup = {};
      let len = 0;
      for (const token of tokens) {
        if (token.type === types_1.types.CHAR) {
          lookup[token.value] = true;
        }
        if (token.type === types_1.types.RANGE) {
          lookup[`${token.from}-${token.to}`] = true;
        }
        len += 1;
      }
      return {
        lookup: () => Object.assign({}, lookup),
        len
      };
    }
    exports2.INTS = setToLookup(Sets.ints().set);
    exports2.WORDS = setToLookup(Sets.words().set);
    exports2.WHITESPACE = setToLookup(Sets.whitespace().set);
    exports2.NOTANYCHAR = setToLookup(Sets.anyChar().set);
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/write-set-tokens.js
var require_write_set_tokens = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/write-set-tokens.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeSetTokens = exports2.setChar = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets_lookup());
    function setChar(charCode) {
      return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
    }
    exports2.setChar = setChar;
    function isSameSet(set, { lookup, len }) {
      if (len !== set.length) {
        return false;
      }
      const map = lookup();
      for (const elem of set) {
        if (elem.type === types_1.types.SET) {
          return false;
        }
        const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
        if (map[key]) {
          map[key] = false;
        } else {
          return false;
        }
      }
      return true;
    }
    function writeSetTokens(set, isNested = false) {
      if (isSameSet(set.set, sets.INTS)) {
        return set.not ? "\\D" : "\\d";
      }
      if (isSameSet(set.set, sets.WORDS)) {
        return set.not ? "\\W" : "\\w";
      }
      if (set.not && isSameSet(set.set, sets.NOTANYCHAR)) {
        return ".";
      }
      if (isSameSet(set.set, sets.WHITESPACE)) {
        return set.not ? "\\S" : "\\s";
      }
      let tokenString = "";
      for (let i = 0; i < set.set.length; i++) {
        const subset = set.set[i];
        tokenString += writeSetToken(subset);
      }
      const contents = `${set.not ? "^" : ""}${tokenString}`;
      return isNested ? contents : `[${contents}]`;
    }
    exports2.writeSetTokens = writeSetTokens;
    function writeSetToken(set) {
      if (set.type === types_1.types.CHAR) {
        return setChar(set.value);
      } else if (set.type === types_1.types.RANGE) {
        return `${setChar(set.from)}-${setChar(set.to)}`;
      }
      return writeSetTokens(set, true);
    }
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/reconstruct.js
var require_reconstruct = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/reconstruct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconstruct = void 0;
    var types_1 = require_types4();
    var write_set_tokens_1 = require_write_set_tokens();
    var reduceStack = (stack) => stack.map(exports2.reconstruct).join("");
    var createAlternate = (token) => {
      if ("options" in token) {
        return token.options.map(reduceStack).join("|");
      } else if ("stack" in token) {
        return reduceStack(token.stack);
      } else {
        throw new Error(`options or stack must be Root or Group token`);
      }
    };
    exports2.reconstruct = (token) => {
      switch (token.type) {
        case types_1.types.ROOT:
          return createAlternate(token);
        case types_1.types.CHAR: {
          const c2 = String.fromCharCode(token.value);
          return (/[[\\{}$^.|?*+()]/.test(c2) ? "\\" : "") + c2;
        }
        case types_1.types.POSITION:
          if (token.value === "^" || token.value === "$") {
            return token.value;
          } else {
            return `\\${token.value}`;
          }
        case types_1.types.REFERENCE:
          return `\\${token.value}`;
        case types_1.types.SET:
          return write_set_tokens_1.writeSetTokens(token);
        case types_1.types.GROUP: {
          const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
          return `(${prefix}${createAlternate(token)})`;
        }
        case types_1.types.REPETITION: {
          const { min, max } = token;
          let endWith;
          if (min === 0 && max === 1) {
            endWith = "?";
          } else if (min === 1 && max === Infinity) {
            endWith = "+";
          } else if (min === 0 && max === Infinity) {
            endWith = "*";
          } else if (max === Infinity) {
            endWith = `{${min},}`;
          } else if (min === max) {
            endWith = `{${min}}`;
          } else {
            endWith = `{${min},${max}}`;
          }
          return `${exports2.reconstruct(token.value)}${endWith}`;
        }
        case types_1.types.RANGE:
          return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
        default:
          throw new Error(`Invalid token type ${token}`);
      }
    };
  }
});

// ../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/ret@0.5.0/node_modules/ret/dist/index.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var types_1 = require_types4();
    Object.defineProperty(exports2, "types", { enumerable: true, get: function() {
      return types_1.types;
    } });
    __exportStar(require_tokenizer(), exports2);
    __exportStar(require_reconstruct(), exports2);
    var tokenizer_1 = require_tokenizer();
    var reconstruct_1 = require_reconstruct();
    __exportStar(require_types4(), exports2);
    exports2.default = tokenizer_1.tokenizer;
    module2.exports = tokenizer_1.tokenizer;
    module2.exports.types = types_1.types;
    module2.exports.reconstruct = reconstruct_1.reconstruct;
  }
});

// ../../node_modules/.pnpm/safe-regex2@4.0.0/node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS({
  "../../node_modules/.pnpm/safe-regex2@4.0.0/node_modules/safe-regex2/index.js"(exports2, module2) {
    "use strict";
    var parse = require_dist2();
    var types = parse.types;
    function safeRegex(re, opts) {
      if (!opts) opts = {};
      const replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re)) re = re.source;
      else if (typeof re !== "string") re = String(re);
      try {
        re = parse(re);
      } catch (err) {
        return false;
      }
      let reps = 0;
      return function walk(node, starHeight) {
        let i;
        let ok;
        let len;
        if (node.type === types.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1) return false;
          if (reps > replimit) return false;
        }
        if (node.options) {
          for (i = 0, len = node.options.length; i < len; i++) {
            ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok) return false;
          }
        }
        const stack = node.stack || node.value && node.value.stack;
        if (!stack) return true;
        for (i = 0; i < stack.length; i++) {
          ok = walk(stack[i], starHeight);
          if (!ok) return false;
        }
        return true;
      }(re, 0);
    }
    function isRegExp(x) {
      return {}.toString.call(x) === "[object RegExp]";
    }
    module2.exports = safeRegex;
    module2.exports.default = safeRegex;
    module2.exports.safeRegex = safeRegex;
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/http-method.js
var require_http_method = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/http-method.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      name: "__fmw_internal_strategy_merged_tree_http_method__",
      storage: function() {
        const handlers = {};
        return {
          get: (type) => {
            return handlers[type] || null;
          },
          set: (type, store) => {
            handlers[type] = store;
          }
        };
      },
      /* c8 ignore next 1 */
      deriveConstraint: (req) => req.method,
      mustMatchWhenDerived: true
    };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/pretty-print.js"(exports2, module2) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var httpMethodStrategy = require_http_method();
    var treeDataSymbol = Symbol("treeData");
    function printObjectTree(obj, parentPrefix = "") {
      let tree = "";
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        const isLast = i === keys.length - 1;
        const nodePrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
        const childPrefix = isLast ? "    " : "\u2502   ";
        const nodeData = value[treeDataSymbol] || "";
        const prefixedNodeData = nodeData.split("\n").join("\n" + parentPrefix + childPrefix);
        tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
        tree += printObjectTree(value, parentPrefix + childPrefix);
      }
      return tree;
    }
    function parseFunctionName(fn) {
      let fName = fn.name || "";
      fName = fName.replace("bound", "").trim();
      fName = (fName || "anonymous") + "()";
      return fName;
    }
    function parseMeta(meta) {
      if (Array.isArray(meta)) return meta.map((m) => parseMeta(m));
      if (typeof meta === "symbol") return meta.toString();
      if (typeof meta === "function") return parseFunctionName(meta);
      return meta;
    }
    function getRouteMetaData(route, options) {
      if (!options.includeMeta) return {};
      const metaDataObject = options.buildPrettyMeta(route);
      const filteredMetaData = {};
      let includeMetaKeys = options.includeMeta;
      if (!Array.isArray(includeMetaKeys)) {
        includeMetaKeys = Reflect.ownKeys(metaDataObject);
      }
      for (const metaKey of includeMetaKeys) {
        if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue;
        const serializedKey = metaKey.toString();
        const metaValue = metaDataObject[metaKey];
        if (metaValue !== void 0 && metaValue !== null) {
          const serializedValue = JSON.stringify(parseMeta(metaValue));
          filteredMetaData[serializedKey] = serializedValue;
        }
      }
      return filteredMetaData;
    }
    function serializeMetaData(metaData) {
      let serializedMetaData = "";
      for (const [key, value] of Object.entries(metaData)) {
        serializedMetaData += `
\u2022 (${key}) ${value}`;
      }
      return serializedMetaData;
    }
    function normalizeRoute(route) {
      const constraints = { ...route.opts.constraints };
      const method = constraints[httpMethodStrategy.name];
      delete constraints[httpMethodStrategy.name];
      return { ...route, method, opts: { constraints } };
    }
    function serializeRoute(route) {
      let serializedRoute = ` (${route.method})`;
      const constraints = route.opts.constraints || {};
      if (Object.keys(constraints).length !== 0) {
        serializedRoute += " " + JSON.stringify(constraints);
      }
      serializedRoute += serializeMetaData(route.metaData);
      return serializedRoute;
    }
    function mergeSimilarRoutes(routes) {
      return routes.reduce((mergedRoutes, route) => {
        for (const nodeRoute of mergedRoutes) {
          if (deepEqual(route.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route.metaData, nodeRoute.metaData)) {
            nodeRoute.method += ", " + route.method;
            return mergedRoutes;
          }
        }
        mergedRoutes.push(route);
        return mergedRoutes;
      }, []);
    }
    function serializeNode(node, prefix, options) {
      let routes = node.routes;
      if (options.method === void 0) {
        routes = routes.map(normalizeRoute);
      }
      routes = routes.map((route) => {
        route.metaData = getRouteMetaData(route, options);
        return route;
      });
      if (options.method === void 0) {
        routes = mergeSimilarRoutes(routes);
      }
      return routes.map(serializeRoute).join(`
${prefix}`);
    }
    function buildObjectTree(node, tree, prefix, options) {
      if (node.isLeafNode || options.commonPrefix !== false) {
        prefix = prefix || "(empty root node)";
        tree = tree[prefix] = {};
        if (node.isLeafNode) {
          tree[treeDataSymbol] = serializeNode(node, prefix, options);
        }
        prefix = "";
      }
      if (node.staticChildren) {
        for (const child of Object.values(node.staticChildren)) {
          buildObjectTree(child, tree, prefix + child.prefix, options);
        }
      }
      if (node.parametricChildren) {
        for (const child of Object.values(node.parametricChildren)) {
          const childPrefix = Array.from(child.nodePaths).join("|");
          buildObjectTree(child, tree, prefix + childPrefix, options);
        }
      }
      if (node.wildcardChild) {
        buildObjectTree(node.wildcardChild, tree, "*", options);
      }
    }
    function prettyPrintTree(root, options) {
      const objectTree = {};
      buildObjectTree(root, objectTree, root.prefix, options);
      return printObjectTree(objectTree);
    }
    module2.exports = { prettyPrintTree };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/null-object.js
var require_null_object = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/null-object.js"(exports2, module2) {
    "use strict";
    var NullObject = function() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    module2.exports = {
      NullObject
    };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/handler-storage.js
var require_handler_storage = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/handler-storage.js"(exports2, module2) {
    "use strict";
    var { NullObject } = require_null_object();
    var httpMethodStrategy = require_http_method();
    var HandlerStorage = class {
      constructor() {
        this.unconstrainedHandler = null;
        this.constraints = [];
        this.handlers = [];
        this.constrainedHandlerStores = null;
      }
      // This is the hot path for node handler finding -- change with care!
      getMatchingHandler(derivedConstraints) {
        if (derivedConstraints === void 0) {
          return this.unconstrainedHandler;
        }
        return this._getHandlerMatchingConstraints(derivedConstraints);
      }
      addHandler(constrainer, route) {
        const params = route.params;
        const constraints = route.opts.constraints || {};
        const handlerObject = {
          params,
          constraints,
          handler: route.handler,
          store: route.store || null,
          _createParamsObject: this._compileCreateParamsObject(params)
        };
        const constraintsNames = Object.keys(constraints);
        if (constraintsNames.length === 0) {
          this.unconstrainedHandler = handlerObject;
        }
        for (const constraint of constraintsNames) {
          if (!this.constraints.includes(constraint)) {
            if (constraint === "version") {
              this.constraints.unshift(constraint);
            } else {
              this.constraints.push(constraint);
            }
          }
        }
        const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
        if (!isMergedTree && this.handlers.length >= 31) {
          throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
        }
        this.handlers.push(handlerObject);
        this.handlers.sort((a2, b3) => Object.keys(a2.constraints).length - Object.keys(b3.constraints).length);
        if (!isMergedTree) {
          this._compileGetHandlerMatchingConstraints(constrainer, constraints);
        }
      }
      _compileCreateParamsObject(params) {
        const fnBody = [];
        fnBody.push("const fn = function _createParamsObject (paramsArray) {");
        fnBody.push("const params = new NullObject()");
        for (let i = 0; i < params.length; i++) {
          fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
        }
        fnBody.push("return params");
        fnBody.push("}");
        fnBody.push("return fn");
        return new Function("NullObject", fnBody.join("\n"))(NullObject);
      }
      _getHandlerMatchingConstraints() {
        return null;
      }
      // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
      // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
      // The store's implementation comes from the strategies provided to the Router.
      _buildConstraintStore(store, constraint) {
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            let indexes = store.get(constraintValue) || 0;
            indexes |= 1 << i;
            store.set(constraintValue, indexes);
          }
        }
      }
      // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
      _constrainedIndexBitmask(constraint) {
        let mask4 = 0;
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            mask4 |= 1 << i;
          }
        }
        return ~mask4;
      }
      // Compile a fast function to match the handlers for this node
      // The function implements a general case multi-constraint matching algorithm.
      // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
      // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
      // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
      // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
      _compileGetHandlerMatchingConstraints(constrainer) {
        this.constrainedHandlerStores = {};
        for (const constraint of this.constraints) {
          const store = constrainer.newStoreForConstraint(constraint);
          this.constrainedHandlerStores[constraint] = store;
          this._buildConstraintStore(store, constraint);
        }
        const lines = [];
        lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
        for (const constraint of this.constraints) {
          lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
          const strategy = constrainer.strategies[constraint];
          const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
          lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
        }
        for (const constraint in constrainer.strategies) {
          const strategy = constrainer.strategies[constraint];
          if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
            lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
          }
        }
        lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
        this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
      }
    };
    module2.exports = HandlerStorage;
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/node.js"(exports2, module2) {
    "use strict";
    var HandlerStorage = require_handler_storage();
    var NODE_TYPES = {
      STATIC: 0,
      PARAMETRIC: 1,
      WILDCARD: 2
    };
    var Node = class {
      constructor() {
        this.isLeafNode = false;
        this.routes = null;
        this.handlerStorage = null;
      }
      addRoute(route, constrainer) {
        if (this.routes === null) {
          this.routes = [];
        }
        if (this.handlerStorage === null) {
          this.handlerStorage = new HandlerStorage();
        }
        this.isLeafNode = true;
        this.routes.push(route);
        this.handlerStorage.addHandler(constrainer, route);
      }
    };
    var ParentNode = class extends Node {
      constructor() {
        super();
        this.staticChildren = {};
      }
      findStaticMatchingChild(path, pathIndex) {
        const staticChild = this.staticChildren[path.charAt(pathIndex)];
        if (staticChild === void 0 || !staticChild.matchPrefix(path, pathIndex)) {
          return null;
        }
        return staticChild;
      }
      getStaticChild(path, pathIndex = 0) {
        if (path.length === pathIndex) {
          return this;
        }
        const staticChild = this.findStaticMatchingChild(path, pathIndex);
        if (staticChild) {
          return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
        }
        return null;
      }
      createStaticChild(path) {
        if (path.length === 0) {
          return this;
        }
        let staticChild = this.staticChildren[path.charAt(0)];
        if (staticChild) {
          let i = 1;
          for (; i < staticChild.prefix.length; i++) {
            if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
              staticChild = staticChild.split(this, i);
              break;
            }
          }
          return staticChild.createStaticChild(path.slice(i));
        }
        const label = path.charAt(0);
        this.staticChildren[label] = new StaticNode(path);
        return this.staticChildren[label];
      }
    };
    var StaticNode = class _StaticNode extends ParentNode {
      constructor(prefix) {
        super();
        this.prefix = prefix;
        this.wildcardChild = null;
        this.parametricChildren = [];
        this.kind = NODE_TYPES.STATIC;
        this._compilePrefixMatch();
      }
      getParametricChild(regex) {
        const regexpSource = regex && regex.source;
        const parametricChild = this.parametricChildren.find((child) => {
          const childRegexSource = child.regex && child.regex.source;
          return childRegexSource === regexpSource;
        });
        if (parametricChild) {
          return parametricChild;
        }
        return null;
      }
      createParametricChild(regex, staticSuffix, nodePath) {
        let parametricChild = this.getParametricChild(regex);
        if (parametricChild) {
          parametricChild.nodePaths.add(nodePath);
          return parametricChild;
        }
        parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
        this.parametricChildren.push(parametricChild);
        this.parametricChildren.sort((child1, child2) => {
          if (!child1.isRegex) return 1;
          if (!child2.isRegex) return -1;
          if (child1.staticSuffix === null) return 1;
          if (child2.staticSuffix === null) return -1;
          if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
          if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
          return 0;
        });
        return parametricChild;
      }
      getWildcardChild() {
        return this.wildcardChild;
      }
      createWildcardChild() {
        this.wildcardChild = this.getWildcardChild() || new WildcardNode();
        return this.wildcardChild;
      }
      split(parentNode, length) {
        const parentPrefix = this.prefix.slice(0, length);
        const childPrefix = this.prefix.slice(length);
        this.prefix = childPrefix;
        this._compilePrefixMatch();
        const staticNode = new _StaticNode(parentPrefix);
        staticNode.staticChildren[childPrefix.charAt(0)] = this;
        parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
        return staticNode;
      }
      getNextNode(path, pathIndex, nodeStack, paramsCount) {
        let node = this.findStaticMatchingChild(path, pathIndex);
        let parametricBrotherNodeIndex = 0;
        if (node === null) {
          if (this.parametricChildren.length === 0) {
            return this.wildcardChild;
          }
          node = this.parametricChildren[0];
          parametricBrotherNodeIndex = 1;
        }
        if (this.wildcardChild !== null) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.wildcardChild
          });
        }
        for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.parametricChildren[i]
          });
        }
        return node;
      }
      _compilePrefixMatch() {
        if (this.prefix.length === 1) {
          this.matchPrefix = () => true;
          return;
        }
        const lines = [];
        for (let i = 1; i < this.prefix.length; i++) {
          const charCode = this.prefix.charCodeAt(i);
          lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
        }
        this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
      }
    };
    var ParametricNode = class extends ParentNode {
      constructor(regex, staticSuffix, nodePath) {
        super();
        this.isRegex = !!regex;
        this.regex = regex || null;
        this.staticSuffix = staticSuffix || null;
        this.kind = NODE_TYPES.PARAMETRIC;
        this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
      }
      getNextNode(path, pathIndex) {
        return this.findStaticMatchingChild(path, pathIndex);
      }
    };
    var WildcardNode = class extends Node {
      constructor() {
        super();
        this.kind = NODE_TYPES.WILDCARD;
      }
      getNextNode() {
        return null;
      }
    };
    module2.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/accept-version.js"(exports2, module2) {
    "use strict";
    var assert4 = require("node:assert");
    function SemVerStore() {
      if (!(this instanceof SemVerStore)) {
        return new SemVerStore();
      }
      this.store = {};
      this.maxMajor = 0;
      this.maxMinors = {};
      this.maxPatches = {};
    }
    SemVerStore.prototype.set = function(version4, store) {
      if (typeof version4 !== "string") {
        throw new TypeError("Version should be a string");
      }
      let [major, minor, patch] = version4.split(".");
      if (isNaN(major)) {
        throw new TypeError("Major version must be a numeric value");
      }
      major = Number(major);
      minor = Number(minor) || 0;
      patch = Number(patch) || 0;
      if (major >= this.maxMajor) {
        this.maxMajor = major;
        this.store.x = store;
        this.store["*"] = store;
        this.store["x.x"] = store;
        this.store["x.x.x"] = store;
      }
      if (minor >= (this.maxMinors[major] || 0)) {
        this.maxMinors[major] = minor;
        this.store[`${major}.x`] = store;
        this.store[`${major}.x.x`] = store;
      }
      if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
        this.maxPatches[`${major}.${minor}`] = patch;
        this.store[`${major}.${minor}.x`] = store;
      }
      this.store[`${major}.${minor}.${patch}`] = store;
      return this;
    };
    SemVerStore.prototype.get = function(version4) {
      return this.store[version4];
    };
    module2.exports = {
      name: "version",
      mustMatchWhenDerived: true,
      storage: SemVerStore,
      validate(value) {
        assert4(typeof value === "string", "Version should be a string");
      }
    };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/strategies/accept-host.js"(exports2, module2) {
    "use strict";
    var assert4 = require("node:assert");
    function HostStorage() {
      const hosts = {};
      const regexHosts = [];
      return {
        get: (host) => {
          const exact = hosts[host];
          if (exact) {
            return exact;
          }
          for (const regex of regexHosts) {
            if (regex.host.test(host)) {
              return regex.value;
            }
          }
        },
        set: (host, value) => {
          if (host instanceof RegExp) {
            regexHosts.push({ host, value });
          } else {
            hosts[host] = value;
          }
        }
      };
    }
    module2.exports = {
      name: "host",
      mustMatchWhenDerived: false,
      storage: HostStorage,
      validate(value) {
        assert4(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
      }
    };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/constrainer.js"(exports2, module2) {
    "use strict";
    var acceptVersionStrategy = require_accept_version();
    var acceptHostStrategy = require_accept_host();
    var assert4 = require("node:assert");
    var Constrainer = class {
      constructor(customStrategies) {
        this.strategies = {
          version: acceptVersionStrategy,
          host: acceptHostStrategy
        };
        this.strategiesInUse = /* @__PURE__ */ new Set();
        this.asyncStrategiesInUse = /* @__PURE__ */ new Set();
        if (customStrategies) {
          for (const strategy of Object.values(customStrategies)) {
            this.addConstraintStrategy(strategy);
          }
        }
      }
      isStrategyUsed(strategyName) {
        return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
      }
      hasConstraintStrategy(strategyName) {
        const customConstraintStrategy = this.strategies[strategyName];
        if (customConstraintStrategy !== void 0) {
          return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
        }
        return false;
      }
      addConstraintStrategy(strategy) {
        assert4(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
        assert4(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
        assert4(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
        if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
          throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
        }
        if (this.isStrategyUsed(strategy.name)) {
          throw new Error(`There already exists a route with ${strategy.name} constraint.`);
        }
        strategy.isCustom = true;
        strategy.isAsync = strategy.deriveConstraint.length === 3;
        this.strategies[strategy.name] = strategy;
        if (strategy.mustMatchWhenDerived) {
          this.noteUsage({ [strategy.name]: strategy });
        }
      }
      deriveConstraints(req, ctx, done) {
        const constraints = this.deriveSyncConstraints(req, ctx);
        if (done === void 0) {
          return constraints;
        }
        this.deriveAsyncConstraints(constraints, req, ctx, done);
      }
      deriveSyncConstraints(req, ctx) {
        return void 0;
      }
      // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
      noteUsage(constraints) {
        if (constraints) {
          const beforeSize = this.strategiesInUse.size;
          for (const key in constraints) {
            const strategy = this.strategies[key];
            if (strategy.isAsync) {
              this.asyncStrategiesInUse.add(key);
            } else {
              this.strategiesInUse.add(key);
            }
          }
          if (beforeSize !== this.strategiesInUse.size) {
            this._buildDeriveConstraints();
          }
        }
      }
      newStoreForConstraint(constraint) {
        if (!this.strategies[constraint]) {
          throw new Error(`No strategy registered for constraint key ${constraint}`);
        }
        return this.strategies[constraint].storage();
      }
      validateConstraints(constraints) {
        for (const key in constraints) {
          const value = constraints[key];
          if (typeof value === "undefined") {
            throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
          }
          const strategy = this.strategies[key];
          if (!strategy) {
            throw new Error(`No strategy registered for constraint key ${key}`);
          }
          if (strategy.validate) {
            strategy.validate(value);
          }
        }
      }
      deriveAsyncConstraints(constraints, req, ctx, done) {
        let asyncConstraintsCount = this.asyncStrategiesInUse.size;
        if (asyncConstraintsCount === 0) {
          done(null, constraints);
          return;
        }
        constraints = constraints || {};
        for (const key of this.asyncStrategiesInUse) {
          const strategy = this.strategies[key];
          strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
            if (err !== null) {
              done(err);
              return;
            }
            constraints[key] = constraintValue;
            if (--asyncConstraintsCount === 0) {
              done(null, constraints);
            }
          });
        }
      }
      // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
      // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
      // This allows us to not allocate an object to hold constraint values if no constraints are defined.
      _buildDeriveConstraints() {
        if (this.strategiesInUse.size === 0) return;
        const lines = ["return {"];
        for (const key of this.strategiesInUse) {
          const strategy = this.strategies[key];
          if (!strategy.isCustom) {
            if (key === "version") {
              lines.push("   version: req.headers['accept-version'],");
            } else {
              lines.push("   host: req.headers.host || req.headers[':authority'],");
            }
          } else {
            lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
          }
        }
        lines.push("}");
        this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
      }
    };
    module2.exports = Constrainer;
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/http-methods.js
var require_http_methods = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/http-methods.js"(exports2, module2) {
    "use strict";
    var httpMethods = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "QUERY",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    module2.exports = httpMethods;
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/url-sanitizer.js
var require_url_sanitizer = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/lib/url-sanitizer.js"(exports2, module2) {
    "use strict";
    function decodeComponentChar(highCharCode, lowCharCode) {
      if (highCharCode === 50) {
        if (lowCharCode === 53) return "%";
        if (lowCharCode === 51) return "#";
        if (lowCharCode === 52) return "$";
        if (lowCharCode === 54) return "&";
        if (lowCharCode === 66) return "+";
        if (lowCharCode === 98) return "+";
        if (lowCharCode === 67) return ",";
        if (lowCharCode === 99) return ",";
        if (lowCharCode === 70) return "/";
        if (lowCharCode === 102) return "/";
        return null;
      }
      if (highCharCode === 51) {
        if (lowCharCode === 65) return ":";
        if (lowCharCode === 97) return ":";
        if (lowCharCode === 66) return ";";
        if (lowCharCode === 98) return ";";
        if (lowCharCode === 68) return "=";
        if (lowCharCode === 100) return "=";
        if (lowCharCode === 70) return "?";
        if (lowCharCode === 102) return "?";
        return null;
      }
      if (highCharCode === 52 && lowCharCode === 48) {
        return "@";
      }
      return null;
    }
    function safeDecodeURI(path, useSemicolonDelimiter) {
      let shouldDecode = false;
      let shouldDecodeParam = false;
      let querystring = "";
      for (let i = 1; i < path.length; i++) {
        const charCode = path.charCodeAt(i);
        if (charCode === 37) {
          const highCharCode = path.charCodeAt(i + 1);
          const lowCharCode = path.charCodeAt(i + 2);
          if (decodeComponentChar(highCharCode, lowCharCode) === null) {
            shouldDecode = true;
          } else {
            shouldDecodeParam = true;
            if (highCharCode === 50 && lowCharCode === 53) {
              shouldDecode = true;
              path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
              i += 2;
            }
            i += 2;
          }
        } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
          querystring = path.slice(i + 1);
          path = path.slice(0, i);
          break;
        }
      }
      const decodedPath = shouldDecode ? decodeURI(path) : path;
      return { path: decodedPath, querystring, shouldDecodeParam };
    }
    function safeDecodeURIComponent(uriComponent) {
      const startIndex = uriComponent.indexOf("%");
      if (startIndex === -1) return uriComponent;
      let decoded = "";
      let lastIndex = startIndex;
      for (let i = startIndex; i < uriComponent.length; i++) {
        if (uriComponent.charCodeAt(i) === 37) {
          const highCharCode = uriComponent.charCodeAt(i + 1);
          const lowCharCode = uriComponent.charCodeAt(i + 2);
          const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
          decoded += uriComponent.slice(lastIndex, i) + decodedChar;
          lastIndex = i + 3;
        }
      }
      return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
    }
    module2.exports = { safeDecodeURI, safeDecodeURIComponent };
  }
});

// ../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/index.js
var require_find_my_way = __commonJS({
  "../../node_modules/.pnpm/find-my-way@9.1.0/node_modules/find-my-way/index.js"(exports2, module2) {
    "use strict";
    var assert4 = require("node:assert");
    var querystring = require_lib();
    var isRegexSafe = require_safe_regex2();
    var deepEqual = require_fast_deep_equal();
    var { prettyPrintTree } = require_pretty_print();
    var { StaticNode, NODE_TYPES } = require_node();
    var Constrainer = require_constrainer();
    var httpMethods = require_http_methods();
    var httpMethodStrategy = require_http_method();
    var { safeDecodeURI, safeDecodeURIComponent } = require_url_sanitizer();
    var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
    var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
    if (!isRegexSafe(FULL_PATH_REGEXP)) {
      throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
      throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
    }
    function Router(opts) {
      if (!(this instanceof Router)) {
        return new Router(opts);
      }
      opts = opts || {};
      this._opts = opts;
      if (opts.defaultRoute) {
        assert4(typeof opts.defaultRoute === "function", "The default route must be a function");
        this.defaultRoute = opts.defaultRoute;
      } else {
        this.defaultRoute = null;
      }
      if (opts.onBadUrl) {
        assert4(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
        this.onBadUrl = opts.onBadUrl;
      } else {
        this.onBadUrl = null;
      }
      if (opts.buildPrettyMeta) {
        assert4(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
        this.buildPrettyMeta = opts.buildPrettyMeta;
      } else {
        this.buildPrettyMeta = defaultBuildPrettyMeta;
      }
      if (opts.querystringParser) {
        assert4(typeof opts.querystringParser === "function", "querystringParser must be a function");
        this.querystringParser = opts.querystringParser;
      } else {
        this.querystringParser = (query) => query === "" ? {} : querystring.parse(query);
      }
      this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
      this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
      this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
      this.maxParamLength = opts.maxParamLength || 100;
      this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
      this.constrainer = new Constrainer(opts.constraints);
      this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
      this.routes = [];
      this.trees = {};
    }
    Router.prototype.on = function on(method, path, opts, handler, store) {
      if (typeof opts === "function") {
        if (handler !== void 0) {
          store = handler;
        }
        handler = opts;
        opts = {};
      }
      assert4(typeof path === "string", "Path should be a string");
      assert4(path.length > 0, "The path could not be empty");
      assert4(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
      assert4(typeof handler === "function", "Handler should be a function");
      const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert4(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
        this.on(method, pathFull, opts, handler, store);
        this.on(method, pathOptional, opts, handler, store);
        return;
      }
      const route = path;
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        assert4(typeof method2 === "string", "Method should be a string");
        assert4(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
        this._on(method2, path, opts, handler, store, route);
      }
    };
    Router.prototype._on = function _on(method, path, opts, handler, store) {
      let constraints = {};
      if (opts.constraints !== void 0) {
        assert4(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
        if (Object.keys(opts.constraints).length !== 0) {
          constraints = opts.constraints;
        }
      }
      this.constrainer.validateConstraints(constraints);
      this.constrainer.noteUsage(constraints);
      if (this.trees[method] === void 0) {
        this.trees[method] = new StaticNode("/");
      }
      let pattern = path;
      if (pattern === "*" && this.trees[method].prefix.length !== 0) {
        const currentRoot = this.trees[method];
        this.trees[method] = new StaticNode("");
        this.trees[method].staticChildren["/"] = currentRoot;
      }
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.split("::").join(":");
          staticNodePath = staticNodePath.split("%").join("%25");
          currentNode = currentNode.createStaticChild(staticNodePath);
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert4(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = true;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.split("::").join(":");
                staticPart = staticPart.split("%").join("%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.createWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      if (pattern === "*") {
        pattern = "/*";
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`);
        }
      }
      const route = { method, path, pattern, params, opts, handler, store };
      this.routes.push(route);
      currentNode.addRoute(route, this.constrainer);
    };
    Router.prototype.hasRoute = function hasRoute(method, path, constraints) {
      const route = this.findRoute(method, path, constraints);
      return route !== null;
    };
    Router.prototype.findRoute = function findNode(method, path, constraints = {}) {
      if (this.trees[method] === void 0) {
        return null;
      }
      let pattern = path;
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.split("::").join(":");
          staticNodePath = staticNodePath.split("%").join("%25");
          currentNode = currentNode.getStaticChild(staticNodePath);
          if (currentNode === null) {
            return null;
          }
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert4(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = false;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.split("::").join(":");
                staticPart = staticPart.split("%").join("%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
                if (currentNode === null) {
                  return null;
                }
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.getWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          return {
            handler: existRoute.handler,
            store: existRoute.store,
            params: existRoute.params
          };
        }
      }
      return null;
    };
    Router.prototype.hasConstraintStrategy = function(strategyName) {
      return this.constrainer.hasConstraintStrategy(strategyName);
    };
    Router.prototype.addConstraintStrategy = function(constraints) {
      this.constrainer.addConstraintStrategy(constraints);
      this._rebuild(this.routes);
    };
    Router.prototype.reset = function reset() {
      this.trees = {};
      this.routes = [];
    };
    Router.prototype.off = function off(method, path, constraints) {
      assert4(typeof path === "string", "Path should be a string");
      assert4(path.length > 0, "The path could not be empty");
      assert4(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
      assert4(
        typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null,
        "Constraints should be an object or undefined."
      );
      const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert4(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
        this.off(method, pathFull, constraints);
        this.off(method, pathOptional, constraints);
        return;
      }
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        this._off(method2, path, constraints);
      }
    };
    Router.prototype._off = function _off(method, path, constraints) {
      assert4(typeof method === "string", "Method should be a string");
      assert4(httpMethods.includes(method), `Method '${method}' is not an http method.`);
      function matcherWithoutConstraints(route) {
        return method !== route.method || path !== route.path;
      }
      function matcherWithConstraints(route) {
        return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {});
      }
      const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
      const newRoutes = this.routes.filter(predicate);
      this._rebuild(newRoutes);
    };
    Router.prototype.lookup = function lookup(req, res, ctx, done) {
      if (typeof ctx === "function") {
        done = ctx;
        ctx = void 0;
      }
      if (done === void 0) {
        const constraints = this.constrainer.deriveConstraints(req, ctx);
        const handle = this.find(req.method, req.url, constraints);
        return this.callHandler(handle, req, res, ctx);
      }
      this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
        if (err !== null) {
          done(err);
          return;
        }
        try {
          const handle = this.find(req.method, req.url, constraints);
          const result = this.callHandler(handle, req, res, ctx);
          done(null, result);
        } catch (err2) {
          done(err2);
        }
      });
    };
    Router.prototype.callHandler = function callHandler(handle, req, res, ctx) {
      if (handle === null) return this._defaultRoute(req, res, ctx);
      return ctx === void 0 ? handle.handler(req, res, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams);
    };
    Router.prototype.find = function find(method, path, derivedConstraints) {
      let currentNode = this.trees[method];
      if (currentNode === void 0) return null;
      if (path.charCodeAt(0) !== 47) {
        path = path.replace(FULL_PATH_REGEXP, "/");
      }
      if (this.ignoreDuplicateSlashes) {
        path = removeDuplicateSlashes(path);
      }
      let sanitizedUrl;
      let querystring2;
      let shouldDecodeParam;
      try {
        sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
        path = sanitizedUrl.path;
        querystring2 = sanitizedUrl.querystring;
        shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
      } catch (error) {
        return this._onBadUrl(path);
      }
      if (this.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      const originPath = path;
      if (this.caseSensitive === false) {
        path = path.toLowerCase();
      }
      const maxParamLength = this.maxParamLength;
      let pathIndex = currentNode.prefix.length;
      const params = [];
      const pathLen = path.length;
      const brothersNodesStack = [];
      while (true) {
        if (pathIndex === pathLen && currentNode.isLeafNode) {
          const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
          if (handle !== null) {
            return {
              handler: handle.handler,
              store: handle.store,
              params: handle._createParamsObject(params),
              searchParams: this.querystringParser(querystring2)
            };
          }
        }
        let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);
        if (node === null) {
          if (brothersNodesStack.length === 0) {
            return null;
          }
          const brotherNodeState = brothersNodesStack.pop();
          pathIndex = brotherNodeState.brotherPathIndex;
          params.splice(brotherNodeState.paramsCount);
          node = brotherNodeState.brotherNode;
        }
        currentNode = node;
        if (currentNode.kind === NODE_TYPES.STATIC) {
          pathIndex += currentNode.prefix.length;
          continue;
        }
        if (currentNode.kind === NODE_TYPES.WILDCARD) {
          let param2 = originPath.slice(pathIndex);
          if (shouldDecodeParam) {
            param2 = safeDecodeURIComponent(param2);
          }
          params.push(param2);
          pathIndex = pathLen;
          continue;
        }
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.isRegex) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null) continue;
          for (let i = 1; i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return null;
            }
            params.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return null;
          }
          params.push(param);
        }
        pathIndex = paramEndIndex;
      }
    };
    Router.prototype._rebuild = function(routes) {
      this.reset();
      for (const route of routes) {
        const { method, path, opts, handler, store } = route;
        this._on(method, path, opts, handler, store);
      }
    };
    Router.prototype._defaultRoute = function(req, res, ctx) {
      if (this.defaultRoute !== null) {
        return ctx === void 0 ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
      } else {
        res.statusCode = 404;
        res.end();
      }
    };
    Router.prototype._onBadUrl = function(path) {
      if (this.onBadUrl === null) {
        return null;
      }
      const onBadUrl = this.onBadUrl;
      return {
        handler: (req, res, ctx) => onBadUrl(path, req, res),
        params: {},
        store: null
      };
    };
    Router.prototype.prettyPrint = function(options = {}) {
      const method = options.method;
      options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
      let tree = null;
      if (method === void 0) {
        const { version: version4, host, ...constraints } = this.constrainer.strategies;
        constraints[httpMethodStrategy.name] = httpMethodStrategy;
        const mergedRouter = new Router({ ...this._opts, constraints });
        const mergedRoutes = this.routes.map((route) => {
          const constraints2 = {
            ...route.opts.constraints,
            [httpMethodStrategy.name]: route.method
          };
          return { ...route, method: "MERGED", opts: { constraints: constraints2 } };
        });
        mergedRouter._rebuild(mergedRoutes);
        tree = mergedRouter.trees.MERGED;
      } else {
        tree = this.trees[method];
      }
      if (tree == null) return "(empty tree)";
      return prettyPrintTree(tree, options);
    };
    for (const i in httpMethods) {
      if (!httpMethods.hasOwnProperty(i)) continue;
      const m = httpMethods[i];
      const methodName = m.toLowerCase();
      Router.prototype[methodName] = function(path, handler, store) {
        return this.on(m, path, handler, store);
      };
    }
    Router.prototype.all = function(path, handler, store) {
      this.on(httpMethods, path, handler, store);
    };
    module2.exports = Router;
    function escapeRegExp(string2) {
      return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function removeDuplicateSlashes(path) {
      return path.replace(/\/\/+/g, "/");
    }
    function trimLastSlash(path) {
      if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
        return path.slice(0, -1);
      }
      return path;
    }
    function trimRegExpStartAndEnd(regexString) {
      if (regexString.charCodeAt(1) === 94) {
        regexString = regexString.slice(0, 1) + regexString.slice(2);
      }
      if (regexString.charCodeAt(regexString.length - 2) === 36) {
        regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
      }
      return regexString;
    }
    function getClosingParenthensePosition(path, idx) {
      let parentheses = 1;
      while (idx < path.length) {
        idx++;
        if (path[idx] === "\\") {
          idx++;
          continue;
        }
        if (path[idx] === ")") {
          parentheses--;
        } else if (path[idx] === "(") {
          parentheses++;
        }
        if (!parentheses) return idx;
      }
      throw new TypeError('Invalid regexp expression in "' + path + '"');
    }
    function defaultBuildPrettyMeta(route) {
      if (!route) return {};
      if (!route.store) return {};
      return Object.assign({}, route.store);
    }
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/headRoute.js"(exports2, module2) {
    "use strict";
    function headRouteOnSendHandler(req, reply, payload, done) {
      if (payload === void 0) {
        reply.header("content-length", "0");
        return done(null, null);
      }
      if (typeof payload.resume === "function") {
        payload.on("error", (err) => {
          reply.log.error({ err }, "Error on Stream found for HEAD route");
        });
        payload.resume();
        return done(null, null);
      }
      const size = "" + Buffer.byteLength(payload);
      reply.header("content-length", size);
      done(null, null);
    }
    function parseHeadOnSendHandlers(onSendHandlers) {
      if (onSendHandlers == null) return headRouteOnSendHandler;
      return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
    }
    module2.exports = {
      parseHeadOnSendHandlers
    };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/route.js
var require_route = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/route.js"(exports2, module2) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Context = require_context();
    var handleRequest = require_handleRequest();
    var { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = require_hooks();
    var { normalizeSchema } = require_schemas();
    var { parseHeadOnSendHandlers } = require_headRoute();
    var {
      compileSchemasForValidation,
      compileSchemasForSerialization
    } = require_validation();
    var {
      FST_ERR_SCH_VALIDATION_BUILD,
      FST_ERR_SCH_SERIALIZATION_BUILD,
      FST_ERR_DUPLICATED_ROUTE,
      FST_ERR_INVALID_URL,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
      FST_ERR_ROUTE_DUPLICATED_HANDLER,
      FST_ERR_ROUTE_HANDLER_NOT_FN,
      FST_ERR_ROUTE_MISSING_HANDLER,
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
      FST_ERR_ROUTE_METHOD_INVALID,
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER
    } = require_errors2();
    var {
      kRoutePrefix,
      kSupportedHTTPMethods,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kOptions,
      kReplySerializerDefault,
      kReplyIsError,
      kRequestPayloadStream,
      kDisableRequestLogging,
      kSchemaErrorFormatter,
      kErrorHandler,
      kHasBeenDecorated,
      kRequestAcceptVersion,
      kRouteByFastify,
      kRouteContext
    } = require_symbols2();
    var { buildErrorHandler } = require_error_handler();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    function buildRouting(options) {
      const router2 = FindMyWay(options.config);
      let avvio;
      let fourOhFour;
      let logger;
      let hasLogger;
      let setupResponseListeners;
      let throwIfAlreadyStarted;
      let disableRequestLogging;
      let ignoreTrailingSlash;
      let ignoreDuplicateSlashes;
      let return503OnClosing;
      let globalExposeHeadRoutes;
      let keepAliveConnections;
      let closing = false;
      return {
        /**
         * @param {import('../fastify').FastifyServerOptions} options
         * @param {*} fastifyArgs
         */
        setup(options2, fastifyArgs) {
          avvio = fastifyArgs.avvio;
          fourOhFour = fastifyArgs.fourOhFour;
          logger = fastifyArgs.logger;
          hasLogger = fastifyArgs.hasLogger;
          setupResponseListeners = fastifyArgs.setupResponseListeners;
          throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
          globalExposeHeadRoutes = options2.exposeHeadRoutes;
          disableRequestLogging = options2.disableRequestLogging;
          ignoreTrailingSlash = options2.ignoreTrailingSlash;
          ignoreDuplicateSlashes = options2.ignoreDuplicateSlashes;
          return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
          keepAliveConnections = fastifyArgs.keepAliveConnections;
        },
        routing: router2.lookup.bind(router2),
        // router func to find the right handler to call
        route,
        // configure a route in the fastify instance
        hasRoute,
        prepareRoute,
        routeHandler,
        closeRoutes: () => {
          closing = true;
        },
        printRoutes: router2.prettyPrint.bind(router2),
        addConstraintStrategy,
        hasConstraintStrategy,
        isAsyncConstraint,
        findRoute
      };
      function addConstraintStrategy(strategy) {
        throwIfAlreadyStarted("Cannot add constraint strategy!");
        return router2.addConstraintStrategy(strategy);
      }
      function hasConstraintStrategy(strategyName) {
        return router2.hasConstraintStrategy(strategyName);
      }
      function isAsyncConstraint() {
        return router2.constrainer.asyncStrategiesInUse.size > 0;
      }
      function prepareRoute({ method, url, options: options2, handler, isFastify }) {
        if (typeof url !== "string") {
          throw new FST_ERR_INVALID_URL(typeof url);
        }
        if (!handler && typeof options2 === "function") {
          handler = options2;
          options2 = {};
        } else if (handler && typeof handler === "function") {
          if (Object.prototype.toString.call(options2) !== "[object Object]") {
            throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url);
          } else if (options2.handler) {
            if (typeof options2.handler === "function") {
              throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url);
            } else {
              throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url);
            }
          }
        }
        options2 = Object.assign({}, options2, {
          method,
          url,
          path: url,
          handler: handler || options2 && options2.handler
        });
        return route.call(this, { options: options2, isFastify });
      }
      function hasRoute({ options: options2 }) {
        const normalizedMethod = options2.method?.toUpperCase() ?? "";
        return router2.hasRoute(
          normalizedMethod,
          options2.url || "",
          options2.constraints
        );
      }
      function findRoute(options2) {
        const route2 = router2.find(
          options2.method,
          options2.url || "",
          options2.constraints
        );
        if (route2) {
          return {
            handler: route2.handler,
            params: route2.params,
            searchParams: route2.searchParams
          };
        } else {
          return null;
        }
      }
      function route({ options: options2, isFastify }) {
        throwIfAlreadyStarted("Cannot add route!");
        const opts = { ...options2 };
        const path = opts.url || opts.path || "";
        if (!opts.handler) {
          throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path);
        }
        if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path);
        }
        validateBodyLimitOption(opts.bodyLimit);
        const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
        let isGetRoute = false;
        let isHeadRoute = false;
        if (Array.isArray(opts.method)) {
          for (let i = 0; i < opts.method.length; ++i) {
            opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
            validateSchemaBodyOption.call(this, opts.method[i], path, opts.schema);
            isGetRoute = opts.method.includes("GET");
            isHeadRoute = opts.method.includes("HEAD");
          }
        } else {
          opts.method = normalizeAndValidateMethod.call(this, opts.method);
          validateSchemaBodyOption.call(this, opts.method, path, opts.schema);
          isGetRoute = opts.method === "GET";
          isHeadRoute = opts.method === "HEAD";
        }
        const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
        const prefix = this[kRoutePrefix];
        if (path === "/" && prefix.length > 0 && opts.method !== "HEAD") {
          switch (opts.prefixTrailingSlash) {
            case "slash":
              addNewRoute.call(this, { path, isFastify });
              break;
            case "no-slash":
              addNewRoute.call(this, { path: "", isFastify });
              break;
            case "both":
            default:
              addNewRoute.call(this, { path: "", isFastify });
              if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
                addNewRoute.call(this, { path, prefixing: true, isFastify });
              }
          }
        } else if (path[0] === "/" && prefix.endsWith("/")) {
          addNewRoute.call(this, { path: path.slice(1), isFastify });
        } else {
          addNewRoute.call(this, { path, isFastify });
        }
        return this;
        function addNewRoute({ path: path2, prefixing = false, isFastify: isFastify2 = false }) {
          const url = prefix + path2;
          opts.url = url;
          opts.path = url;
          opts.routePath = path2;
          opts.prefix = prefix;
          opts.logLevel = opts.logLevel || this[kLogLevel];
          if (this[kLogSerializers] || opts.logSerializers) {
            opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
          }
          if (opts.attachValidation == null) {
            opts.attachValidation = false;
          }
          if (prefixing === false) {
            for (const hook of this[kHooks].onRoute) {
              hook.call(this, opts);
            }
          }
          for (const hook of lifecycleHooks) {
            if (opts && hook in opts) {
              if (Array.isArray(opts[hook])) {
                for (const func of opts[hook]) {
                  if (typeof func !== "function") {
                    throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                  }
                  if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                    if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else if (hook === "onRequestAbort") {
                    if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else {
                    if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  }
                }
              } else if (opts[hook] !== void 0 && typeof opts[hook] !== "function") {
                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
              }
            }
          }
          const constraints = opts.constraints || {};
          const config = {
            ...opts.config,
            url,
            method: opts.method
          };
          const context = new Context({
            schema: opts.schema,
            handler: opts.handler.bind(this),
            config,
            errorHandler: opts.errorHandler,
            childLoggerFactory: opts.childLoggerFactory,
            bodyLimit: opts.bodyLimit,
            logLevel: opts.logLevel,
            logSerializers: opts.logSerializers,
            attachValidation: opts.attachValidation,
            schemaErrorFormatter: opts.schemaErrorFormatter,
            replySerializer: this[kReplySerializerDefault],
            validatorCompiler: opts.validatorCompiler,
            serializerCompiler: opts.serializerCompiler,
            exposeHeadRoute: shouldExposeHead,
            prefixTrailingSlash: opts.prefixTrailingSlash || "both",
            server: this,
            isFastify: isFastify2
          });
          const headHandler = router2.findRoute("HEAD", opts.url, constraints);
          const hasHEADHandler = headHandler !== null;
          try {
            router2.on(opts.method, opts.url, { constraints }, routeHandler, context);
          } catch (error) {
            if (!context[kRouteByFastify]) {
              const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route`);
              if (isDuplicatedRoute) {
                throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
              }
              throw error;
            }
          }
          this.after((notHandledErr, done) => {
            context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
            context._parserOptions.limit = opts.bodyLimit || null;
            context.logLevel = opts.logLevel;
            context.logSerializers = opts.logSerializers;
            context.attachValidation = opts.attachValidation;
            context[kReplySerializerDefault] = this[kReplySerializerDefault];
            context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;
            avvio.once("preReady", () => {
              for (const hook of lifecycleHooks) {
                const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
                context[hook] = toSet.length ? toSet : null;
              }
              while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
                context.Request = context.Request.parent;
              }
              while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
                context.Reply = context.Reply.parent;
              }
              fourOhFour.setContext(this, context);
              if (opts.schema) {
                context.schema = normalizeSchema(context.schema, this.initialConfig);
                const schemaController = this[kSchemaController];
                if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                  schemaController.setupValidator(this[kOptions]);
                }
                try {
                  const isCustom = typeof opts?.validatorCompiler === "function" || schemaController.isCustomValidatorCompiler;
                  compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
                } catch (error) {
                  throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message);
                }
                if (opts.schema.response && !opts.serializerCompiler) {
                  schemaController.setupSerializer(this[kOptions]);
                }
                try {
                  compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
                } catch (error) {
                  throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message);
                }
              }
            });
            done(notHandledErr);
          });
          if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
            const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
            prepareRoute.call(this, { method: "HEAD", url: path2, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
          }
        }
      }
      function routeHandler(req, res, params, context, query) {
        const id3 = getGenReqId(context.server, req);
        const loggerOpts = {
          level: context.logLevel
        };
        if (context.logSerializers) {
          loggerOpts.serializers = context.logSerializers;
        }
        const childLogger = createChildLogger(context, logger, req, id3, loggerOpts);
        childLogger[kDisableRequestLogging] = disableRequestLogging;
        if (closing === true) {
          if (req.httpVersionMajor !== 2) {
            res.setHeader("Connection", "close");
          }
          if (return503OnClosing) {
            const headers = {
              "Content-Type": "application/json",
              "Content-Length": "80"
            };
            res.writeHead(503, headers);
            res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
            childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
            return;
          }
        }
        const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
        if (connHeader === "keep-alive") {
          if (keepAliveConnections.has(req.socket) === false) {
            keepAliveConnections.add(req.socket);
            req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
          }
        }
        if (req.headers[kRequestAcceptVersion] !== void 0) {
          req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
          req.headers[kRequestAcceptVersion] = void 0;
        }
        const request = new context.Request(id3, params, req, query, childLogger, context);
        const reply = new context.Reply(res, request, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request }, "incoming request");
        }
        if (hasLogger === true || context.onResponse !== null) {
          setupResponseListeners(reply);
        }
        if (context.onRequest !== null) {
          onRequestHookRunner(
            context.onRequest,
            request,
            reply,
            runPreParsing
          );
        } else {
          runPreParsing(null, request, reply);
        }
        if (context.onRequestAbort !== null) {
          req.on("close", () => {
            if (req.aborted) {
              onRequestAbortHookRunner(
                context.onRequestAbort,
                request,
                handleOnRequestAbortHooksErrors.bind(null, reply)
              );
            }
          });
        }
        if (context.onTimeout !== null) {
          if (!request.raw.socket._meta) {
            request.raw.socket.on("timeout", handleTimeout);
          }
          request.raw.socket._meta = { context, request, reply };
        }
      }
    }
    function handleOnRequestAbortHooksErrors(reply, err) {
      if (err) {
        reply.log.error({ err }, "onRequestAborted hook failed");
      }
    }
    function handleTimeout() {
      const { context, request, reply } = this._meta;
      onTimeoutHookRunner(
        context.onTimeout,
        request,
        reply,
        noop
      );
    }
    function normalizeAndValidateMethod(method) {
      if (typeof method !== "string") {
        throw new FST_ERR_ROUTE_METHOD_INVALID();
      }
      method = method.toUpperCase();
      if (!this[kSupportedHTTPMethods].bodyless.has(method) && !this[kSupportedHTTPMethods].bodywith.has(method)) {
        throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
      }
      return method;
    }
    function validateSchemaBodyOption(method, path, schema) {
      if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
        throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path);
      }
    }
    function validateBodyLimitOption(bodyLimit) {
      if (bodyLimit === void 0) return;
      if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
        throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
      }
    }
    function runPreParsing(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      request[kRequestPayloadStream] = request.raw;
      if (request[kRouteContext].preParsing !== null) {
        preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
      } else {
        handleRequest.call(request.server, null, request, reply);
      }
    }
    function removeTrackedSocket() {
      this.keepAliveConnections.delete(this.socket);
    }
    function noop() {
    }
    module2.exports = { buildRouting, validateBodyLimitOption };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/fourOhFour.js"(exports2, module2) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Reply = require_reply();
    var Request = require_request();
    var Context = require_context();
    var {
      kRoutePrefix,
      kCanSetNotFoundHandler,
      kFourOhFourLevelInstance,
      kFourOhFourContext,
      kHooks,
      kErrorHandler
    } = require_symbols2();
    var { lifecycleHooks } = require_hooks();
    var { buildErrorHandler } = require_error_handler();
    var {
      FST_ERR_NOT_FOUND
    } = require_errors2();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    function fourOhFour(options) {
      const { logger, disableRequestLogging } = options;
      const router2 = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
      let _onBadUrlHandler = null;
      return { router: router2, setNotFoundHandler, setContext, arrange404 };
      function arrange404(instance) {
        instance[kFourOhFourLevelInstance] = instance;
        instance[kCanSetNotFoundHandler] = true;
        router2.onBadUrl = router2.onBadUrl.bind(instance);
        router2.defaultRoute = router2.defaultRoute.bind(instance);
      }
      function basic404(request, reply) {
        const { url, method } = request.raw;
        const message = `Route ${method}:${url} not found`;
        if (!disableRequestLogging) {
          request.log.info(message);
        }
        reply.code(404).send({
          message,
          error: "Not Found",
          statusCode: 404
        });
      }
      function createOnBadUrl() {
        return function onBadUrl(path, req, res) {
          const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
          const id3 = getGenReqId(fourOhFourContext.server, req);
          const childLogger = createChildLogger(fourOhFourContext, logger, req, id3);
          const request = new Request(id3, null, req, null, childLogger, fourOhFourContext);
          const reply = new Reply(res, request, childLogger);
          _onBadUrlHandler(request, reply);
        };
      }
      function setContext(instance, context) {
        const _404Context = Object.assign({}, instance[kFourOhFourContext]);
        _404Context.onSend = context.onSend;
        context[kFourOhFourContext] = _404Context;
      }
      function setNotFoundHandler(opts, handler, avvio, routeHandler) {
        if (this[kCanSetNotFoundHandler] === void 0) {
          this[kCanSetNotFoundHandler] = true;
        }
        if (this[kFourOhFourContext] === void 0) {
          this[kFourOhFourContext] = null;
        }
        const _fastify = this;
        const prefix = this[kRoutePrefix] || "/";
        if (this[kCanSetNotFoundHandler] === false) {
          throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
        }
        if (typeof opts === "object") {
          if (opts.preHandler) {
            if (Array.isArray(opts.preHandler)) {
              opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
            } else {
              opts.preHandler = opts.preHandler.bind(_fastify);
            }
          }
          if (opts.preValidation) {
            if (Array.isArray(opts.preValidation)) {
              opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
            } else {
              opts.preValidation = opts.preValidation.bind(_fastify);
            }
          }
        }
        if (typeof opts === "function") {
          handler = opts;
          opts = void 0;
        }
        opts = opts || {};
        if (handler) {
          this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
          handler = handler.bind(this);
          _onBadUrlHandler = handler;
        } else {
          handler = basic404;
          _onBadUrlHandler = basic404;
        }
        this.after((notHandledErr, done) => {
          _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
          done(notHandledErr);
        });
      }
      function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
        const context = new Context({
          schema: opts.schema,
          handler,
          config: opts.config || {},
          server: this
        });
        avvio.once("preReady", () => {
          const context2 = this[kFourOhFourContext];
          for (const hook of lifecycleHooks) {
            const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
            context2[hook] = toSet.length ? toSet : null;
          }
          context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
        });
        if (this[kFourOhFourContext] !== null && prefix === "/") {
          Object.assign(this[kFourOhFourContext], context);
          return;
        }
        this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
        router2.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
        router2.all(prefix, routeHandler, context);
      }
      function fourOhFourFallBack(req, res) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id3 = getGenReqId(fourOhFourContext.server, req);
        const childLogger = createChildLogger(fourOhFourContext, logger, req, id3);
        childLogger.info({ req }, "incoming request");
        const request = new Request(id3, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply(res, request, childLogger);
        request.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
        request.log.warn(router2.prettyPrint());
        reply.code(404).send(new FST_ERR_NOT_FOUND());
      }
    }
    module2.exports = fourOhFour;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/configValidator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "type": "object", "additionalProperties": false, "properties": { "connectionTimeout": { "type": "integer", "default": 0 }, "keepAliveTimeout": { "type": "integer", "default": 72e3 }, "forceCloseConnections": { "oneOf": [{ "type": "string", "pattern": "idle" }, { "type": "boolean" }] }, "maxRequestsPerSocket": { "type": "integer", "default": 0, "nullable": true }, "requestTimeout": { "type": "integer", "default": 0 }, "bodyLimit": { "type": "integer", "default": 1048576 }, "caseSensitive": { "type": "boolean", "default": true }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "http2": { "type": "boolean" }, "https": { "if": { "not": { "oneOf": [{ "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["allowHTTP1"], "properties": { "allowHTTP1": { "type": "boolean" } } }] } }, "then": { "setDefaultValue": true } }, "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "disableRequestLogging": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "onProtoPoisoning": { "type": "string", "default": "error" }, "onConstructorPoisoning": { "type": "string", "default": "error" }, "pluginTimeout": { "type": "integer", "default": 1e4 }, "requestIdHeader": { "anyOf": [{ "type": "boolean" }, { "type": "string" }], "default": false }, "requestIdLogLabel": { "type": "string", "default": "reqId" }, "http2SessionTimeout": { "type": "integer", "default": 72e3 }, "exposeHeadRoutes": { "type": "boolean", "default": true }, "useSemicolonDelimiter": { "type": "boolean", "default": false }, "constraints": { "type": "object", "additionalProperties": { "type": "object", "required": ["name", "storage", "validate", "deriveConstraint"], "additionalProperties": true, "properties": { "name": { "type": "string" }, "storage": {}, "validate": {}, "deriveConstraint": {} } } } } };
    var func2 = Object.prototype.hasOwnProperty;
    var pattern0 = new RegExp("idle", "u");
    function validate10(data4, { instancePath = "", parentData, parentDataProperty, rootData = data4 } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
          if (data4.connectionTimeout === void 0) {
            data4.connectionTimeout = 0;
          }
          if (data4.keepAliveTimeout === void 0) {
            data4.keepAliveTimeout = 72e3;
          }
          if (data4.maxRequestsPerSocket === void 0) {
            data4.maxRequestsPerSocket = 0;
          }
          if (data4.requestTimeout === void 0) {
            data4.requestTimeout = 0;
          }
          if (data4.bodyLimit === void 0) {
            data4.bodyLimit = 1048576;
          }
          if (data4.caseSensitive === void 0) {
            data4.caseSensitive = true;
          }
          if (data4.allowUnsafeRegex === void 0) {
            data4.allowUnsafeRegex = false;
          }
          if (data4.ignoreTrailingSlash === void 0) {
            data4.ignoreTrailingSlash = false;
          }
          if (data4.ignoreDuplicateSlashes === void 0) {
            data4.ignoreDuplicateSlashes = false;
          }
          if (data4.disableRequestLogging === void 0) {
            data4.disableRequestLogging = false;
          }
          if (data4.maxParamLength === void 0) {
            data4.maxParamLength = 100;
          }
          if (data4.onProtoPoisoning === void 0) {
            data4.onProtoPoisoning = "error";
          }
          if (data4.onConstructorPoisoning === void 0) {
            data4.onConstructorPoisoning = "error";
          }
          if (data4.pluginTimeout === void 0) {
            data4.pluginTimeout = 1e4;
          }
          if (data4.requestIdHeader === void 0) {
            data4.requestIdHeader = false;
          }
          if (data4.requestIdLogLabel === void 0) {
            data4.requestIdLogLabel = "reqId";
          }
          if (data4.http2SessionTimeout === void 0) {
            data4.http2SessionTimeout = 72e3;
          }
          if (data4.exposeHeadRoutes === void 0) {
            data4.exposeHeadRoutes = true;
          }
          if (data4.useSemicolonDelimiter === void 0) {
            data4.useSemicolonDelimiter = false;
          }
          const _errs1 = errors;
          for (const key0 in data4) {
            if (!func2.call(schema11.properties, key0)) {
              delete data4[key0];
            }
          }
          if (_errs1 === errors) {
            let data0 = data4.connectionTimeout;
            const _errs2 = errors;
            if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                  coerced0 = +data0;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data4 !== void 0) {
                  data4["connectionTimeout"] = coerced0;
                }
              }
            }
            var valid0 = _errs2 === errors;
            if (valid0) {
              let data1 = data4.keepAliveTimeout;
              const _errs4 = errors;
              if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
                let dataType1 = typeof data1;
                let coerced1 = void 0;
                if (!(coerced1 !== void 0)) {
                  if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                    coerced1 = +data1;
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                    return false;
                  }
                }
                if (coerced1 !== void 0) {
                  data1 = coerced1;
                  if (data4 !== void 0) {
                    data4["keepAliveTimeout"] = coerced1;
                  }
                }
              }
              var valid0 = _errs4 === errors;
              if (valid0) {
                if (data4.forceCloseConnections !== void 0) {
                  let data22 = data4.forceCloseConnections;
                  const _errs6 = errors;
                  const _errs7 = errors;
                  let valid1 = false;
                  let passing0 = null;
                  const _errs8 = errors;
                  if (typeof data22 !== "string") {
                    let dataType2 = typeof data22;
                    let coerced2 = void 0;
                    if (!(coerced2 !== void 0)) {
                      if (dataType2 == "number" || dataType2 == "boolean") {
                        coerced2 = "" + data22;
                      } else if (data22 === null) {
                        coerced2 = "";
                      } else {
                        const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err0];
                        } else {
                          vErrors.push(err0);
                        }
                        errors++;
                      }
                    }
                    if (coerced2 !== void 0) {
                      data22 = coerced2;
                      if (data4 !== void 0) {
                        data4["forceCloseConnections"] = coerced2;
                      }
                    }
                  }
                  if (errors === _errs8) {
                    if (typeof data22 === "string") {
                      if (!pattern0.test(data22)) {
                        const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                        if (vErrors === null) {
                          vErrors = [err1];
                        } else {
                          vErrors.push(err1);
                        }
                        errors++;
                      }
                    }
                  }
                  var _valid0 = _errs8 === errors;
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 0;
                  }
                  const _errs10 = errors;
                  if (typeof data22 !== "boolean") {
                    let coerced3 = void 0;
                    if (!(coerced3 !== void 0)) {
                      if (data22 === "false" || data22 === 0 || data22 === null) {
                        coerced3 = false;
                      } else if (data22 === "true" || data22 === 1) {
                        coerced3 = true;
                      } else {
                        const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                        if (vErrors === null) {
                          vErrors = [err2];
                        } else {
                          vErrors.push(err2);
                        }
                        errors++;
                      }
                    }
                    if (coerced3 !== void 0) {
                      data22 = coerced3;
                      if (data4 !== void 0) {
                        data4["forceCloseConnections"] = coerced3;
                      }
                    }
                  }
                  var _valid0 = _errs10 === errors;
                  if (_valid0 && valid1) {
                    valid1 = false;
                    passing0 = [passing0, 1];
                  } else {
                    if (_valid0) {
                      valid1 = true;
                      passing0 = 1;
                    }
                  }
                  if (!valid1) {
                    const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err3];
                    } else {
                      vErrors.push(err3);
                    }
                    errors++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors = _errs7;
                    if (vErrors !== null) {
                      if (_errs7) {
                        vErrors.length = _errs7;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid0 = _errs6 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  let data32 = data4.maxRequestsPerSocket;
                  const _errs12 = errors;
                  if (!(typeof data32 == "number" && (!(data32 % 1) && !isNaN(data32)) && isFinite(data32)) && data32 !== null) {
                    let dataType4 = typeof data32;
                    let coerced4 = void 0;
                    if (!(coerced4 !== void 0)) {
                      if (dataType4 === "boolean" || data32 === null || dataType4 === "string" && data32 && data32 == +data32 && !(data32 % 1)) {
                        coerced4 = +data32;
                      } else if (data32 === "" || data32 === 0 || data32 === false) {
                        coerced4 = null;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced4 !== void 0) {
                      data32 = coerced4;
                      if (data4 !== void 0) {
                        data4["maxRequestsPerSocket"] = coerced4;
                      }
                    }
                  }
                  var valid0 = _errs12 === errors;
                  if (valid0) {
                    let data42 = data4.requestTimeout;
                    const _errs15 = errors;
                    if (!(typeof data42 == "number" && (!(data42 % 1) && !isNaN(data42)) && isFinite(data42))) {
                      let dataType5 = typeof data42;
                      let coerced5 = void 0;
                      if (!(coerced5 !== void 0)) {
                        if (dataType5 === "boolean" || data42 === null || dataType5 === "string" && data42 && data42 == +data42 && !(data42 % 1)) {
                          coerced5 = +data42;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced5 !== void 0) {
                        data42 = coerced5;
                        if (data4 !== void 0) {
                          data4["requestTimeout"] = coerced5;
                        }
                      }
                    }
                    var valid0 = _errs15 === errors;
                    if (valid0) {
                      let data5 = data4.bodyLimit;
                      const _errs17 = errors;
                      if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                        let dataType6 = typeof data5;
                        let coerced6 = void 0;
                        if (!(coerced6 !== void 0)) {
                          if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                            coerced6 = +data5;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                            return false;
                          }
                        }
                        if (coerced6 !== void 0) {
                          data5 = coerced6;
                          if (data4 !== void 0) {
                            data4["bodyLimit"] = coerced6;
                          }
                        }
                      }
                      var valid0 = _errs17 === errors;
                      if (valid0) {
                        let data6 = data4.caseSensitive;
                        const _errs19 = errors;
                        if (typeof data6 !== "boolean") {
                          let coerced7 = void 0;
                          if (!(coerced7 !== void 0)) {
                            if (data6 === "false" || data6 === 0 || data6 === null) {
                              coerced7 = false;
                            } else if (data6 === "true" || data6 === 1) {
                              coerced7 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced7 !== void 0) {
                            data6 = coerced7;
                            if (data4 !== void 0) {
                              data4["caseSensitive"] = coerced7;
                            }
                          }
                        }
                        var valid0 = _errs19 === errors;
                        if (valid0) {
                          let data7 = data4.allowUnsafeRegex;
                          const _errs21 = errors;
                          if (typeof data7 !== "boolean") {
                            let coerced8 = void 0;
                            if (!(coerced8 !== void 0)) {
                              if (data7 === "false" || data7 === 0 || data7 === null) {
                                coerced8 = false;
                              } else if (data7 === "true" || data7 === 1) {
                                coerced8 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced8 !== void 0) {
                              data7 = coerced8;
                              if (data4 !== void 0) {
                                data4["allowUnsafeRegex"] = coerced8;
                              }
                            }
                          }
                          var valid0 = _errs21 === errors;
                          if (valid0) {
                            if (data4.http2 !== void 0) {
                              let data8 = data4.http2;
                              const _errs23 = errors;
                              if (typeof data8 !== "boolean") {
                                let coerced9 = void 0;
                                if (!(coerced9 !== void 0)) {
                                  if (data8 === "false" || data8 === 0 || data8 === null) {
                                    coerced9 = false;
                                  } else if (data8 === "true" || data8 === 1) {
                                    coerced9 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced9 !== void 0) {
                                  data8 = coerced9;
                                  if (data4 !== void 0) {
                                    data4["http2"] = coerced9;
                                  }
                                }
                              }
                              var valid0 = _errs23 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data4.https !== void 0) {
                                let data9 = data4.https;
                                const _errs25 = errors;
                                const _errs26 = errors;
                                let valid2 = true;
                                const _errs27 = errors;
                                const _errs28 = errors;
                                const _errs29 = errors;
                                const _errs30 = errors;
                                let valid4 = false;
                                let passing1 = null;
                                const _errs31 = errors;
                                if (typeof data9 !== "boolean") {
                                  let coerced10 = void 0;
                                  if (!(coerced10 !== void 0)) {
                                    if (data9 === "false" || data9 === 0 || data9 === null) {
                                      coerced10 = false;
                                    } else if (data9 === "true" || data9 === 1) {
                                      coerced10 = true;
                                    } else {
                                      const err4 = {};
                                      if (vErrors === null) {
                                        vErrors = [err4];
                                      } else {
                                        vErrors.push(err4);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced10 !== void 0) {
                                    data9 = coerced10;
                                    if (data4 !== void 0) {
                                      data4["https"] = coerced10;
                                    }
                                  }
                                }
                                var _valid2 = _errs31 === errors;
                                if (_valid2) {
                                  valid4 = true;
                                  passing1 = 0;
                                }
                                const _errs33 = errors;
                                if (data9 !== null) {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data9 === "" || data9 === 0 || data9 === false) {
                                      coerced11 = null;
                                    } else {
                                      const err5 = {};
                                      if (vErrors === null) {
                                        vErrors = [err5];
                                      } else {
                                        vErrors.push(err5);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data9 = coerced11;
                                    if (data4 !== void 0) {
                                      data4["https"] = coerced11;
                                    }
                                  }
                                }
                                var _valid2 = _errs33 === errors;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                  passing1 = [passing1, 1];
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                    passing1 = 1;
                                  }
                                  const _errs35 = errors;
                                  if (errors === _errs35) {
                                    if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                      let missing0;
                                      if (data9.allowHTTP1 === void 0 && (missing0 = "allowHTTP1")) {
                                        const err6 = {};
                                        if (vErrors === null) {
                                          vErrors = [err6];
                                        } else {
                                          vErrors.push(err6);
                                        }
                                        errors++;
                                      } else {
                                        const _errs37 = errors;
                                        for (const key1 in data9) {
                                          if (!(key1 === "allowHTTP1")) {
                                            delete data9[key1];
                                          }
                                        }
                                        if (_errs37 === errors) {
                                          if (data9.allowHTTP1 !== void 0) {
                                            let data10 = data9.allowHTTP1;
                                            if (typeof data10 !== "boolean") {
                                              let coerced12 = void 0;
                                              if (!(coerced12 !== void 0)) {
                                                if (data10 === "false" || data10 === 0 || data10 === null) {
                                                  coerced12 = false;
                                                } else if (data10 === "true" || data10 === 1) {
                                                  coerced12 = true;
                                                } else {
                                                  const err7 = {};
                                                  if (vErrors === null) {
                                                    vErrors = [err7];
                                                  } else {
                                                    vErrors.push(err7);
                                                  }
                                                  errors++;
                                                }
                                              }
                                              if (coerced12 !== void 0) {
                                                data10 = coerced12;
                                                if (data9 !== void 0) {
                                                  data9["allowHTTP1"] = coerced12;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    } else {
                                      const err8 = {};
                                      if (vErrors === null) {
                                        vErrors = [err8];
                                      } else {
                                        vErrors.push(err8);
                                      }
                                      errors++;
                                    }
                                  }
                                  var _valid2 = _errs35 === errors;
                                  if (_valid2 && valid4) {
                                    valid4 = false;
                                    passing1 = [passing1, 2];
                                  } else {
                                    if (_valid2) {
                                      valid4 = true;
                                      passing1 = 2;
                                    }
                                  }
                                }
                                if (!valid4) {
                                  const err9 = {};
                                  if (vErrors === null) {
                                    vErrors = [err9];
                                  } else {
                                    vErrors.push(err9);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs30;
                                  if (vErrors !== null) {
                                    if (_errs30) {
                                      vErrors.length = _errs30;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var valid3 = _errs29 === errors;
                                if (valid3) {
                                  const err10 = {};
                                  if (vErrors === null) {
                                    vErrors = [err10];
                                  } else {
                                    vErrors.push(err10);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs28;
                                  if (vErrors !== null) {
                                    if (_errs28) {
                                      vErrors.length = _errs28;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var _valid1 = _errs27 === errors;
                                errors = _errs26;
                                if (vErrors !== null) {
                                  if (_errs26) {
                                    vErrors.length = _errs26;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                                if (_valid1) {
                                  const _errs40 = errors;
                                  data4["https"] = true;
                                  var _valid1 = _errs40 === errors;
                                  valid2 = _valid1;
                                }
                                if (!valid2) {
                                  const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                                  if (vErrors === null) {
                                    vErrors = [err11];
                                  } else {
                                    vErrors.push(err11);
                                  }
                                  errors++;
                                  validate10.errors = vErrors;
                                  return false;
                                }
                                var valid0 = _errs25 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                let data11 = data4.ignoreTrailingSlash;
                                const _errs41 = errors;
                                if (typeof data11 !== "boolean") {
                                  let coerced13 = void 0;
                                  if (!(coerced13 !== void 0)) {
                                    if (data11 === "false" || data11 === 0 || data11 === null) {
                                      coerced13 = false;
                                    } else if (data11 === "true" || data11 === 1) {
                                      coerced13 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced13 !== void 0) {
                                    data11 = coerced13;
                                    if (data4 !== void 0) {
                                      data4["ignoreTrailingSlash"] = coerced13;
                                    }
                                  }
                                }
                                var valid0 = _errs41 === errors;
                                if (valid0) {
                                  let data12 = data4.ignoreDuplicateSlashes;
                                  const _errs43 = errors;
                                  if (typeof data12 !== "boolean") {
                                    let coerced14 = void 0;
                                    if (!(coerced14 !== void 0)) {
                                      if (data12 === "false" || data12 === 0 || data12 === null) {
                                        coerced14 = false;
                                      } else if (data12 === "true" || data12 === 1) {
                                        coerced14 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced14 !== void 0) {
                                      data12 = coerced14;
                                      if (data4 !== void 0) {
                                        data4["ignoreDuplicateSlashes"] = coerced14;
                                      }
                                    }
                                  }
                                  var valid0 = _errs43 === errors;
                                  if (valid0) {
                                    let data13 = data4.disableRequestLogging;
                                    const _errs45 = errors;
                                    if (typeof data13 !== "boolean") {
                                      let coerced15 = void 0;
                                      if (!(coerced15 !== void 0)) {
                                        if (data13 === "false" || data13 === 0 || data13 === null) {
                                          coerced15 = false;
                                        } else if (data13 === "true" || data13 === 1) {
                                          coerced15 = true;
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                          return false;
                                        }
                                      }
                                      if (coerced15 !== void 0) {
                                        data13 = coerced15;
                                        if (data4 !== void 0) {
                                          data4["disableRequestLogging"] = coerced15;
                                        }
                                      }
                                    }
                                    var valid0 = _errs45 === errors;
                                    if (valid0) {
                                      let data14 = data4.maxParamLength;
                                      const _errs47 = errors;
                                      if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                                        let dataType16 = typeof data14;
                                        let coerced16 = void 0;
                                        if (!(coerced16 !== void 0)) {
                                          if (dataType16 === "boolean" || data14 === null || dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1)) {
                                            coerced16 = +data14;
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                            return false;
                                          }
                                        }
                                        if (coerced16 !== void 0) {
                                          data14 = coerced16;
                                          if (data4 !== void 0) {
                                            data4["maxParamLength"] = coerced16;
                                          }
                                        }
                                      }
                                      var valid0 = _errs47 === errors;
                                      if (valid0) {
                                        let data15 = data4.onProtoPoisoning;
                                        const _errs49 = errors;
                                        if (typeof data15 !== "string") {
                                          let dataType17 = typeof data15;
                                          let coerced17 = void 0;
                                          if (!(coerced17 !== void 0)) {
                                            if (dataType17 == "number" || dataType17 == "boolean") {
                                              coerced17 = "" + data15;
                                            } else if (data15 === null) {
                                              coerced17 = "";
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          if (coerced17 !== void 0) {
                                            data15 = coerced17;
                                            if (data4 !== void 0) {
                                              data4["onProtoPoisoning"] = coerced17;
                                            }
                                          }
                                        }
                                        var valid0 = _errs49 === errors;
                                        if (valid0) {
                                          let data16 = data4.onConstructorPoisoning;
                                          const _errs51 = errors;
                                          if (typeof data16 !== "string") {
                                            let dataType18 = typeof data16;
                                            let coerced18 = void 0;
                                            if (!(coerced18 !== void 0)) {
                                              if (dataType18 == "number" || dataType18 == "boolean") {
                                                coerced18 = "" + data16;
                                              } else if (data16 === null) {
                                                coerced18 = "";
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            if (coerced18 !== void 0) {
                                              data16 = coerced18;
                                              if (data4 !== void 0) {
                                                data4["onConstructorPoisoning"] = coerced18;
                                              }
                                            }
                                          }
                                          var valid0 = _errs51 === errors;
                                          if (valid0) {
                                            let data17 = data4.pluginTimeout;
                                            const _errs53 = errors;
                                            if (!(typeof data17 == "number" && (!(data17 % 1) && !isNaN(data17)) && isFinite(data17))) {
                                              let dataType19 = typeof data17;
                                              let coerced19 = void 0;
                                              if (!(coerced19 !== void 0)) {
                                                if (dataType19 === "boolean" || data17 === null || dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1)) {
                                                  coerced19 = +data17;
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced19 !== void 0) {
                                                data17 = coerced19;
                                                if (data4 !== void 0) {
                                                  data4["pluginTimeout"] = coerced19;
                                                }
                                              }
                                            }
                                            var valid0 = _errs53 === errors;
                                            if (valid0) {
                                              let data18 = data4.requestIdHeader;
                                              const _errs55 = errors;
                                              const _errs56 = errors;
                                              let valid6 = false;
                                              const _errs57 = errors;
                                              if (typeof data18 !== "boolean") {
                                                let coerced20 = void 0;
                                                if (!(coerced20 !== void 0)) {
                                                  if (data18 === "false" || data18 === 0 || data18 === null) {
                                                    coerced20 = false;
                                                  } else if (data18 === "true" || data18 === 1) {
                                                    coerced20 = true;
                                                  } else {
                                                    const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                    if (vErrors === null) {
                                                      vErrors = [err12];
                                                    } else {
                                                      vErrors.push(err12);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                if (coerced20 !== void 0) {
                                                  data18 = coerced20;
                                                  if (data4 !== void 0) {
                                                    data4["requestIdHeader"] = coerced20;
                                                  }
                                                }
                                              }
                                              var _valid3 = _errs57 === errors;
                                              valid6 = valid6 || _valid3;
                                              if (!valid6) {
                                                const _errs59 = errors;
                                                if (typeof data18 !== "string") {
                                                  let dataType21 = typeof data18;
                                                  let coerced21 = void 0;
                                                  if (!(coerced21 !== void 0)) {
                                                    if (dataType21 == "number" || dataType21 == "boolean") {
                                                      coerced21 = "" + data18;
                                                    } else if (data18 === null) {
                                                      coerced21 = "";
                                                    } else {
                                                      const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                      if (vErrors === null) {
                                                        vErrors = [err13];
                                                      } else {
                                                        vErrors.push(err13);
                                                      }
                                                      errors++;
                                                    }
                                                  }
                                                  if (coerced21 !== void 0) {
                                                    data18 = coerced21;
                                                    if (data4 !== void 0) {
                                                      data4["requestIdHeader"] = coerced21;
                                                    }
                                                  }
                                                }
                                                var _valid3 = _errs59 === errors;
                                                valid6 = valid6 || _valid3;
                                              }
                                              if (!valid6) {
                                                const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err14];
                                                } else {
                                                  vErrors.push(err14);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs56;
                                                if (vErrors !== null) {
                                                  if (_errs56) {
                                                    vErrors.length = _errs56;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs55 === errors;
                                              if (valid0) {
                                                let data19 = data4.requestIdLogLabel;
                                                const _errs61 = errors;
                                                if (typeof data19 !== "string") {
                                                  let dataType22 = typeof data19;
                                                  let coerced22 = void 0;
                                                  if (!(coerced22 !== void 0)) {
                                                    if (dataType22 == "number" || dataType22 == "boolean") {
                                                      coerced22 = "" + data19;
                                                    } else if (data19 === null) {
                                                      coerced22 = "";
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced22 !== void 0) {
                                                    data19 = coerced22;
                                                    if (data4 !== void 0) {
                                                      data4["requestIdLogLabel"] = coerced22;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs61 === errors;
                                                if (valid0) {
                                                  let data20 = data4.http2SessionTimeout;
                                                  const _errs63 = errors;
                                                  if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                                                    let dataType23 = typeof data20;
                                                    let coerced23 = void 0;
                                                    if (!(coerced23 !== void 0)) {
                                                      if (dataType23 === "boolean" || data20 === null || dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1)) {
                                                        coerced23 = +data20;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced23 !== void 0) {
                                                      data20 = coerced23;
                                                      if (data4 !== void 0) {
                                                        data4["http2SessionTimeout"] = coerced23;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs63 === errors;
                                                  if (valid0) {
                                                    let data21 = data4.exposeHeadRoutes;
                                                    const _errs65 = errors;
                                                    if (typeof data21 !== "boolean") {
                                                      let coerced24 = void 0;
                                                      if (!(coerced24 !== void 0)) {
                                                        if (data21 === "false" || data21 === 0 || data21 === null) {
                                                          coerced24 = false;
                                                        } else if (data21 === "true" || data21 === 1) {
                                                          coerced24 = true;
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                          return false;
                                                        }
                                                      }
                                                      if (coerced24 !== void 0) {
                                                        data21 = coerced24;
                                                        if (data4 !== void 0) {
                                                          data4["exposeHeadRoutes"] = coerced24;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs65 === errors;
                                                    if (valid0) {
                                                      let data22 = data4.useSemicolonDelimiter;
                                                      const _errs67 = errors;
                                                      if (typeof data22 !== "boolean") {
                                                        let coerced25 = void 0;
                                                        if (!(coerced25 !== void 0)) {
                                                          if (data22 === "false" || data22 === 0 || data22 === null) {
                                                            coerced25 = false;
                                                          } else if (data22 === "true" || data22 === 1) {
                                                            coerced25 = true;
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                            return false;
                                                          }
                                                        }
                                                        if (coerced25 !== void 0) {
                                                          data22 = coerced25;
                                                          if (data4 !== void 0) {
                                                            data4["useSemicolonDelimiter"] = coerced25;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs67 === errors;
                                                      if (valid0) {
                                                        if (data4.constraints !== void 0) {
                                                          let data23 = data4.constraints;
                                                          const _errs69 = errors;
                                                          if (errors === _errs69) {
                                                            if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                                                              for (const key2 in data23) {
                                                                let data24 = data23[key2];
                                                                const _errs72 = errors;
                                                                if (errors === _errs72) {
                                                                  if (data24 && typeof data24 == "object" && !Array.isArray(data24)) {
                                                                    let missing1;
                                                                    if (data24.name === void 0 && (missing1 = "name") || data24.storage === void 0 && (missing1 = "storage") || data24.validate === void 0 && (missing1 = "validate") || data24.deriveConstraint === void 0 && (missing1 = "deriveConstraint")) {
                                                                      validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                      return false;
                                                                    } else {
                                                                      if (data24.name !== void 0) {
                                                                        let data25 = data24.name;
                                                                        if (typeof data25 !== "string") {
                                                                          let dataType26 = typeof data25;
                                                                          let coerced26 = void 0;
                                                                          if (!(coerced26 !== void 0)) {
                                                                            if (dataType26 == "number" || dataType26 == "boolean") {
                                                                              coerced26 = "" + data25;
                                                                            } else if (data25 === null) {
                                                                              coerced26 = "";
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          if (coerced26 !== void 0) {
                                                                            data25 = coerced26;
                                                                            if (data24 !== void 0) {
                                                                              data24["name"] = coerced26;
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid7 = _errs72 === errors;
                                                                if (!valid7) {
                                                                  break;
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs69 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
    module2.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 72e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "allowUnsafeRegex": false, "disableRequestLogging": false, "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": false, "requestIdLogLabel": "reqId", "http2SessionTimeout": 72e3, "exposeHeadRoutes": true, "useSemicolonDelimiter": false };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/initialConfigValidation.js"(exports2, module2) {
    "use strict";
    var validate = require_configValidator();
    var deepClone = require_rfdc()({ circles: true, proto: false });
    var { FST_ERR_INIT_OPTS_INVALID } = require_errors2();
    function validateInitialConfig(options) {
      const opts = deepClone(options);
      if (!validate(opts)) {
        const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e2) => e2.message)));
        error.errors = validate.errors;
        throw error;
      }
      return deepFreezeObject(opts);
    }
    function deepFreezeObject(object3) {
      const properties = Object.getOwnPropertyNames(object3);
      for (const name of properties) {
        const value = object3[name];
        if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
          continue;
        }
        object3[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
      }
      return Object.freeze(object3);
    }
    module2.exports = validateInitialConfig;
    module2.exports.defaultInitOptions = validate.defaultInitOptions;
    module2.exports.utils = { deepFreezeObject };
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/pluginOverride.js"(exports2, module2) {
    "use strict";
    var {
      kAvvioBoot,
      kChildren,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kPluginNameChain
    } = require_symbols2();
    var Reply = require_reply();
    var Request = require_request();
    var SchemaController = require_schema_controller();
    var ContentTypeParser = require_contentTypeParser();
    var { buildHooks } = require_hooks();
    var pluginUtils = require_pluginUtils();
    module2.exports = function override(old, fn, opts) {
      const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);
      const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
      if (shouldSkipOverride) {
        old[kPluginNameChain].push(fnName);
        return old;
      }
      const instance = Object.create(old);
      old[kChildren].push(instance);
      instance.ready = old[kAvvioBoot].bind(instance);
      instance[kChildren] = [];
      instance[kReply] = Reply.buildReply(instance[kReply]);
      instance[kRequest] = Request.buildRequest(instance[kRequest]);
      instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
      instance[kHooks] = buildHooks(instance[kHooks]);
      instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
      instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
      instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
      instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
      instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
      instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);
      instance[kPluginNameChain] = [fnName];
      if (instance[kLogSerializers] || opts.logSerializers) {
        instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
      }
      if (opts.prefix) {
        instance[kFourOhFour].arrange404(instance);
      }
      for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);
      return instance;
    };
    function buildRoutePrefix(instancePrefix, pluginPrefix) {
      if (!pluginPrefix) {
        return instancePrefix;
      }
      if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
        pluginPrefix = pluginPrefix.slice(1);
      } else if (pluginPrefix[0] !== "/") {
        pluginPrefix = "/" + pluginPrefix;
      }
      return instancePrefix + pluginPrefix;
    }
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/lib/noop-set.js"(exports2, module2) {
    "use strict";
    module2.exports = function noopSet() {
      return {
        [Symbol.iterator]: function* () {
        },
        add() {
        },
        delete() {
        },
        has() {
          return true;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/cookie@1.0.2/node_modules/cookie/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/.pnpm/cookie@1.0.2/node_modules/cookie/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = parse;
    exports2.serialize = serialize;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parse(str, options) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options?.decode || decode2;
      let index = 0;
      do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
          break;
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        if (obj[key] === void 0) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);
          const value = dec(str.slice(valStartIdx, valEndIdx));
          obj[key] = value;
        }
        index = endIdx + 1;
      } while (index < len);
      return obj;
    }
    function startIndex(str, index, max) {
      do {
        const code = str.charCodeAt(index);
        if (code !== 32 && code !== 9)
          return index;
      } while (++index < max);
      return max;
    }
    function endIndex(str, index, min) {
      while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 32 && code !== 9)
          return index + 1;
      }
      return min;
    }
    function serialize(name, val, options) {
      const enc = options?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
      }
      let str = name + "=" + value;
      if (!options)
        return str;
      if (options.maxAge !== void 0) {
        if (!Number.isInteger(options.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
      }
      if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
          throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
      }
      if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
          throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
      }
      if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
      }
      if (options.httpOnly) {
        str += "; HttpOnly";
      }
      if (options.secure) {
        str += "; Secure";
      }
      if (options.partitioned) {
        str += "; Partitioned";
      }
      if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
      }
      if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
      }
      return str;
    }
    function decode2(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e2) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/parse-url.js
var require_parse_url = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/parse-url.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("node:url");
    var BASE_URL2 = "http://localhost";
    module2.exports = function parseURL(url, query) {
      if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
        url = BASE_URL2 + url;
      }
      const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL2), url) : new URL2(url, BASE_URL2);
      if (typeof query === "string") {
        query = new URLSearchParams(query);
        for (const key of query.keys()) {
          result.searchParams.delete(key);
          for (const value of query.getAll(key)) {
            result.searchParams.append(key, value);
          }
        }
      } else {
        const merged = Object.assign({}, url.query, query);
        for (const key in merged) {
          const value = merged[key];
          if (Array.isArray(value)) {
            result.searchParams.delete(key);
            for (const param of value) {
              result.searchParams.append(key, param);
            }
          } else {
            result.searchParams.set(key, value);
          }
        }
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/form-data.js
var require_form_data = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/form-data.js"(exports2, module2) {
    "use strict";
    var { randomUUID } = require("node:crypto");
    var { Readable } = require("node:stream");
    var textEncoder;
    function isFormDataLike(payload) {
      return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
    }
    function formDataToStream(formdata) {
      textEncoder = textEncoder ?? new TextEncoder();
      const boundary = `----formdata-${randomUUID()}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const linebreak = new Uint8Array([13, 10]);
      async function* asyncIterator() {
        for (const [name, value] of formdata) {
          if (typeof value === "string") {
            yield textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
            yield textEncoder.encode(`${normalizeLinefeeds(value)}\r
`);
          } else {
            let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
            value.name && (header += `; filename="${escape2(value.name)}"`);
            header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
            yield textEncoder.encode(header);
            if (value.stream) {
              yield* value.stream();
            } else {
              yield value;
            }
            yield linebreak;
          }
        }
        yield textEncoder.encode(`--${boundary}--`);
      }
      const stream = Readable.from(asyncIterator());
      return {
        stream,
        contentType: `multipart/form-data; boundary=${boundary}`
      };
    }
    module2.exports.isFormDataLike = isFormDataLike;
    module2.exports.formDataToStream = formDataToStream;
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/request.js"(exports2, module2) {
    "use strict";
    var { Readable, addAbortSignal } = require("node:stream");
    var util2 = require("node:util");
    var cookie = require_dist3();
    var assert4 = require("node:assert");
    var { createDeprecation } = require_process_warning();
    var parseURL = require_parse_url();
    var { isFormDataLike, formDataToStream } = require_form_data();
    var { EventEmitter } = require("node:events");
    var FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
      name: "FastifyDeprecationLightMyRequest",
      code: "FST_LIGHTMYREQUEST_DEP01",
      message: 'You are accessing "request.connection", use "request.socket" instead.'
    });
    function hostHeaderFromURL(parsedURL) {
      return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
    }
    var MockSocket = class extends EventEmitter {
      constructor(remoteAddress) {
        super();
        this.remoteAddress = remoteAddress;
      }
    };
    function CustomRequest(options) {
      return new _CustomLMRRequest(this);
      function _CustomLMRRequest(obj) {
        Request.call(obj, {
          ...options,
          Request: void 0
        });
        Object.assign(this, obj);
        for (const fn of Object.keys(Request.prototype)) {
          this.constructor.prototype[fn] = Request.prototype[fn];
        }
        util2.inherits(this.constructor, options.Request);
        return this;
      }
    }
    function Request(options) {
      Readable.call(this, {
        autoDestroy: false
      });
      const parsedURL = parseURL(options.url || options.path, options.query);
      this.url = parsedURL.pathname + parsedURL.search;
      this.aborted = false;
      this.httpVersionMajor = 1;
      this.httpVersionMinor = 1;
      this.httpVersion = "1.1";
      this.method = options.method ? options.method.toUpperCase() : "GET";
      this.headers = {};
      this.rawHeaders = [];
      const headers = options.headers || {};
      for (const field in headers) {
        const fieldLowerCase = field.toLowerCase();
        if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === void 0) {
          this.headers[fieldLowerCase] = void 0;
          continue;
        }
        const value = headers[field];
        assert4(value !== void 0, 'invalid value "undefined" for header ' + field);
        this.headers[fieldLowerCase] = "" + value;
      }
      if ("user-agent" in this.headers === false) {
        this.headers["user-agent"] = "lightMyRequest";
      }
      this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
      if (options.cookies) {
        const { cookies } = options;
        const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
        if (this.headers.cookie) {
          cookieValues.unshift(this.headers.cookie);
        }
        this.headers.cookie = cookieValues.join("; ");
      }
      this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
      Object.defineProperty(this, "connection", {
        get() {
          FST_LIGHTMYREQUEST_DEP01();
          return this.socket;
        },
        configurable: true
      });
      let payload = options.payload || options.body || null;
      let payloadResume = payload && typeof payload.resume === "function";
      if (isFormDataLike(payload)) {
        const stream = formDataToStream(payload);
        payload = stream.stream;
        payloadResume = true;
        this.headers["content-type"] = stream.contentType;
      }
      if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
        payload = JSON.stringify(payload);
        if ("content-type" in this.headers === false) {
          this.headers["content-type"] = "application/json";
        }
      }
      if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
        this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
      }
      for (const header of Object.keys(this.headers)) {
        this.rawHeaders.push(header, this.headers[header]);
      }
      this._lightMyRequest = {
        payload,
        isDone: false,
        simulate: options.simulate || {},
        payloadAsStream: options.payloadAsStream,
        signal: options.signal
      };
      const signal = options.signal;
      if (signal) {
        addAbortSignal(signal, this);
      }
      return this;
    }
    util2.inherits(Request, Readable);
    util2.inherits(CustomRequest, Request);
    Request.prototype.prepare = function(next) {
      const payload = this._lightMyRequest.payload;
      if (!payload || typeof payload.resume !== "function") {
        return next();
      }
      const chunks = [];
      payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
      payload.on("end", () => {
        const payload2 = Buffer.concat(chunks);
        this.headers["content-length"] = this.headers["content-length"] || "" + payload2.length;
        this._lightMyRequest.payload = payload2;
        return next();
      });
      payload.resume();
    };
    Request.prototype._read = function(size) {
      setImmediate(() => {
        if (this._lightMyRequest.isDone) {
          if (this._lightMyRequest.simulate.end !== false) {
            this.push(null);
          }
          return;
        }
        this._lightMyRequest.isDone = true;
        if (this._lightMyRequest.payload) {
          if (this._lightMyRequest.simulate.split) {
            this.push(this._lightMyRequest.payload.slice(0, 1));
            this.push(this._lightMyRequest.payload.slice(1));
          } else {
            this.push(this._lightMyRequest.payload);
          }
        }
        if (this._lightMyRequest.simulate.error) {
          this.emit("error", new Error("Simulated"));
        }
        if (this._lightMyRequest.simulate.close) {
          this.emit("close");
        }
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
      });
    };
    Request.prototype.destroy = function(error) {
      if (this.destroyed || this._lightMyRequest.isDone) return;
      this.destroyed = true;
      if (error) {
        this._error = true;
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    module2.exports = Request;
    module2.exports.Request = Request;
    module2.exports.CustomRequest = CustomRequest;
  }
});

// ../../node_modules/.pnpm/set-cookie-parser@2.7.1/node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "../../node_modules/.pnpm/set-cookie-parser@2.7.1/node_modules/set-cookie-parser/lib/set-cookie.js"(exports2, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e2) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e2
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start2;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start2 = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start2, lastComma));
              start2 = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start2, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/response.js
var require_response = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/response.js"(exports2, module2) {
    "use strict";
    var http3 = require("node:http");
    var { Writable, Readable, addAbortSignal } = require("node:stream");
    var util2 = require("node:util");
    var setCookie = require_set_cookie();
    function Response(req, onEnd, reject) {
      http3.ServerResponse.call(this, req);
      if (req._lightMyRequest?.payloadAsStream) {
        this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read() {
        } }) };
        const signal = req._lightMyRequest.signal;
        if (signal) {
          addAbortSignal(signal, this._lightMyRequest.stream);
        }
      } else {
        this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
      }
      this.setHeader("foo", "bar");
      this.removeHeader("foo");
      this.assignSocket(getNullSocket());
      this._promiseCallback = typeof reject === "function";
      let called = false;
      const onEndSuccess = (payload) => {
        called = true;
        if (this._promiseCallback) {
          return process.nextTick(() => onEnd(payload));
        }
        process.nextTick(() => onEnd(null, payload));
      };
      this._lightMyRequest.onEndSuccess = onEndSuccess;
      const onEndFailure = (err) => {
        if (called) return;
        called = true;
        if (this._lightMyRequest.stream) {
          const res = generatePayload(this);
          res.raw.req = req;
          this._lightMyRequest.stream._read = function() {
            this.destroy(err || new Error("premature close"));
          };
          onEndSuccess(res);
        } else {
          if (this._promiseCallback) {
            return process.nextTick(() => reject(err));
          }
          process.nextTick(() => onEnd(err, null));
        }
      };
      if (this._lightMyRequest.stream) {
        this.once("finish", () => {
          this._lightMyRequest.stream.push(null);
        });
      } else {
        this.once("finish", () => {
          const res = generatePayload(this);
          res.raw.req = req;
          onEndSuccess(res);
        });
      }
      this.connection.once("error", onEndFailure);
      this.once("error", onEndFailure);
      this.once("close", onEndFailure);
    }
    util2.inherits(Response, http3.ServerResponse);
    Response.prototype.setTimeout = function(msecs, callback) {
      this.timeoutHandle = setTimeout(() => {
        this.emit("timeout");
      }, msecs);
      this.on("timeout", callback);
      return this;
    };
    Response.prototype.writeHead = function() {
      const result = http3.ServerResponse.prototype.writeHead.apply(this, arguments);
      copyHeaders(this);
      if (this._lightMyRequest.stream) {
        this._lightMyRequest.onEndSuccess(generatePayload(this));
      }
      return result;
    };
    Response.prototype.write = function(data4, encoding, callback) {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
      http3.ServerResponse.prototype.write.call(this, data4, encoding, callback);
      if (this._lightMyRequest.stream) {
        this._lightMyRequest.stream.push(Buffer.from(data4, encoding));
      } else {
        this._lightMyRequest.payloadChunks.push(Buffer.from(data4, encoding));
      }
      return true;
    };
    Response.prototype.end = function(data4, encoding, callback) {
      if (data4) {
        this.write(data4, encoding);
      }
      http3.ServerResponse.prototype.end.call(this, callback);
      this.emit("finish");
      this.destroy();
    };
    Response.prototype.destroy = function(error) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (error) {
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    Response.prototype.addTrailers = function(trailers) {
      for (const key in trailers) {
        this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
      }
    };
    function generatePayload(response) {
      if (response._lightMyRequest.headers === null) {
        copyHeaders(response);
      }
      serializeHeaders(response);
      const res = {
        raw: {
          res: response
        },
        headers: response._lightMyRequest.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {},
        get cookies() {
          return setCookie.parse(this);
        }
      };
      res.trailers = response._lightMyRequest.trailers;
      if (response._lightMyRequest.payloadChunks) {
        const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
        res.rawPayload = rawBuffer;
        res.payload = rawBuffer.toString();
        res.body = res.payload;
        res.json = function parseJsonPayload() {
          return JSON.parse(res.payload);
        };
      } else {
        res.json = function() {
          throw new Error("Response payload is not available with payloadAsStream: true");
        };
      }
      res.stream = function streamPayload() {
        if (response._lightMyRequest.stream) {
          return response._lightMyRequest.stream;
        }
        return Readable.from(response._lightMyRequest.payloadChunks);
      };
      return res;
    }
    function getNullSocket() {
      return new Writable({
        write(chunk, encoding, callback) {
          setImmediate(callback);
        }
      });
    }
    function serializeHeaders(response) {
      const headers = response._lightMyRequest.headers;
      for (const headerName of Object.keys(headers)) {
        const headerValue = headers[headerName];
        if (Array.isArray(headerValue)) {
          headers[headerName] = headerValue.map((value) => "" + value);
        } else {
          headers[headerName] = "" + headerValue;
        }
      }
    }
    function copyHeaders(response) {
      response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
      ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
        const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
        const field = response._header?.match(regex);
        if (field) {
          response._lightMyRequest.headers[name.toLowerCase()] = field[1];
        }
      });
    }
    module2.exports = Response;
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/config-validator.js
var require_config_validator = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/lib/config-validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "type": "object", "properties": { "url": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "path": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "cookies": { "type": "object", "additionalProperties": true }, "headers": { "type": "object", "additionalProperties": true }, "query": { "anyOf": [{ "type": "object", "additionalProperties": true }, { "type": "string" }] }, "simulate": { "type": "object", "properties": { "end": { "type": "boolean" }, "split": { "type": "boolean" }, "error": { "type": "boolean" }, "close": { "type": "boolean" } } }, "authority": { "type": "string" }, "remoteAddress": { "type": "string" }, "method": { "type": "string", "enum": ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] }, "validate": { "type": "boolean" } }, "additionalProperties": true, "oneOf": [{ "required": ["url"] }, { "required": ["path"] }] };
    function validate10(data4, { instancePath = "", parentData, parentDataProperty, rootData = data4 } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
        let missing0;
        if (data4.url === void 0 && (missing0 = "url")) {
          const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors;
      if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
        let missing1;
        if (data4.path === void 0 && (missing1 = "path")) {
          const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
      }
      var _valid0 = _errs3 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
        validate10.errors = vErrors;
        return false;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      if (errors === 0) {
        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
          if (data4.url !== void 0) {
            let data0 = data4.url;
            const _errs5 = errors;
            const _errs6 = errors;
            let valid2 = false;
            let passing1 = null;
            const _errs7 = errors;
            if (typeof data0 !== "string") {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 == "number" || dataType0 == "boolean") {
                  coerced0 = "" + data0;
                } else if (data0 === null) {
                  coerced0 = "";
                } else {
                  const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors++;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data4 !== void 0) {
                  data4["url"] = coerced0;
                }
              }
            }
            var _valid1 = _errs7 === errors;
            if (_valid1) {
              valid2 = true;
              passing1 = 0;
            }
            const _errs9 = errors;
            if (errors === _errs9) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                let missing2;
                if (data0.pathname === void 0 && (missing2 = "pathname")) {
                  const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors++;
                } else {
                  if (data0.protocol !== void 0) {
                    let data1 = data0.protocol;
                    const _errs12 = errors;
                    if (typeof data1 !== "string") {
                      let dataType1 = typeof data1;
                      let coerced1 = void 0;
                      if (!(coerced1 !== void 0)) {
                        if (dataType1 == "number" || dataType1 == "boolean") {
                          coerced1 = "" + data1;
                        } else if (data1 === null) {
                          coerced1 = "";
                        } else {
                          const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err5];
                          } else {
                            vErrors.push(err5);
                          }
                          errors++;
                        }
                      }
                      if (coerced1 !== void 0) {
                        data1 = coerced1;
                        if (data0 !== void 0) {
                          data0["protocol"] = coerced1;
                        }
                      }
                    }
                    var valid3 = _errs12 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.hostname !== void 0) {
                      let data22 = data0.hostname;
                      const _errs14 = errors;
                      if (typeof data22 !== "string") {
                        let dataType2 = typeof data22;
                        let coerced2 = void 0;
                        if (!(coerced2 !== void 0)) {
                          if (dataType2 == "number" || dataType2 == "boolean") {
                            coerced2 = "" + data22;
                          } else if (data22 === null) {
                            coerced2 = "";
                          } else {
                            const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err6];
                            } else {
                              vErrors.push(err6);
                            }
                            errors++;
                          }
                        }
                        if (coerced2 !== void 0) {
                          data22 = coerced2;
                          if (data0 !== void 0) {
                            data0["hostname"] = coerced2;
                          }
                        }
                      }
                      var valid3 = _errs14 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data0.pathname !== void 0) {
                        let data32 = data0.pathname;
                        const _errs16 = errors;
                        if (typeof data32 !== "string") {
                          let dataType3 = typeof data32;
                          let coerced3 = void 0;
                          if (!(coerced3 !== void 0)) {
                            if (dataType3 == "number" || dataType3 == "boolean") {
                              coerced3 = "" + data32;
                            } else if (data32 === null) {
                              coerced3 = "";
                            } else {
                              const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err7];
                              } else {
                                vErrors.push(err7);
                              }
                              errors++;
                            }
                          }
                          if (coerced3 !== void 0) {
                            data32 = coerced3;
                            if (data0 !== void 0) {
                              data0["pathname"] = coerced3;
                            }
                          }
                        }
                        var valid3 = _errs16 === errors;
                      } else {
                        var valid3 = true;
                      }
                    }
                  }
                }
              } else {
                const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
            var _valid1 = _errs9 === errors;
            if (_valid1 && valid2) {
              valid2 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid1) {
                valid2 = true;
                passing1 = 1;
              }
            }
            if (!valid2) {
              const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors = _errs6;
              if (vErrors !== null) {
                if (_errs6) {
                  vErrors.length = _errs6;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs5 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data4.path !== void 0) {
              let data42 = data4.path;
              const _errs18 = errors;
              const _errs19 = errors;
              let valid4 = false;
              let passing2 = null;
              const _errs20 = errors;
              if (typeof data42 !== "string") {
                let dataType4 = typeof data42;
                let coerced4 = void 0;
                if (!(coerced4 !== void 0)) {
                  if (dataType4 == "number" || dataType4 == "boolean") {
                    coerced4 = "" + data42;
                  } else if (data42 === null) {
                    coerced4 = "";
                  } else {
                    const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err10];
                    } else {
                      vErrors.push(err10);
                    }
                    errors++;
                  }
                }
                if (coerced4 !== void 0) {
                  data42 = coerced4;
                  if (data4 !== void 0) {
                    data4["path"] = coerced4;
                  }
                }
              }
              var _valid2 = _errs20 === errors;
              if (_valid2) {
                valid4 = true;
                passing2 = 0;
              }
              const _errs22 = errors;
              if (errors === _errs22) {
                if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
                  let missing3;
                  if (data42.pathname === void 0 && (missing3 = "pathname")) {
                    const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors++;
                  } else {
                    if (data42.protocol !== void 0) {
                      let data5 = data42.protocol;
                      const _errs25 = errors;
                      if (typeof data5 !== "string") {
                        let dataType5 = typeof data5;
                        let coerced5 = void 0;
                        if (!(coerced5 !== void 0)) {
                          if (dataType5 == "number" || dataType5 == "boolean") {
                            coerced5 = "" + data5;
                          } else if (data5 === null) {
                            coerced5 = "";
                          } else {
                            const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err12];
                            } else {
                              vErrors.push(err12);
                            }
                            errors++;
                          }
                        }
                        if (coerced5 !== void 0) {
                          data5 = coerced5;
                          if (data42 !== void 0) {
                            data42["protocol"] = coerced5;
                          }
                        }
                      }
                      var valid5 = _errs25 === errors;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data42.hostname !== void 0) {
                        let data6 = data42.hostname;
                        const _errs27 = errors;
                        if (typeof data6 !== "string") {
                          let dataType6 = typeof data6;
                          let coerced6 = void 0;
                          if (!(coerced6 !== void 0)) {
                            if (dataType6 == "number" || dataType6 == "boolean") {
                              coerced6 = "" + data6;
                            } else if (data6 === null) {
                              coerced6 = "";
                            } else {
                              const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err13];
                              } else {
                                vErrors.push(err13);
                              }
                              errors++;
                            }
                          }
                          if (coerced6 !== void 0) {
                            data6 = coerced6;
                            if (data42 !== void 0) {
                              data42["hostname"] = coerced6;
                            }
                          }
                        }
                        var valid5 = _errs27 === errors;
                      } else {
                        var valid5 = true;
                      }
                      if (valid5) {
                        if (data42.pathname !== void 0) {
                          let data7 = data42.pathname;
                          const _errs29 = errors;
                          if (typeof data7 !== "string") {
                            let dataType7 = typeof data7;
                            let coerced7 = void 0;
                            if (!(coerced7 !== void 0)) {
                              if (dataType7 == "number" || dataType7 == "boolean") {
                                coerced7 = "" + data7;
                              } else if (data7 === null) {
                                coerced7 = "";
                              } else {
                                const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                if (vErrors === null) {
                                  vErrors = [err14];
                                } else {
                                  vErrors.push(err14);
                                }
                                errors++;
                              }
                            }
                            if (coerced7 !== void 0) {
                              data7 = coerced7;
                              if (data42 !== void 0) {
                                data42["pathname"] = coerced7;
                              }
                            }
                          }
                          var valid5 = _errs29 === errors;
                        } else {
                          var valid5 = true;
                        }
                      }
                    }
                  }
                } else {
                  const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }
                  errors++;
                }
              }
              var _valid2 = _errs22 === errors;
              if (_valid2 && valid4) {
                valid4 = false;
                passing2 = [passing2, 1];
              } else {
                if (_valid2) {
                  valid4 = true;
                  passing2 = 1;
                }
              }
              if (!valid4) {
                const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors++;
                validate10.errors = vErrors;
                return false;
              } else {
                errors = _errs19;
                if (vErrors !== null) {
                  if (_errs19) {
                    vErrors.length = _errs19;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid1 = _errs18 === errors;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data4.cookies !== void 0) {
                let data8 = data4.cookies;
                const _errs31 = errors;
                if (errors === _errs31) {
                  if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                    validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs31 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data4.headers !== void 0) {
                  let data9 = data4.headers;
                  const _errs34 = errors;
                  if (errors === _errs34) {
                    if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                      validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid1 = _errs34 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data4.query !== void 0) {
                    let data10 = data4.query;
                    const _errs37 = errors;
                    const _errs38 = errors;
                    let valid6 = false;
                    const _errs39 = errors;
                    if (errors === _errs39) {
                      if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                        const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                        if (vErrors === null) {
                          vErrors = [err17];
                        } else {
                          vErrors.push(err17);
                        }
                        errors++;
                      }
                    }
                    var _valid3 = _errs39 === errors;
                    valid6 = valid6 || _valid3;
                    if (!valid6) {
                      const _errs42 = errors;
                      if (typeof data10 !== "string") {
                        let dataType8 = typeof data10;
                        let coerced8 = void 0;
                        if (!(coerced8 !== void 0)) {
                          if (dataType8 == "number" || dataType8 == "boolean") {
                            coerced8 = "" + data10;
                          } else if (data10 === null) {
                            coerced8 = "";
                          } else {
                            const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err18];
                            } else {
                              vErrors.push(err18);
                            }
                            errors++;
                          }
                        }
                        if (coerced8 !== void 0) {
                          data10 = coerced8;
                          if (data4 !== void 0) {
                            data4["query"] = coerced8;
                          }
                        }
                      }
                      var _valid3 = _errs42 === errors;
                      valid6 = valid6 || _valid3;
                    }
                    if (!valid6) {
                      const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                      if (vErrors === null) {
                        vErrors = [err19];
                      } else {
                        vErrors.push(err19);
                      }
                      errors++;
                      validate10.errors = vErrors;
                      return false;
                    } else {
                      errors = _errs38;
                      if (vErrors !== null) {
                        if (_errs38) {
                          vErrors.length = _errs38;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid1 = _errs37 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data4.simulate !== void 0) {
                      let data11 = data4.simulate;
                      const _errs44 = errors;
                      if (errors === _errs44) {
                        if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                          if (data11.end !== void 0) {
                            let data12 = data11.end;
                            const _errs46 = errors;
                            if (typeof data12 !== "boolean") {
                              let coerced9 = void 0;
                              if (!(coerced9 !== void 0)) {
                                if (data12 === "false" || data12 === 0 || data12 === null) {
                                  coerced9 = false;
                                } else if (data12 === "true" || data12 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== void 0) {
                                data12 = coerced9;
                                if (data11 !== void 0) {
                                  data11["end"] = coerced9;
                                }
                              }
                            }
                            var valid7 = _errs46 === errors;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.split !== void 0) {
                              let data13 = data11.split;
                              const _errs48 = errors;
                              if (typeof data13 !== "boolean") {
                                let coerced10 = void 0;
                                if (!(coerced10 !== void 0)) {
                                  if (data13 === "false" || data13 === 0 || data13 === null) {
                                    coerced10 = false;
                                  } else if (data13 === "true" || data13 === 1) {
                                    coerced10 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced10 !== void 0) {
                                  data13 = coerced10;
                                  if (data11 !== void 0) {
                                    data11["split"] = coerced10;
                                  }
                                }
                              }
                              var valid7 = _errs48 === errors;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.error !== void 0) {
                                let data14 = data11.error;
                                const _errs50 = errors;
                                if (typeof data14 !== "boolean") {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data14 === "false" || data14 === 0 || data14 === null) {
                                      coerced11 = false;
                                    } else if (data14 === "true" || data14 === 1) {
                                      coerced11 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data14 = coerced11;
                                    if (data11 !== void 0) {
                                      data11["error"] = coerced11;
                                    }
                                  }
                                }
                                var valid7 = _errs50 === errors;
                              } else {
                                var valid7 = true;
                              }
                              if (valid7) {
                                if (data11.close !== void 0) {
                                  let data15 = data11.close;
                                  const _errs52 = errors;
                                  if (typeof data15 !== "boolean") {
                                    let coerced12 = void 0;
                                    if (!(coerced12 !== void 0)) {
                                      if (data15 === "false" || data15 === 0 || data15 === null) {
                                        coerced12 = false;
                                      } else if (data15 === "true" || data15 === 1) {
                                        coerced12 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced12 !== void 0) {
                                      data15 = coerced12;
                                      if (data11 !== void 0) {
                                        data11["close"] = coerced12;
                                      }
                                    }
                                  }
                                  var valid7 = _errs52 === errors;
                                } else {
                                  var valid7 = true;
                                }
                              }
                            }
                          }
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                      var valid1 = _errs44 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data4.authority !== void 0) {
                        let data16 = data4.authority;
                        const _errs54 = errors;
                        if (typeof data16 !== "string") {
                          let dataType13 = typeof data16;
                          let coerced13 = void 0;
                          if (!(coerced13 !== void 0)) {
                            if (dataType13 == "number" || dataType13 == "boolean") {
                              coerced13 = "" + data16;
                            } else if (data16 === null) {
                              coerced13 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced13 !== void 0) {
                            data16 = coerced13;
                            if (data4 !== void 0) {
                              data4["authority"] = coerced13;
                            }
                          }
                        }
                        var valid1 = _errs54 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data4.remoteAddress !== void 0) {
                          let data17 = data4.remoteAddress;
                          const _errs56 = errors;
                          if (typeof data17 !== "string") {
                            let dataType14 = typeof data17;
                            let coerced14 = void 0;
                            if (!(coerced14 !== void 0)) {
                              if (dataType14 == "number" || dataType14 == "boolean") {
                                coerced14 = "" + data17;
                              } else if (data17 === null) {
                                coerced14 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced14 !== void 0) {
                              data17 = coerced14;
                              if (data4 !== void 0) {
                                data4["remoteAddress"] = coerced14;
                              }
                            }
                          }
                          var valid1 = _errs56 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data4.method !== void 0) {
                            let data18 = data4.method;
                            const _errs58 = errors;
                            if (typeof data18 !== "string") {
                              let dataType15 = typeof data18;
                              let coerced15 = void 0;
                              if (!(coerced15 !== void 0)) {
                                if (dataType15 == "number" || dataType15 == "boolean") {
                                  coerced15 = "" + data18;
                                } else if (data18 === null) {
                                  coerced15 = "";
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                              }
                              if (coerced15 !== void 0) {
                                data18 = coerced15;
                                if (data4 !== void 0) {
                                  data4["method"] = coerced15;
                                }
                              }
                            }
                            if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                              validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                              return false;
                            }
                            var valid1 = _errs58 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data4.validate !== void 0) {
                              let data19 = data4.validate;
                              const _errs60 = errors;
                              if (typeof data19 !== "boolean") {
                                let coerced16 = void 0;
                                if (!(coerced16 !== void 0)) {
                                  if (data19 === "false" || data19 === 0 || data19 === null) {
                                    coerced16 = false;
                                  } else if (data19 === "true" || data19 === 1) {
                                    coerced16 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced16 !== void 0) {
                                  data19 = coerced16;
                                  if (data4 !== void 0) {
                                    data4["validate"] = coerced16;
                                  }
                                }
                              }
                              var valid1 = _errs60 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// ../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/index.js
var require_light_my_request = __commonJS({
  "../../node_modules/.pnpm/light-my-request@6.3.0/node_modules/light-my-request/index.js"(exports2, module2) {
    "use strict";
    var assert4 = require("node:assert");
    var Request = require_request2();
    var Response = require_response();
    var errorMessage = "The dispatch function has already been invoked";
    var optsValidator = require_config_validator();
    function inject(dispatchFunc, options, callback) {
      if (callback === void 0) {
        return new Chain(dispatchFunc, options);
      } else {
        return doInject(dispatchFunc, options, callback);
      }
    }
    function makeRequest(dispatchFunc, server, req, res) {
      req.once("error", function(err) {
        if (this.destroyed) res.destroy(err);
      });
      req.once("close", function() {
        if (this.destroyed && !this._error) res.destroy();
      });
      return req.prepare(() => dispatchFunc.call(server, req, res));
    }
    function doInject(dispatchFunc, options, callback) {
      options = typeof options === "string" ? { url: options } : options;
      if (options.validate !== false) {
        assert4(typeof dispatchFunc === "function", "dispatchFunc should be a function");
        const isOptionValid = optsValidator(options);
        if (!isOptionValid) {
          throw new Error(optsValidator.errors.map((e2) => e2.message));
        }
      }
      const server = options.server || {};
      const RequestConstructor = options.Request ? Request.CustomRequest : Request;
      if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response.prototype);
      }
      if (typeof callback === "function") {
        const req = new RequestConstructor(options);
        const res = new Response(req, callback);
        return makeRequest(dispatchFunc, server, req, res);
      } else {
        return new Promise((resolve, reject) => {
          const req = new RequestConstructor(options);
          const res = new Response(req, resolve, reject);
          makeRequest(dispatchFunc, server, req, res);
        });
      }
    }
    function Chain(dispatch, option) {
      if (typeof option === "string") {
        this.option = { url: option };
      } else {
        this.option = Object.assign({}, option);
      }
      this.dispatch = dispatch;
      this._hasInvoked = false;
      this._promise = null;
      if (this.option.autoStart !== false) {
        process.nextTick(() => {
          if (!this._hasInvoked) {
            this.end();
          }
        });
      }
    }
    var httpMethods = [
      "delete",
      "get",
      "head",
      "options",
      "patch",
      "post",
      "put",
      "trace"
    ];
    httpMethods.forEach((method) => {
      Chain.prototype[method] = function(url) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option.url = url;
        this.option.method = method.toUpperCase();
        return this;
      };
    });
    var chainMethods = [
      "body",
      "cookies",
      "headers",
      "payload",
      "query"
    ];
    chainMethods.forEach((method) => {
      Chain.prototype[method] = function(value) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option[method] = value;
        return this;
      };
    });
    Chain.prototype.end = function(callback) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this._hasInvoked = true;
      if (typeof callback === "function") {
        doInject(this.dispatch, this.option, callback);
      } else {
        this._promise = doInject(this.dispatch, this.option);
        return this._promise;
      }
    };
    Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
      if (method === "constructor") return;
      Chain.prototype[method] = function(...args) {
        if (!this._promise) {
          if (this._hasInvoked === true) {
            throw new Error(errorMessage);
          }
          this._hasInvoked = true;
          this._promise = doInject(this.dispatch, this.option);
        }
        return this._promise[method](...args);
      };
    });
    function isInjection(obj) {
      return obj instanceof Request || obj instanceof Response || obj && obj.constructor && obj.constructor.name === "_CustomLMRRequest";
    }
    module2.exports = inject;
    module2.exports.default = inject;
    module2.exports.inject = inject;
    module2.exports.isInjection = isInjection;
  }
});

// ../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/fastify.js
var require_fastify = __commonJS({
  "../../node_modules/.pnpm/fastify@5.1.0/node_modules/fastify/fastify.js"(exports2, module2) {
    "use strict";
    var VERSION = "5.1.0";
    var Avvio = require_boot();
    var http3 = require("node:http");
    var diagnostics = require("node:diagnostics_channel");
    var lightMyRequest;
    var {
      kAvvioBoot,
      kChildren,
      kServerBindings,
      kBodyLimit,
      kSupportedHTTPMethods,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kRequestAcceptVersion,
      kReplySerializerDefault,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kState,
      kOptions,
      kPluginNameChain,
      kSchemaErrorFormatter,
      kErrorHandler,
      kKeepAliveConnections,
      kChildLoggerFactory,
      kGenReqId
    } = require_symbols2();
    var { createServer } = require_server();
    var Reply = require_reply();
    var Request = require_request();
    var Context = require_context();
    var decorator = require_decorate();
    var ContentTypeParser = require_contentTypeParser();
    var SchemaController = require_schema_controller();
    var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks();
    var { createChildLogger, defaultChildLoggerFactory, createLogger } = require_logger_factory();
    var pluginUtils = require_pluginUtils();
    var { getGenReqId, reqIdGenFactory } = require_reqIdGenFactory();
    var { buildRouting, validateBodyLimitOption } = require_route();
    var build404 = require_fourOhFour();
    var getSecuredInitialConfig = require_initialConfigValidation();
    var override = require_pluginOverride();
    var noopSet = require_noop_set();
    var {
      appendStackTrace,
      AVVIO_ERRORS_MAP,
      ...errorCodes
    } = require_errors2();
    var { defaultInitOptions } = getSecuredInitialConfig;
    var {
      FST_ERR_ASYNC_CONSTRAINT,
      FST_ERR_BAD_URL,
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
      FST_ERR_OPTIONS_NOT_OBJ,
      FST_ERR_QSP_NOT_FN,
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
      FST_ERR_INSTANCE_ALREADY_LISTENING,
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_ROUTE_REWRITE_NOT_STR,
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
      FST_ERR_ERROR_HANDLER_NOT_FN,
      FST_ERR_ROUTE_METHOD_INVALID
    } = errorCodes;
    var { buildErrorHandler } = require_error_handler();
    var initChannel = diagnostics.channel("fastify.initialization");
    function defaultBuildPrettyMeta(route) {
      const cleanKeys = {};
      const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
      allowedProps.concat(supportedHooks).forEach((k) => {
        cleanKeys[k] = route.store[k];
      });
      return Object.assign({}, cleanKeys);
    }
    function fastify(options) {
      if (options && typeof options !== "object") {
        throw new FST_ERR_OPTIONS_NOT_OBJ();
      } else {
        options = Object.assign({}, options);
      }
      if (options.querystringParser && typeof options.querystringParser !== "function") {
        throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser);
      }
      if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
        throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
      }
      validateBodyLimitOption(options.bodyLimit);
      const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
      const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
      const requestIdLogLabel = options.requestIdLogLabel || "reqId";
      const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
      const disableRequestLogging = options.disableRequestLogging || false;
      const ajvOptions = Object.assign({
        customOptions: {},
        plugins: []
      }, options.ajv);
      const frameworkErrors = options.frameworkErrors;
      if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
      }
      if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
      }
      const { logger, hasLogger } = createLogger(options);
      options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
      options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
      options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
      options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
      options.logger = logger;
      options.requestIdHeader = requestIdHeader;
      options.requestIdLogLabel = requestIdLogLabel;
      options.disableRequestLogging = disableRequestLogging;
      options.ajv = ajvOptions;
      options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
      const initialConfig = getSecuredInitialConfig(options);
      options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
      const router2 = buildRouting({
        config: {
          defaultRoute,
          onBadUrl,
          constraints: options.constraints,
          ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
          ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
          maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
          caseSensitive: options.caseSensitive,
          allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
          buildPrettyMeta: defaultBuildPrettyMeta,
          querystringParser: options.querystringParser,
          useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
        }
      });
      const fourOhFour = build404(options);
      const httpHandler = wrapRouting(router2, options);
      options.http2SessionTimeout = initialConfig.http2SessionTimeout;
      const { server, listen } = createServer(options, httpHandler);
      const serverHasCloseAllConnections = typeof server.closeAllConnections === "function";
      const serverHasCloseIdleConnections = typeof server.closeIdleConnections === "function";
      let forceCloseConnections = options.forceCloseConnections;
      if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
        throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE();
      } else if (typeof forceCloseConnections !== "boolean") {
        forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
      }
      const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet();
      const setupResponseListeners = Reply.setupResponseListeners;
      const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
      const fastify2 = {
        // Fastify internals
        [kState]: {
          listening: false,
          closing: false,
          started: false,
          ready: false,
          booting: false,
          readyPromise: null
        },
        [kKeepAliveConnections]: keepAliveConnections,
        [kSupportedHTTPMethods]: {
          bodyless: /* @__PURE__ */ new Set([
            // Standard
            "GET",
            "HEAD",
            "TRACE"
          ]),
          bodywith: /* @__PURE__ */ new Set([
            // Standard
            "DELETE",
            "OPTIONS",
            "PATCH",
            "PUT",
            "POST"
          ])
        },
        [kOptions]: options,
        [kChildren]: [],
        [kServerBindings]: [],
        [kBodyLimit]: bodyLimit,
        [kRoutePrefix]: "",
        [kLogLevel]: "",
        [kLogSerializers]: null,
        [kHooks]: new Hooks(),
        [kSchemaController]: schemaController,
        [kSchemaErrorFormatter]: null,
        [kErrorHandler]: buildErrorHandler(),
        [kChildLoggerFactory]: defaultChildLoggerFactory,
        [kReplySerializerDefault]: null,
        [kContentTypeParser]: new ContentTypeParser(
          bodyLimit,
          options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning,
          options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning
        ),
        [kReply]: Reply.buildReply(Reply),
        [kRequest]: Request.buildRequest(Request, options.trustProxy),
        [kFourOhFour]: fourOhFour,
        [pluginUtils.kRegisteredPlugins]: [],
        [kPluginNameChain]: ["fastify"],
        [kAvvioBoot]: null,
        [kGenReqId]: genReqId,
        // routing method
        routing: httpHandler,
        // routes shorthand methods
        delete: function _delete(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "DELETE", url, options: options2, handler });
        },
        get: function _get(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "GET", url, options: options2, handler });
        },
        head: function _head(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "HEAD", url, options: options2, handler });
        },
        trace: function _trace(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "TRACE", url, options: options2, handler });
        },
        patch: function _patch(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "PATCH", url, options: options2, handler });
        },
        post: function _post(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "POST", url, options: options2, handler });
        },
        put: function _put(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "PUT", url, options: options2, handler });
        },
        options: function _options(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "OPTIONS", url, options: options2, handler });
        },
        all: function _all(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: this.supportedMethods, url, options: options2, handler });
        },
        // extended route
        route: function _route(options2) {
          return router2.route.call(this, { options: options2 });
        },
        hasRoute: function _route(options2) {
          return router2.hasRoute.call(this, { options: options2 });
        },
        findRoute: function _findRoute(options2) {
          return router2.findRoute(options2);
        },
        // expose logger instance
        log: logger,
        // type provider
        withTypeProvider,
        // hooks
        addHook,
        // schemas
        addSchema,
        getSchema: schemaController.getSchema.bind(schemaController),
        getSchemas: schemaController.getSchemas.bind(schemaController),
        setValidatorCompiler,
        setSerializerCompiler,
        setSchemaController,
        setReplySerializer,
        setSchemaErrorFormatter,
        // set generated request id
        setGenReqId,
        // custom parsers
        addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
        hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
        getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
        defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
        removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
        removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
        // Fastify architecture methods (initialized by Avvio)
        register: null,
        after: null,
        ready: null,
        onClose: null,
        close: null,
        printPlugins: null,
        hasPlugin: function(name) {
          return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
        },
        // http server
        listen,
        server,
        addresses: function() {
          const binded = this[kServerBindings].map((b3) => b3.address());
          binded.push(this.server.address());
          return binded.filter((adr) => adr);
        },
        // extend fastify objects
        decorate: decorator.add,
        hasDecorator: decorator.exist,
        decorateReply: decorator.decorateReply,
        decorateRequest: decorator.decorateRequest,
        hasRequestDecorator: decorator.existRequest,
        hasReplyDecorator: decorator.existReply,
        addHttpMethod,
        // fake http injection
        inject,
        // pretty print of the registered routes
        printRoutes,
        // custom error handling
        setNotFoundHandler,
        setErrorHandler,
        // child logger
        setChildLoggerFactory,
        // Set fastify initial configuration options read-only object
        initialConfig,
        // constraint strategies
        addConstraintStrategy: router2.addConstraintStrategy.bind(router2),
        hasConstraintStrategy: router2.hasConstraintStrategy.bind(router2)
      };
      Object.defineProperties(fastify2, {
        listeningOrigin: {
          get() {
            const address = this.addresses().slice(-1).pop();
            if (typeof address === "string") {
              return address;
            }
            const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
            return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
          }
        },
        pluginName: {
          configurable: true,
          get() {
            if (this[kPluginNameChain].length > 1) {
              return this[kPluginNameChain].join(" -> ");
            }
            return this[kPluginNameChain][0];
          }
        },
        prefix: {
          configurable: true,
          get() {
            return this[kRoutePrefix];
          }
        },
        validatorCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getValidatorCompiler();
          }
        },
        serializerCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getSerializerCompiler();
          }
        },
        childLoggerFactory: {
          configurable: true,
          get() {
            return this[kChildLoggerFactory];
          }
        },
        version: {
          configurable: true,
          get() {
            return VERSION;
          }
        },
        errorHandler: {
          configurable: true,
          get() {
            return this[kErrorHandler].func;
          }
        },
        genReqId: {
          configurable: true,
          get() {
            return this[kGenReqId];
          }
        },
        supportedMethods: {
          configurable: false,
          get() {
            return [
              ...this[kSupportedHTTPMethods].bodyless,
              ...this[kSupportedHTTPMethods].bodywith
            ];
          }
        }
      });
      if (options.schemaErrorFormatter) {
        validateSchemaErrorFormatter(options.schemaErrorFormatter);
        fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
      }
      const avvioPluginTimeout = Number(options.pluginTimeout);
      const avvio = Avvio(fastify2, {
        autostart: false,
        timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
        expose: {
          use: "register"
        }
      });
      avvio.override = override;
      avvio.on("start", () => fastify2[kState].started = true);
      fastify2[kAvvioBoot] = fastify2.ready;
      fastify2.ready = ready;
      fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
      avvio.once("preReady", () => {
        fastify2.onClose((instance, done) => {
          fastify2[kState].closing = true;
          router2.closeRoutes();
          hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
            if (fastify2[kState].listening) {
              if (forceCloseConnections === "idle") {
                instance.server.closeIdleConnections();
              } else if (serverHasCloseAllConnections && forceCloseConnections) {
                instance.server.closeAllConnections();
              } else if (forceCloseConnections === true) {
                for (const conn of fastify2[kKeepAliveConnections]) {
                  conn.destroy();
                  fastify2[kKeepAliveConnections].delete(conn);
                }
              }
            }
            if (!options.serverFactory || fastify2[kState].listening) {
              instance.server.close(function(err) {
                if (err && err.code !== "ERR_SERVER_NOT_RUNNING") {
                  done(null);
                } else {
                  done();
                }
              });
            } else {
              process.nextTick(done, null);
            }
          });
        });
      });
      const onBadUrlContext = new Context({
        server: fastify2,
        config: {}
      });
      fastify2.setNotFoundHandler();
      fourOhFour.arrange404(fastify2);
      router2.setup(options, {
        avvio,
        fourOhFour,
        logger,
        hasLogger,
        setupResponseListeners,
        throwIfAlreadyStarted,
        keepAliveConnections
      });
      server.on("clientError", options.clientErrorHandler.bind(fastify2));
      if (initChannel.hasSubscribers) {
        initChannel.publish({ fastify: fastify2 });
      }
      if ("asyncDispose" in Symbol) {
        fastify2[Symbol.asyncDispose] = function dispose() {
          return fastify2.close();
        };
      }
      return fastify2;
      function throwIfAlreadyStarted(msg) {
        if (fastify2[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
      }
      function inject(opts, cb) {
        if (lightMyRequest === void 0) {
          lightMyRequest = require_light_my_request();
        }
        if (fastify2[kState].started) {
          if (fastify2[kState].closing) {
            const error = new FST_ERR_REOPENED_CLOSE_SERVER();
            if (cb) {
              cb(error);
              return;
            } else {
              return Promise.reject(error);
            }
          }
          return lightMyRequest(httpHandler, opts, cb);
        }
        if (cb) {
          this.ready((err) => {
            if (err) cb(err, null);
            else lightMyRequest(httpHandler, opts, cb);
          });
        } else {
          return lightMyRequest((req, res) => {
            this.ready(function(err) {
              if (err) {
                res.emit("error", err);
                return;
              }
              httpHandler(req, res);
            });
          }, opts);
        }
      }
      function ready(cb) {
        if (this[kState].readyPromise !== null) {
          if (cb != null) {
            this[kState].readyPromise.then(() => cb(null, fastify2), cb);
            return;
          }
          return this[kState].readyPromise;
        }
        let resolveReady;
        let rejectReady;
        process.nextTick(runHooks);
        this[kState].readyPromise = new Promise(function(resolve, reject) {
          resolveReady = resolve;
          rejectReady = reject;
        });
        if (!cb) {
          return this[kState].readyPromise;
        } else {
          this[kState].readyPromise.then(() => cb(null, fastify2), cb);
        }
        function runHooks() {
          fastify2[kAvvioBoot]((err, done) => {
            if (err || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
              manageErr(err);
            } else {
              fastify2[kState].booting = true;
              hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
            }
            done();
          });
        }
        function manageErr(err) {
          err = err != null && AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          if (err) {
            return rejectReady(err);
          }
          resolveReady(fastify2);
          fastify2[kState].booting = false;
          fastify2[kState].ready = true;
          fastify2[kState].promise = null;
        }
      }
      function withTypeProvider() {
        return this;
      }
      function addHook(name, fn) {
        throwIfAlreadyStarted('Cannot call "addHook"!');
        if (fn == null) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
        }
        if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onReady" || name === "onListen") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onRequestAbort") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        }
        if (name === "onClose") {
          this.onClose(fn.bind(this));
        } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
          this[kHooks].add(name, fn);
        } else {
          this.after((err, done) => {
            _addHook.call(this, name, fn);
            done(err);
          });
        }
        return this;
        function _addHook(name2, fn2) {
          this[kHooks].add(name2, fn2);
          this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
        }
      }
      function addSchema(schema) {
        throwIfAlreadyStarted('Cannot call "addSchema"!');
        this[kSchemaController].add(schema);
        this[kChildren].forEach((child) => child.addSchema(schema));
        return this;
      }
      function defaultClientErrorHandler(err, socket) {
        if (err.code === "ECONNRESET" || socket.destroyed) {
          return;
        }
        let body, errorCode, errorStatus, errorLabel;
        if (err.code === "ERR_HTTP_REQUEST_TIMEOUT") {
          errorCode = "408";
          errorStatus = http3.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
          errorLabel = "timeout";
        } else if (err.code === "HPE_HEADER_OVERFLOW") {
          errorCode = "431";
          errorStatus = http3.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
          errorLabel = "header_overflow";
        } else {
          errorCode = "400";
          errorStatus = http3.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
          errorLabel = "error";
        }
        this.log.trace({ err }, `client ${errorLabel}`);
        if (socket.writable) {
          socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
        }
        socket.destroy(err);
      }
      function defaultRoute(req, res) {
        if (req.headers["accept-version"] !== void 0) {
          req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
          req.headers["accept-version"] = void 0;
        }
        fourOhFour.router.lookup(req, res);
      }
      function onBadUrl(path, req, res) {
        if (frameworkErrors) {
          const id3 = getGenReqId(onBadUrlContext.server, req);
          const childLogger = createChildLogger(onBadUrlContext, logger, req, id3);
          const request = new Request(id3, null, req, null, childLogger, onBadUrlContext);
          const reply = new Reply(res, request, childLogger);
          if (disableRequestLogging === false) {
            childLogger.info({ req: request }, "incoming request");
          }
          return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply);
        }
        const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
        res.writeHead(400, {
          "Content-Type": "application/json",
          "Content-Length": body.length
        });
        res.end(body);
      }
      function buildAsyncConstraintCallback(isAsync2, req, res) {
        if (isAsync2 === false) return void 0;
        return function onAsyncConstraintError(err) {
          if (err) {
            if (frameworkErrors) {
              const id3 = getGenReqId(onBadUrlContext.server, req);
              const childLogger = createChildLogger(onBadUrlContext, logger, req, id3);
              const request = new Request(id3, null, req, null, childLogger, onBadUrlContext);
              const reply = new Reply(res, request, childLogger);
              if (disableRequestLogging === false) {
                childLogger.info({ req: request }, "incoming request");
              }
              return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request, reply);
            }
            const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
            res.writeHead(500, {
              "Content-Type": "application/json",
              "Content-Length": body.length
            });
            res.end(body);
          }
        };
      }
      function setNotFoundHandler(opts, handler) {
        throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
        fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router2.routeHandler);
        return this;
      }
      function setValidatorCompiler(validatorCompiler) {
        throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
        this[kSchemaController].setValidatorCompiler(validatorCompiler);
        return this;
      }
      function setSchemaErrorFormatter(errorFormatter) {
        throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
        validateSchemaErrorFormatter(errorFormatter);
        this[kSchemaErrorFormatter] = errorFormatter.bind(this);
        return this;
      }
      function setSerializerCompiler(serializerCompiler) {
        throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
        this[kSchemaController].setSerializerCompiler(serializerCompiler);
        return this;
      }
      function setSchemaController(schemaControllerOpts) {
        throwIfAlreadyStarted('Cannot call "setSchemaController"!');
        const old = this[kSchemaController];
        const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
        this[kSchemaController] = schemaController2;
        this.getSchema = schemaController2.getSchema.bind(schemaController2);
        this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
        return this;
      }
      function setReplySerializer(replySerializer) {
        throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
        this[kReplySerializerDefault] = replySerializer;
        return this;
      }
      function setErrorHandler(func) {
        throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
        if (typeof func !== "function") {
          throw new FST_ERR_ERROR_HANDLER_NOT_FN();
        }
        this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
        return this;
      }
      function setChildLoggerFactory(factory) {
        throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
        this[kChildLoggerFactory] = factory;
        return this;
      }
      function printRoutes(opts = {}) {
        opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
        return router2.printRoutes(opts);
      }
      function wrapRouting(router3, { rewriteUrl, logger: logger2 }) {
        let isAsync2;
        return function preRouting(req, res) {
          if (isAsync2 === void 0) isAsync2 = router3.isAsyncConstraint();
          if (rewriteUrl) {
            req.originalUrl = req.url;
            const url = rewriteUrl.call(fastify2, req);
            if (typeof url === "string") {
              req.url = url;
            } else {
              const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
              req.destroy(err);
            }
          }
          router3.routing(req, res, buildAsyncConstraintCallback(isAsync2, req, res));
        };
      }
      function setGenReqId(func) {
        throwIfAlreadyStarted('Cannot call "setGenReqId"!');
        this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
        return this;
      }
      function addHttpMethod(method, { hasBody = false } = {}) {
        if (typeof method !== "string" || http3.METHODS.indexOf(method) === -1) {
          throw new FST_ERR_ROUTE_METHOD_INVALID();
        }
        if (hasBody === true) {
          this[kSupportedHTTPMethods].bodywith.add(method);
          this[kSupportedHTTPMethods].bodyless.delete(method);
        } else {
          this[kSupportedHTTPMethods].bodywith.delete(method);
          this[kSupportedHTTPMethods].bodyless.add(method);
        }
        const _method = method.toLowerCase();
        if (!this.hasDecorator(_method)) {
          this.decorate(_method, function(url, options2, handler) {
            return router2.prepareRoute.call(this, { method, url, options: options2, handler });
          });
        }
        return this;
      }
    }
    function validateSchemaErrorFormatter(schemaErrorFormatter) {
      if (typeof schemaErrorFormatter !== "function") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
      } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
      }
    }
    module2.exports = fastify;
    module2.exports.errorCodes = errorCodes;
    module2.exports.fastify = fastify;
    module2.exports.default = fastify;
  }
});

// ../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/getPluginName.js
var require_getPluginName = __commonJS({
  "../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/getPluginName.js"(exports2, module2) {
    "use strict";
    var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module2.exports = function getPluginName(fn) {
      if (fn.name.length > 0) return fn.name;
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 10;
      try {
        throw new Error("anonymous function");
      } catch (e2) {
        Error.stackTraceLimit = stackTraceLimit;
        return extractPluginName(e2.stack);
      }
    };
    function extractPluginName(stack) {
      const m = stack.match(fpStackTracePattern);
      return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    }
    module2.exports.extractPluginName = extractPluginName;
  }
});

// ../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/toCamelCase.js
var require_toCamelCase = __commonJS({
  "../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/toCamelCase.js"(exports2, module2) {
    "use strict";
    module2.exports = function toCamelCase(name) {
      if (name[0] === "@") {
        name = name.slice(1).replace("/", "-");
      }
      return name.replace(/-(.)/g, function(match, g1) {
        return g1.toUpperCase();
      });
    };
  }
});

// ../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/plugin.js
var require_plugin2 = __commonJS({
  "../../node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/plugin.js"(exports2, module2) {
    "use strict";
    var getPluginName = require_getPluginName();
    var toCamelCase = require_toCamelCase();
    var count = 0;
    function plugin(fn, options = {}) {
      let autoName = false;
      if (fn.default !== void 0) {
        fn = fn.default;
      }
      if (typeof fn !== "function") {
        throw new TypeError(
          `fastify-plugin expects a function, instead got a '${typeof fn}'`
        );
      }
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = getPluginName(fn) + "-auto-" + count++;
      }
      fn[Symbol.for("skip-override")] = options.encapsulate !== true;
      fn[Symbol.for("fastify.display-name")] = options.name;
      fn[Symbol.for("plugin-meta")] = options;
      if (!fn.default) {
        fn.default = fn;
      }
      const camelCase = toCamelCase(options.name);
      if (!autoName && !fn[camelCase]) {
        fn[camelCase] = fn;
      }
      return fn;
    }
    module2.exports = plugin;
    module2.exports.default = plugin;
    module2.exports.fastifyPlugin = plugin;
  }
});

// ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iterator.js"(exports2, module2) {
    function Iterator(next) {
      if (typeof next !== "function")
        throw new Error("obliterator/iterator: expecting a function!");
      this.next = next;
    }
    if (typeof Symbol !== "undefined")
      Iterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator.of = function() {
      var args = arguments, l = args.length, i = 0;
      return new Iterator(function() {
        if (i >= l) return { done: true };
        return { done: false, value: args[i++] };
      });
    };
    Iterator.empty = function() {
      var iterator = new Iterator(function() {
        return { done: true };
      });
      return iterator;
    };
    Iterator.fromSequence = function(sequence) {
      var i = 0, l = sequence.length;
      return new Iterator(function() {
        if (i >= l) return { done: true };
        return { done: false, value: sequence[i++] };
      });
    };
    Iterator.is = function(value) {
      if (value instanceof Iterator) return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module2.exports = Iterator;
  }
});

// ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/support.js
var require_support = __commonJS({
  "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/support.js"(exports2) {
    exports2.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    exports2.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
  }
});

// ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/foreach.js
var require_foreach = __commonJS({
  "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/foreach.js"(exports2, module2) {
    var support = require_support();
    var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
    var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
    module2.exports = function forEach(iterable, callback) {
      var iterator, k, i, l, s2;
      if (!iterable) throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i = 0;
        while (s2 = iterator.next(), s2.done !== true) {
          callback(s2.value, i);
          i++;
        }
        return;
      }
      for (k in iterable) {
        if (iterable.hasOwnProperty(k)) {
          callback(iterable[k], k);
        }
      }
      return;
    };
  }
});

// ../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS({
  "../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/typed-arrays.js"(exports2) {
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports2.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
    };
    exports2.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports2.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports2.getMinimalRepresentation = function(array, getter) {
      var maxType = null, maxPriority = 0, p, t, v, i, l;
      for (i = 0, l = array.length; i < l; i++) {
        v = getter ? getter(array[i]) : array[i];
        t = exports2.getNumberType(v);
        p = TYPE_PRIORITY[t.name];
        if (p > maxPriority) {
          maxPriority = p;
          maxType = t;
        }
      }
      return maxType;
    };
    exports2.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports2.concat = function() {
      var length = 0, i, o, l;
      for (i = 0, l = arguments.length; i < l; i++)
        length += arguments[i].length;
      var array = new arguments[0].constructor(length);
      for (i = 0, o = 0; i < l; i++) {
        array.set(arguments[i], o);
        o += arguments[i].length;
      }
      return array;
    };
    exports2.indices = function(length) {
      var PointerArray = exports2.getPointerArray(length);
      var array = new PointerArray(length);
      for (var i = 0; i < length; i++)
        array[i] = i;
      return array;
    };
  }
});

// ../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS({
  "../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/iterables.js"(exports2) {
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray2(target) {
      var l = guessLength(target);
      var array = typeof l === "number" ? new Array(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i++] = value;
      });
      return array;
    }
    function toArrayWithIndices(target) {
      var l = guessLength(target);
      var IndexArray = typeof l === "number" ? typed.getPointerArray(l) : Array;
      var array = typeof l === "number" ? new Array(l) : [];
      var indices = typeof l === "number" ? new IndexArray(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i] = value;
        indices[i] = i++;
      });
      return [array, indices];
    }
    exports2.isArrayLike = isArrayLike;
    exports2.guessLength = guessLength;
    exports2.toArray = toArray2;
    exports2.toArrayWithIndices = toArrayWithIndices;
  }
});

// ../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/lru-cache.js
var require_lru_cache = __commonJS({
  "../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/lru-cache.js"(exports2, module2) {
    var Iterator = require_iterator();
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    var iterables = require_iterables();
    function LRUCache(Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      this.capacity = capacity;
      if (typeof this.capacity !== "number" || this.capacity <= 0)
        throw new Error("mnemonist/lru-cache: capacity should be positive number.");
      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)
        throw new Error("mnemonist/lru-cache: capacity should be a finite positive integer.");
      var PointerArray = typed.getPointerArray(capacity);
      this.forward = new PointerArray(capacity);
      this.backward = new PointerArray(capacity);
      this.K = typeof Keys === "function" ? new Keys(capacity) : new Array(capacity);
      this.V = typeof Values === "function" ? new Values(capacity) : new Array(capacity);
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    }
    LRUCache.prototype.clear = function() {
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    };
    LRUCache.prototype.splayOnTop = function(pointer) {
      var oldHead = this.head;
      if (this.head === pointer)
        return this;
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.tail === pointer) {
        this.tail = previous;
      } else {
        this.backward[next] = previous;
      }
      this.forward[previous] = next;
      this.backward[oldHead] = pointer;
      this.head = pointer;
      this.forward[pointer] = oldHead;
      return this;
    };
    LRUCache.prototype.set = function(key, value) {
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
    };
    LRUCache.prototype.setpop = function(key, value) {
      var oldValue = null;
      var oldKey = null;
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return { evicted: false, key, value: oldValue };
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[oldKey];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
      if (oldKey) {
        return { evicted: true, key: oldKey, value: oldValue };
      } else {
        return null;
      }
    };
    LRUCache.prototype.has = function(key) {
      return key in this.items;
    };
    LRUCache.prototype.get = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      this.splayOnTop(pointer);
      return this.V[pointer];
    };
    LRUCache.prototype.peek = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      return this.V[pointer];
    };
    LRUCache.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      while (i < l) {
        callback.call(scope, values[pointer], keys[pointer], this);
        pointer = forward[pointer];
        i++;
      }
    };
    LRUCache.prototype.keys = function() {
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var key = keys[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value: key
        };
      });
    };
    LRUCache.prototype.values = function() {
      var i = 0, l = this.size;
      var pointer = this.head, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var value = values[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value
        };
      });
    };
    LRUCache.prototype.entries = function() {
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var key = keys[pointer], value = values[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value: [key, value]
        };
      });
    };
    if (typeof Symbol !== "undefined")
      LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;
    LRUCache.prototype.inspect = function() {
      var proxy = /* @__PURE__ */ new Map();
      var iterator = this.entries(), step;
      while (step = iterator.next(), !step.done)
        proxy.set(step.value[0], step.value[1]);
      Object.defineProperty(proxy, "constructor", {
        value: LRUCache,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      LRUCache.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache.prototype.inspect;
    LRUCache.from = function(iterable, Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
      } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      var cache = new LRUCache(Keys, Values, capacity);
      forEach(iterable, function(value, key) {
        cache.set(key, value);
      });
      return cache;
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/@fastify+cors@10.0.1/node_modules/@fastify/cors/vary.js
var require_vary = __commonJS({
  "../../node_modules/.pnpm/@fastify+cors@10.0.1/node_modules/@fastify/cors/vary.js"(exports2, module2) {
    "use strict";
    var LRUCache = require_lru_cache();
    var validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
    function validateFieldname(fieldname) {
      if (validFieldnameRE.test(fieldname) === false) {
        throw new TypeError("Fieldname contains invalid characters.");
      }
    }
    function parse(header) {
      header = header.trim().toLowerCase();
      const result = [];
      if (header.length === 0) {
      } else if (header.indexOf(",") === -1) {
        result.push(header);
      } else {
        const il = header.length;
        let i = 0;
        let pos = 0;
        let char;
        for (i = 0; i < il; ++i) {
          char = header[i];
          if (char === " ") {
            pos = i + 1;
          } else if (char === ",") {
            if (pos !== i) {
              result.push(header.slice(pos, i));
            }
            pos = i + 1;
          }
        }
        if (pos !== i) {
          result.push(header.slice(pos, i));
        }
      }
      return result;
    }
    function createAddFieldnameToVary(fieldname) {
      const headerCache = new LRUCache(1e3);
      validateFieldname(fieldname);
      return function(reply) {
        let header = reply.getHeader("Vary");
        if (!header) {
          reply.header("Vary", fieldname);
          return;
        }
        if (header === "*") {
          return;
        }
        if (fieldname === "*") {
          reply.header("Vary", "*");
          return;
        }
        if (Array.isArray(header)) {
          header = header.join(", ");
        }
        if (!headerCache.has(header)) {
          const vals = parse(header);
          if (vals.indexOf("*") !== -1) {
            headerCache.set(header, "*");
          } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
            headerCache.set(header, header + ", " + fieldname);
          } else {
            headerCache.set(header, null);
          }
        }
        const cached = headerCache.get(header);
        if (cached !== null) {
          reply.header("Vary", cached);
        }
      };
    }
    module2.exports.createAddFieldnameToVary = createAddFieldnameToVary;
    module2.exports.addOriginToVaryHeader = createAddFieldnameToVary("Origin");
    module2.exports.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary("Access-Control-Request-Headers");
    module2.exports.parse = parse;
  }
});

// ../../node_modules/.pnpm/@fastify+cors@10.0.1/node_modules/@fastify/cors/index.js
var require_cors = __commonJS({
  "../../node_modules/.pnpm/@fastify+cors@10.0.1/node_modules/@fastify/cors/index.js"(exports2, module2) {
    "use strict";
    var fp = require_plugin2();
    var {
      addAccessControlRequestHeadersToVaryHeader,
      addOriginToVaryHeader
    } = require_vary();
    var defaultOptions5 = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      hook: "onRequest",
      preflightContinue: false,
      optionsSuccessStatus: 204,
      credentials: false,
      exposedHeaders: null,
      allowedHeaders: null,
      maxAge: null,
      preflight: true,
      strictPreflight: true
    };
    var validHooks = [
      "onRequest",
      "preParsing",
      "preValidation",
      "preHandler",
      "preSerialization",
      "onSend"
    ];
    var hookWithPayload = [
      "preSerialization",
      "preParsing",
      "onSend"
    ];
    function validateHook(value, next) {
      if (validHooks.indexOf(value) !== -1) {
        return;
      }
      next(new TypeError("@fastify/cors: Invalid hook option provided."));
    }
    function fastifyCors(fastify, opts, next) {
      fastify.decorateRequest("corsPreflightEnabled", false);
      let hideOptionsRoute = true;
      if (typeof opts === "function") {
        handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions5.hook }, next);
      } else if (opts.delegator) {
        const { delegator, ...options } = opts;
        handleCorsOptionsDelegator(delegator, fastify, options, next);
      } else {
        if (opts.hideOptionsRoute !== void 0) hideOptionsRoute = opts.hideOptionsRoute;
        const corsOptions = normalizeCorsOptions(opts);
        validateHook(corsOptions.hook, next);
        if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, payload, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        } else {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        }
      }
      fastify.options("*", { schema: { hide: hideOptionsRoute } }, (req, reply) => {
        if (!req.corsPreflightEnabled) {
          reply.callNotFound();
          return;
        }
        reply.send();
      });
      next();
    }
    function handleCorsOptionsDelegator(optionsResolver, fastify, opts, next) {
      const hook = opts && opts.hook || defaultOptions5.hook;
      validateHook(hook, next);
      if (optionsResolver.length === 2) {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, payload, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        }
      } else {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, payload, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        }
      }
    }
    function handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next) {
      optionsResolver(req, (err, options) => {
        if (err) {
          next(err);
        } else {
          addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
        }
      });
    }
    function normalizeCorsOptions(opts, dynamic) {
      const corsOptions = { ...defaultOptions5, ...opts };
      if (Array.isArray(opts.origin) && opts.origin.indexOf("*") !== -1) {
        corsOptions.origin = "*";
      }
      if (Number.isInteger(corsOptions.cacheControl)) {
        corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
      } else if (typeof corsOptions.cacheControl !== "string") {
        corsOptions.cacheControl = null;
      }
      corsOptions.dynamic = dynamic || false;
      return corsOptions;
    }
    function addCorsHeadersHandler(fastify, options, req, reply, next) {
      if (typeof options.origin !== "string" && options.origin !== false || options.dynamic) {
        addOriginToVaryHeader(reply);
      }
      const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin);
      resolveOriginOption(req, (error, resolvedOriginOption) => {
        if (error !== null) {
          return next(error);
        }
        if (resolvedOriginOption === false) {
          return next();
        }
        if (!resolvedOriginOption) {
          return next(new Error("Invalid CORS origin option"));
        }
        addCorsHeaders(req, reply, resolvedOriginOption, options);
        if (req.raw.method === "OPTIONS" && options.preflight === true) {
          if (options.strictPreflight === true && (!req.headers.origin || !req.headers["access-control-request-method"])) {
            reply.status(400).type("text/plain").send("Invalid Preflight Request");
            return;
          }
          req.corsPreflightEnabled = true;
          addPreflightHeaders(req, reply, options);
          if (!options.preflightContinue) {
            reply.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
            return;
          }
        }
        return next();
      });
    }
    function addCorsHeaders(req, reply, originOption, corsOptions) {
      const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
      if (origin) {
        reply.header("Access-Control-Allow-Origin", origin);
      }
      if (corsOptions.credentials) {
        reply.header("Access-Control-Allow-Credentials", "true");
      }
      if (corsOptions.exposedHeaders !== null) {
        reply.header(
          "Access-Control-Expose-Headers",
          Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders
        );
      }
    }
    function addPreflightHeaders(req, reply, corsOptions) {
      reply.header(
        "Access-Control-Allow-Methods",
        Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods
      );
      if (corsOptions.allowedHeaders === null) {
        addAccessControlRequestHeadersToVaryHeader(reply);
        const reqAllowedHeaders = req.headers["access-control-request-headers"];
        if (reqAllowedHeaders !== void 0) {
          reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
        }
      } else {
        reply.header(
          "Access-Control-Allow-Headers",
          Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders
        );
      }
      if (corsOptions.maxAge !== null) {
        reply.header("Access-Control-Max-Age", String(corsOptions.maxAge));
      }
      if (corsOptions.cacheControl) {
        reply.header("Cache-Control", corsOptions.cacheControl);
      }
    }
    function resolveOriginWrapper(fastify, origin) {
      return function(req, cb) {
        const result = origin.call(fastify, req.headers.origin, cb);
        if (result && typeof result.then === "function") {
          result.then((res) => cb(null, res), cb);
        }
      };
    }
    function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
      if (typeof originOption === "string") {
        return originOption;
      }
      return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
    }
    function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (let i = 0; i < allowedOrigin.length; ++i) {
          if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (typeof allowedOrigin === "string") {
        return reqOrigin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        allowedOrigin.lastIndex = 0;
        return allowedOrigin.test(reqOrigin);
      } else {
        return !!allowedOrigin;
      }
    }
    var _fastifyCors = fp(fastifyCors, {
      fastify: "5.x",
      name: "@fastify/cors"
    });
    module2.exports = _fastifyCors;
    module2.exports.fastifyCors = _fastifyCors;
    module2.exports.default = _fastifyCors;
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream3(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data4 = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data4)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream3;
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants3();
    var FastBuffer = Buffer[Symbol.species];
    function concat4(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask4, output2, offset, length) {
      for (let i = 0; i < length; i++) {
        output2[offset + i] = source[i] ^ mask4[i & 3];
      }
    }
    function _unmask(buffer, mask4) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask4[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data4) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data4)) return data4;
      let buf;
      if (data4 instanceof ArrayBuffer) {
        buf = new FastBuffer(data4);
      } else if (ArrayBuffer.isView(data4)) {
        buf = new FastBuffer(data4.buffer, data4.byteOffset, data4.byteLength);
      } else {
        buf = Buffer.from(data4);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat: concat4,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask4, output2, offset, length) {
          if (length < 48) _mask(source, mask4, output2, offset, length);
          else bufferUtil.mask(source, mask4, output2, offset, length);
        };
        module2.exports.unmask = function(buffer, mask4) {
          if (buffer.length < 32) _unmask(buffer, mask4);
          else bufferUtil.unmask(buffer, mask4);
        };
      } catch (e2) {
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants3();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data4, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data4, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data4, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data4, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data4, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data4);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data5 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data5);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data4, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data4);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data5 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data5 = new FastBuffer(data5.buffer, data5.byteOffset, data5.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data5);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js
var require_validation3 = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e2) {
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants3();
    var { concat: concat4, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation3();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver3 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n3) {
        this._bufferedBytes -= n3;
        if (n3 === this._buffers[0].length) return this._buffers.shift();
        if (n3 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n3,
            buf.length - n3
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n3);
        }
        const dst = Buffer.allocUnsafe(n3);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n3;
          if (n3 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n3,
              buf.length - n3
            );
          }
          n3 -= buf.length;
        } while (n3 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data4 = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data4 = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data4, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data4, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data4, cb);
          return;
        }
        if (data4.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data4);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data4, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data4, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data4;
          if (this._binaryType === "nodebuffer") {
            data4 = concat4(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data4 = toArrayBuffer(concat4(fragments, messageLength));
          } else {
            data4 = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data4, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data4, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat4(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data4, cb) {
        if (this._opcode === 8) {
          if (data4.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data4.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data4.buffer,
              data4.byteOffset + 2,
              data4.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data4);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data4);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver3;
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants3();
    var { isValidStatusCode } = require_validation3();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var Sender3 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data4, options) {
        let mask4;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask4 = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask4);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask4[0] = randomPool[randomPoolPointer++];
            mask4[1] = randomPool[randomPoolPointer++];
            mask4[2] = randomPool[randomPoolPointer++];
            mask4[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask4[0] | mask4[1] | mask4[2] | mask4[3]) === 0;
          offset = 6;
        }
        let dataLength4;
        if (typeof data4 === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength4 = options[kByteLength];
          } else {
            data4 = Buffer.from(data4);
            dataLength4 = data4.length;
          }
        } else {
          dataLength4 = data4.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength4;
        if (dataLength4 >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength4 > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength4 + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength4, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength4, 4, 6);
        }
        if (!options.mask) return [target, data4];
        target[1] |= 128;
        target[offset - 4] = mask4[0];
        target[offset - 3] = mask4[1];
        target[offset - 2] = mask4[2];
        target[offset - 1] = mask4[3];
        if (skipMasking) return [target, data4];
        if (merge) {
          applyMask(data4, mask4, target, offset, dataLength4);
          return [target];
        }
        applyMask(data4, mask4, data4, 0, dataLength4);
        return [target, data4];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data4, mask4, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data4 === void 0 || !data4.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data4);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data4 === "string") {
            buf.write(data4, 2);
          } else {
            buf.set(data4, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data4, mask4, cb) {
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data4, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data4, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data4, mask4, cb) {
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data4, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data4, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data4, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data4, this._compress, opts, cb]);
          } else {
            this.dispatch(data4, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data4, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data4, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data4, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data4, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender3;
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants3();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data4, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data4 : data4.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation3();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start2 = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start2 !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start2, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start2 !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start2, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start2 = end = -1;
          } else if (code === 61 && start2 !== -1 && end === -1) {
            paramName = header.slice(start2, i);
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start2 === -1) start2 = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start2 === -1) start2 = i;
            } else if (code === 34 && start2 !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (start2 !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start2, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start2 === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start2, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https3 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes5, createHash: createHash2 } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver3 = require_receiver();
    var Sender3 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants3();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver3({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender3(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data4) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data4, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data4, mask4, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data4 === "function") {
          cb = data4;
          data4 = mask4 = void 0;
        } else if (typeof mask4 === "function") {
          cb = mask4;
          mask4 = void 0;
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        if (mask4 === void 0) mask4 = !this._isServer;
        this._sender.ping(data4 || EMPTY_BUFFER, mask4, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data4, mask4, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data4 === "function") {
          cb = data4;
          data4 = mask4 = void 0;
        } else if (typeof mask4 === "function") {
          cb = mask4;
          mask4 = void 0;
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        if (mask4 === void 0) mask4 = !this._isServer;
        this._sender.pong(data4 || EMPTY_BUFFER, mask4, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data4, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        const opts = {
          binary: typeof data4 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data4 || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes5(16).toString("base64");
      const request = isSecure ? https3.request : http3.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data4, cb) {
      if (data4) {
        const length = toBuffer(data4).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data4, isBinary) {
      this[kWebSocket].emit("message", data4, isBinary);
    }
    function receiverOnPing(data4) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data4, !this._isServer, NOOP);
      websocket.emit("ping", data4);
    }
    function receiverOnPong(data4) {
      this[kWebSocket].emit("pong", data4);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation3();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start2 = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start2 === -1) start2 = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start2 !== -1) end = i;
        } else if (code === 44) {
          if (start2 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start2, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start2 = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start2 === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start2, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http3 = require("http");
    var { Duplex } = require("stream");
    var { createHash: createHash2 } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants3();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer3 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http3.createServer((req, res) => {
            const body = http3.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version4 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version4 !== 8 && version4 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer3;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http3.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon/index.js
var require_poseidon = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon/index.js"(exports2, module2) {
    "use strict";
    var F = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    var N_ROUNDS_F = 8;
    var N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var pow5 = (v) => {
      let o = v * v;
      return v * o * o % F;
    };
    function mix(state, M) {
      const out = [];
      for (let x = 0; x < state.length; x++) {
        let o = 0n;
        for (let y = 0; y < state.length; y++) {
          o = o + M[x][y] * state[y];
        }
        out.push(o % F);
      }
      return out;
    }
    function poseidon(_inputs, opt, nOuts = 1) {
      const inputs = _inputs.map((i) => BigInt(i));
      if (inputs.length <= 0) {
        throw new Error("poseidon-lite: Not enough inputs");
      }
      if (inputs.length > N_ROUNDS_P.length) {
        throw new Error("poseidon-lite: Too many inputs");
      }
      const t = inputs.length + 1;
      const nRoundsF = N_ROUNDS_F;
      const nRoundsP = N_ROUNDS_P[t - 2];
      const {
        C,
        M
      } = opt;
      if (M.length !== t) {
        throw new Error(`poseidon-lite: Incorrect M length, expected ${t} got ${M.length}`);
      }
      let state = [0n, ...inputs];
      for (let x = 0; x < nRoundsF + nRoundsP; x++) {
        for (let y = 0; y < state.length; y++) {
          state[y] = state[y] + C[x * t + y];
          if (x < nRoundsF / 2 || x >= nRoundsF / 2 + nRoundsP) state[y] = pow5(state[y]);
          else if (y === 0) state[y] = pow5(state[y]);
        }
        state = mix(state, M);
      }
      if (typeof nOuts !== "number") throw new Error(`poseidon-lite: expected nOuts to be number got ${typeof nOuts}`);
      if (nOuts === 1) {
        return state[0];
      } else if (nOuts <= state.length) {
        return state.slice(0, nOuts);
      } else {
        throw new Error(`poseidon-lite: Invalid number of outputs requested ${nOuts}, max ${state.length}`);
      }
    }
    module2.exports = poseidon;
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon/unstringify.js
var require_unstringify = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon/unstringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = unstringifyBigInts14;
    function unstringifyBigInts14(o) {
      if (Array.isArray(o)) {
        return o.map(unstringifyBigInts14);
      } else if (typeof o == "object") {
        const res = {};
        for (const [key, val] of Object.entries(o)) {
          res[key] = unstringifyBigInts14(val);
        }
        return res;
      }
      const byteArray = Uint8Array.from(atob(o), (c2) => c2.charCodeAt(0));
      const hex2 = [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
      return BigInt(`0x${hex2}`);
    }
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/constants/5.js
var require__ = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/constants/5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FEhhRZjgD5jnrn3qRfvYO9loZT74OQzeLoa3Bq1AxlE=", "CreykTiOXJ5DwNwfWR+4Ps22UCLhtwr0O4p7QMHf98M=", "K3y7IXiW9SyajAiOZUryHoTN51SjzvWxXE1UZmEtat8=", "K8aw3b4dcBtlcEKL3Byhvw2ln/O7u5X8K8ccDG5nplw=", "EjpVoxmAOE89ILLOy8RO1gw4wR99IOknHvq5qQXu/Tw=", "A3UBzIydyBkwmnafTfCY5YiwGFi8jrfieeKIO+n7jFM=", "HCEW5H4DqGuxFpWwpfbatrmkYLHrlRqwHCWeyj/UfVE=", "LBghNIkDLoWpyMuOmmWDm/rtE+V7wPrknb2uv1T1b5M=", "Luj+09TSxxoEKer9jl2xcY8p4iJ5hf3yrYcDyDW54DE=", "KMZNj17XqsAEySAp2em/kbqUNtHM6UuTFtERxwoMFxQ=", "GKAdn/t0euDePoPHB/iyT2gshPFav1cbNCVKA0eGZeA=", "HCHZK+8ZfnOyNOR3e2DbFOZCpWzucVFdVOGscc3nK9M=", "CtQEzLyx4ZWJfLYMgJgeu51mpmd9u+2ti2RV/mLYB7E=", "Cptt6DMGT5O2rbma9sAFlFy2VMt70UyLl6+LYMwfs4c=", "ExKeP5MK7W1HaQMx/wncUWDvpY3c4sPmGA1FvsOqOm8=", "DXphTImRUIqxzkiVgTuxyC8Yv3v8nigMzKGAeYOTh/E=", "BTL37DbjAEGwSGmGh1yROkm93y9a9f6+jDHy9AlP/qU=", "BrvLjo4YAgEpPnEvSVDxsLvugIydZCY8hNnYrhVcuJI=", "D1WKTbGjrAf2Hi5r7pR/c1hr9A8hHOtPaHylZ4qdyzM=", "K+FApgtbXy+O3XioGKlpsgxkPkGbzwtXfCSg0Oes/pg=", "HEnEuanwn3ua1fdOusxxBRK46Ge6zifLDeoG6JuW9jE=", "FwwacychsSzefzPkdqOaGqd6gcBuLqxQOEewDVl2Uts=", "GcJ9DlL2XKNPTjGgaOSTMca/w52SQfnUwwIEFhXPJ/E=", "LxvcUlT5Igwacx/FJ2lk2rJrOF+kC2sEvtmWDiVDugg=", "BbQtL7zL9NOdK+kznKvp0Nxtkh6FXNkRVLY50o1KHPA=", "EiAEBxWkGtWfT0EODAWkLF/TKsUv6dBviBiNcfYeCTU=", "JflSZSYVW4OUZgn3u5UH3Ukl74cd7pFtkUTrtOzhNDw=", "AXv+QoQpmud0C20OIElR4xSopdBFJBkUeXipWzR0JEQ=", "Kl1HZAIcpx14qWdMtnCPFYjSzq81eMQRHPizWe7wic8=", "F/Atq3RfvjwIEyH+XO+EXnuNBwslFNKbKnt9icwIFdo=", "GdpiYm23GZtl9K3PV/pKPbqhdkp70VVwjubzeMie8BM=", "D4jilfou2BtCbJH6aTZqc+33Xzm/GGNM0mbsQDiCngU=", "H+McVUhUbHlI/k7hvXQS4ygO/30gywmqhfSfJ2YUgBc=", "EP3BYTvb9n84vd5WGy+R5MxItZ+Y1kNjj9wK+tv+Em4=", "HyYYwuvpV0UIucUvAADjPr/drRoD/da8pu9/AJMSe+8=", "Ep/n/D76xqirI9um2IbzlNoR9ZU8+Y4oJpoNuip0XdM=", "Fa/UzfHk+CDBYx1KuFykujuvz+5yvq3p+uYFIxAkSOM=", "Hyx0ulw2fjcNco5x4VsmiFGnu4tFUoy3NJVgeayZsBI=", "ETDhhy128vk2nPWble35zhnwH6icnDaybgne9nhtrTw=", "E1I9Fz9+a623O2P8HJu9vuJCxhvGhlZJMydTOlwbHco=", "FNpA0K9CemXxhBta3JZThlM2j3JUy1Zn3a27rXpXTNQ=", "AJH5ZADkKX6oW7GGwXswToJjjlf9Yx/2MVl24aXdi4Y=", "MDMpv5AxxVFbmjTUmmS7agJnvHtUoN7KXEUCd6ACzcs=", "FO1H5VwdocLwXTwaGy5sGFCfyDNuz+nbc3kW4oP6ghs=", "EWHxCzV3ddgQrVO8xKINWt0rAyUcdH3rBO6UxWXljWs=", "F6ilCucs5wfyK8Bw65koUcqRTrlMxo6vu4qWpxTrgiE=", "Gmxh15Xbr2L5klCzfsXfiGRaHBU3kdtjErky3CUOT2I=", "H4vSq4qoQGZMTu4ZjEaE3EsFdyuyoIadpnIrFfRHoTM=", "H/y4UqTwAnqXmfExzXS5jM+4y8BjSdj+/MYvEMj7Pi8=", "A150LsUvGbNtSJxyD0Z/+td81TvC213dskayMCH3nxg=", "Hfqu5BvflNeDqin8Yrfse1VnOqgY0wX9QtF1oF8uPYY=", "KCE3hHegLplQBaVjUIhUCUW9Mz8tFFXwOKIZuMR5azo=", "HbSk0PI4pXCxBhxu7IHALzH/3Up8GedjF08jjQSJdCE=", "FL94iUV7ILehNns0o6U4IX1pO1JCav9ApLtyiTsXhMo=", "LO1Swr8pb4fldBDD7JqUg6eW0WT2BJEnEJ/w06nAhGU=", "Hd6sWAWn9K2k0EQe0QjjFJ1M5lhPSa5b39RtZ2buozQ=", "Lja05enJe0YjBOjitfnciOHJ8hYboEBnP5ERI/BCrnA=", "DGhA0csGZtxZ6JsYZSddihZLRHxe1kNHyu5jUCwjjV4=", "E34uPonnHUYfTJvD6PEhgyYqTR21XFibLK6qwBI49Yw=", "JQky57CtzyyE7Uv7YKNra4LlWqlHURV7HUV5Swgciq0=", "FwpykvVjTAbdO/CatcnE7NSwDVzi81+XK0VVOR8WtC0=", "DWjLvnconnjVy/UdcPG3W6IV30570BSdELLFDypPO4E=", "DK90VjuQUl9kWm0gNuzRMG+h3GgLSdnOTtJMl0mXMXg=", "IKfRwKJ/zOeP/jcvTFgwaxZvlFbtRs3rJV45W30w1Co=", "BiPzImtUcLJ4m4pTBA5ERDOF6Wuc+gvk01AVFYpGhGU=", "FjIwhojCXnkPV9aKU1AkEkKlYwU0feSlAJzka4zcuR8=", "LeR5Om+ZzRTj9mQiEfTQt7z6NhWXxUT/y1pWfpB29H8=", "HU0G0Z6hsJyteQhtUb3hFyWlVPqZVZyi8J87tz1yjGY=", "BIDnR5pmp82ephyLKJdDiZCDUKvEqvwYzXXjPdEwwUQ=", "MEMLAzaOvKqRJGlgSQvPkX14aBRj4ufXRL+0QzXawk0=", "C1ezcyASfUxQ8mkSSw29yysfE1IkGl0SEDKD4InAx0I=", "LPSJBlDSckDhlfYKT2mO2iSbjdYUsjN2tQF40t9tK48=", "HiIcVSaJi/0S3oaFGg2XA3UaLyOQCKtfm307aRHGQYQ=", "KOB0ha19mS7RpY8ynKEq3OTsaT6927KVLlTTOfLuvaU=", "L0TWT4TeFtxnvV6tUe+x3IOByEUgwShU3V7zoHms1OA=", "BQp2vDLr0d/ivjMPME7ces5xZ6t7oVFvQCHGLPDU+sI=", "L1jEXl1lmmfXgTZyQfbDXYy0Y2HZeyiUfSlCHCcFlKk=", "JejamuDkLoQOBLIwNw54K9tnU0hEMlujb8fl4WDGanQ=", "L+xzTaIP4yAD6gTxJ/hEck84o2i6EMKVRCUr55YED38=", "KIpnePOoOYio7Rcn8V6TtMsU9OOju7kd1tH6yv/9Xu8=", "INzGx1/Yklm+f0BnULPbZ5olqM0nFdJFuRdTkKySLIQ=", "F/QroQlC3yXLilQXgqGLb9Mc+WXREXjHsErEW03qXdM=", "Ao7rhdEVqQQCDgxhSO7GYD6c7avGZKvudkqv1FWYa6U=", "Cx187POnmyrT+imPbOp66V2AwCmezJGOn4ycPTjVnUA=", "BEAznJdkzsecFu/bg0omJh244/Es4c9yLSPA4R/0zwc=", "BspkfClyfBlioAIXfaLVBPSwel9+tXx5uI5reru9rVw=", "LqEgqGT1xAk90ali6PATx7jvd4sE0rpb/DyrKGGbqeM=", "K7c3VGxK7nwMwrqHwRV+KnfEeev7Xcdq27Oc+Gl2M/0=", "DjDaZJBiXTPnnNUBdvVo+aLCjC9EmivVGiXRVoaAOpM=", "DffKcnihNlC5GdhUl7LrsPcQNafCBDDUEx2QOrf1dSE=", "J8xYn1v1hXlKus5Yn7inSi94TAmQuA/KppRAl/hw4tU=", "IlXDajjIc13kXO30Uq+oQjMtMwQveOYMQ8dFVCGzJb8=", "Ez2WAr0zeNafaBwnsFvf/Ji32GzKY9c6YMrtSFeE0Ic=", "DhVI6UKunT4mhgaZuTcnyBeplIYWyT70rM2YGx3D14o=", "DyDw5V2TaJ/gnsMS9q9HYnSC5L3goWAqjiyNboTopq4=", "LlIyhIPLW3/y605FsS5RsmIyybwXtykpVMCp9r+lG7k=", "ArIWLVM+BZpu2iq7dHEu2zp4YL7qld2KSr/JV2YIBPQ=", "GeCSdxXRzG04lCmUf7Nzfa1zOXTGsuE+Wz1DJRlRbHQ=", "DTqABFfXd4VjYwO4uU8X3P/LRgSIcqyfdO9/J+5XNwU=", "LJdNGVJVehqsX3uuSZZhbaYZtz9EHE5QTcj+nPtVnjI=", "B2a/7u3izPNwjhtP8wcUwiwdQ0zb6PVVFLq8LdXZe+8=", "I9rI6lQIL8Ex4XOuVeRjDNTKfIcbKgpHnB505/GR5iw=", "F9X7bCyzcBDj41irLVdTdocO0zGGuOrkmtO0fjQKjX8=", "F13Kx22KgSYTm1g644hTKQJG5D54P6aQPsgAfxeMACM=", "DE/Qj+3l0iGtt6v1SYmMkeW+foW/H9KmEb8YLMLnFlU=", "J3k0uQnnLTo0dbsex2arejitWbEoMD/FAC8Cplvf5yk=", "Dog0mZjf5wPxsYRST5w5TWAEzKz5y5UolujP2wsHi2g=", "HxsgeLYLD84Hgk4qK8jK6O5nNRSwBwqLRXEMx4y7mUI=", "LrFVlWbFNt28MW9kgtUfo0BVdldwD1uKhG6BKg7TNNE=", "HE29wzXPZ2Q1Ugi0ydJD00VB1iPGad7Cw7oGa76vZ3M=", "I3SmstpvjKuOXP6NgF3Tot/KHot+ul3IV0Ah/RJB47Q=", "Gd00JTPMxgOplzjj+1pWm5TvcbPkn5D7h09hYXMwcvQ=", "IX1m22x/s+/6UIgAWH0us8bQPYOFEy8vzOfzXycFzM8=", "CBX7hZH+AQOM06OziyNvnvynfGGNO/xsKn+okpbH5k8=", "K7lDtAwr1FamwXhTscqI6w/zb1l0sv+aX1CT6b9joW8=", "EaUVP85llRPufLmXSubLpYHjtM0UVwxXCf7D2NP8guk=", "G3K/0HY12FAbLv+HhaJJW650x2U8+Q5tXJ8URCaDbfQ=", "FJAsBwDuyJeuF4uoyvhQ15Px2HUSvqDs6jnPax/uIz0=", "CcE4xuCmFqSf+Q1DprBD87dFt4hlhW3EwaReL9hMs/Q=", "BbWKPc5XsoGicdaYlQUtiHRYpxV4PoMX4CSmGjXsELw=", "K+jSlSXAz91eazEl473jv1WOVfvoZ/AkRXqWdlR00Dc=", "Bh1y948bqdxrTX93hCJdaoG9/Bta1sJDafnAVgUj2a0=", "C/GK78rP+r30ES7drcphRXOLSAOzYUW7lRbbUBoGkuk=", "LnPdEF+osuyTHYzfKexnnjqYAakwcafV6jBlklXwO8Y=", "D4RA72Z8mugTN7pdjJJ6U0fecpaGCyEcrR7L+101mO8=", "AE0wOy3qYnsnMb6D+TrDTn0U0XihOABVjKc5Y5XrEY8=", "I0VBrXIECnDaKZajUmkjDJRpnu8xOk1IBQgAjLw9N8E=", "DRI/HnLSa5K92P1z0UKGwxKtTCOstGsuCMFXEEQJ4XQ=", "L7Ngd28N551wmO56pBI8Be5rBai+Rgp3TzoEjhOFRbs=", "A2hcB5Q04WcnbFfTzHlwO339xBwVbqHot/mbaValUyY=", "Jgrw4P/8yXcsFjGxeTRFZrR6qto2geuQNMb3XDcFwcc=", "KGK0E3T4m2lSdLM7dz8lVJFuK/+f9nJUX8L0lWP2J2c=", "AqmRL+FwMQInGJ6h5pHQNi8Ys4tACw7/GSyllRPrqNU=", "COUTreaUoNisHz6/GpZEDTLHE9UFjhIk4HA0jCgfSm8=", "FApKQx4u55QA7XRll42EdzITxigmT/gPIax6a2c9Cas=", "KWr00BnLXffZWbKdVJw/BxICtOuotT3F7pee0UM3eSc=", "AYMuKEp/TIFhSIK2k5/A8YVXO9ICPj5QV2VHC7gSs0k=", "GoTVame/3T2WWr3NMpqnjU/pNDRJby0QOGH9GdZtcmA=", "BAy4KEd3OSfSrv3AdIkDep0fdjHsp1yfsN2gy5294UM=", "AQ3PCEzCnLfK7PJqpjO85O0rAZ8oh87nsaePidP6vi8=", "B+3CKgkR6iFEJe9UK3dtsjsP5YF4ENQMcsqYqr2a+oM=", "LupKsIrsd18hSEeeo2+7lpNtpYuki9HS06zUgXOqq+c=", "HkDA6CV/5KYQBc3PrRSM9/R9G1z936oIJzhpVRgkXxk=", "I6J4CVg70epR9DbeVEPhCPadRM31HcHwPiGUi0mAuHY=", "LkZSsETb/kDmO2sjL81fPzmr+9IFHuaK3HVAgNSSUKk=", "Eeer227Lr8Ln2M3v6ce5xQR160dds8LK9/fWf0hXdfI=", "GZ1SNQzDDoxzgh+AIJbw5UehNVGye/a4mTlvY6xc+Oc=", "D1ddbuZ8vs2YNFYk4DKjfIWafL7zCz/dyUnNCXhIQQE=", "HEtvmiritBjmJlrLqclrBhhNBwKOX7eE80da53cv8Fc=", "Lctc+Ilt458ijhV8DFWT9GJvubwiUgY4PbIDYKvwySU=", "E0CrufThExhr3CbL30vMpQtTGhB/hjylRFdePPhw+OE=", "I2jmkrcnh8uIcOqIjnFOAG9Z0rRGDPt0xIqMxzsdGls=", "H6ua3ZuqSk9W8jFld1xvLZIqdjKpT5Y3S33IUnVvVLY=", "DH97gjANPGzj+JV7oeSt1UxMAV4g2XZdIgVxwWq4aA8=", "FdY+hr6s2Txgg2iOXZyPPGlHkp+fH5mrV4pMOpIu/wM=", "C+hDrl+bB+UlcheK99ro7QXTaxLAYHhikpNV6nQCPZ4=", "EzJ0nFI2lMtpNeCWOgfoGwWWfOHZUMC3MQWOySp6DJo=", "JUOUCIEOB0wL3UWYuYFf7okruVylECns8Am/+lubloI=", "BX6NGd2ZmpGNopsJQLODup/RXbCw9kmW3/Z/61X5p0I=", "HgFON+mxF887SHDZmfK1XTU00Ka+mOnjV/pD8B5wop0=", "Gk7STm4DrrzWvbEAUz3JZll6/hXIUbS4Y/boiQhMZHk=", "JTQgAHCD8aqGOtR2CQXBA57UERyfBT8ncQRS+DzjapA=", "InahRBlxcJr/5tKpkyAAHsRexyFVxXXd7srA4ydZqwY=", "KJV90SGOp5n9NBHrGTJYU633rorhKB91MwL+fTHfp7A=", "L9klcmq3lMiL11eWqj5/HmaS8pFM+AImfd8B43kCoAg=", "HPilycdqhLFHyCONklPNVbR8DEPYKWbEY2ooZ0cF/Zo=", "A3PLvDBuG6uecHc2hxXmIwtLLi5KHbnGdLjDWaQekQg=", "BgKD0v5/I9/1E9kRCz3GJEi8SPUxzgweq1kgvyMpCkA=", "DatGXW2RB0DzPvbMDq3HG/gRm9/Vo1J9yLv636pAJjw=", "DLp7y8giSyqOSroXl3IwpobNZCHcDKU0bzRGtiQ5xMM=", "HkNl2weQycT0RbBlPEZv8h25bDi0B2uovWi8tN6mkR0=", "G7LbohmamrO8hu9fnef2xcoT1g6rQs7WjemPxkOACo0=", "CtPBhwxtbvQO661SEjzRopE9nWLoC/usroEuCCAh+co=", "AbCYyR57DLtcNFiAd8Dd+VMA3fYUk1YwwM46JickUwg=", "Gf1cDqwU+udZi9TO6jseKZiwwWhJO21yrkG1duVbnD8=", "DUdJ15zBY/FxEKQEpG/kJ8ZDTz/me357TM+mq5W9fhg=", "Hrv+gRSkG7gJ4LMzmSQSMuuUCthyjIpRbUCtpEDb/c8=", "JwTlthM9l2TW0/F9SdgzIj45N/gOufrqu/upuvS0wbg=", "IWXhyAJzBbGuDjI1cWNeXVQNE9cQw/mjkLaRPxTQNeM=", "LjSX5NNf2llsBq+mO8Og8uVdTuukrOtg5lCBrWOqi4o=", "Ax2kNF7s1ttsD3sHx4Fdet0f4FRtc49NeatcV6qEHt8=", "CJ7OVOR6pckI5D5fCHN8FDaWcIkAasqxyc0Z6sSiCHY=", "L1PBXire0zxH9VoHBIPmzH84Ifv4qkBnfQVS7Z0Q2Ec=", "FCqjT0suitDfeiGz45wAyLCqKFcJSAHqr9cr7+0Hf5M=", "F66k2kx7zw11iLAU64tAl53Scl7aTmrOMxmCRnx/8r8=", "DpcMGdGXSNjEZRBNjwIgA2P5pBeG8C8YJ3QrINwNFyc=", "BLytnlU3lWQvWbr3FKa9tDL8RaCgt38aujqYI0dt+bk=", "JCwL+82qdvcV29S6glxx/P7WccGxkB+khMh/gQMV0M4=", "JdsTQ8JBBAcQI/tu002ZCQeDEeHv6FrwoRsZEU+p55A=", "L/5NnEIKWenNx8Masr81GHyhR8uJijlC3rNnd4YDaoA=", "EluwOvPizxi75vW1kOs7+NDRumO+aWSD6Y8oO8fNB6M=", "CBa+QnRbfbtM7/5bjiTqYP2LcZ3rpQA3rHt1lIdFxrw=", "ERFg+az27DYNG2pxIxOg28viPmRCAFVHHS7kxd7bNdQ=", "E3eXjhsfaokl+o57eUG9+PtZq5VCNCQZKD2CA0Nck5E=", "De/B2IghZu88zeU6TyNvuoPThGIZN87lfkIaUT0NM5c=", "L4+lx4xwbjpdSgPyp6OVMEbX6Uy4in7zUOZ7W6Dw3r8=", "GiqVfsCnI9phwhNLqwvxe+sA5tzYRpDCMNy55Y2pSCc=", "HN+HEJlfXgNBK0p/aZUy+f0B8OoWeo38Hd834oBa3e8=", "Jv0xRxgow2rjbCe3SAVLDAxP5SObMBaZ43Ze6+zBiUY=", "B3XZlswsRFbzA6LB+QB2R+Eakh2f6j97kmFDuZ0voL4=", "AW+5M3cIymOM39qRvQ2uprlyJO97IGJnKt3RvRi7iQA=", "LDkvvn0/3kL8pPlHi7Q5MxJYJVNW8YSvb3bxGQVBF9c=", "GHoqO/eaafo+UInvnx/Vb9tHxV7s53qiKKo94bSGvLE=", "AnGoY6KAoyZB/6M1ELLt0njJhjA1lTLz5Qaydf1dIM4=", "FVdFnJx0yUqgDlr2mh4xEvtpU3zol+wMcYlY2WUW8qs=", "Ko4myo1kfZpjiFFuqdz/iQg9U55YFowqUMba4w8QnyE=", "Ict1IZTPQ/O1GULrAEDrqd4rz7HCo/rpeSS3EPJoMs0=", "LCba+Za+JHrNbdSsrWDTi1pHHmMiGI0CwTfny0hDd+w=", "AkAXbuDnmC7r6Spo0+OjjCaCGswPXQWM+ME3vKLSbxs=", "JjbglzyGXBvZdN142qqNCoTNr2vhrUfs8qDRjxFzGPI=", "GehPTyWnmUlgQWYdxdl1toH24GdEzuibe+XZ/eF0SsA=", "Dr+JBko68kfKHzb281cBiOJx4LMmxPsmZk6J4UVMoRA=", "Jcfpe0db4A6LVZo4xFI2T0ycUx/suKxpj3/XPOIucew=", "BETJnlkjU+WuyqMCrdkBwU2MVScKFgr+1EKe9VmK108=", "E424iHgwVl8mk9Dg8C5OeeFEln8LpTsDUZq6dktcmUo=", "JNQPRiEU/p7gKq/PdLT8ok4a42XcdcO1K7E8u7LyHt0=", "IeZdbY7kN2C8pA5zC130xM86inMtsUj0spUbTGHWjow=", "JI3XlmnsCdvwNQoV1sdcapvarO/KFNUTAJePE9GrbRw=", "K4I4wVSPnL4p/TXPkee0jw69p+Y57faf6NWrp5JNU2I=", "JDn9I5JX84GBx7489RPxv3I166lPa4lCqUy93s9vYvc=", "IAlYI1KBphuixL4KoygqGMdLbSYvXefC4z0rs+iT3+w=", "Dh7KXfiO5fYM+n4f5b77txn62CEfqbLQL8wjMZDBfxI=", "JrU0J/mz6ix2nZxmD8YIgaFpwScy0AG3FY7ksbhCyiQ=", "IPOz9Kyv6fivPgZmGzqPd4+igSUiudcKZ0As/42ysbQ=", "IR5dKznWJSCnpifs6MrLrJ+XUG3vTsKGkoumwn1GOxc=", "C7dD7jSAISnFVnMa7Z0wLc0IUxPOVy9iQtE4MuU2tLQ=", "I8smYbSI7nHkx1P/I65L0l2KRAlPZrZTKXfiIUDrpcs=", "A6NaoxI5Ec20U1uu0zWfX2pSBbnJPvMdNTI6R4B7i8k=", "J4A4SKCu2WqT+pQ7ZjXkUCF+E39K3nSmLXkXMicUtpc=", "DLN4OcLJp/95iEy+x19B6b5eR8dtYVOCMb2BYpltb2c=", "HwAm0L8fjh3VQjzC/sH7XNqh7NxMPLIY287vd8ANL5M=", "AqfXu5cLim7S7mb6u7qVa22jsQD1tfuSju9C+XCCc8k=", "DP1/QhXkNMjaF+wyWLC8YFrRqy6QqklDUeTuQLvEkfo=", "GAsRtyBiKhVoSdxvf25/VxZZvmloIjDF7ZrDOXAKfN4=", "BOlqllvOPToKJKSkV8lRWCyHE0nOfu4aq/5XipTGUBE=", "FZMfeCtF9/tlbyzb0fdwXDU6I/4dMKWkahUi7RYN860=", "LiluV8l6Uwms0m/r9VrJY6VETBxfcDrYig17l7ndOLE=", "JhV7zreOhGu7Ji+aHgbUJxveWlvOjwQZlS+X/9E+rKg=", "IZTriYR9aw8Yl/Z18ZwMVrYbEySO/zyjbjT7nRx57kM=", "I1C/NUd2VomRUa193pbqeFfhVQFEcAjatrPSfI/6J08=", "GkhvCuWRys2vCcWKScTReVQFQ1NAgZ4APwRp0RC3dSs=", "G1bc92+yPMSoNNRVpAZeEzVxQCt98wnVm8MQXUKowwE=", "GnSdeWSvC3ICkT7yBMZT8rS/tlzqt7aFIzq1nOO7aSU=", "GK5ZAHP5aWlq92L/pOjw67+X+Mx4fjfN3R8yG+O+rbs=", "IcR7J12C3eZGDV52mplCEUSxxanaWSlK3py7MXED8kk=", "BHPdvVLnN+UnNk6OtjIHl1w41f1swysnIQKwgs0VGPs=", "CxL6yVttOogdiSZXyEJOZFrE5rAFFfkC1ZRXQwKybgI=", "CK52FqJgz2ZX+Pc6woRYjSxfB/9CXYN6p83O9j4+IQM=", "A52vaHYoC4Doc78qMv0oNKg8aXV7rdWKiI74Gekmzig=", "Jeex10cKPHXxPwtWVGyOCfLY7+/wbvdm+ceDyoadEw0=", "Ho/TY0w/92QYTQNDX5hYSxG1sVrrnHUmLaPx6iwqnno=", "JB3MUaw3gIpBXdHjwoHwWv8ReJ3Ayv3XejVITgmT+aQ=", "H/wxU8Vu+XVZMs6ivgVzdJva/hxPoHgaS4tAeM6ddUc=", "F2MNYtmj5RDIik1Dw2D5K8D6ALZgMa3sKb2VQ/06F+4=", "KYBADt0ddOPWnbVFjSzNX6vbI27BaoKkMBoKtZ6kpuk=", "MDT7JDZhI+xtyvytNXJtv7FhlMA23NZI+mlDm/zQDNQ=", "Gqfo9Bicqd/z2yq3ZIvgojkplc5GBB4EaA3KitcjLfA=", "H6GV+DSmnmI3L2DrSX2hZ2RurhQVPYA7OdxdEfXXgAs=", "DyPxx01fv2GVrVpq7l5WmTxUd+hFP1uToNe6/TMwNtM=", "AWVW+sk0inNatQqgiclxUbPKrwogo0+52TcFBaFRVyk=", "I9kreTZIEQ/Fru8GM/DHfKyw27yhh5uKb25d9EXl9ws=", "LkwQ7F5l4vI5u8Q8EwMd8mhqtA/XmjBLBdYRuCPyO3M=", "EkGLv9d7Y61eFoZK2cMv+/xaPdm3jsK3kyn+XgqNKVM=", "HkqKrOFavB1bdqnoSEMdLAanj3K2vrsSk+bFjlGFaW0=", "Dz6WEH3s29aHLCDqCaz5LN8Xo+4dEzFIgJLZYXbet1U=", "ASw3gCB/OVzCHesKvZUWge6jJJjdumzol6j58MI1cGc=", "E+qxtOZyuhscG7kBdpMB8eVlnQPqEMYd4kd/8KwiFCE=", "INxmSrsgt0VsBmKc43oeyxonpOiyTjG0i5xGNaowMj4=", "LGseLP6njiw2eF52qM+xsFfpRx8k9bORF1w97LAeAA8=", "GIySYlX1t689qWNVcpwqhnCrTCxwQASBsqyQN0Dgxas=", "L5kTII4J49bp5vumOE/QdquJ8mYpduPjDghwuzDrVPI=", "KzOAPZCIlwbnFPcgtWKNJvtgtUWh8+nOSaaukSsCQIY=", "JsyrwQ6wQyfLXMPd4quzbwlwhsl+c4wTPJ9XB350iwk=", "GxauDXxUQIy3X9kx8kZ1HysMPcINeegqJTG3bCK01d8=", "EdC7RhvYryhE9J8PhAyU75UYslETRHQtH1Q4/j1BWuQ=", "IzAxhHtHa+rQEY09szjokTPsQg1nPlBK1kclnfZVVx4=", "H4TpeJW+5DjrPJLcmxhGya0pwWQ4ewautu0YQe2MTco=", "J39/m1QvDCu19FvtBU8JYkU2AQw8+UUtInMZMyf4AdY=", "HvyckGnlBouqwT0uZkVkG30n6A/CMHcWFTXERoLuV6k=", "DW7Ed3YeLvusTxSzvz1SV6meZMPyX+EE+vmIsg/l/0Q=", "Dg59fFUBmZt9Fhc7WbfK4fIDvvIa6/ACUYgUOcz5MBM=", "IXvvL08SxtzJHCBYojORy3feU8puRNzcbqPTb+oybqY=", "BXgMiK3wFTG1D4F+P+RER9KbNaqKOJxx6M8SJqzvaLo=", "GHM4h6ays7TJDY5JkBluI0ReR9fqWTnr+4mj7j1ntL0=", "ILrOY6z8rgscnyvuJLjp2oW6WX03sJBXIMTxXbIxsHo=", "Fm6llTdaZ4asUn7p7O1z7Wv1UIdqvK86yStCyAiwDY8=", "MEJiqe/0BArPQ+Mi1vUmdq4vhT7C56gNsAxIjPkXx04=", "ImuscFAWbl9tt4zQsS028wW26MmgVRFK13Ceb1ckW2s=", "JrL1OcVzgp9qypG6qVRQW8XD604d8dY4WCcX+98jiMw=", "BqD79M1S6Tul5MbEr2XbAu6WKX+K0gDy8c/yUudptVE=", "LLnCQRLTU0Gs6siDYPtSiSTli27KwyG5+ynmqjNo/yM=", "IOiKTWB1Jt0H/gijVSpEZpEp64f8wLE6rI/or9kwFSE=", "FURkmivXPjunLzlt+R3WVAHdj69R3jJfuu251TatlPw=", "GYAHdFeZVxLETafhdxMljj+Os1S/2A7Z6vPsuvaWAQU=", "JdHSL/E+dwXTwIX5f8Tk9pFLgv+qXSCR7GTaxCN2Xvc=", "L+yZDvVW7+EDWkZP9VgedAZ0Rc1Uq8r2uMA5n+DSTPw=", "G9lWNQbZVE7z5IMOE1RQEsV5N5wtzBMwQWxK5JvE7GE=", "AK/80XumADxW36hVcfwpc3siWoDUgOfdft7AHxTyMBA=", "I2cNuu+WaIHwf5GaLYgxKMeyPPdnpHeysuB2K8DbwYs=", "H5OlMpFzlMfiL9F6vupjicZv164t2fAvhg9tlpR/Dt0=", "LeQun1N7fWGwITdxwOdPVVUSvge2pQk0c04sW+tAvjc=", "JcVX9FuZeBzTfTuyKTFmKmf3izd4LIhbRWu5bVXohAQ=", "IHTItwlwXJiIU4p/ijxK/2R3Mb0W+OJU+nTqnyvnZiw=", "Jzg1WVYpgTiUnkQhcdak5LdO8gZXQNt8/DoLYP1XOss=", "E9Nq0KTr64GWl3hkllnGXLfQxBzFGYcf23Gp6moMqlY=", "CKLBi6QTgTSMGs+/lhdxaAa0YqFpG8LjQ7ebgIXjdrA=", "BZCS/Dla7ShYB7v1V62aEEH1nAeYIrEIhFeIL+57YSw=", "FhkkFRtaWtLYysEZUiqZGpBvFehTHccFZ/ayg3HMJOM=", "HGjKj3qhdlkHVAXvY0G45popi5pNcvO7hUswnkuoehs=", "J/XQO8ocggf3I5pLLPc65VmhWqN+e93fOqsF7sXOVZI=", "Dsv/SEaWKpddNH6pqPxGX7RoYVV2IvLCVkp+Y5gzwWk=", "J3xN4jY9i1tFbPxaf/jkb/LsjapZhV9a1kvAUh86xWc=", "GxGGLFKs01G3pGR5P0+7V/7Jn4MrYyJvldF1yNL8CLI=", "BqcZxYTHT/vdchjrVly0yL2GyS49+zxz4VJyAapRI04=", "Iw5K3uy3mYd/fOmljINrmdUzWEoZXB13oxOr4cfRJr0=", "ELEJuGSAnEdnoTPM5sutbIhigXO46lHozKhYMMp95SI=", "DiEReXDc+9SxUmslNjbzd1ONO0+q61qLJL9iANFMxZE=", "Jmc0mXhAE2L2sXk57rDmT/VWB+vbNccHHbRrs+e6R3g=", "BQAPpf2lBeApoTv+MEwmew2GxywDm6v20/8C7iRr4C4=", "Jk2eCUrtX0GmAkIiCjSihAiQh7JDapv86BdMyb6MLiA=", "CAdvnEdD3mEw/2Is9AHt0skvJL/hFPPF5ySJF0YxXEc=", "EyNwq927Cx3VfypSDCUza9fO3pS5W79cIVHW2I5kG2Q=", "CP8RFreiJ7/f1EZaZ4kIgrYVyMTBfyjY0klY7fYC3cs=", "K8sLDbi54+ArfpwclGD92cbNmFYjMuZI2KPgq5RZdSA=", "EupozmiBvsrX+KaxF7A6uXb3q9WX+QOwvyMNINIalDo=", "J0OcmKdmiAZ6CXsZtv3X141fiOJ04Nj+peprdAb92n8=", "AvQNCtBfVlLjHvlECtcevIQZ45NJOTfwXwBJnQKpnjY=", "L78EKEMn7k9oDwa9OQ4wnQ0TrMdLnFsUtjBZuMx6v/U=", "G+aG1T4qitV6gosGUUJc/Gl4xwJ+2/JH9rZyPCHfhuc=", "JoO0JehaUI+WhS8UtCIPz+n3rYsXv+/A40jEfKeLtX8=", "FtrOmy6AEuMdscfr5nLYa75hoao+FpPg7d/A3gqd2VE=", "J6Mh+MfTyQIuli9/7y48hItFOdu3WqE58wQw/lRbzts=", "BszXIQ3uHWsOIreeEtGQgtgHi3iNcQB7leendO2GplE=", "CkHdQiIWU3Ur7zUPbXSpF7bLsf12o6EhZvTQvpeOQCY=", "IgoCiB5NR6yU2VDN+DhidNF4LifL0NhFl43uyRKY8WU=", "DiFVpUX+Xzy7Y5dgZYnqwZzZJjkznGsBcpikrTQItLk=", "Dw8ZxikeUVRqJnxgzHdOX7nQiLrFMHgtiR7Br0uEcHM=", "DpJbzRxt20o6HGfsje771AxTwNM+eu7xtGeVrtWUPJ0=", "KtAAsXSKu4Es1uVBEoa5/z7wpb09JZo25F7wW561vus=", "CmWqIy0y7W6N5j0c3/68Lz+mFkZcJ6r5fozT3P9khlI=", "AmPYRwq0scYddNjoliQvTyYdyxZ6OgaSOJPXyyyT1qE=", "KQHZRq3clLBA/VgATZpfjNGSZUDHqGEs7BxYy2DCs6U=", "GInPqCCfSVLfkCLbncWDtXF6BpbaQc7mSTfQzWMh5pM=", "I2Bk1xy2xkyEdHrCX8+NiBUC5fA7/4dWG4WhFrHzmso=", "L/ehdP/Owphi4E9dvcc+vzZhVwAzV2KQwMH2zYztJ64=", "GeckoddCyrEDRV8AQO33RaJpanEITJPjInFUUN1Nb1s=", "A+7TiStvDmxdoQWcXzeTmFg1qig1AKgSmQSpTIfxYb8=", "COK4Jzv6MMGshQMG2R5Gip6NBQkq7ky8gMaHJIRjujA=", "B63Mp22DN3KIOaG2rDs+1Cr7h9cq+Y9S9Bby7FiyjOw=", "Fx7zeJa64rECCgpYOb1ReEzhG7QjfVSMFxFp0y+hm0A=", "IP/fy4b00AUGTtvClpGMMy0y++/xcp3lBWomq7w6Nfo=", "COzXpvFzXu2GuqCU5gj0iPONuzmPz+1LmUODoMqORkc=", "HD9dhuWSH96YkBifHYxhh1QohgDmkovBgqxNXkyfDMs=", "KcYRhO2dRg8zdVihr2Oap+PAl15AFO2OvK1KJdUeq/M=", "De/UWyiVhygiituy29rval6bGmSQKnNPQCuM77irO1Y=", "CnTqItigkzYGBhAXmsHYL/+pSS33be7U6mDgEzsIEag=", "A6N78S2vFADSl6xKwTuiTBfcJi2xbIUj3u5ODM3ppoA=", "Ef4XkNWrv1k1/yIxjk9//mmWatovkTa1T4MOrLCmU2g=", "AYFlhC9AY3XyNGaGkVr7FL8f4FZMiFjuO94Kuj3l9o8=", "Jh2yXnz/Wp+3LydrH5JgtmcwD7fTYbUP1cDotplbBfk=", "KjrDMUsrZueW++Nt93jF5GlyMgzEPsgHBIgmtnBLp8Q=", "I8qkuA7PqZ6dP+orvB2782nRv8iTfQPQdAYcMP2M12s=", "J9smAIXiJImN8UXyP2NfIGbY5OEk5YHoxiYZKbHf4Qc=", "J09sX9NKeE1rkV7wXUJO5sC6u/Np55qxOLgWe1YY7H8=", "LDop4TqE0moJEckona8apM9YQKraBwHVfiPfx5babaE=", "HqIQ8gAaM00+gB9OUycNQtp6rzF6VTtCgqp46qIoLm0=", "JU2+tSiEtpnBun+g1ugNYQkDsYo+UJw2NRzMOwJJRuM=", "BZ54HWWJbr4OS6JtwvKZB/R7ze2kososcT2FBeox/V0=", "C1sc7GPULV5hXcJpuIWiTO8wPseMly3RfNuz6RXMT/s=", "KnwBXpw7LFfKi30m05obzIXW/6y32fvWbSqPHWTtDJI=", "Kbc2uRHXGnnPY9im94bxG9Wr7iQWHcVnp8hR6uHkO1E=", "KFdFqQp/49Ca9agIcEvGnG8XAeVzkS31zB4mXVlsQUE=", "LZAbgZXDyWyMNuuZ/sATTsK4MEroEL0w2lVOMICCZxU=", "GQXTUYNV6rp4WbWR7XuMnCU5gPBFDb31TXp3groFg5I=", "I+gTAm/AuABk0ZtcVCiUL99+/qgL+o7ECVJyv9t7TJ8=", "I8ChmiUsh+axwcIbGnmAAgDD+/8+MwDn5VaAcd6e+4E=", "EcSuYHuuSSQTv2LNqiwoaO0f7G3AYxsGfKYPqxJbnio=", "LNBV67fuRoY2XepFDwRv9iQF+uGxr8n7AXB8+B2g47k=", "BTyf7y4CH6miD62iL96hUFtYoxWbu0czfb95GyFbFFI=", "CjW9dOh8urqr6JrRMZ0snoY7TGMcIZOMmlOVv5eHKp8=", "HBFQVlOc4gzVoE0aXEPisA++g7JZAb429d3EZm/Dg/4=", "JClUBH5Xcv073tWQ7IvrTFQvLiZMjD4oTNxHNQXFGpA=", "Diq9MVtHwNyThJwM3yZ+gRy9vbIApufCtn7ffLAXQhQ=", "KCs3AgwIkNdRw/12lQ2AaGaOHf6uYh3VUtLeiH2i6nU=", "KJM4UiZrUtnqa1u5I9nZTy5aW+XHeOdeB5QsI0tkO9k=", "CZq2dlUFuhGY7xQOd7eVTU++eaBWznK6zjnASMANo88=", "KvIR2OCsLY/af4SbjyKaIlxhhrVXYsensq4tHdhcV8s=", "DNBw8jQBSigJq5DHHB2mHpipYyL+3Zm2qq4coQTz+s8=", "Jnk+KryNPDDGBib7qhWPJjWH1r0Vgz1EixFiZLkwJWo=", "IlvjbtDuheH4Ra2oTldIpWaZFSET/2G1BWtti95gwZ0=", "AhdPSe2wLVFU0r7KLckrnMWVOD2h/ejwnkte4+paBl4=", "D2SJHCyLAg5Gw1lMt1jwvdzb0JvQMIgW+0FzSoaYcsM=", "GSqEyi+Z02mR4tKx3v85idHBVsI54Q6fVhQOGFRXYGc=", "Kd/Ne2PwWr8nU6jDQda3pgxiQ7BMmhuLMyC7oEpNR4c=", "HuJ61rm1qGdzOvxhorPnalK6PkvV5let6R/AOIGduls=", "CrR3PxUMP4rTvJU49DzsOVp+NzGulz/v62I6CSF+ZMc=", "E8NSoC9ZUYYgLLC5n6WMVUKrZ/m206Cv0QPe7/bYD0E=", "KpfPLBDEv7/SmfZ8UqFp+SwFt9rFakHE3U/ofIJGzhQ=", "AL7LtHBCvX+Mn2u0IhYtGu0ImihIL3/RarBqEyhf5wI=", "AI5E2iHXOGkbiBdX7zftKcW9n3pEUPz1MpCpLMLKIXY=", "KyBai21LcGPZMfO7XTRkBThD/n++S4PBeIP4ZSeIKhg=", "LZ4yp8kFVv4QjSVawB513zOPzWOyv4TBkoDUJymIY/w=", "KaMiqEwlvS3fbi5CACKNlavWNJoCJmrB27pSBzjOypc=", "BnjJv8by3wEvT+VeM7torBTO0d8NAhUnkgidBG2CjEM=", "D6/zpedCV5T+IKfg62FbixdgOUt/IwQoajrkAJEk2yM=", "H49bYRr5/rnOqGwIQFgSBVPkBBA67iE/WkHR0CVBwNM=", "Fgh12EeWAvlvQKzC0ELuUsFYi2op3kKEllptxskw6gc=", "Fth6UYOjFqHXCvyVHv4s1mfHcyj8/aRYy/X+MEX0bZ4="],
      M: [["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EZJPAv0ZsJJVqqHPRuoFGOPXv+70dCFglJEBHbC9CwI=", "JH+n8CIwShmU/1BUVsIgHvm3FzaUmNP/zkRmAe2d+EU=", "A/17Ge8shh8i93/4EPVOJ3vJTrdsAtedmGvj3N8FHD8=", "GL1BI5w+cVeaZ3RD7P+9VVqB7u6mk1Kmi2fIVjwMKgY=", "LXjDpdKN6f81vwoldjUZblcwyn9ASTJ3B4zXXai069w="], ["ClFKXCJ/TOyV36Ap6N0STDSJWqRrsnwJEfN4DVAVVAo=", "GS4W0X2VayV7haZS7v3y7glYnqxb6AkVd1cj0ssdoG0=", "KYzgweMRO7k1xwWOd3K1M7GqnbDAkmvciRflYFyjrBA=", "CUy06DYhr9Jx5BvHFyfwFY69YSI5rJ1pixf+S+Bbf8g=", "A9iAOVvpPCfWSa9f0ULnazORjLiEHVooFzvVz30yh5E=", "KO6ua1hmrWjkQ7uvkWgNt9fiswN+OP72G0LLzP/OyoE="], ["J4u0mntORK6kbrD4gstpKAGm5g/dW1wjxjzWXMzk/go=", "Bj7ewb7YMfUGr422SNb96hRTRYh+i9z/EJA1odm2dNc=", "G67xy1UJtSakIGH7U2V/mbMjJQDoVRksvoyUDgaMR18=", "EyRWSse9+eIhZOmFjX+o42ixZerqPa9Otn7lnA3y5dQ=", "AFdhuMauyxqMpOpN/CyDdgZKSoAEzu2iEKVSQFYt3BM=", "EMnigxWdWMtMsuNf3oOjuh/cKAAu2ZY9KpnxhheKFI0="], ["DDmen2eqQHB6ID/u+wuVi72tzsXKNJAdJT0CaiQZ9qI=", "CD8N8/GgNR0DMOw/9gLKjMNTt/bnYscQcYTNe0I0SfY=", "Gmdk1ZQ/xKcgtMChn9uMcRmEMHKHpYubX59dWCEssmM=", "ARpjom/qv4f6Zr3mbMJakiyWOC12xqf/SPFTe+rtaDo=", "CMp7ZGV8NUjzK+9bY60kKIpBwLJRCZrSf5Q0MH4+ZNQ=", "AZmCcEcek2GVVEawzbi+qRXsBnXxzWSN3LBDA1B6RIk="], ["HWs9X26jacJvgl0jYpM+qjHqNewKd8H72eAcoVI+RDI=", "EZ7xiLs90NMjBpdsGZQehmS+aH56aWkton2iFabwbUA=", "LZ4KtcBok9/f0DSBOBuoa25ikt9WCdcfLGSy2aefgJ4=", "JfFmMb93Bg9+o0CHwCW/E1eEMZ7wjNouMUGe4KUp5lg=", "FEx6EdpafF2rrj8z+9A8rYbRi8WUx5pJfsuYlO21VPE=", "D5cRYmJ3I/P+rayyiwwQTLj3TeUIdS+o18DbKvE96O4="], ["JL5RAJVDYgbdCr0LDLuVyIOrMEqlJZixppMG7JgaaI0=", "IRYQ4q1KN3Qm+t9waLDBpsKZoWTBwaYD6u2USHDQubk=", "FaZ9mBBBsfbwnz+evv2GTnedOvCBV3hqwHdQXlDsefw=", "BJMn+nnSjBKiyCQGlH938Gd1sCh0aLMTaHdwHb58lZg=", "IwlA3MUjJlj/nClpej/UFtFw6MmY8aqF3qDELXn5Uao=", "GxIcBJzRFZ4okAfgydqZlcxLq0wm+4iOw5cqii5laWQ="]]
    };
    exports2.default = _default;
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon5.js
var require_poseidon5 = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon5 = poseidon52;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c2 = (0, _unstringify.default)(_.default);
    function poseidon52(inputs, nOuts) {
      return (0, _poseidon.default)(inputs, c2, nOuts);
    }
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/constants/2.js
var require__2 = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/constants/2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DumlkrqalRjQWYbWVvQMIRTEmTwRuymTjSHUcwTNjm4=", "APFEUjXyFIxZhlhxafwbzYh7CNTQCGjfVpb/9AlW6GQ=", "CN/zSH6KyZ4fKaBY0PqAuTDHKHMLerNs6HnziQ7Pc/U=", "Lye+aQ/a7kbDzij3UysTyFbDU0LIS9puIJZjEPrcAdA=", "KyrhrPaLe40kFr6/PU9iNLdj/gS4BD7ki4MnvryhbPI=", "AxnQYgcr737MperAb5fU1VlSwXWrawPq5ktEx9vxHPo=", "KIE9yuuuqoKKN234evSmO8i3vyetScYpjvezh78oUm0=", "JydnOyzLyQPxgb844cHUDSAzhlIAw1K8FQkord35y3g=", "I07EXKJ3J8LnSr0rKhSUzW771D40BYfWuPueMeZcxjI=", "FbUlNAMa4Y9/hiyyz3z3YKsQqBUKM3sczZn/boeX1Cg=", "Dcj61tnks19e2aPRhrec444Oio0bWLEy1wHU7s9o0fY=", "G82V/8IR+8pgD3BfrT+1Z+pOs3j2Lh/sl4BVGKR+TZw=", "EFILCrchyt/p7/gbAW/DTcdto2wleJN4F8uXjQad5Vk=", "H21IFJuOf32bJX2O1fu69CkySYB1/tCs6IqeuB9WJ/Y=", "HZZV9lIwkBTSngDvNaIIm//43ByBbw3JyjS9tUYMhwU=", "BN9aVv+VvK+wUfexzUOpm6cx/2fkcDIFj+PUGFaXzH0=", "BnLZlfj/9kAVGz0pDO2vFIaQoQqMhCSn9uwoK25L6Cg=", "CZlStBSIRFSyEgDX/6/dXwyancwG8nCOn8HYIJtcdbk=", "BSy6IlXf0Ax8SDFDuo1GlEjkNYaptM2Rg/0OhDprn6Y=", "C4ut7mkK246wvXRxK3mZr4LeVXByUa13Fgd8uTxGTdw=", "EZsVkPEzB69aHuZRAgwHx0nBXWBoOoBQuWPQqOSyvdE=", "AxULfNbV0XslKdNr4PZ7gyxKz8iE707lzhW+C/tKjQk=", "LMYYLF4UVG488ZUfFzkSNVN077g9gImKvmnLMXyepWU=", "AFAyVR5jeMRQz+EppASzdkIYyt7awU4rktLNcxEb8Pk=", "IzI34yibqjS7FH6XLry5UWRpw5n8wGn7iPnaLMKCdrU=", "Bcj09OvUpuPJgNMWdL++YyMDfyGzSuWk6AwtTCTWAoA=", "CnsdsTBC05a6BdgYoxnyUlK8817zru2R7h8JslkPxls=", "KnO3H5shDPWxQpZXLJ0y2/FW4rCG/0fcXfVCNlpATsA=", "GsmwQXq8yaGTUQfp/8kdw+wY8sTb5/Ipdqdgu1xQxGA=", "EsAzmuCDdII/q7B2cH70eSafPk1ssQQ0kBXuBG3JP8A=", "C3R1sQKhZa1/WxjbTh5wT1KQCqMlO6rGgkZoLlbpoo4=", "A3woSeGRyj7bHF5J9ui4kXyEPjeTZvLqMqs6qI1/hEg=", "BaaBH4VW8BTpJnRmHiF+m9UgbFyToH3BRf2xdqcWNG8=", "KaeV59mAKJRulHt11U6fBEB26Hp7KIO0e2de9fOL1m4=", "IEOaDISzIutFo4V6/Bj1gm6Mc4LIoVhcUHvhmZgf0i8=", "Lguo2U2ez0qU7CBQxzcf8btQ8neZqEttSipvKgmCyIc=", "FD/RFc4I+yfKOOt8zoIrRReCLNIQkEjS5tDdzKF9ccg=", "DGTL7LHHNLhXlo273PgTzfhhFlkyPby/yEMjYjvpyvE=", "AoowWEfGg/ZG/KklwWP/WudPNI1iwrZw8UJs75QD2lM=", "Lk71EP8Lb9pfqUCrTEOA8mpry2TYlCe4JNZ1W1254ww=", "AIHJW8QzhOZj15JwyVbOO4kltPbQM7B4uWOE9QV5QA4=", "LtXwyRy9l0kYfi+t5ofgXuJJGzScA5oLuoqfQCOguzg=", "MFCZkfiNo1BLvzdO1ari8DRIoix2I0yMmQ8B8zpzUgY=", "HD8g/VVAmlMiG3xNSaNWufChEZ+yBntBp1KQlEJOxq0=", "ELTn86td8AMElRRFm24Y7sRrsiE+jhMeFwiHtH3cuWw=", "KhmCl5w/9/Q93VQ9iRwqvd2A+ATAd9d1A5qjUC5Dre8=", "HHTuZPFeHbb+3b6tVtbVXbpDHrw5bJr5XK0PExW9XJE=", "B1M+yFC6f5jquTA8rOAbS55PLouCcIz6nC/kWgrhRqA=", "IVdrQ45QBEmhUeTurxexVChcaPQtQsGAihGr83ZMB1A=", "LxfAVZuP55YIrVyhk9YvELzoOEyBXwkGdD1pMINtSp4=", "LUd+OGLQdwinnoqulGFwvJd1pCATGEdK5mWwsbficw4=", "Fi9SQ5ZwZMOQ4JVXeYTyka+6ImbDj1q82Jvg9bJ0fqs=", "K0yyM+3pukgmTs0siuUNGteoWWqH8p+Kd3enAJI5MxE=", "LI+8st2Fc9wduvj0YihUd22y7s5thcTPQlTnw14DsHo=", "HW80dyXkgWry/0U/DNVrGZ4bYen2Aemt5eiNuHCUnak=", "IEsMOX9OvnHrwtiz31uRPfnmrAK2jTEyTNSa9cRWVSk=", "DEy53DxP2BdPEUmzxjw8L57LgnzX3CVTT/j7dbx5xQI=", "F0rWGhRIyJmiVBZHT0kwMB5cSUdSeeBjmmFt3EW8e1Q=", "GpYXe89NjYn3Wd9OwvPN4uqqKMF3zA+hOpgW1Jo40u8=", "Bm0EskMx1xzQ74BUvGDE/wUgLBJqIzwagkKs42C4owo=", "KkxPxuwLDPUhlXgoccbdOzgcxl9y4CrVJwN6Yqob2AQ=", "E6stE2zPN9RH6fLhSnztyV5yf4RG9tnX5Vr8ASGf1kk=", "ESFVL8omBhYZ0k2EPcgnacGwT87Cb1UZTC4+hprMapo=", "AO9lMyKxPWyIm8gXFcN9d6bNJn1ZXEqJCaVUbHyXz/E=", "DiVIPkWmZSCLJh2Lp0BR5kAMd21lJZXZhFrKNdijl9M=", "KfU23LnddoIkUmRlnhXYjjlaw9Td6S2MRkSNuXnuuok=", "KlbvnyxT/rrf2jNXXb29iFoSTieAu+oXDkVrqs4Ppb4=", "HINhx461z13s+3otF7XECfKuKZmkZ2Lo7kFiQKjLmvE=", "FRr/XziyCg/ARzCJqvAga4Po5op2RQe/09CrS+dDGcU=", "BMYYfkHtiB3BsjnIj3+dQ6n1L8jIts3R525HYVtR8QA=", "E7N72A9NJ/sQ2EMx9vttU0uBxh7RV3ZEnoAbfdycKWc=", "AaXFNic8LZ31eL+9MsF7eizjZkwqUgMskyHOscToqOQ=", "KrNWGDTKc4Na0F9desuVC0qaLGZrlybagyI5Blt8OwI=", "HU2OwpHnINsgD+bWhsDWE6yvavTpXTv2n37VFqWXtkY=", "BBKU0sxITSKPV4T+eRn9K7klNRJAoEtxFRTJyAtlrx0=", "FUrJjgFwjGEcT6cVmR8ASJj1eTnRJuOSBClx3ZDoH8Y=", "CzOdisyn1Pg+7dhAk671EFCzaEyI+LCwRSRWO8bqTaQ=", "CVXknmYQyUJUpPhM+6s0RZjw5x6v9Kfdge2VtQg5yC4=", "BnRqYVbrpUQmueIiBvFavKmm9B5vU1xvNSVAHqBlRiY=", "Dxj1oOzRQjxJbzggxUnCeDjleQ4r0KGWrJF8f/Mgd/s=", "BPbuyhdR9zCKxZ7/W+smHku1Y1g+3nvJKnOCI9b3bhM=", "K1aXM2TExPXBo+xNo83OA4gR6xFvs+RbwXaNJvwLN1g=", "Ejdp3UnVsFTc12uJgEsby44TkrOFcWpdg/62XUN/Ke8=", "IUe0JPxIyAqI7lK5EWmqzqmJ9kRkcRUJlCV7L7AcY+k=", "D9wfWFSLhXAabFUF6jMqKWR+bzStQkPC6lStiXzr5U0=", "Ejc6glH+oATfaKvPD3eG1Lzv8oxdu+DDlE9oXMCgsfI=", "IeT06l81+FutfqUv90LJ6KZCdWtq9EID3YofNcGpADU=", "FiQ5FtadLKPftHIiJNTEYrVzZkkvRekNioGTTxvDsUc=", "HvvkbdeleLT2b5rbyItDeKvCFWbhoEU8oTpBWcrASsI=", "B+pehTfPXdCIhgIOI6fzh9Ro1VJb5m+FO2csyWqIlpo=", "BajE+ZaLiqO3tHijD5pbY2UPGadefOEcqf4WwLdsALw=", "IPBXcSzCFlT7/lm9NF6NrD94GMcBuceILZ1Xtyoy6D8=", "BKEu3tqd/WiWcvjGf+4xY23NjojQHUkBm9kLM+sz22k=", "J+iNjBXzfc7kTx5UJaUd7L0TbOUJGmdn5J7JVEzNEBo=", "L+7Re4QoXtm4pcjF6VpB9m4JZhmncDIjF2xB7kM95NE=", "HtfMdu30XHxAQkFCD3Kc85TllCkRMSoNaXK4vVOv8rg=", "FXQumbm/oyMVf/jFhvVmDqxng0dhRM3K3yh0vkVGaxo=", "GqwoU4f2XoLIlfxoh930BXcQdFTG7AMXKE8DPyfQx4U=", "JYUcPIRdR5D53a29tgVzV4MuLnpJd19x7HWpZVTWfHc=", "FaWCFWXMLsLOeEV9sZft81O367osVSM3DdzMPZ8Uamc=", "JBHVekgTuZgO+n4xodtZZtz2TzYEQndQLxVIXyjHFyc=", "AC5vjWUgzUcT4zW4wLbS5kfpqY4S9M0lWIKLXvbLTJs=", "L/e8j0OAzemX2gC2FrD80a+PDpHi/h7XOYg0YJ4DFdI=", "ALmDG5SFJVle4CckRxvNGC6VIfa3u2jx6Tvk/rsNPL4=", "Ci9TdouOv2qGkTsOV8BOARykCGSKR0OofXetvwycNRI=", "ACSBVhQv0Dc6R5+R/yOelg9Zn/fpS+abfyopAwXhGY0=", "Fx1WILh7+xMoz4wCqz8MmjlxlqpqVCwjUOtRKisrzak=", "FwpPVVNvfclwCHx8ENb612DJUhct1U3ZnRBF5Ow0qAg=", "KaujP3mf5mwu8xNK6gQzbsw344wc0hG6SC7KF+Lb+uE=", "HpvBeaT911j90bsZRQiNR+cNEUoD9qDotbplA2nmSXM=", "HdJpeZtmD61Y9/SJLfsLWv6q2GmpxLRPnJ4cQ72vjwk=", "Is28i3ARetFAEYHQLhVFnnzNQm/oacfJXR3Syw8krzg=", "DvBC5FR3HFM6n1elXFA/zv0xUPUu2Up81bqTucfazv0=", "EWCeBq1sj+Lyh/MDYDfohRMY6LCKA1mgOzBP/KYugoQ=", "EWbZ5VRhbbqedT7qQnwXt/7NWMB23+QnCLCPW3g6qa8=", "LeUpiUMahZWTQTAmNUQT2xd/v0zSrAtW+FWoiDV+5GY=", "MAbrT/x6hYGabaSS86isHfUa7lsXuOiddL8Bz19x6a0=", "KvQfu2G6ioD9z2//nj9vQimT/o8KRjn5YjRMgiUUUIY=", "EZ5oTeR2FV/lprQajryF24cYqyeInoXngbIUus5IJ8M=", "GDW3huLokl4Yi+pZrjY1N7USSMI4KPBHz/eEuXs/2AA=", "KCAaNMWU36NNeUmWxkM6INFSusKnkFySbEDihasy7rY=", "CD79eifRdRCU6A/vr3iwAIZMgutXEYdySnYfiMIsxOc=", "C2+Io1dxmVJhWOYc7qJ76BHBbfd3TdhRngeVZPYf0Ts=", "Dsho5tFeUdlkT2bh1kcalFiVEcoA0p4QFDkObuQlT1s=", "KvM+P4ZncScawMmz7S4RQuzT50uTnNQNANk3q4TJhZE=", "C1ICEfkEtefQm12WHGrOdzRWjFR91oWLNkzl5HlR8Xg=", "Cy1yLQkZoarY21jxAGKpLqDFasQnDoIsyiKGIBiKHUA=", "H3kNTX+M8JTZgM6zfCRT6Ve1SpmRyji74AYdHtblYtQ=", "AXHrld+/fR6uqXzThfeAFQiFwWI1oqao2pLOsB5QQjM=", "DC0OO1/VdUkym/aIXaZrm3kLQN79LIZQdiMFOBsWiHM=", "EWL7KGicJxVOWoIotOcrN3y8r6WJ4oPDXTgDBUQHoY0=", "LxRZtl3uRBtkrThqkegxDygsWpKonhmSFiPvgklxG8A=", "Hm/zIWtojD2ZbXQ2fVzUwbxInUZ1TrcSwkP3DRtTz7s=", "AcqL5zgyuNBoFIfSfRV4AtdBpvNs3CoFdogfkyZHiHU=", "H3c1cG/+n8WG+XbVvfIj3GgChggLEM6gC5td4xX5ZQ4=", "JSK2D06jMHZAoMLc4EH7qSGsEKPV8JbvR0XKg4KF8Bk=", "I/C+4AGxAp1SVQdd3JV/gzQYytT1K2w/jOFsI1VyV1s=", "K8Gui43buB/KrC1EVV7VaF0UJjPp35BfZtlAEJMILVk=", "D5QGuCllZKNzBFB7jbo+0WI3EnOgex/JgBH81q1yIF8=", "I2Co6wzH3vpntymY3pBxThfnWxdKUu5KyxJsjNmV8Kg=", "FYcaXN3q2XaATIA8uu8lXrSBWl6W34sAbcu8J2f4iUg=", "GTpWdmmY7p4KhlLdLzsdoDYvT1T3I3lUT5V8ze77Qg8=", "KjlKQ5NPhpgvm+Vv9PqxcDsuY8itM0g05DCYBed3rg8=", "GFmVTP64aV8+i2NdyzRRkoks0RIjRDuntBZuiHbA0UI=", "BOEYF2MFDlgBNETby5nxkCsRvCXZC73KQI04GfT+0ys=", "D9slPe6Dhp1AwzXqZN6MW7EOuC2wi16LH15VUr/QXyM=", "BYy+ippQJ72qTvtiOt6tYnXwhobxwImEqdfFuum08cA=", "E4Ltzplx4YZJfq2xrrH1KyO0uDvvAjqw0VIotMzspZo=", "A0ZJkPBFxu4IGcpR/RGwvn9huOuZ8Ut34eZjRgHZ6LU=", "I/e/yHINwpb/8ztB+Y/4PG/KtGBdsutaqlvBN663Clg=", "ClmhWOPuwhF+bpTn8OnezxjD/9XhUxqSGWNhWLuvYvI=", "BuxUyAOBwFK1i/I7MS/9POLE66BlQgr49MI+0Adf0Hs=", "EYhy3IMuDrVHa1ZkjoZ+yLCTQPenvLG0li8P+e0fnQE=", "E9afoSfYNBZa1cfLp61Z7VLgsPDkLX/qleGQa1IJIbE=", "FpoXf2PqaBJwscaHenPSG94UOUL7cdxV/YpJ8Z8Qx3s=", "BO9RWRxurZfvQvKHrc5A2Tq+sDK5IvZv+36aWnRQVE0=", "JW4XWh3AeTkOzXynA/suOxnsYYBdTwPO1fRe5t0Paew=", "MBAtKGNqvV/l8q9BL/YAT3XMNg0yBd0toAKBPT4s7rI=", "EJmOQt/NO78cBxS8c+sb9ARDo/qZvvSjH9Mb4YL8x5I=", "GT7djp/PPXYl+n0ktZih2J8zYur01YLv7K12+HnjaGA=", "GBaK/TTy2RXQNozoC3szR9HHpWHOYRQl8mZNeqUfC10=", "KTg8AevTtqsMAXZW6+ZYtqMo7He8M2JuKeLpWzPqYRE=", "EGRtLyYD3jmh9K5ed3GmSnAttuhvt2q2AL9XP5AQxxE=", "C+teB9GycUX1dfE5WlW/Ey+QwltA2ns4ZNAkLcsRF/s=", "FtaFJSB4wTPcDT7K1itciDD5W7LlS1mr3/vwGNlvozY=", "Cmq9HYM5OPM8dBVOBAS0tApVW7vsId36/Wct1iBH8Bo=", "GmefXTbre1yOoSpMLe3I/rEt/+7EUDFycKbxmzTPGGA=", "CYD7IzvUVsI5dNUODr/eRyakI+raTo9v+8dZLj8bk9Y=", "FhtCIy5huEy/GBCvk6OPwM7OPVYoySggA+ustcMSxys=", "CtoQqQx/BSCVD31Hpg1eakk/CXh/FWTl0JID20feGgs=", "GnMNNyMQuoIyA0WimsQjjtPweoorThIbtQ3bmvQH9FE=", "LIEg8mjvBU+BcGTDad2n6pCDd/6rpcTf+9oQ71joxVY=", "HHyIJPdYdT+lfAB4nGhCF7kw6VMTvLc+bnuGSaSWj3A=", "LNntMfX4aRyOOeQHenT6oPQArYtJHrP3tHsn+j/Rz3c=", "I/9PnUaBNFfPYNkvV2GDmaXgIqwyHKVQhUriORiiLuo=", "CZRaXRR6T2bO7OZAXd3Z0K9aLFEDUpQH3/HqWPGAQm0=", "GI2cUoAl1MK2dmDGt3G5D3x9puqinT8mim3SI+xvxjA=", "MFDjeZZZa3+B9oMRQx2HNNun2SbTYzWV4MDY3fTw9H8=", "Fa8RaTloMKkWAMqBAsNcQmzq5UYeP5XYnYKVGNMK/Xg=", "HabQmIVDLqmgbZ83+HPZhdrpM+NRRmspBChNozINisw=", "J5bqkNJpryn1+KzzOSESTk5PrT2+ZYlF5UbuQR3aqcs=", "IC190doPa0sDJcizMHdC8B4VYS7I6TBKfLAxngHTLWA=", "CW1nkNBbt1kVapUromPWcqLX+ceI9Mgxop2s5MD4vl8=", "BU76H2Ww/OKDgIllJ12He0ONojzlsT4ZY3mMsUR9JaQ=", "GxYvg9kX6T7bMwjCmALeudiqaQETsuFIZMz24Y5BZfE=", "IeUkHhJWTdb9nxzdKg3jnu3+/BRmzFaOxc63RaBQbtw=", "HPtWYujPWskiaoDuF7Nqvstzq1+H4WGSe0NJ4Q5L3wg=", "DyEXfjAqdxu65tjR7LNztiyZrzRiIKwBKcU/Zm6yQQA=", "FnFSI3RgaZKv+w3X9xsSvsQjau3mKQVGvO9+H1FcIyA=", "D6PsW5SIJZwutM8kUBv62b4uyeQsXMjM1BnSppLK2HA=", "GTwOBOC9KYNXyyZsFQYIDtNu3OhcZIzAhejFexq1S7o=", "ECrfjvdHNaJ+kSgwbcvDyZ9vcpHNQGV4zhTqKtq6aPg=", "D+CveFjkmFnipU1vGtlFsTFqokv73SOuQKbQy3DD6rE=", "IW9nF7vH3tsIU2oiIIQ/Ti2l8dqp69796KXqc0R5jSI=", "HaVcyQDw0h9KPmlDkZGKGzwjsqx3PGs++I4uQigyUWE="],
      M: [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20="], ["KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "LiQZ+ewC7DlMmHHIMpY9wbiddDyMe5ZAKbIxFoex/iM=", "EBBx8AMjebaXMVh2aQ8FPRSNThCfX7BlyKrMVaD4m/o="], ["FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac=", "F2zAKWla0CWCpw7/CKb9mdBX4S5Y59e2sWzfq8juKRE=", "GaP8ClZwK/QXun/uOAJZP6ZERwMHBD93cyec1x0l1eA="]]
    };
    exports2.default = _default;
  }
});

// ../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon2.js
var require_poseidon2 = __commonJS({
  "../../node_modules/.pnpm/poseidon-lite@0.3.0/node_modules/poseidon-lite/poseidon2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon2 = poseidon23;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c2 = (0, _unstringify.default)(_.default);
    function poseidon23(inputs, nOuts) {
      return (0, _poseidon.default)(inputs, c2, nOuts);
    }
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/utils.js"(exports2) {
    exports2.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
      const b3 = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b3[i] = Number(v & 0xFFn);
        v = v >> 8n;
      }
      return b3;
    };
    exports2.bigInt2U32LE = function bigInt2BytesLE(_a, len) {
      const b3 = Array(len);
      let v = BigInt(_a);
      for (let i = 0; i < len; i++) {
        b3[i] = Number(v & 0xFFFFFFFFn);
        v = v >> 32n;
      }
      return b3;
    };
    exports2.isOcamNum = function(a2) {
      if (!Array.isArray(a2)) return false;
      if (a2.length != 3) return false;
      if (typeof a2[0] !== "number") return false;
      if (typeof a2[1] !== "number") return false;
      if (!Array.isArray(a2[2])) return false;
      return true;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_int.js
var require_build_int = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_int.js"(exports2, module2) {
    module2.exports = function buildInt(module3, n64, _prefix) {
      const prefix = _prefix || "int";
      if (module3.modules[prefix]) return prefix;
      module3.modules[prefix] = {};
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      function buildCopy() {
        const f2 = module3.addFunction(prefix + "_copy");
        f2.addParam("px", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i * 8,
              c2.i64_load(
                c2.getLocal("px"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f2 = module3.addFunction(prefix + "_zero");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < n64; i++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i * 8,
              c2.i64_const(0)
            )
          );
        }
      }
      function buildOne() {
        const f2 = module3.addFunction(prefix + "_one");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i64_store(
            c2.getLocal("pr"),
            0,
            c2.i64_const(1)
          )
        );
        for (let i = 1; i < n64; i++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i * 8,
              c2.i64_const(0)
            )
          );
        }
      }
      function buildIsZero() {
        const f2 = module3.addFunction(prefix + "_isZero");
        f2.addParam("px", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n3) {
          if (n3 == 0) {
            return c2.ret(c2.i64_eqz(
              c2.i64_load(c2.getLocal("px"))
            ));
          }
          return c2.if(
            c2.i64_eqz(
              c2.i64_load(c2.getLocal("px"), n3 * 8)
            ),
            getCompCode(n3 - 1),
            c2.ret(c2.i32_const(0))
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildEq() {
        const f2 = module3.addFunction(prefix + "_eq");
        f2.addParam("px", "i32");
        f2.addParam("py", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n3) {
          if (n3 == 0) {
            return c2.ret(c2.i64_eq(
              c2.i64_load(c2.getLocal("px")),
              c2.i64_load(c2.getLocal("py"))
            ));
          }
          return c2.if(
            c2.i64_eq(
              c2.i64_load(c2.getLocal("px"), n3 * 8),
              c2.i64_load(c2.getLocal("py"), n3 * 8)
            ),
            getCompCode(n3 - 1),
            c2.ret(c2.i32_const(0))
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildGte() {
        const f2 = module3.addFunction(prefix + "_gte");
        f2.addParam("px", "i32");
        f2.addParam("py", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n3) {
          if (n3 == 0) {
            return c2.ret(c2.i64_ge_u(
              c2.i64_load(c2.getLocal("px")),
              c2.i64_load(c2.getLocal("py"))
            ));
          }
          return c2.if(
            c2.i64_lt_u(
              c2.i64_load(c2.getLocal("px"), n3 * 8),
              c2.i64_load(c2.getLocal("py"), n3 * 8)
            ),
            c2.ret(c2.i32_const(0)),
            c2.if(
              c2.i64_gt_u(
                c2.i64_load(c2.getLocal("px"), n3 * 8),
                c2.i64_load(c2.getLocal("py"), n3 * 8)
              ),
              c2.ret(c2.i32_const(1)),
              getCompCode(n3 - 1)
            )
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildAdd() {
        const f2 = module3.addFunction(prefix + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.setReturnType("i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_add(
            c2.i64_load32_u(c2.getLocal("x")),
            c2.i64_load32_u(c2.getLocal("y"))
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("r"),
          c2.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_add(
                c2.i64_load32_u(c2.getLocal("x"), 4 * i),
                c2.i64_load32_u(c2.getLocal("y"), 4 * i)
              ),
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("r"),
            i * 4,
            c2.getLocal("c")
          ));
        }
        f2.addCode(c2.i32_wrap_i64(c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))));
      }
      function buildSub() {
        const f2 = module3.addFunction(prefix + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.setReturnType("i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_sub(
            c2.i64_load32_u(c2.getLocal("x")),
            c2.i64_load32_u(c2.getLocal("y"))
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("r"),
          c2.i64_and(
            c2.getLocal("c"),
            c2.i64_const("0xFFFFFFFF")
          )
        ));
        for (let i = 1; i < n32; i++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_sub(
                c2.i64_load32_u(c2.getLocal("x"), 4 * i),
                c2.i64_load32_u(c2.getLocal("y"), 4 * i)
              ),
              c2.i64_shr_s(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("r"),
            i * 4,
            c2.i64_and(c2.getLocal("c"), c2.i64_const("0xFFFFFFFF"))
          ));
        }
        f2.addCode(c2.i32_wrap_i64(c2.i64_shr_s(c2.getLocal("c"), c2.i64_const(32))));
      }
      function buildMul() {
        const f2 = module3.addFunction(prefix + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        for (let i = 0; i < n32; i++) {
          f2.addLocal("x" + i, "i64");
          f2.addLocal("y" + i, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const loadX = [];
        const loadY = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c2.teeLocal("x" + i, c2.i64_load32_u(c2.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c2.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c2.teeLocal("y" + j, c2.i64_load32_u(c2.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c2.getLocal("y" + j);
          }
          return c2.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.getLocal("r"),
              k * 4,
              c2.getLocal(c0)
            )
          );
          [c0, c1] = [c1, c0];
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_shr_u(
                c2.getLocal(c0),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 * 2 - 4,
            c2.getLocal(c0)
          )
        );
      }
      function buildSquare() {
        const f2 = module3.addFunction(prefix + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("c0_old", "i64");
        f2.addLocal("c1_old", "i64");
        for (let i = 0; i < n32; i++) {
          f2.addLocal("x" + i, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const loadX = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c2.teeLocal("x" + i, c2.i64_load32_u(c2.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c2.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c2.teeLocal("x" + j, c2.i64_load32_u(c2.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c2.getLocal("x" + j);
          }
          return c2.i64_mul(X, Y);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f2.addCode(
            c2.setLocal(c0, c2.i64_const(0)),
            c2.setLocal(c1, c2.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0,
              c2.i64_shl(
                c2.i64_and(
                  c2.getLocal(c0),
                  c2.i64_const(4294967295)
                ),
                c2.i64_const(1)
              )
            )
          );
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_add(
                c2.i64_shl(
                  c2.getLocal(c1),
                  c2.i64_const(1)
                ),
                c2.i64_shr_u(
                  c2.getLocal(c0),
                  c2.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  c2.i64_and(
                    c2.getLocal(c0_old),
                    c2.i64_const(4294967295)
                  )
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.i64_add(
                    c2.getLocal(c1),
                    c2.i64_shr_u(
                      c2.getLocal(c0),
                      c2.i64_const(32)
                    )
                  ),
                  c2.getLocal(c1_old)
                )
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.getLocal("r"),
              k * 4,
              c2.getLocal(c0)
            )
          );
          f2.addCode(
            c2.setLocal(
              c0_old,
              c2.getLocal(c1)
            ),
            c2.setLocal(
              c1_old,
              c2.i64_shr_u(
                c2.getLocal(c0_old),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 * 2 - 4,
            c2.getLocal(c0_old)
          )
        );
      }
      function buildSquareOld() {
        const f2 = module3.addFunction(prefix + "_squareOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function _buildMul1() {
        const f2 = module3.addFunction(prefix + "__mul1");
        f2.addParam("px", "i32");
        f2.addParam("y", "i64");
        f2.addParam("pr", "i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_mul(
            c2.i64_load32_u(c2.getLocal("px"), 0, 0),
            c2.getLocal("y")
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("pr"),
          0,
          0,
          c2.getLocal("c")
        ));
        for (let i = 1; i < n32; i++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_mul(
                c2.i64_load32_u(c2.getLocal("px"), 4 * i, 0),
                c2.getLocal("y")
              ),
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("pr"),
            i * 4,
            0,
            c2.getLocal("c")
          ));
        }
      }
      function _buildAdd1() {
        const f2 = module3.addFunction(prefix + "__add1");
        f2.addParam("x", "i32");
        f2.addParam("y", "i64");
        f2.addLocal("c", "i64");
        f2.addLocal("px", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal("px", c2.getLocal("x")));
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_add(
            c2.i64_load32_u(c2.getLocal("px"), 0, 0),
            c2.getLocal("y")
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("px"),
          0,
          0,
          c2.getLocal("c")
        ));
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_shr_u(
            c2.getLocal("c"),
            c2.i64_const(32)
          )
        ));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i64_eqz(c2.getLocal("c"))
          ),
          c2.setLocal(
            "px",
            c2.i32_add(
              c2.getLocal("px"),
              c2.i32_const(4)
            )
          ),
          c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_load32_u(c2.getLocal("px"), 0, 0),
              c2.getLocal("c")
            )
          ),
          c2.i64_store32(
            c2.getLocal("px"),
            0,
            0,
            c2.getLocal("c")
          ),
          c2.setLocal(
            "c",
            c2.i64_shr_u(
              c2.getLocal("c"),
              c2.i64_const(32)
            )
          ),
          c2.br(0)
        )));
      }
      function buildDiv() {
        _buildMul1();
        _buildAdd1();
        const f2 = module3.addFunction(prefix + "_div");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("c", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("rr", "i32");
        f2.addLocal("cc", "i32");
        f2.addLocal("eX", "i32");
        f2.addLocal("eY", "i32");
        f2.addLocal("sy", "i64");
        f2.addLocal("sx", "i64");
        f2.addLocal("ec", "i32");
        const c2 = f2.getCodeBuilder();
        const Y = c2.i32_const(module3.alloc(n8));
        const Caux = c2.i32_const(module3.alloc(n8));
        const Raux = c2.i32_const(module3.alloc(n8));
        const C = c2.getLocal("cc");
        const R = c2.getLocal("rr");
        const pr1 = module3.alloc(n8 * 2);
        const R1 = c2.i32_const(pr1);
        const R2 = c2.i32_const(pr1 + n8);
        f2.addCode(c2.if(
          c2.getLocal("c"),
          c2.setLocal("cc", c2.getLocal("c")),
          c2.setLocal("cc", Caux)
        ));
        f2.addCode(c2.if(
          c2.getLocal("r"),
          c2.setLocal("rr", c2.getLocal("r")),
          c2.setLocal("rr", Raux)
        ));
        f2.addCode(c2.call(prefix + "_copy", c2.getLocal("x"), R));
        f2.addCode(c2.call(prefix + "_copy", c2.getLocal("y"), Y));
        f2.addCode(c2.call(prefix + "_zero", C));
        f2.addCode(c2.call(prefix + "_zero", R1));
        f2.addCode(c2.setLocal("eX", c2.i32_const(n8 - 1)));
        f2.addCode(c2.setLocal("eY", c2.i32_const(n8 - 1)));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i32_or(
              c2.i32_load8_u(
                c2.i32_add(Y, c2.getLocal("eY")),
                0,
                0
              ),
              c2.i32_eq(
                c2.getLocal("eY"),
                c2.i32_const(3)
              )
            )
          ),
          c2.setLocal("eY", c2.i32_sub(c2.getLocal("eY"), c2.i32_const(1))),
          c2.br(0)
        )));
        f2.addCode(
          c2.setLocal(
            "sy",
            c2.i64_add(
              c2.i64_load32_u(
                c2.i32_sub(
                  c2.i32_add(Y, c2.getLocal("eY")),
                  c2.i32_const(3)
                ),
                0,
                0
              ),
              c2.i64_const(1)
            )
          )
        );
        f2.addCode(
          c2.if(
            c2.i64_eq(
              c2.getLocal("sy"),
              c2.i64_const(1)
            ),
            c2.drop(c2.i64_div_u(c2.i64_const(0), c2.i64_const(0)))
          )
        );
        f2.addCode(c2.block(c2.loop(
          // while (eX>7)&&(Y[eX]==0) ex--;
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_or(
                c2.i32_load8_u(
                  c2.i32_add(R, c2.getLocal("eX")),
                  0,
                  0
                ),
                c2.i32_eq(
                  c2.getLocal("eX"),
                  c2.i32_const(7)
                )
              )
            ),
            c2.setLocal("eX", c2.i32_sub(c2.getLocal("eX"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.setLocal(
            "sx",
            c2.i64_load(
              c2.i32_sub(
                c2.i32_add(R, c2.getLocal("eX")),
                c2.i32_const(7)
              ),
              0,
              0
            )
          ),
          c2.setLocal(
            "sx",
            c2.i64_div_u(
              c2.getLocal("sx"),
              c2.getLocal("sy")
            )
          ),
          c2.setLocal(
            "ec",
            c2.i32_sub(
              c2.i32_sub(
                c2.getLocal("eX"),
                c2.getLocal("eY")
              ),
              c2.i32_const(4)
            )
          ),
          // While greater than 32 bits or ec is neg, shr and inc exp
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_and(
                c2.i64_eqz(
                  c2.i64_and(
                    c2.getLocal("sx"),
                    c2.i64_const("0xFFFFFFFF00000000")
                  )
                ),
                c2.i32_ge_s(
                  c2.getLocal("ec"),
                  c2.i32_const(0)
                )
              )
            ),
            c2.setLocal(
              "sx",
              c2.i64_shr_u(
                c2.getLocal("sx"),
                c2.i64_const(8)
              )
            ),
            c2.setLocal(
              "ec",
              c2.i32_add(
                c2.getLocal("ec"),
                c2.i32_const(1)
              )
            ),
            c2.br(0)
          )),
          c2.if(
            c2.i64_eqz(c2.getLocal("sx")),
            [
              ...c2.br_if(
                2,
                c2.i32_eqz(c2.call(prefix + "_gte", R, Y))
              ),
              ...c2.setLocal("sx", c2.i64_const(1)),
              ...c2.setLocal("ec", c2.i32_const(0))
            ]
          ),
          c2.call(prefix + "__mul1", Y, c2.getLocal("sx"), R2),
          c2.drop(c2.call(
            prefix + "_sub",
            R,
            c2.i32_sub(R2, c2.getLocal("ec")),
            R
          )),
          c2.call(
            prefix + "__add1",
            c2.i32_add(C, c2.getLocal("ec")),
            c2.getLocal("sx")
          ),
          c2.br(0)
        )));
      }
      function buildInverseMod() {
        const f2 = module3.addFunction(prefix + "_inverseMod");
        f2.addParam("px", "i32");
        f2.addParam("pm", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("t", "i32");
        f2.addLocal("newt", "i32");
        f2.addLocal("r", "i32");
        f2.addLocal("qq", "i32");
        f2.addLocal("qr", "i32");
        f2.addLocal("newr", "i32");
        f2.addLocal("swp", "i32");
        f2.addLocal("x", "i32");
        f2.addLocal("signt", "i32");
        f2.addLocal("signnewt", "i32");
        f2.addLocal("signx", "i32");
        const c2 = f2.getCodeBuilder();
        const aux1 = c2.i32_const(module3.alloc(n8));
        const aux2 = c2.i32_const(module3.alloc(n8));
        const aux3 = c2.i32_const(module3.alloc(n8));
        const aux4 = c2.i32_const(module3.alloc(n8));
        const aux5 = c2.i32_const(module3.alloc(n8));
        const aux6 = c2.i32_const(module3.alloc(n8));
        const mulBuff = c2.i32_const(module3.alloc(n8 * 2));
        const aux7 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.setLocal("t", aux1),
          c2.call(prefix + "_zero", aux1),
          c2.setLocal("signt", c2.i32_const(0))
        );
        f2.addCode(
          c2.setLocal("r", aux2),
          c2.call(prefix + "_copy", c2.getLocal("pm"), aux2)
        );
        f2.addCode(
          c2.setLocal("newt", aux3),
          c2.call(prefix + "_one", aux3),
          c2.setLocal("signnewt", c2.i32_const(0))
        );
        f2.addCode(
          c2.setLocal("newr", aux4),
          c2.call(prefix + "_copy", c2.getLocal("px"), aux4)
        );
        f2.addCode(c2.setLocal("qq", aux5));
        f2.addCode(c2.setLocal("qr", aux6));
        f2.addCode(c2.setLocal("x", aux7));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.call(prefix + "_isZero", c2.getLocal("newr"))
          ),
          c2.call(prefix + "_div", c2.getLocal("r"), c2.getLocal("newr"), c2.getLocal("qq"), c2.getLocal("qr")),
          c2.call(prefix + "_mul", c2.getLocal("qq"), c2.getLocal("newt"), mulBuff),
          c2.if(
            c2.getLocal("signt"),
            c2.if(
              c2.getLocal("signnewt"),
              c2.if(
                c2.call(prefix + "_gte", mulBuff, c2.getLocal("t")),
                [
                  ...c2.drop(c2.call(prefix + "_sub", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(0))
                ],
                [
                  ...c2.drop(c2.call(prefix + "_sub", c2.getLocal("t"), mulBuff, c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(1))
                ]
              ),
              [
                ...c2.drop(c2.call(prefix + "_add", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                ...c2.setLocal("signx", c2.i32_const(1))
              ]
            ),
            c2.if(
              c2.getLocal("signnewt"),
              [
                ...c2.drop(c2.call(prefix + "_add", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                ...c2.setLocal("signx", c2.i32_const(0))
              ],
              c2.if(
                c2.call(prefix + "_gte", c2.getLocal("t"), mulBuff),
                [
                  ...c2.drop(c2.call(prefix + "_sub", c2.getLocal("t"), mulBuff, c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(0))
                ],
                [
                  ...c2.drop(c2.call(prefix + "_sub", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(1))
                ]
              )
            )
          ),
          c2.setLocal("swp", c2.getLocal("t")),
          c2.setLocal("t", c2.getLocal("newt")),
          c2.setLocal("newt", c2.getLocal("x")),
          c2.setLocal("x", c2.getLocal("swp")),
          c2.setLocal("signt", c2.getLocal("signnewt")),
          c2.setLocal("signnewt", c2.getLocal("signx")),
          c2.setLocal("swp", c2.getLocal("r")),
          c2.setLocal("r", c2.getLocal("newr")),
          c2.setLocal("newr", c2.getLocal("qr")),
          c2.setLocal("qr", c2.getLocal("swp")),
          c2.br(0)
        )));
        f2.addCode(c2.if(
          c2.getLocal("signt"),
          c2.drop(c2.call(prefix + "_sub", c2.getLocal("pm"), c2.getLocal("t"), c2.getLocal("pr"))),
          c2.call(prefix + "_copy", c2.getLocal("t"), c2.getLocal("pr"))
        ));
      }
      buildCopy();
      buildZero();
      buildIsZero();
      buildOne();
      buildEq();
      buildGte();
      buildAdd();
      buildSub();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildDiv();
      buildInverseMod();
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_gte");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_div");
      module3.exportFunction(prefix + "_inverseMod");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_timesscalar.js
var require_build_timesscalar = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_timesscalar.js"(exports2, module2) {
    module2.exports = function buildTimesScalar(module3, fnName, elementLen, opAB, opAA, opCopy, opInit) {
      const f2 = module3.addFunction(fnName);
      f2.addParam("base", "i32");
      f2.addParam("scalar", "i32");
      f2.addParam("scalarLength", "i32");
      f2.addParam("r", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("b", "i32");
      const c2 = f2.getCodeBuilder();
      const aux = c2.i32_const(module3.alloc(elementLen));
      f2.addCode(
        c2.if(
          c2.i32_eqz(c2.getLocal("scalarLength")),
          [
            ...c2.call(opInit, c2.getLocal("r")),
            ...c2.ret([])
          ]
        )
      );
      f2.addCode(c2.call(opCopy, c2.getLocal("base"), aux));
      f2.addCode(c2.call(opInit, c2.getLocal("r")));
      f2.addCode(c2.setLocal("i", c2.getLocal("scalarLength")));
      f2.addCode(c2.block(c2.loop(
        c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
        c2.setLocal(
          "b",
          c2.i32_load8_u(
            c2.i32_add(
              c2.getLocal("scalar"),
              c2.getLocal("i")
            )
          )
        ),
        ...innerLoop(),
        c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
        c2.br(0)
      )));
      function innerLoop() {
        const code = [];
        for (let i = 0; i < 8; i++) {
          code.push(
            ...c2.call(opAA, c2.getLocal("r"), c2.getLocal("r")),
            ...c2.if(
              c2.i32_ge_u(c2.getLocal("b"), c2.i32_const(128 >> i)),
              [
                ...c2.setLocal(
                  "b",
                  c2.i32_sub(
                    c2.getLocal("b"),
                    c2.i32_const(128 >> i)
                  )
                ),
                ...c2.call(opAB, c2.getLocal("r"), aux, c2.getLocal("r"))
              ]
            )
          );
        }
        return code;
      }
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchinverse.js
var require_build_batchinverse = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchinverse.js"(exports2, module2) {
    module2.exports = buildBatchInverse;
    function buildBatchInverse(module3, prefix) {
      const n8 = module3.modules[prefix].n64 * 8;
      const f2 = module3.addFunction(prefix + "_batchInverse");
      f2.addParam("pIn", "i32");
      f2.addParam("inStep", "i32");
      f2.addParam("n", "i32");
      f2.addParam("pOut", "i32");
      f2.addParam("outStep", "i32");
      f2.addLocal("itAux", "i32");
      f2.addLocal("itIn", "i32");
      f2.addLocal("itOut", "i32");
      f2.addLocal("i", "i32");
      const c2 = f2.getCodeBuilder();
      const AUX = c2.i32_const(module3.alloc(n8));
      f2.addCode(
        c2.setLocal("itAux", c2.i32_load(c2.i32_const(0))),
        c2.i32_store(
          c2.i32_const(0),
          c2.i32_add(
            c2.getLocal("itAux"),
            c2.i32_mul(
              c2.i32_add(
                c2.getLocal("n"),
                c2.i32_const(1)
              ),
              c2.i32_const(n8)
            )
          )
        )
      );
      f2.addCode(
        // aux[0] = a;
        c2.call(prefix + "_one", c2.getLocal("itAux")),
        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
        c2.setLocal("itIn", c2.getLocal("pIn")),
        c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
        c2.setLocal("i", c2.i32_const(0)),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("itIn")),
            c2.call(
              prefix + "_copy",
              c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)),
              c2.getLocal("itAux")
            ),
            c2.call(
              prefix + "_mul",
              c2.getLocal("itIn"),
              c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)),
              c2.getLocal("itAux")
            )
          ),
          c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.getLocal("inStep"))),
          c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
          c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        )),
        // point to the last
        c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.getLocal("inStep"))),
        c2.setLocal("itAux", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))),
        // itOut = pOut + (n-1)*stepOut   // Point to the last
        c2.setLocal(
          "itOut",
          c2.i32_add(
            c2.getLocal("pOut"),
            c2.i32_mul(
              c2.i32_sub(c2.getLocal("n"), c2.i32_const(1)),
              c2.getLocal("outStep")
            )
          )
        ),
        // aux[n-1] = 1/aux[n-1]
        c2.call(prefix + "_inverse", c2.getLocal("itAux"), c2.getLocal("itAux")),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("itIn")),
            [
              ...c2.call(
                prefix + "_copy",
                c2.getLocal("itAux"),
                c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))
              ),
              ...c2.call(
                prefix + "_zero",
                c2.getLocal("itOut")
              )
            ],
            [
              ...c2.call(prefix + "_copy", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)), AUX),
              ...c2.call(
                prefix + "_mul",
                c2.getLocal("itAux"),
                c2.getLocal("itIn"),
                c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))
              ),
              ...c2.call(
                prefix + "_mul",
                c2.getLocal("itAux"),
                AUX,
                c2.getLocal("itOut")
              )
            ]
          ),
          c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.getLocal("inStep"))),
          c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.getLocal("outStep"))),
          c2.setLocal("itAux", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))),
          c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        ))
      );
      f2.addCode(
        c2.i32_store(
          c2.i32_const(0),
          c2.getLocal("itAux")
        )
      );
    }
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchconvertion.js
var require_build_batchconvertion = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchconvertion.js"(exports2, module2) {
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f2 = module3.addFunction(fnName);
      f2.addParam("pIn", "i32");
      f2.addParam("n", "i32");
      f2.addParam("pOut", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("itIn", "i32");
      f2.addLocal("itOut", "i32");
      const c2 = f2.getCodeBuilder();
      if (reverse) {
        f2.addCode(
          c2.setLocal(
            "itIn",
            c2.i32_add(
              c2.getLocal("pIn"),
              c2.i32_mul(
                c2.i32_sub(
                  c2.getLocal("n"),
                  c2.i32_const(1)
                ),
                c2.i32_const(sizeIn)
              )
            )
          ),
          c2.setLocal(
            "itOut",
            c2.i32_add(
              c2.getLocal("pOut"),
              c2.i32_mul(
                c2.i32_sub(
                  c2.getLocal("n"),
                  c2.i32_const(1)
                ),
                c2.i32_const(sizeOut)
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.call(internalFnName, c2.getLocal("itIn"), c2.getLocal("itOut")),
            c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.i32_const(sizeIn))),
            c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      } else {
        f2.addCode(
          c2.setLocal("itIn", c2.getLocal("pIn")),
          c2.setLocal("itOut", c2.getLocal("pOut")),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.call(internalFnName, c2.getLocal("itIn"), c2.getLocal("itOut")),
            c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(sizeIn))),
            c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchop.js
var require_build_batchop = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_batchop.js"(exports2, module2) {
    module2.exports = buildBatchConvertion;
    function buildBatchConvertion(module3, fnName, internalFnName, sizeIn, sizeOut, reverse) {
      if (typeof reverse === "undefined") {
        if (sizeIn < sizeOut) {
          reverse = true;
        } else {
          reverse = false;
        }
      }
      const f2 = module3.addFunction(fnName);
      f2.addParam("pIn1", "i32");
      f2.addParam("pIn2", "i32");
      f2.addParam("n", "i32");
      f2.addParam("pOut", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("itIn1", "i32");
      f2.addLocal("itIn2", "i32");
      f2.addLocal("itOut", "i32");
      const c2 = f2.getCodeBuilder();
      if (reverse) {
        f2.addCode(
          c2.setLocal(
            "itIn1",
            c2.i32_add(
              c2.getLocal("pIn1"),
              c2.i32_mul(
                c2.i32_sub(
                  c2.getLocal("n"),
                  c2.i32_const(1)
                ),
                c2.i32_const(sizeIn)
              )
            )
          ),
          c2.setLocal(
            "itIn2",
            c2.i32_add(
              c2.getLocal("pIn2"),
              c2.i32_mul(
                c2.i32_sub(
                  c2.getLocal("n"),
                  c2.i32_const(1)
                ),
                c2.i32_const(sizeIn)
              )
            )
          ),
          c2.setLocal(
            "itOut",
            c2.i32_add(
              c2.getLocal("pOut"),
              c2.i32_mul(
                c2.i32_sub(
                  c2.getLocal("n"),
                  c2.i32_const(1)
                ),
                c2.i32_const(sizeOut)
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.call(internalFnName, c2.getLocal("itIn1"), c2.getLocal("itIn2"), c2.getLocal("itOut")),
            c2.setLocal("itIn1", c2.i32_sub(c2.getLocal("itIn1"), c2.i32_const(sizeIn))),
            c2.setLocal("itIn2", c2.i32_sub(c2.getLocal("itIn2"), c2.i32_const(sizeIn))),
            c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      } else {
        f2.addCode(
          c2.setLocal("itIn1", c2.getLocal("pIn1")),
          c2.setLocal("itIn2", c2.getLocal("pIn2")),
          c2.setLocal("itOut", c2.getLocal("pOut")),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.call(internalFnName, c2.getLocal("itIn1"), c2.getLocal("itIn2"), c2.getLocal("itOut")),
            c2.setLocal("itIn1", c2.i32_add(c2.getLocal("itIn1"), c2.i32_const(sizeIn))),
            c2.setLocal("itIn2", c2.i32_add(c2.getLocal("itIn2"), c2.i32_const(sizeIn))),
            c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
    }
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bigint.js
var require_bigint = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bigint.js"(exports2, module2) {
    function compare(a2, b3) {
      return a2 === b3 ? 0 : a2 > b3 ? 1 : -1;
    }
    function square2(n3) {
      return n3 * n3;
    }
    function isOdd3(n3) {
      return n3 % 2n !== 0n;
    }
    function isEven(n3) {
      return n3 % 2n === 0n;
    }
    function isNegative3(n3) {
      return n3 < 0n;
    }
    function isPositive(n3) {
      return n3 > 0n;
    }
    function bitLength3(n3) {
      if (isNegative3(n3)) {
        return n3.toString(2).length - 1;
      } else {
        return n3.toString(2).length;
      }
    }
    function abs2(n3) {
      return n3 < 0n ? -n3 : n3;
    }
    function isUnit(n3) {
      return abs2(n3) === 1n;
    }
    function modInv(a2, n3) {
      var t = 0n, newT = 1n, r2 = n3, newR = abs2(a2), q, lastT, lastR;
      while (newR !== 0n) {
        q = r2 / newR;
        lastT = t;
        lastR = r2;
        t = newT;
        r2 = newR;
        newT = lastT - q * newT;
        newR = lastR - q * newR;
      }
      if (!isUnit(r2)) throw new Error(a2.toString() + " and " + n3.toString() + " are not co-prime");
      if (compare(t, 0n) === -1) {
        t = t + n3;
      }
      if (isNegative3(a2)) {
        return -t;
      }
      return t;
    }
    function modPow(n3, exp3, mod3) {
      if (mod3 === 0n) throw new Error("Cannot take modPow with modulus 0");
      var r2 = 1n, base = n3 % mod3;
      if (isNegative3(exp3)) {
        exp3 = exp3 * -1n;
        base = modInv(base, mod3);
      }
      while (isPositive(exp3)) {
        if (base === 0n) return 0n;
        if (isOdd3(exp3)) r2 = r2 * base % mod3;
        exp3 = exp3 / 2n;
        base = square2(base) % mod3;
      }
      return r2;
    }
    function compareAbs(a2, b3) {
      a2 = a2 >= 0n ? a2 : -a2;
      b3 = b3 >= 0n ? b3 : -b3;
      return a2 === b3 ? 0 : a2 > b3 ? 1 : -1;
    }
    function isDivisibleBy(a2, n3) {
      if (n3 === 0n) return false;
      if (isUnit(n3)) return true;
      if (compareAbs(n3, 2n) === 0) return isEven(a2);
      return a2 % n3 === 0n;
    }
    function isBasicPrime(v) {
      var n3 = abs2(v);
      if (isUnit(n3)) return false;
      if (n3 === 2n || n3 === 3n || n3 === 5n) return true;
      if (isEven(n3) || isDivisibleBy(n3, 3n) || isDivisibleBy(n3, 5n)) return false;
      if (n3 < 49n) return true;
    }
    function prev(n3) {
      return n3 - 1n;
    }
    function millerRabinTest(n3, a2) {
      var nPrev = prev(n3), b3 = nPrev, r2 = 0, d2, i, x;
      while (isEven(b3)) b3 = b3 / 2n, r2++;
      next: for (i = 0; i < a2.length; i++) {
        if (n3 < a2[i]) continue;
        x = modPow(BigInt(a2[i]), b3, n3);
        if (isUnit(x) || x === nPrev) continue;
        for (d2 = r2 - 1; d2 != 0; d2--) {
          x = square2(x) % n3;
          if (isUnit(x)) return false;
          if (x === nPrev) continue next;
        }
        return false;
      }
      return true;
    }
    function isPrime(p) {
      var isPrime2 = isBasicPrime(p);
      if (isPrime2 !== void 0) return isPrime2;
      var n3 = abs2(p);
      var bits3 = bitLength3(n3);
      if (bits3 <= 64)
        return millerRabinTest(n3, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * Number(bits3);
      var t = Math.ceil(logN);
      for (var a2 = [], i = 0; i < t; i++) {
        a2.push(BigInt(i + 2));
      }
      return millerRabinTest(n3, a2);
    }
    module2.exports.bitLength = bitLength3;
    module2.exports.isOdd = isOdd3;
    module2.exports.isNegative = isNegative3;
    module2.exports.abs = abs2;
    module2.exports.isUnit = isUnit;
    module2.exports.compare = compare;
    module2.exports.modInv = modInv;
    module2.exports.modPow = modPow;
    module2.exports.isPrime = isPrime;
    module2.exports.square = square2;
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f1m.js
var require_build_f1m = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f1m.js"(exports2, module2) {
    var buildInt = require_build_int();
    var utils2 = require_utils3();
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    var buildBatchConvertion = require_build_batchconvertion();
    var buildBatchOp = require_build_batchop();
    var { bitLength: bitLength3, modInv, modPow, isPrime, isOdd: isOdd3, square: square2 } = require_bigint();
    module2.exports = function buildF1m(module3, _q, _prefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength3(q - 1n) - 1) / 64) + 1;
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1m";
      if (module3.modules[prefix]) return prefix;
      const intPrefix = buildInt(module3, n64, _intPrefix);
      const pq = module3.alloc(n8, utils2.bigInt2BytesLE(q, n8));
      const pR2 = module3.alloc(utils2.bigInt2BytesLE(square2(1n << BigInt(n64 * 64)) % q, n8));
      const pOne = module3.alloc(utils2.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q, n8));
      const pZero = module3.alloc(utils2.bigInt2BytesLE(0n, n8));
      const _minusOne = q - 1n;
      const _e = _minusOne >> 1n;
      const pe = module3.alloc(n8, utils2.bigInt2BytesLE(_e, n8));
      const _ePlusOne = _e + 1n;
      const pePlusOne = module3.alloc(n8, utils2.bigInt2BytesLE(_ePlusOne, n8));
      module3.modules[prefix] = {
        pq,
        pR2,
        n64,
        q,
        pOne,
        pZero,
        pePlusOne
      };
      function buildOne() {
        const f2 = module3.addFunction(prefix + "_one");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_copy", c2.i32_const(pOne), c2.getLocal("pr")));
      }
      function buildAdd() {
        const f2 = module3.addFunction(prefix + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_add", c2.getLocal("x"), c2.getLocal("y"), c2.getLocal("r")),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSub() {
        const f2 = module3.addFunction(prefix + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_sub", c2.getLocal("x"), c2.getLocal("y"), c2.getLocal("r")),
            c2.drop(c2.call(intPrefix + "_add", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
          )
        );
      }
      function buildNeg() {
        const f2 = module3.addFunction(prefix + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(prefix + "_sub", c2.i32_const(pZero), c2.getLocal("x"), c2.getLocal("r"))
        );
      }
      function buildIsNegative() {
        const f2 = module3.addFunction(prefix + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.call(prefix + "_fromMontgomery", c2.getLocal("x"), AUX),
          c2.call(intPrefix + "_gte", AUX, c2.i32_const(pePlusOne))
        );
      }
      function buildSign() {
        const f2 = module3.addFunction(prefix + "_sign");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_isZero", c2.getLocal("x")),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(prefix + "_fromMontgomery", c2.getLocal("x"), AUX),
          c2.if(
            c2.call(intPrefix + "_gte", AUX, c2.i32_const(pePlusOne)),
            c2.ret(c2.i32_const(-1))
          ),
          c2.ret(c2.i32_const(1))
        );
      }
      function buildMReduct() {
        const carries = module3.alloc(n32 * n32 * 8);
        const f2 = module3.addFunction(prefix + "_mReduct");
        f2.addParam("t", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("np32", "i64");
        f2.addLocal("c", "i64");
        f2.addLocal("m", "i64");
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        for (let i = 0; i < n32; i++) {
          f2.addCode(c2.setLocal("c", c2.i64_const(0)));
          f2.addCode(
            c2.setLocal(
              "m",
              c2.i64_and(
                c2.i64_mul(
                  c2.i64_load32_u(c2.getLocal("t"), i * 4),
                  c2.getLocal("np32")
                ),
                c2.i64_const("0xFFFFFFFF")
              )
            )
          );
          for (let j = 0; j < n32; j++) {
            f2.addCode(
              c2.setLocal(
                "c",
                c2.i64_add(
                  c2.i64_add(
                    c2.i64_load32_u(c2.getLocal("t"), (i + j) * 4),
                    c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
                  ),
                  c2.i64_mul(
                    c2.i64_load32_u(c2.i32_const(pq), j * 4),
                    c2.getLocal("m")
                  )
                )
              )
            );
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("t"),
                (i + j) * 4,
                c2.getLocal("c")
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.i32_const(carries),
              i * 4,
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          );
        }
        f2.addCode(
          c2.call(
            prefix + "_add",
            c2.i32_const(carries),
            c2.i32_add(
              c2.getLocal("t"),
              c2.i32_const(n32 * 4)
            ),
            c2.getLocal("r")
          )
        );
      }
      function buildMul() {
        const f2 = module3.addFunction(prefix + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f2.addLocal("x" + i, "i64");
          f2.addLocal("y" + i, "i64");
          f2.addLocal("m" + i, "i64");
          f2.addLocal("q" + i, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        const loadX = [];
        const loadY = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c2.teeLocal("x" + i, c2.i64_load32_u(c2.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c2.getLocal("x" + i);
          }
          if (!loadY[j]) {
            Y = c2.teeLocal("y" + j, c2.i64_load32_u(c2.getLocal("y"), j * 4));
            loadY[j] = true;
          } else {
            Y = c2.getLocal("y" + j);
          }
          return c2.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c2.teeLocal("q" + i, c2.i64_load32_u(c2.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c2.getLocal("q" + i);
          }
          M = c2.getLocal("m" + j);
          return c2.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          for (let i = Math.max(0, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f2.addCode(
              c2.setLocal(
                "m" + k,
                c2.i64_and(
                  c2.i64_mul(
                    c2.i64_and(
                      c2.getLocal(c0),
                      c2.i64_const(4294967295)
                    ),
                    c2.getLocal("np32")
                  ),
                  c2.i64_const("0xFFFFFFFF")
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("r"),
                (k - n32) * 4,
                c2.getLocal(c0)
              )
            );
          }
          [c0, c1] = [c1, c0];
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_shr_u(
                c2.getLocal(c0),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 - 4,
            c2.getLocal(c0)
          )
        );
        f2.addCode(
          c2.if(
            c2.i32_wrap_i64(c2.getLocal(c1)),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSquare() {
        const f2 = module3.addFunction(prefix + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("c0_old", "i64");
        f2.addLocal("c1_old", "i64");
        f2.addLocal("np32", "i64");
        for (let i = 0; i < n32; i++) {
          f2.addLocal("x" + i, "i64");
          f2.addLocal("m" + i, "i64");
          f2.addLocal("q" + i, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        const loadX = [];
        const loadQ = [];
        function mulij(i, j) {
          let X, Y;
          if (!loadX[i]) {
            X = c2.teeLocal("x" + i, c2.i64_load32_u(c2.getLocal("x"), i * 4));
            loadX[i] = true;
          } else {
            X = c2.getLocal("x" + i);
          }
          if (!loadX[j]) {
            Y = c2.teeLocal("x" + j, c2.i64_load32_u(c2.getLocal("x"), j * 4));
            loadX[j] = true;
          } else {
            Y = c2.getLocal("x" + j);
          }
          return c2.i64_mul(X, Y);
        }
        function mulqm(i, j) {
          let Q, M;
          if (!loadQ[i]) {
            Q = c2.teeLocal("q" + i, c2.i64_load32_u(c2.i32_const(0), pq + i * 4));
            loadQ[i] = true;
          } else {
            Q = c2.getLocal("q" + i);
          }
          M = c2.getLocal("m" + j);
          return c2.i64_mul(Q, M);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k = 0; k < n32 * 2 - 1; k++) {
          f2.addCode(
            c2.setLocal(c0, c2.i64_const(0)),
            c2.setLocal(c1, c2.i64_const(0))
          );
          for (let i = Math.max(0, k - n32 + 1); i < k + 1 >> 1 && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0,
              c2.i64_shl(
                c2.i64_and(
                  c2.getLocal(c0),
                  c2.i64_const(4294967295)
                ),
                c2.i64_const(1)
              )
            )
          );
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_add(
                c2.i64_shl(
                  c2.getLocal(c1),
                  c2.i64_const(1)
                ),
                c2.i64_shr_u(
                  c2.getLocal(c0),
                  c2.i64_const(32)
                )
              )
            )
          );
          if (k % 2 == 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(k >> 1, k >> 1)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k > 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  c2.i64_and(
                    c2.getLocal(c0_old),
                    c2.i64_const(4294967295)
                  )
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.i64_add(
                    c2.getLocal(c1),
                    c2.i64_shr_u(
                      c2.getLocal(c0),
                      c2.i64_const(32)
                    )
                  ),
                  c2.getLocal(c1_old)
                )
              )
            );
          }
          for (let i = Math.max(1, k - n32 + 1); i <= k && i < n32; i++) {
            const j = k - i;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(i, j)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k < n32) {
            f2.addCode(
              c2.setLocal(
                "m" + k,
                c2.i64_and(
                  c2.i64_mul(
                    c2.i64_and(
                      c2.getLocal(c0),
                      c2.i64_const(4294967295)
                    ),
                    c2.getLocal("np32")
                  ),
                  c2.i64_const("0xFFFFFFFF")
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(0, k)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k >= n32) {
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("r"),
                (k - n32) * 4,
                c2.getLocal(c0)
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0_old,
              c2.getLocal(c1)
            ),
            c2.setLocal(
              c1_old,
              c2.i64_shr_u(
                c2.getLocal(c0_old),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 - 4,
            c2.getLocal(c0_old)
          )
        );
        f2.addCode(
          c2.if(
            c2.i32_wrap_i64(c2.getLocal(c1_old)),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSquareOld() {
        const f2 = module3.addFunction(prefix + "_squareOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function buildToMontgomery() {
        const f2 = module3.addFunction(prefix + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix + "_mul", c2.getLocal("x"), c2.i32_const(pR2), c2.getLocal("r")));
      }
      function buildFromMontgomery() {
        const pAux2 = module3.alloc(n8 * 2);
        const f2 = module3.addFunction(prefix + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_copy", c2.getLocal("x"), c2.i32_const(pAux2)));
        f2.addCode(c2.call(intPrefix + "_zero", c2.i32_const(pAux2 + n8)));
        f2.addCode(c2.call(prefix + "_mReduct", c2.i32_const(pAux2), c2.getLocal("r")));
      }
      function buildInverse() {
        const f2 = module3.addFunction(prefix + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix + "_fromMontgomery", c2.getLocal("x"), c2.getLocal("r")));
        f2.addCode(c2.call(intPrefix + "_inverseMod", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")));
        f2.addCode(c2.call(prefix + "_toMontgomery", c2.getLocal("r"), c2.getLocal("r")));
      }
      let _nqr = 2n;
      if (isPrime(q)) {
        while (modPow(_nqr, _e, q) !== _minusOne) _nqr = _nqr + 1n;
      }
      let s2 = 0;
      let _t = _minusOne;
      while (!isOdd3(_t) && _t !== 0n) {
        s2++;
        _t = _t >> 1n;
      }
      const pt = module3.alloc(n8, utils2.bigInt2BytesLE(_t, n8));
      const _nqrToT = modPow(_nqr, _t, q);
      const pNqrToT = module3.alloc(utils2.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q, n8));
      const _tPlusOneOver2 = _t + 1n >> 1n;
      const ptPlusOneOver2 = module3.alloc(n8, utils2.bigInt2BytesLE(_tPlusOneOver2, n8));
      function buildSqrt2() {
        const f2 = module3.addFunction(prefix + "_sqrt");
        f2.addParam("n", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        const c2 = f2.getCodeBuilder();
        const ONE = c2.i32_const(pOne);
        const C = c2.i32_const(module3.alloc(n8));
        const T = c2.i32_const(module3.alloc(n8));
        const R = c2.i32_const(module3.alloc(n8));
        const SQ = c2.i32_const(module3.alloc(n8));
        const B = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          // If (n==0) return 0
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("n")),
            c2.ret(
              c2.call(prefix + "_zero", c2.getLocal("r"))
            )
          ),
          c2.setLocal("m", c2.i32_const(s2)),
          c2.call(prefix + "_copy", c2.i32_const(pNqrToT), C),
          c2.call(prefix + "_exp", c2.getLocal("n"), c2.i32_const(pt), c2.i32_const(n8), T),
          c2.call(prefix + "_exp", c2.getLocal("n"), c2.i32_const(ptPlusOneOver2), c2.i32_const(n8), R),
          c2.block(c2.loop(
            c2.br_if(1, c2.call(prefix + "_eq", T, ONE)),
            c2.call(prefix + "_square", T, SQ),
            c2.setLocal("i", c2.i32_const(1)),
            c2.block(c2.loop(
              c2.br_if(1, c2.call(prefix + "_eq", SQ, ONE)),
              c2.call(prefix + "_square", SQ, SQ),
              c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.call(prefix + "_copy", C, B),
            c2.setLocal("j", c2.i32_sub(c2.i32_sub(c2.getLocal("m"), c2.getLocal("i")), c2.i32_const(1))),
            c2.block(c2.loop(
              c2.br_if(1, c2.i32_eqz(c2.getLocal("j"))),
              c2.call(prefix + "_square", B, B),
              c2.setLocal("j", c2.i32_sub(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("m", c2.getLocal("i")),
            c2.call(prefix + "_square", B, C),
            c2.call(prefix + "_mul", T, C, T),
            c2.call(prefix + "_mul", R, B, R),
            c2.br(0)
          )),
          c2.if(
            c2.call(prefix + "_isNegative", R),
            c2.call(prefix + "_neg", R, c2.getLocal("r")),
            c2.call(prefix + "_copy", R, c2.getLocal("r"))
          )
        );
      }
      function buildIsSquare() {
        const f2 = module3.addFunction(prefix + "_isSquare");
        f2.addParam("n", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const ONE = c2.i32_const(pOne);
        const AUX = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("n")),
            c2.ret(c2.i32_const(1))
          ),
          c2.call(prefix + "_exp", c2.getLocal("n"), c2.i32_const(pe), c2.i32_const(n8), AUX),
          c2.call(prefix + "_eq", AUX, ONE)
        );
      }
      function buildLoad() {
        const f2 = module3.addFunction(prefix + "_load");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("p", "i32");
        f2.addLocal("l", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        const c2 = f2.getCodeBuilder();
        const R = c2.i32_const(module3.alloc(n8));
        const pAux = module3.alloc(n8);
        const AUX = c2.i32_const(pAux);
        f2.addCode(
          c2.call(intPrefix + "_zero", c2.getLocal("r")),
          c2.setLocal("i", c2.i32_const(n8)),
          c2.setLocal("p", c2.getLocal("scalar")),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_gt_u(c2.getLocal("i"), c2.getLocal("scalarLen"))),
            c2.if(
              c2.i32_eq(c2.getLocal("i"), c2.i32_const(n8)),
              c2.call(prefix + "_one", R),
              c2.call(prefix + "_mul", R, c2.i32_const(pR2), R)
            ),
            c2.call(prefix + "_mul", c2.getLocal("p"), R, AUX),
            c2.call(prefix + "_add", c2.getLocal("r"), AUX, c2.getLocal("r")),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(n8))),
            c2.br(0)
          )),
          c2.setLocal("l", c2.i32_rem_u(c2.getLocal("scalarLen"), c2.i32_const(n8))),
          c2.if(c2.i32_eqz(c2.getLocal("l")), c2.ret([])),
          c2.call(intPrefix + "_zero", AUX),
          c2.setLocal("j", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("j"), c2.getLocal("l"))),
            c2.i32_store8(
              c2.getLocal("j"),
              pAux,
              c2.i32_load8_u(c2.getLocal("p"))
            ),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(1))),
            c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.if(
            c2.i32_eq(c2.getLocal("i"), c2.i32_const(n8)),
            c2.call(prefix + "_one", R),
            c2.call(prefix + "_mul", R, c2.i32_const(pR2), R)
          ),
          c2.call(prefix + "_mul", AUX, R, AUX),
          c2.call(prefix + "_add", c2.getLocal("r"), AUX, c2.getLocal("r"))
        );
      }
      function buildTimesScalar() {
        const f2 = module3.addFunction(prefix + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.call(prefix + "_load", c2.getLocal("scalar"), c2.getLocal("scalarLen"), AUX),
          c2.call(prefix + "_toMontgomery", AUX, AUX),
          c2.call(prefix + "_mul", c2.getLocal("x"), AUX, c2.getLocal("r"))
        );
      }
      function buildIsOne() {
        const f2 = module3.addFunction(prefix + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.ret(c2.call(intPrefix + "_eq", c2.getLocal("x"), c2.i32_const(pOne)))
        );
      }
      module3.exportFunction(intPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(intPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(intPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(intPrefix + "_eq", prefix + "_eq");
      buildIsOne();
      buildAdd();
      buildSub();
      buildNeg();
      buildMReduct();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildToMontgomery();
      buildFromMontgomery();
      buildIsNegative();
      buildSign();
      buildInverse();
      buildOne();
      buildLoad();
      buildTimesScalar();
      buildBatchInverse(module3, prefix);
      buildBatchConvertion(module3, prefix + "_batchToMontgomery", prefix + "_toMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchFromMontgomery", prefix + "_fromMontgomery", n8, n8);
      buildBatchConvertion(module3, prefix + "_batchNeg", prefix + "_neg", n8, n8);
      buildBatchOp(module3, prefix + "_batchAdd", prefix + "_add", n8, n8);
      buildBatchOp(module3, prefix + "_batchSub", prefix + "_sub", n8, n8);
      buildBatchOp(module3, prefix + "_batchMul", prefix + "_mul", n8, n8);
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_mReduct");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_squareOld");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_load");
      module3.exportFunction(prefix + "_timesScalar");
      buildExp(
        module3,
        prefix + "_exp",
        n8,
        prefix + "_mul",
        prefix + "_square",
        intPrefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_batchInverse");
      if (isPrime(q)) {
        buildSqrt2();
        buildIsSquare();
        module3.exportFunction(prefix + "_sqrt");
        module3.exportFunction(prefix + "_isSquare");
      }
      module3.exportFunction(prefix + "_batchToMontgomery");
      module3.exportFunction(prefix + "_batchFromMontgomery");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f1.js
var require_build_f1 = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f1.js"(exports2, module2) {
    var buildF1m = require_build_f1m();
    var { bitLength: bitLength3 } = require_bigint();
    module2.exports = function buildF1(module3, _q, _prefix, _f1mPrefix, _intPrefix) {
      const q = BigInt(_q);
      const n64 = Math.floor((bitLength3(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const prefix = _prefix || "f1";
      if (module3.modules[prefix]) return prefix;
      module3.modules[prefix] = {
        n64
      };
      const intPrefix = _intPrefix || "int";
      const f1mPrefix = buildF1m(module3, q, _f1mPrefix, intPrefix);
      const pR2 = module3.modules[f1mPrefix].pR2;
      const pq = module3.modules[f1mPrefix].pq;
      const pePlusOne = module3.modules[f1mPrefix].pePlusOne;
      function buildMul() {
        const pAux1 = module3.alloc(n8);
        const f2 = module3.addFunction(prefix + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(f1mPrefix + "_mul", c2.getLocal("x"), c2.getLocal("y"), c2.i32_const(pAux1)));
        f2.addCode(c2.call(f1mPrefix + "_mul", c2.i32_const(pAux1), c2.i32_const(pR2), c2.getLocal("r")));
      }
      function buildSquare() {
        const f2 = module3.addFunction(prefix + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function buildInverse() {
        const f2 = module3.addFunction(prefix + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_inverseMod", c2.getLocal("x"), c2.i32_const(pq), c2.getLocal("r")));
      }
      function buildIsNegative() {
        const f2 = module3.addFunction(prefix + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(intPrefix + "_gte", c2.getLocal("x"), c2.i32_const(pePlusOne))
        );
      }
      buildMul();
      buildSquare();
      buildInverse();
      buildIsNegative();
      module3.exportFunction(f1mPrefix + "_add", prefix + "_add");
      module3.exportFunction(f1mPrefix + "_sub", prefix + "_sub");
      module3.exportFunction(f1mPrefix + "_neg", prefix + "_neg");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_inverse");
      module3.exportFunction(prefix + "_isNegative");
      module3.exportFunction(f1mPrefix + "_copy", prefix + "_copy");
      module3.exportFunction(f1mPrefix + "_zero", prefix + "_zero");
      module3.exportFunction(f1mPrefix + "_one", prefix + "_one");
      module3.exportFunction(f1mPrefix + "_isZero", prefix + "_isZero");
      module3.exportFunction(f1mPrefix + "_eq", prefix + "_eq");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f2m.js
var require_build_f2m = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f2m.js"(exports2, module2) {
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    var utils2 = require_utils3();
    module2.exports = function buildF2m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix]) return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      const q = module3.modules[f1mPrefix].q;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 2
      };
      function buildAdd() {
        const f2 = module3.addFunction(prefix + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_add", x0, y0, r0),
          c2.call(f1mPrefix + "_add", x1, y1, r1)
        );
      }
      function buildTimesScalar() {
        const f2 = module3.addFunction(prefix + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_timesScalar", x0, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r0),
          c2.call(f1mPrefix + "_timesScalar", x1, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r1)
        );
      }
      function buildSub() {
        const f2 = module3.addFunction(prefix + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_sub", x0, y0, r0),
          c2.call(f1mPrefix + "_sub", x1, y1, r1)
        );
      }
      function buildNeg() {
        const f2 = module3.addFunction(prefix + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_neg", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildConjugate() {
        const f2 = module3.addFunction(prefix + "_conjugate");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildIsNegative() {
        const f2 = module3.addFunction(prefix + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.if(
            c2.call(f1mPrefix + "_isZero", x1),
            c2.ret(c2.call(f1mPrefix + "_isNegative", x0))
          ),
          c2.ret(c2.call(f1mPrefix + "_isNegative", x1))
        );
      }
      function buildMul() {
        const f2 = module3.addFunction(prefix + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const A = c2.i32_const(module3.alloc(f1n8));
        const B = c2.i32_const(module3.alloc(f1n8));
        const C = c2.i32_const(module3.alloc(f1n8));
        const D = c2.i32_const(module3.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_mul", x0, y0, A),
          // A = x0*y0
          c2.call(f1mPrefix + "_mul", x1, y1, B),
          // B = x1*y1
          c2.call(f1mPrefix + "_add", x0, x1, C),
          // C = x0 + x1
          c2.call(f1mPrefix + "_add", y0, y1, D),
          // D = y0 + y1
          c2.call(f1mPrefix + "_mul", C, D, C),
          // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1
          //  c.call(f1mPrefix + "_mul", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)
          c2.call(mulNonResidueFn, B, r0),
          // r0 = nr*(x1*y1)
          c2.call(f1mPrefix + "_add", A, r0, r0),
          // r0 = x0*y0 + nr*(x1*y1)
          c2.call(f1mPrefix + "_add", A, B, r1),
          // r1 = x0*y0+x1*y1
          c2.call(f1mPrefix + "_sub", C, r1, r1)
          // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0
        );
      }
      function buildMul1() {
        const f2 = module3.addFunction(prefix + "_mul1");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y = c2.getLocal("y");
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_mul", x0, y, r0),
          // A = x0*y
          c2.call(f1mPrefix + "_mul", x1, y, r1)
          // B = x1*y
        );
      }
      function buildSquare() {
        const f2 = module3.addFunction(prefix + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const AB = c2.i32_const(module3.alloc(f1n8));
        const APB = c2.i32_const(module3.alloc(f1n8));
        const APNB = c2.i32_const(module3.alloc(f1n8));
        const ABPNAB = c2.i32_const(module3.alloc(f1n8));
        f2.addCode(
          // AB = x0*y1
          c2.call(f1mPrefix + "_mul", x0, x1, AB),
          // APB = x0+y1
          c2.call(f1mPrefix + "_add", x0, x1, APB),
          // APBN0 = x0 + nr*x1
          c2.call(mulNonResidueFn, x1, APNB),
          c2.call(f1mPrefix + "_add", x0, APNB, APNB),
          // ABPNAB = ab + nr*ab
          c2.call(mulNonResidueFn, AB, ABPNAB),
          c2.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
          // r0 = APB * APNB - ABPNAB
          c2.call(f1mPrefix + "_mul", APB, APNB, r0),
          c2.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
          // r1 = AB + AB
          c2.call(f1mPrefix + "_add", AB, AB, r1)
        );
      }
      function buildToMontgomery() {
        const f2 = module3.addFunction(prefix + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_toMontgomery", x0, r0),
          c2.call(f1mPrefix + "_toMontgomery", x1, r1)
        );
      }
      function buildFromMontgomery() {
        const f2 = module3.addFunction(prefix + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c2.call(f1mPrefix + "_fromMontgomery", x1, r1)
        );
      }
      function buildCopy() {
        const f2 = module3.addFunction(prefix + "_copy");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_copy", x1, r1)
        );
      }
      function buildZero() {
        const f2 = module3.addFunction(prefix + "_zero");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_zero", x0),
          c2.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildOne() {
        const f2 = module3.addFunction(prefix + "_one");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_one", x0),
          c2.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildEq() {
        const f2 = module3.addFunction(prefix + "_eq");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        f2.addCode(
          c2.i32_and(
            c2.call(f1mPrefix + "_eq", x0, y0),
            c2.call(f1mPrefix + "_eq", x1, y1)
          )
        );
      }
      function buildIsZero() {
        const f2 = module3.addFunction(prefix + "_isZero");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.i32_and(
            c2.call(f1mPrefix + "_isZero", x0),
            c2.call(f1mPrefix + "_isZero", x1)
          )
        );
      }
      function buildInverse() {
        const f2 = module3.addFunction(prefix + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const t0 = c2.i32_const(module3.alloc(f1n8));
        const t1 = c2.i32_const(module3.alloc(f1n8));
        const t2 = c2.i32_const(module3.alloc(f1n8));
        const t3 = c2.i32_const(module3.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", x0, t0),
          c2.call(f1mPrefix + "_square", x1, t1),
          // c.call(f1mPrefix+"_mul", t1, c.i32_const(pNonResidue), t2),
          c2.call(mulNonResidueFn, t1, t2),
          c2.call(f1mPrefix + "_sub", t0, t2, t2),
          c2.call(f1mPrefix + "_inverse", t2, t3),
          c2.call(f1mPrefix + "_mul", x0, t3, r0),
          c2.call(f1mPrefix + "_mul", x1, t3, r1),
          c2.call(f1mPrefix + "_neg", r1, r1)
        );
      }
      function buildSign() {
        const f2 = module3.addFunction(prefix + "_sign");
        f2.addParam("x", "i32");
        f2.addLocal("s", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x1)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.ret(c2.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f2 = module3.addFunction(prefix + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.ret(c2.i32_and(
            c2.call(f1mPrefix + "_isOne", x0),
            c2.call(f1mPrefix + "_isZero", x1)
          ))
        );
      }
      function buildSqrt2() {
        const f2 = module3.addFunction(prefix + "_sqrt");
        f2.addParam("a", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const e34 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const e12 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8)));
        const a2 = c2.getLocal("a");
        const a1 = c2.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c2.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c2.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c2.i32_const(pn1);
        const n1a = c2.i32_const(pn1);
        const n1b = c2.i32_const(pn1 + f1n8);
        const x0 = c2.i32_const(module3.alloc(f1n8 * 2));
        const b3 = c2.i32_const(module3.alloc(f1n8 * 2));
        f2.addCode(
          c2.call(prefix + "_one", n1),
          c2.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix + "_exp", a2, e34, c2.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix + "_square", a1, alpha),
          c2.call(prefix + "_mul", a2, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c2.call(prefix + "_conjugate", alpha, a0),
          c2.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c2.if(c2.call(prefix + "_eq", a0, n1), c2.unreachable()),
          // const x0 = F.mul(a1, a);
          c2.call(prefix + "_mul", a1, a2, x0),
          // if (F.eq(alfa, F.negone)) {
          c2.if(
            c2.call(prefix + "_eq", alpha, n1),
            [
              // x = F.mul(x0, [F.F.zero, F.F.one]);
              ...c2.call(f1mPrefix + "_zero", n1a),
              ...c2.call(f1mPrefix + "_one", n1b),
              ...c2.call(prefix + "_mul", n1, x0, c2.getLocal("pr"))
            ],
            [
              // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);
              ...c2.call(prefix + "_one", b3),
              ...c2.call(prefix + "_add", b3, alpha, b3),
              ...c2.call(prefix + "_exp", b3, e12, c2.i32_const(f1n8), b3),
              // x = F.mul(b, x0);
              ...c2.call(prefix + "_mul", b3, x0, c2.getLocal("pr"))
            ]
          )
        );
      }
      function buildIsSquare() {
        const f2 = module3.addFunction(prefix + "_isSquare");
        f2.addParam("a", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const e34 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8)));
        const a2 = c2.getLocal("a");
        const a1 = c2.i32_const(module3.alloc(f1n8 * 2));
        const alpha = c2.i32_const(module3.alloc(f1n8 * 2));
        const a0 = c2.i32_const(module3.alloc(f1n8 * 2));
        const pn1 = module3.alloc(f1n8 * 2);
        const n1 = c2.i32_const(pn1);
        f2.addCode(
          c2.call(prefix + "_one", n1),
          c2.call(prefix + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix + "_exp", a2, e34, c2.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix + "_square", a1, alpha),
          c2.call(prefix + "_mul", a2, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c2.call(prefix + "_conjugate", alpha, a0),
          c2.call(prefix + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c2.if(
            c2.call(
              prefix + "_eq",
              a0,
              n1
            ),
            c2.ret(c2.i32_const(0))
          ),
          c2.ret(c2.i32_const(1))
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildMul1();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildConjugate();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildSign();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_mul1");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_conjugate");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 2,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      buildSqrt2();
      buildIsSquare();
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_sqrt");
      module3.exportFunction(prefix + "_isSquare");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f3m.js
var require_build_f3m = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_f3m.js"(exports2, module2) {
    var buildExp = require_build_timesscalar();
    var buildBatchInverse = require_build_batchinverse();
    module2.exports = function buildF3m(module3, mulNonResidueFn, prefix, f1mPrefix) {
      if (module3.modules[prefix]) return prefix;
      const f1n8 = module3.modules[f1mPrefix].n64 * 8;
      module3.modules[prefix] = {
        n64: module3.modules[f1mPrefix].n64 * 3
      };
      function buildAdd() {
        const f2 = module3.addFunction(prefix + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_add", x0, y0, r0),
          c2.call(f1mPrefix + "_add", x1, y1, r1),
          c2.call(f1mPrefix + "_add", x2, y2, r2)
        );
      }
      function buildTimesScalar() {
        const f2 = module3.addFunction(prefix + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_timesScalar", x0, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r0),
          c2.call(f1mPrefix + "_timesScalar", x1, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r1),
          c2.call(f1mPrefix + "_timesScalar", x2, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r2)
        );
      }
      function buildSub() {
        const f2 = module3.addFunction(prefix + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_sub", x0, y0, r0),
          c2.call(f1mPrefix + "_sub", x1, y1, r1),
          c2.call(f1mPrefix + "_sub", x2, y2, r2)
        );
      }
      function buildNeg() {
        const f2 = module3.addFunction(prefix + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_neg", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1),
          c2.call(f1mPrefix + "_neg", x2, r2)
        );
      }
      function buildIsNegative() {
        const f2 = module3.addFunction(prefix + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.if(
            c2.call(f1mPrefix + "_isZero", x2),
            c2.if(
              c2.call(f1mPrefix + "_isZero", x1),
              c2.ret(c2.call(f1mPrefix + "_isNegative", x0)),
              c2.ret(c2.call(f1mPrefix + "_isNegative", x1))
            )
          ),
          c2.ret(c2.call(f1mPrefix + "_isNegative", x2))
        );
      }
      function buildMul() {
        const f2 = module3.addFunction(prefix + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const cd = f2.getCodeBuilder();
        const a2 = cd.getLocal("x");
        const b3 = cd.i32_add(cd.getLocal("x"), cd.i32_const(f1n8));
        const c2 = cd.i32_add(cd.getLocal("x"), cd.i32_const(2 * f1n8));
        const A = cd.getLocal("y");
        const B = cd.i32_add(cd.getLocal("y"), cd.i32_const(f1n8));
        const C = cd.i32_add(cd.getLocal("y"), cd.i32_const(2 * f1n8));
        const r0 = cd.getLocal("r");
        const r1 = cd.i32_add(cd.getLocal("r"), cd.i32_const(f1n8));
        const r2 = cd.i32_add(cd.getLocal("r"), cd.i32_const(2 * f1n8));
        const aA = cd.i32_const(module3.alloc(f1n8));
        const bB = cd.i32_const(module3.alloc(f1n8));
        const cC = cd.i32_const(module3.alloc(f1n8));
        const a_b = cd.i32_const(module3.alloc(f1n8));
        const A_B = cd.i32_const(module3.alloc(f1n8));
        const a_c = cd.i32_const(module3.alloc(f1n8));
        const A_C = cd.i32_const(module3.alloc(f1n8));
        const b_c = cd.i32_const(module3.alloc(f1n8));
        const B_C = cd.i32_const(module3.alloc(f1n8));
        const aA_bB = cd.i32_const(module3.alloc(f1n8));
        const aA_cC = cd.i32_const(module3.alloc(f1n8));
        const bB_cC = cd.i32_const(module3.alloc(f1n8));
        const AUX = cd.i32_const(module3.alloc(f1n8));
        f2.addCode(
          cd.call(f1mPrefix + "_mul", a2, A, aA),
          cd.call(f1mPrefix + "_mul", b3, B, bB),
          cd.call(f1mPrefix + "_mul", c2, C, cC),
          cd.call(f1mPrefix + "_add", a2, b3, a_b),
          cd.call(f1mPrefix + "_add", A, B, A_B),
          cd.call(f1mPrefix + "_add", a2, c2, a_c),
          cd.call(f1mPrefix + "_add", A, C, A_C),
          cd.call(f1mPrefix + "_add", b3, c2, b_c),
          cd.call(f1mPrefix + "_add", B, C, B_C),
          cd.call(f1mPrefix + "_add", aA, bB, aA_bB),
          cd.call(f1mPrefix + "_add", aA, cC, aA_cC),
          cd.call(f1mPrefix + "_add", bB, cC, bB_cC),
          cd.call(f1mPrefix + "_mul", b_c, B_C, r0),
          cd.call(f1mPrefix + "_sub", r0, bB_cC, r0),
          cd.call(mulNonResidueFn, r0, r0),
          cd.call(f1mPrefix + "_add", aA, r0, r0),
          cd.call(f1mPrefix + "_mul", a_b, A_B, r1),
          cd.call(f1mPrefix + "_sub", r1, aA_bB, r1),
          cd.call(mulNonResidueFn, cC, AUX),
          cd.call(f1mPrefix + "_add", r1, AUX, r1),
          cd.call(f1mPrefix + "_mul", a_c, A_C, r2),
          cd.call(f1mPrefix + "_sub", r2, aA_cC, r2),
          cd.call(f1mPrefix + "_add", r2, bB, r2)
        );
      }
      function buildSquare() {
        const f2 = module3.addFunction(prefix + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const A = c2.getLocal("x");
        const B = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const C = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        const s0 = c2.i32_const(module3.alloc(f1n8));
        const ab = c2.i32_const(module3.alloc(f1n8));
        const s1 = c2.i32_const(module3.alloc(f1n8));
        const s2 = c2.i32_const(module3.alloc(f1n8));
        const bc = c2.i32_const(module3.alloc(f1n8));
        const s3 = c2.i32_const(module3.alloc(f1n8));
        const s4 = c2.i32_const(module3.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", A, s0),
          c2.call(f1mPrefix + "_mul", A, B, ab),
          c2.call(f1mPrefix + "_add", ab, ab, s1),
          c2.call(f1mPrefix + "_sub", A, B, s2),
          c2.call(f1mPrefix + "_add", s2, C, s2),
          c2.call(f1mPrefix + "_square", s2, s2),
          c2.call(f1mPrefix + "_mul", B, C, bc),
          c2.call(f1mPrefix + "_add", bc, bc, s3),
          c2.call(f1mPrefix + "_square", C, s4),
          c2.call(mulNonResidueFn, s3, r0),
          c2.call(f1mPrefix + "_add", s0, r0, r0),
          c2.call(mulNonResidueFn, s4, r1),
          c2.call(f1mPrefix + "_add", s1, r1, r1),
          c2.call(f1mPrefix + "_add", s0, s4, r2),
          c2.call(f1mPrefix + "_sub", s3, r2, r2),
          c2.call(f1mPrefix + "_add", s2, r2, r2),
          c2.call(f1mPrefix + "_add", s1, r2, r2)
        );
      }
      function buildToMontgomery() {
        const f2 = module3.addFunction(prefix + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_toMontgomery", x0, r0),
          c2.call(f1mPrefix + "_toMontgomery", x1, r1),
          c2.call(f1mPrefix + "_toMontgomery", x2, r2)
        );
      }
      function buildFromMontgomery() {
        const f2 = module3.addFunction(prefix + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c2.call(f1mPrefix + "_fromMontgomery", x1, r1),
          c2.call(f1mPrefix + "_fromMontgomery", x2, r2)
        );
      }
      function buildCopy() {
        const f2 = module3.addFunction(prefix + "_copy");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_copy", x1, r1),
          c2.call(f1mPrefix + "_copy", x2, r2)
        );
      }
      function buildZero() {
        const f2 = module3.addFunction(prefix + "_zero");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_zero", x0),
          c2.call(f1mPrefix + "_zero", x1),
          c2.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildOne() {
        const f2 = module3.addFunction(prefix + "_one");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_one", x0),
          c2.call(f1mPrefix + "_zero", x1),
          c2.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildEq() {
        const f2 = module3.addFunction(prefix + "_eq");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.i32_and(
            c2.i32_and(
              c2.call(f1mPrefix + "_eq", x0, y0),
              c2.call(f1mPrefix + "_eq", x1, y1)
            ),
            c2.call(f1mPrefix + "_eq", x2, y2)
          )
        );
      }
      function buildIsZero() {
        const f2 = module3.addFunction(prefix + "_isZero");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.i32_and(
            c2.i32_and(
              c2.call(f1mPrefix + "_isZero", x0),
              c2.call(f1mPrefix + "_isZero", x1)
            ),
            c2.call(f1mPrefix + "_isZero", x2)
          )
        );
      }
      function buildInverse() {
        const f2 = module3.addFunction(prefix + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        const t0 = c2.i32_const(module3.alloc(f1n8));
        const t1 = c2.i32_const(module3.alloc(f1n8));
        const t2 = c2.i32_const(module3.alloc(f1n8));
        const t3 = c2.i32_const(module3.alloc(f1n8));
        const t4 = c2.i32_const(module3.alloc(f1n8));
        const t5 = c2.i32_const(module3.alloc(f1n8));
        const c0 = c2.i32_const(module3.alloc(f1n8));
        const c1 = c2.i32_const(module3.alloc(f1n8));
        const c22 = c2.i32_const(module3.alloc(f1n8));
        const t6 = c2.i32_const(module3.alloc(f1n8));
        const AUX = c2.i32_const(module3.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", x0, t0),
          c2.call(f1mPrefix + "_square", x1, t1),
          c2.call(f1mPrefix + "_square", x2, t2),
          c2.call(f1mPrefix + "_mul", x0, x1, t3),
          c2.call(f1mPrefix + "_mul", x0, x2, t4),
          c2.call(f1mPrefix + "_mul", x1, x2, t5),
          c2.call(mulNonResidueFn, t5, c0),
          c2.call(f1mPrefix + "_sub", t0, c0, c0),
          c2.call(mulNonResidueFn, t2, c1),
          c2.call(f1mPrefix + "_sub", c1, t3, c1),
          c2.call(f1mPrefix + "_sub", t1, t4, c22),
          c2.call(f1mPrefix + "_mul", x2, c1, t6),
          c2.call(f1mPrefix + "_mul", x1, c22, AUX),
          c2.call(f1mPrefix + "_add", t6, AUX, t6),
          c2.call(mulNonResidueFn, t6, t6),
          c2.call(f1mPrefix + "_mul", x0, c0, AUX),
          c2.call(f1mPrefix + "_add", AUX, t6, t6),
          c2.call(f1mPrefix + "_inverse", t6, t6),
          c2.call(f1mPrefix + "_mul", t6, c0, r0),
          c2.call(f1mPrefix + "_mul", t6, c1, r1),
          c2.call(f1mPrefix + "_mul", t6, c22, r2)
        );
      }
      function buildSign() {
        const f2 = module3.addFunction(prefix + "_sign");
        f2.addParam("x", "i32");
        f2.addLocal("s", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x2)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x1)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.ret(c2.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f2 = module3.addFunction(prefix + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8 * 2));
        f2.addCode(
          c2.ret(
            c2.i32_and(
              c2.i32_and(
                c2.call(f1mPrefix + "_isOne", x0),
                c2.call(f1mPrefix + "_isZero", x1)
              ),
              c2.call(f1mPrefix + "_isZero", x2)
            )
          )
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildSign();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar();
      buildIsNegative();
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isOne");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_one");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_mul");
      module3.exportFunction(prefix + "_square");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_sign");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_inverse");
      buildBatchInverse(module3, prefix);
      buildExp(
        module3,
        prefix + "_exp",
        f1n8 * 3,
        prefix + "_mul",
        prefix + "_square",
        prefix + "_copy",
        prefix + "_one"
      );
      module3.exportFunction(prefix + "_exp");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_batchInverse");
      module3.exportFunction(prefix + "_isNegative");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_timesscalarnaf.js
var require_build_timesscalarnaf = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_timesscalarnaf.js"(exports2, module2) {
    module2.exports = function buildTimesScalarNAF(module3, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
      const f2 = module3.addFunction(fnName);
      f2.addParam("base", "i32");
      f2.addParam("scalar", "i32");
      f2.addParam("scalarLength", "i32");
      f2.addParam("r", "i32");
      f2.addLocal("old0", "i32");
      f2.addLocal("nbits", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("last", "i32");
      f2.addLocal("cur", "i32");
      f2.addLocal("carry", "i32");
      f2.addLocal("p", "i32");
      const c2 = f2.getCodeBuilder();
      const aux = c2.i32_const(module3.alloc(elementLen));
      function getBit(IDX) {
        return c2.i32_and(
          c2.i32_shr_u(
            c2.i32_load(
              c2.i32_add(
                c2.getLocal("scalar"),
                c2.i32_and(
                  c2.i32_shr_u(
                    IDX,
                    c2.i32_const(3)
                  ),
                  c2.i32_const(4294967292)
                )
              )
            ),
            c2.i32_and(
              IDX,
              c2.i32_const(31)
            )
          ),
          c2.i32_const(1)
        );
      }
      function pushBit(b3) {
        return [
          ...c2.i32_store8(
            c2.getLocal("p"),
            c2.i32_const(b3)
          ),
          ...c2.setLocal(
            "p",
            c2.i32_add(
              c2.getLocal("p"),
              c2.i32_const(1)
            )
          )
        ];
      }
      f2.addCode(
        c2.if(
          c2.i32_eqz(c2.getLocal("scalarLength")),
          [
            ...c2.call(opInit, c2.getLocal("r")),
            ...c2.ret([])
          ]
        ),
        c2.setLocal("nbits", c2.i32_shl(c2.getLocal("scalarLength"), c2.i32_const(3))),
        c2.setLocal("old0", c2.i32_load(c2.i32_const(0))),
        c2.setLocal("p", c2.getLocal("old0")),
        c2.i32_store(
          c2.i32_const(0),
          c2.i32_and(
            c2.i32_add(
              c2.i32_add(
                c2.getLocal("old0"),
                c2.i32_const(32)
              ),
              c2.getLocal("nbits")
            ),
            c2.i32_const(4294967288)
          )
        ),
        c2.setLocal("i", c2.i32_const(1)),
        c2.setLocal("last", getBit(c2.i32_const(0))),
        c2.setLocal("carry", c2.i32_const(0)),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("nbits"))),
          c2.setLocal("cur", getBit(c2.getLocal("i"))),
          c2.if(
            c2.getLocal("last"),
            c2.if(
              c2.getLocal("cur"),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(1)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(255)
                ]
              ),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(255)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(1)
                ]
              )
            ),
            c2.if(
              c2.getLocal("cur"),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(0)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(1)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ]
              ),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(1)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ]
              )
            )
          ),
          c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        )),
        c2.if(
          c2.getLocal("last"),
          c2.if(
            c2.getLocal("carry"),
            [
              ...pushBit(255),
              ...pushBit(0),
              ...pushBit(1)
            ],
            [
              ...pushBit(1)
            ]
          ),
          c2.if(
            c2.getLocal("carry"),
            [
              ...pushBit(0),
              ...pushBit(1)
            ]
          )
        ),
        c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
        // p already points to the last bit
        c2.call(opCopy, c2.getLocal("base"), aux),
        c2.call(opInit, c2.getLocal("r")),
        c2.block(c2.loop(
          c2.call(opAA, c2.getLocal("r"), c2.getLocal("r")),
          c2.setLocal(
            "cur",
            c2.i32_load8_u(
              c2.getLocal("p")
            )
          ),
          c2.if(
            c2.getLocal("cur"),
            c2.if(
              c2.i32_eq(c2.getLocal("cur"), c2.i32_const(1)),
              c2.call(opAB, c2.getLocal("r"), aux, c2.getLocal("r")),
              c2.call(opAmB, c2.getLocal("r"), aux, c2.getLocal("r"))
            )
          ),
          c2.br_if(1, c2.i32_eq(c2.getLocal("old0"), c2.getLocal("p"))),
          c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
          c2.br(0)
        )),
        c2.i32_store(c2.i32_const(0), c2.getLocal("old0"))
      );
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_multiexp.js
var require_build_multiexp = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_multiexp.js"(exports2, module2) {
    module2.exports = function buildMultiexp2(module3, prefix, fnName, opAdd, n8b) {
      const n64g = module3.modules[prefix].n64;
      const n8g = n64g * 8;
      function buildGetChunk() {
        const f2 = module3.addFunction(fnName + "_getChunk");
        f2.addParam("pScalar", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("startBit", "i32");
        f2.addParam("chunkSize", "i32");
        f2.addLocal("bitsToEnd", "i32");
        f2.addLocal("mask", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "bitsToEnd",
            c2.i32_sub(
              c2.i32_mul(
                c2.getLocal("scalarSize"),
                c2.i32_const(8)
              ),
              c2.getLocal("startBit")
            )
          ),
          c2.if(
            c2.i32_gt_s(
              c2.getLocal("chunkSize"),
              c2.getLocal("bitsToEnd")
            ),
            c2.setLocal(
              "mask",
              c2.i32_sub(
                c2.i32_shl(
                  c2.i32_const(1),
                  c2.getLocal("bitsToEnd")
                ),
                c2.i32_const(1)
              )
            ),
            c2.setLocal(
              "mask",
              c2.i32_sub(
                c2.i32_shl(
                  c2.i32_const(1),
                  c2.getLocal("chunkSize")
                ),
                c2.i32_const(1)
              )
            )
          ),
          c2.i32_and(
            c2.i32_shr_u(
              c2.i32_load(
                c2.i32_add(
                  c2.getLocal("pScalar"),
                  c2.i32_shr_u(
                    c2.getLocal("startBit"),
                    c2.i32_const(3)
                  )
                ),
                0,
                // offset
                0
                // align to byte.
              ),
              c2.i32_and(
                c2.getLocal("startBit"),
                c2.i32_const(7)
              )
            ),
            c2.getLocal("mask")
          )
        );
      }
      function buildMutiexpChunk() {
        const f2 = module3.addFunction(fnName + "_chunk");
        f2.addParam("pBases", "i32");
        f2.addParam("pScalars", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("n", "i32");
        f2.addParam("startBit", "i32");
        f2.addParam("chunkSize", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("nChunks", "i32");
        f2.addLocal("itScalar", "i32");
        f2.addLocal("endScalar", "i32");
        f2.addLocal("itBase", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("nTable", "i32");
        f2.addLocal("pTable", "i32");
        f2.addLocal("idx", "i32");
        f2.addLocal("pIdxTable", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.i32_eqz(c2.getLocal("n")),
            [
              ...c2.call(prefix + "_zero", c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          // Allocate memory
          c2.setLocal(
            "nTable",
            c2.i32_shl(
              c2.i32_const(1),
              c2.getLocal("chunkSize")
            )
          ),
          c2.setLocal("pTable", c2.i32_load(c2.i32_const(0))),
          c2.i32_store(
            c2.i32_const(0),
            c2.i32_add(
              c2.getLocal("pTable"),
              c2.i32_mul(
                c2.getLocal("nTable"),
                c2.i32_const(n8g)
              )
            )
          ),
          // Reset Table
          c2.setLocal("j", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("j"),
                c2.getLocal("nTable")
              )
            ),
            c2.call(
              prefix + "_zero",
              c2.i32_add(
                c2.getLocal("pTable"),
                c2.i32_mul(
                  c2.getLocal("j"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
            c2.br(0)
          )),
          // Distribute elements
          c2.setLocal("itBase", c2.getLocal("pBases")),
          c2.setLocal("itScalar", c2.getLocal("pScalars")),
          c2.setLocal(
            "endScalar",
            c2.i32_add(
              c2.getLocal("pScalars"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.getLocal("scalarSize")
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("itScalar"),
                c2.getLocal("endScalar")
              )
            ),
            c2.setLocal(
              "idx",
              c2.call(
                fnName + "_getChunk",
                c2.getLocal("itScalar"),
                c2.getLocal("scalarSize"),
                c2.getLocal("startBit"),
                c2.getLocal("chunkSize")
              )
            ),
            c2.if(
              c2.getLocal("idx"),
              [
                ...c2.setLocal(
                  "pIdxTable",
                  c2.i32_add(
                    c2.getLocal("pTable"),
                    c2.i32_mul(
                      c2.i32_sub(
                        c2.getLocal("idx"),
                        c2.i32_const(1)
                      ),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                ...c2.call(
                  opAdd,
                  c2.getLocal("pIdxTable"),
                  c2.getLocal("itBase"),
                  c2.getLocal("pIdxTable")
                )
              ]
            ),
            c2.setLocal("itScalar", c2.i32_add(c2.getLocal("itScalar"), c2.getLocal("scalarSize"))),
            c2.setLocal("itBase", c2.i32_add(c2.getLocal("itBase"), c2.i32_const(n8b))),
            c2.br(0)
          )),
          c2.call(fnName + "_reduceTable", c2.getLocal("pTable"), c2.getLocal("chunkSize")),
          c2.call(
            prefix + "_copy",
            c2.getLocal("pTable"),
            c2.getLocal("pr")
          ),
          c2.i32_store(
            c2.i32_const(0),
            c2.getLocal("pTable")
          )
        );
      }
      function buildMultiexp3() {
        const f2 = module3.addFunction(fnName);
        f2.addParam("pBases", "i32");
        f2.addParam("pScalars", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("chunkSize", "i32");
        f2.addLocal("nChunks", "i32");
        f2.addLocal("itScalar", "i32");
        f2.addLocal("endScalar", "i32");
        f2.addLocal("itBase", "i32");
        f2.addLocal("itBit", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("nTable", "i32");
        f2.addLocal("pTable", "i32");
        f2.addLocal("idx", "i32");
        f2.addLocal("pIdxTable", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module3.alloc(n8g));
        const pTSizes2 = module3.alloc([
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          16,
          16,
          15,
          14,
          13,
          13,
          12,
          11,
          10,
          9,
          8,
          7,
          7,
          6,
          5,
          4,
          3,
          2,
          1,
          1,
          1,
          1
        ]);
        f2.addCode(
          c2.call(prefix + "_zero", c2.getLocal("pr")),
          c2.if(
            c2.i32_eqz(c2.getLocal("n")),
            c2.ret([])
          ),
          c2.setLocal("chunkSize", c2.i32_load8_u(c2.i32_clz(c2.getLocal("n")), pTSizes2)),
          c2.setLocal(
            "nChunks",
            c2.i32_add(
              c2.i32_div_u(
                c2.i32_sub(
                  c2.i32_shl(
                    c2.getLocal("scalarSize"),
                    c2.i32_const(3)
                  ),
                  c2.i32_const(1)
                ),
                c2.getLocal("chunkSize")
              ),
              c2.i32_const(1)
            )
          ),
          // Allocate memory
          c2.setLocal(
            "itBit",
            c2.i32_mul(
              c2.i32_sub(
                c2.getLocal("nChunks"),
                c2.i32_const(1)
              ),
              c2.getLocal("chunkSize")
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_lt_s(
                c2.getLocal("itBit"),
                c2.i32_const(0)
              )
            ),
            // Double nChunk times
            c2.if(
              c2.i32_eqz(c2.call(prefix + "_isZero", c2.getLocal("pr"))),
              [
                ...c2.setLocal("j", c2.i32_const(0)),
                ...c2.block(c2.loop(
                  c2.br_if(
                    1,
                    c2.i32_eq(
                      c2.getLocal("j"),
                      c2.getLocal("chunkSize")
                    )
                  ),
                  c2.call(prefix + "_double", c2.getLocal("pr"), c2.getLocal("pr")),
                  c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
                  c2.br(0)
                ))
              ]
            ),
            c2.call(
              fnName + "_chunk",
              c2.getLocal("pBases"),
              c2.getLocal("pScalars"),
              c2.getLocal("scalarSize"),
              c2.getLocal("n"),
              c2.getLocal("itBit"),
              c2.getLocal("chunkSize"),
              aux
            ),
            c2.call(
              prefix + "_add",
              c2.getLocal("pr"),
              aux,
              c2.getLocal("pr")
            ),
            c2.setLocal("itBit", c2.i32_sub(c2.getLocal("itBit"), c2.getLocal("chunkSize"))),
            c2.br(0)
          ))
        );
      }
      function buildReduceTable() {
        const f2 = module3.addFunction(fnName + "_reduceTable");
        f2.addParam("pTable", "i32");
        f2.addParam("p", "i32");
        f2.addLocal("half", "i32");
        f2.addLocal("it1", "i32");
        f2.addLocal("it2", "i32");
        f2.addLocal("pAcc", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.i32_eq(c2.getLocal("p"), c2.i32_const(1)),
            c2.ret([])
          ),
          c2.setLocal(
            "half",
            c2.i32_shl(
              c2.i32_const(1),
              c2.i32_sub(
                c2.getLocal("p"),
                c2.i32_const(1)
              )
            )
          ),
          c2.setLocal("it1", c2.getLocal("pTable")),
          c2.setLocal(
            "it2",
            c2.i32_add(
              c2.getLocal("pTable"),
              c2.i32_mul(
                c2.getLocal("half"),
                c2.i32_const(n8g)
              )
            )
          ),
          c2.setLocal(
            "pAcc",
            c2.i32_sub(
              c2.getLocal("it2"),
              c2.i32_const(n8g)
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("it1"),
                c2.getLocal("pAcc")
              )
            ),
            c2.call(
              prefix + "_add",
              c2.getLocal("it1"),
              c2.getLocal("it2"),
              c2.getLocal("it1")
            ),
            c2.call(
              prefix + "_add",
              c2.getLocal("pAcc"),
              c2.getLocal("it2"),
              c2.getLocal("pAcc")
            ),
            c2.setLocal("it1", c2.i32_add(c2.getLocal("it1"), c2.i32_const(n8g))),
            c2.setLocal("it2", c2.i32_add(c2.getLocal("it2"), c2.i32_const(n8g))),
            c2.br(0)
          )),
          c2.call(
            fnName + "_reduceTable",
            c2.getLocal("pTable"),
            c2.i32_sub(
              c2.getLocal("p"),
              c2.i32_const(1)
            )
          ),
          c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eqz(c2.getLocal("p"))),
            c2.call(prefix + "_double", c2.getLocal("pAcc"), c2.getLocal("pAcc")),
            c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(prefix + "_add", c2.getLocal("pTable"), c2.getLocal("pAcc"), c2.getLocal("pTable"))
        );
      }
      buildGetChunk();
      buildReduceTable();
      buildMutiexpChunk();
      buildMultiexp3();
      module3.exportFunction(fnName);
      module3.exportFunction(fnName + "_chunk");
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_curve_jacobian_a0.js
var require_build_curve_jacobian_a0 = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_curve_jacobian_a0.js"(exports2, module2) {
    var buildTimesScalarNAF = require_build_timesscalarnaf();
    var buildBatchConvertion = require_build_batchconvertion();
    var buildMultiexp2 = require_build_multiexp();
    module2.exports = function buildCurve(module3, prefix, prefixField, pB) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      if (module3.modules[prefix]) return prefix;
      module3.modules[prefix] = {
        n64: n64 * 3
      };
      function buildIsZero() {
        const f2 = module3.addFunction(prefix + "_isZero");
        f2.addParam("p1", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_isZero",
          c2.i32_add(
            c2.getLocal("p1"),
            c2.i32_const(n8 * 2)
          )
        ));
      }
      function buildIsZeroAffine() {
        const f2 = module3.addFunction(prefix + "_isZeroAffine");
        f2.addParam("p1", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i32_and(
            c2.call(
              prefixField + "_isZero",
              c2.getLocal("p1")
            ),
            c2.call(
              prefixField + "_isZero",
              c2.i32_add(
                c2.getLocal("p1"),
                c2.i32_const(n8)
              )
            )
          )
        );
      }
      function buildCopy() {
        const f2 = module3.addFunction(prefix + "_copy");
        f2.addParam("ps", "i32");
        f2.addParam("pd", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < n64 * 3; i++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pd"),
              i * 8,
              c2.i64_load(
                c2.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildCopyAffine() {
        const f2 = module3.addFunction(prefix + "_copyAffine");
        f2.addParam("ps", "i32");
        f2.addParam("pd", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < n64 * 2; i++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pd"),
              i * 8,
              c2.i64_load(
                c2.getLocal("ps"),
                i * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f2 = module3.addFunction(prefix + "_zero");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.getLocal("pr")
        ));
        f2.addCode(c2.call(
          prefixField + "_one",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8)
          )
        ));
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8 * 2)
          )
        ));
      }
      function buildZeroAffine() {
        const f2 = module3.addFunction(prefix + "_zeroAffine");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.getLocal("pr")
        ));
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8)
          )
        ));
      }
      function buildEq() {
        const f2 = module3.addFunction(prefix + "_eq");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        f2.addLocal("z2", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z2", c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8 * 2))));
        const z2 = c2.getLocal("z2");
        const Z1Z1 = c2.i32_const(module3.alloc(n8));
        const Z2Z2 = c2.i32_const(module3.alloc(n8));
        const U12 = c2.i32_const(module3.alloc(n8));
        const U22 = c2.i32_const(module3.alloc(n8));
        const Z1_cubed = c2.i32_const(module3.alloc(n8));
        const Z2_cubed = c2.i32_const(module3.alloc(n8));
        const S12 = c2.i32_const(module3.alloc(n8));
        const S2 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            c2.ret(c2.call(prefix + "_isZero", c2.getLocal("p2")))
          ),
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p2")),
            c2.ret(c2.i32_const(0))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            c2.ret(c2.call(prefix + "_eqMixed", c2.getLocal("p2"), c2.getLocal("p1")))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            c2.ret(c2.call(prefix + "_eqMixed", c2.getLocal("p1"), c2.getLocal("p2")))
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_square", z2, Z2Z2),
          c2.call(prefixField + "_mul", x1, Z2Z2, U12),
          c2.call(prefixField + "_mul", x2, Z1Z1, U22),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c2.call(prefixField + "_mul", y1, Z2_cubed, S12),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", U12, U22),
            c2.if(
              c2.call(prefixField + "_eq", S12, S2),
              c2.ret(c2.i32_const(1))
            )
          ),
          c2.ret(c2.i32_const(0))
        );
      }
      function buildEqMixed() {
        const f2 = module3.addFunction(prefix + "_eqMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const Z1Z1 = c2.i32_const(module3.alloc(n8));
        const U22 = c2.i32_const(module3.alloc(n8));
        const Z1_cubed = c2.i32_const(module3.alloc(n8));
        const S2 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            c2.ret(c2.call(prefix + "_isZeroAffine", c2.getLocal("p2")))
          ),
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p2")),
            c2.ret(c2.i32_const(0))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            c2.ret(c2.call(prefix + "_eqAffine", c2.getLocal("p1"), c2.getLocal("p2")))
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U22),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", x1, U22),
            c2.if(
              c2.call(prefixField + "_eq", y1, S2),
              c2.ret(c2.i32_const(1))
            )
          ),
          c2.ret(c2.i32_const(0))
        );
      }
      function buildDouble() {
        const f2 = module3.addFunction(prefix + "_double");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const A = c2.i32_const(module3.alloc(n8));
        const B = c2.i32_const(module3.alloc(n8));
        const C = c2.i32_const(module3.alloc(n8));
        const D = c2.i32_const(module3.alloc(n8));
        const E = c2.i32_const(module3.alloc(n8));
        const F = c2.i32_const(module3.alloc(n8));
        const G = c2.i32_const(module3.alloc(n8));
        const eightC = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            [
              ...c2.ret(c2.call(prefix + "_doubleAffine", c2.getLocal("p1"), c2.getLocal("pr"))),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", x, A),
          c2.call(prefixField + "_square", y, B),
          c2.call(prefixField + "_square", B, C),
          c2.call(prefixField + "_add", x, B, D),
          c2.call(prefixField + "_square", D, D),
          c2.call(prefixField + "_sub", D, A, D),
          c2.call(prefixField + "_sub", D, C, D),
          c2.call(prefixField + "_add", D, D, D),
          c2.call(prefixField + "_add", A, A, E),
          c2.call(prefixField + "_add", E, A, E),
          c2.call(prefixField + "_square", E, F),
          c2.call(prefixField + "_mul", y, z2, G),
          c2.call(prefixField + "_add", D, D, x3),
          c2.call(prefixField + "_sub", F, x3, x3),
          c2.call(prefixField + "_add", C, C, eightC),
          c2.call(prefixField + "_add", eightC, eightC, eightC),
          c2.call(prefixField + "_add", eightC, eightC, eightC),
          c2.call(prefixField + "_sub", D, x3, y3),
          c2.call(prefixField + "_mul", y3, E, y3),
          c2.call(prefixField + "_sub", y3, eightC, y3),
          c2.call(prefixField + "_add", G, G, z3)
        );
      }
      function buildDoubleAffine() {
        const f2 = module3.addFunction(prefix + "_doubleAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const XX = c2.i32_const(module3.alloc(n8));
        const YY = c2.i32_const(module3.alloc(n8));
        const YYYY = c2.i32_const(module3.alloc(n8));
        const S2 = c2.i32_const(module3.alloc(n8));
        const M = c2.i32_const(module3.alloc(n8));
        const eightYYYY = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p1")),
            [
              ...c2.call(prefix + "_toJacobian", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          // XX = X1^2
          c2.call(prefixField + "_square", x, XX),
          // YY = Y1^2
          c2.call(prefixField + "_square", y, YY),
          // YYYY = YY^2
          c2.call(prefixField + "_square", YY, YYYY),
          // S = 2*((X1+YY)^2-XX-YYYY)
          c2.call(prefixField + "_add", x, YY, S2),
          c2.call(prefixField + "_square", S2, S2),
          c2.call(prefixField + "_sub", S2, XX, S2),
          c2.call(prefixField + "_sub", S2, YYYY, S2),
          c2.call(prefixField + "_add", S2, S2, S2),
          // M = 3*XX+a  (Hera a=0)
          c2.call(prefixField + "_add", XX, XX, M),
          c2.call(prefixField + "_add", M, XX, M),
          // Z3 = 2*Y1
          c2.call(prefixField + "_add", y, y, z3),
          // T = M^2-2*S
          // X3 = T
          c2.call(prefixField + "_square", M, x3),
          c2.call(prefixField + "_sub", x3, S2, x3),
          c2.call(prefixField + "_sub", x3, S2, x3),
          // Y3 = M*(S-T)-8*YYYY
          c2.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
          c2.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c2.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c2.call(prefixField + "_sub", S2, x3, y3),
          c2.call(prefixField + "_mul", y3, M, y3),
          c2.call(prefixField + "_sub", y3, eightYYYY, y3)
        );
      }
      function buildEqAffine() {
        const f2 = module3.addFunction(prefix + "_eqAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.ret(c2.i32_and(
            c2.call(
              prefixField + "_eq",
              c2.getLocal("p1"),
              c2.getLocal("p2")
            ),
            c2.call(
              prefixField + "_eq",
              c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8)),
              c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8))
            )
          ))
        );
      }
      function buildToMontgomery() {
        const f2 = module3.addFunction(prefix + "_toMontgomery");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_toMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f2.addCode(c2.call(
            prefixField + "_toMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i * n8))
          ));
        }
      }
      function buildToMontgomeryAffine() {
        const f2 = module3.addFunction(prefix + "_toMontgomeryAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_toMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f2.addCode(c2.call(
            prefixField + "_toMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomery() {
        const f2 = module3.addFunction(prefix + "_fromMontgomery");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_fromMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i = 1; i < 3; i++) {
          f2.addCode(c2.call(
            prefixField + "_fromMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i * n8))
          ));
        }
      }
      function buildFromMontgomeryAffine() {
        const f2 = module3.addFunction(prefix + "_fromMontgomeryAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_fromMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i = 1; i < 2; i++) {
          f2.addCode(c2.call(
            prefixField + "_fromMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i * n8))
          ));
        }
      }
      function buildAdd() {
        const f2 = module3.addFunction(prefix + "_add");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        f2.addLocal("z2", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z2", c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8 * 2))));
        const z2 = c2.getLocal("z2");
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z1Z1 = c2.i32_const(module3.alloc(n8));
        const Z2Z2 = c2.i32_const(module3.alloc(n8));
        const U12 = c2.i32_const(module3.alloc(n8));
        const U22 = c2.i32_const(module3.alloc(n8));
        const Z1_cubed = c2.i32_const(module3.alloc(n8));
        const Z2_cubed = c2.i32_const(module3.alloc(n8));
        const S12 = c2.i32_const(module3.alloc(n8));
        const S2 = c2.i32_const(module3.alloc(n8));
        const H = c2.i32_const(module3.alloc(n8));
        const S2_minus_S1 = c2.i32_const(module3.alloc(n8));
        const I = c2.i32_const(module3.alloc(n8));
        const J = c2.i32_const(module3.alloc(n8));
        const r2 = c2.i32_const(module3.alloc(n8));
        const r22 = c2.i32_const(module3.alloc(n8));
        const V = c2.i32_const(module3.alloc(n8));
        const V2 = c2.i32_const(module3.alloc(n8));
        const S1_J2 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix + "_copy", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p2")),
            [
              ...c2.call(prefix + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            [
              ...c2.call(prefix + "_addMixed", x2, x1, x3),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            [
              ...c2.call(prefix + "_addMixed", x1, x2, x3),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_square", z2, Z2Z2),
          c2.call(prefixField + "_mul", x1, Z2Z2, U12),
          c2.call(prefixField + "_mul", x2, Z1Z1, U22),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c2.call(prefixField + "_mul", y1, Z2_cubed, S12),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", U12, U22),
            c2.if(
              c2.call(prefixField + "_eq", S12, S2),
              [
                ...c2.call(prefix + "_double", c2.getLocal("p1"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", U22, U12, H),
          c2.call(prefixField + "_sub", S2, S12, S2_minus_S1),
          c2.call(prefixField + "_add", H, H, I),
          c2.call(prefixField + "_square", I, I),
          c2.call(prefixField + "_mul", H, I, J),
          c2.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r2),
          c2.call(prefixField + "_mul", U12, I, V),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V, V, V2),
          c2.call(prefixField + "_sub", r22, J, x3),
          c2.call(prefixField + "_sub", x3, V2, x3),
          c2.call(prefixField + "_mul", S12, J, S1_J2),
          c2.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
          c2.call(prefixField + "_sub", V, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, S1_J2, y3),
          c2.call(prefixField + "_add", z1, z2, z3),
          c2.call(prefixField + "_square", z3, z3),
          c2.call(prefixField + "_sub", z3, Z1Z1, z3),
          c2.call(prefixField + "_sub", z3, Z2Z2, z3),
          c2.call(prefixField + "_mul", z3, H, z3)
        );
      }
      function buildAddMixed() {
        const f2 = module3.addFunction(prefix + "_addMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z1Z1 = c2.i32_const(module3.alloc(n8));
        const U22 = c2.i32_const(module3.alloc(n8));
        const Z1_cubed = c2.i32_const(module3.alloc(n8));
        const S2 = c2.i32_const(module3.alloc(n8));
        const H = c2.i32_const(module3.alloc(n8));
        const HH = c2.i32_const(module3.alloc(n8));
        const S2_minus_y1 = c2.i32_const(module3.alloc(n8));
        const I = c2.i32_const(module3.alloc(n8));
        const J = c2.i32_const(module3.alloc(n8));
        const r2 = c2.i32_const(module3.alloc(n8));
        const r22 = c2.i32_const(module3.alloc(n8));
        const V = c2.i32_const(module3.alloc(n8));
        const V2 = c2.i32_const(module3.alloc(n8));
        const y1_J2 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix + "_copyAffine", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p2")),
            [
              ...c2.call(prefix + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            [
              ...c2.call(prefix + "_addAffine", x1, x2, x3),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U22),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", x1, U22),
            c2.if(
              c2.call(prefixField + "_eq", y1, S2),
              [
                ...c2.call(prefix + "_doubleAffine", c2.getLocal("p2"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", U22, x1, H),
          c2.call(prefixField + "_sub", S2, y1, S2_minus_y1),
          c2.call(prefixField + "_square", H, HH),
          c2.call(prefixField + "_add", HH, HH, I),
          c2.call(prefixField + "_add", I, I, I),
          c2.call(prefixField + "_mul", H, I, J),
          c2.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r2),
          c2.call(prefixField + "_mul", x1, I, V),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V, V, V2),
          c2.call(prefixField + "_sub", r22, J, x3),
          c2.call(prefixField + "_sub", x3, V2, x3),
          c2.call(prefixField + "_mul", y1, J, y1_J2),
          c2.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c2.call(prefixField + "_sub", V, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, y1_J2, y3),
          c2.call(prefixField + "_add", z1, H, z3),
          c2.call(prefixField + "_square", z3, z3),
          c2.call(prefixField + "_sub", z3, Z1Z1, z3),
          c2.call(prefixField + "_sub", z3, HH, z3)
        );
      }
      function buildAddAffine() {
        const f2 = module3.addFunction(prefix + "_addAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const H = c2.i32_const(module3.alloc(n8));
        const HH = c2.i32_const(module3.alloc(n8));
        const y2_minus_y1 = c2.i32_const(module3.alloc(n8));
        const I = c2.i32_const(module3.alloc(n8));
        const J = c2.i32_const(module3.alloc(n8));
        const r2 = c2.i32_const(module3.alloc(n8));
        const r22 = c2.i32_const(module3.alloc(n8));
        const V = c2.i32_const(module3.alloc(n8));
        const V2 = c2.i32_const(module3.alloc(n8));
        const y1_J2 = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p1")),
            [
              ...c2.call(prefix + "_copyAffine", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p2")),
            [
              ...c2.call(prefix + "_copyAffine", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_eq", x1, x2),
            c2.if(
              c2.call(prefixField + "_eq", y1, y2),
              [
                ...c2.call(prefix + "_doubleAffine", c2.getLocal("p2"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", x2, x1, H),
          c2.call(prefixField + "_sub", y2, y1, y2_minus_y1),
          c2.call(prefixField + "_square", H, HH),
          c2.call(prefixField + "_add", HH, HH, I),
          c2.call(prefixField + "_add", I, I, I),
          c2.call(prefixField + "_mul", H, I, J),
          c2.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r2),
          c2.call(prefixField + "_mul", x1, I, V),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V, V, V2),
          c2.call(prefixField + "_sub", r22, J, x3),
          c2.call(prefixField + "_sub", x3, V2, x3),
          c2.call(prefixField + "_mul", y1, J, y1_J2),
          c2.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c2.call(prefixField + "_sub", V, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, y1_J2, y3),
          c2.call(prefixField + "_add", H, H, z3)
        );
      }
      function buildNeg() {
        const f2 = module3.addFunction(prefix + "_neg");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        f2.addCode(
          c2.call(prefixField + "_copy", x, x3),
          c2.call(prefixField + "_neg", y, y3),
          c2.call(prefixField + "_copy", z2, z3)
        );
      }
      function buildNegAffine() {
        const f2 = module3.addFunction(prefix + "_negAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        f2.addCode(
          c2.call(prefixField + "_copy", x, x3),
          c2.call(prefixField + "_neg", y, y3)
        );
      }
      function buildSub() {
        const f2 = module3.addFunction(prefix + "_sub");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix + "_neg", c2.getLocal("p2"), AUX),
          c2.call(prefix + "_add", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildSubMixed() {
        const f2 = module3.addFunction(prefix + "_subMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix + "_negAffine", c2.getLocal("p2"), AUX),
          c2.call(prefix + "_addMixed", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildSubAffine() {
        const f2 = module3.addFunction(prefix + "_subAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix + "_negAffine", c2.getLocal("p2"), AUX),
          c2.call(prefix + "_addAffine", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildNormalize() {
        const f2 = module3.addFunction(prefix + "_normalize");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z_inv = c2.i32_const(module3.alloc(n8));
        const Z2_inv = c2.i32_const(module3.alloc(n8));
        const Z3_inv = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            c2.call(prefix + "_zero", c2.getLocal("pr")),
            [
              ...c2.call(prefixField + "_inverse", z2, Z_inv),
              ...c2.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c2.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c2.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c2.call(prefixField + "_mul", y, Z3_inv, y3),
              ...c2.call(prefixField + "_one", z3)
            ]
          )
        );
      }
      function buildToAffine() {
        const f2 = module3.addFunction(prefix + "_toAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const Z_inv = c2.i32_const(module3.alloc(n8));
        const Z2_inv = c2.i32_const(module3.alloc(n8));
        const Z3_inv = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefixField + "_zero", x3),
              ...c2.call(prefixField + "_zero", y3)
            ],
            [
              ...c2.call(prefixField + "_inverse", z2, Z_inv),
              ...c2.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c2.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c2.call(prefixField + "_mul", x, Z2_inv, x3),
              ...c2.call(prefixField + "_mul", y, Z3_inv, y3)
            ]
          )
        );
      }
      function buildToJacobian() {
        const f2 = module3.addFunction(prefix + "_toJacobian");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("p1")),
            c2.call(prefix + "_zero", c2.getLocal("pr")),
            [
              ...c2.call(prefixField + "_one", z3),
              ...c2.call(prefixField + "_copy", y, y3),
              ...c2.call(prefixField + "_copy", x, x3)
            ]
          )
        );
      }
      function buildBatchToAffine() {
        const f2 = module3.addFunction(prefix + "_batchToAffine");
        f2.addParam("pIn", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("pAux", "i32");
        f2.addLocal("itIn", "i32");
        f2.addLocal("itAux", "i32");
        f2.addLocal("itOut", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const tmp = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.setLocal("pAux", c2.i32_load(c2.i32_const(0))),
          c2.i32_store(
            c2.i32_const(0),
            c2.i32_add(
              c2.getLocal("pAux"),
              c2.i32_mul(c2.getLocal("n"), c2.i32_const(n8))
            )
          ),
          c2.call(
            prefixField + "_batchInverse",
            c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8 * 2)),
            c2.i32_const(n8 * 3),
            c2.getLocal("n"),
            c2.getLocal("pAux"),
            c2.i32_const(n8)
          ),
          c2.setLocal("itIn", c2.getLocal("pIn")),
          c2.setLocal("itAux", c2.getLocal("pAux")),
          c2.setLocal("itOut", c2.getLocal("pOut")),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.if(
              c2.call(prefixField + "_isZero", c2.getLocal("itAux")),
              [
                ...c2.call(prefixField + "_zero", c2.getLocal("itOut")),
                ...c2.call(prefixField + "_zero", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8)))
              ],
              [
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  c2.i32_add(c2.getLocal("itIn"), c2.i32_const(n8)),
                  tmp
                ),
                ...c2.call(
                  prefixField + "_square",
                  c2.getLocal("itAux"),
                  c2.getLocal("itAux")
                ),
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  c2.getLocal("itIn"),
                  c2.getLocal("itOut")
                ),
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  tmp,
                  c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8))
                )
              ]
            ),
            c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(n8 * 3))),
            c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8 * 2))),
            c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.i32_store(
            c2.i32_const(0),
            c2.getLocal("pAux")
          )
        );
      }
      function buildReverseBytes() {
        const f2 = module3.addFunction(prefix + "__reverseBytes");
        f2.addParam("pIn", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("itOut", "i32");
        f2.addLocal("itIn", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "itOut",
            c2.i32_sub(
              c2.i32_add(
                c2.getLocal("pOut"),
                c2.getLocal("n")
              ),
              c2.i32_const(1)
            )
          ),
          c2.setLocal(
            "itIn",
            c2.getLocal("pIn")
          ),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_lt_s(c2.getLocal("itOut"), c2.getLocal("pOut"))),
            c2.i32_store8(
              c2.getLocal("itOut"),
              c2.i32_load8_u(c2.getLocal("itIn"))
            ),
            c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(1))),
            c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildLEMtoC() {
        const f2 = module3.addFunction(prefix + "_LEMtoC");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const tmp = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("pIn")),
            [
              ...c2.call(prefixField + "_zero", c2.getLocal("pOut")),
              ...c2.i32_store8(
                c2.getLocal("pOut"),
                c2.i32_const(64)
              ),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_fromMontgomery", c2.getLocal("pIn"), tmp),
          c2.call(prefix + "__reverseBytes", tmp, c2.i32_const(n8), c2.getLocal("pOut")),
          c2.if(
            c2.i32_eq(
              c2.call(prefixField + "_sign", c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8))),
              c2.i32_const(-1)
            ),
            c2.i32_store8(
              c2.getLocal("pOut"),
              c2.i32_or(
                c2.i32_load8_u(c2.getLocal("pOut")),
                c2.i32_const(128)
              )
            )
          )
        );
      }
      function buildLEMtoU() {
        const f2 = module3.addFunction(prefix + "_LEMtoU");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c2.i32_const(pTmp);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.if(
            c2.call(prefix + "_isZeroAffine", c2.getLocal("pIn")),
            [
              ...c2.call(prefix + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.call(prefix + "_fromMontgomeryAffine", c2.getLocal("pIn"), tmp),
          c2.call(prefix + "__reverseBytes", tmpX, c2.i32_const(n8), c2.getLocal("pOut")),
          c2.call(prefix + "__reverseBytes", tmpY, c2.i32_const(n8), c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
        );
      }
      function buildUtoLEM() {
        const f2 = module3.addFunction(prefix + "_UtoLEM");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmp = c2.i32_const(pTmp);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.if(
            c2.i32_and(c2.i32_load8_u(c2.getLocal("pIn")), c2.i32_const(64)),
            [
              ...c2.call(prefix + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.call(prefix + "__reverseBytes", c2.getLocal("pIn"), c2.i32_const(n8), tmpX),
          c2.call(prefix + "__reverseBytes", c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8)), c2.i32_const(n8), tmpY),
          c2.call(prefix + "_toMontgomeryAffine", tmp, c2.getLocal("pOut"))
        );
      }
      function buildCtoLEM() {
        const f2 = module3.addFunction(prefix + "_CtoLEM");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("firstByte", "i32");
        f2.addLocal("greatest", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module3.alloc(n8 * 2);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.setLocal("firstByte", c2.i32_load8_u(c2.getLocal("pIn"))),
          c2.if(
            c2.i32_and(
              c2.getLocal("firstByte"),
              c2.i32_const(64)
            ),
            [
              ...c2.call(prefix + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.setLocal(
            "greatest",
            c2.i32_and(
              c2.getLocal("firstByte"),
              c2.i32_const(128)
            )
          ),
          c2.call(prefixField + "_copy", c2.getLocal("pIn"), tmpY),
          c2.i32_store8(tmpY, c2.i32_and(c2.getLocal("firstByte"), c2.i32_const(63))),
          c2.call(prefix + "__reverseBytes", tmpY, c2.i32_const(n8), tmpX),
          c2.call(prefixField + "_toMontgomery", tmpX, c2.getLocal("pOut")),
          c2.call(prefixField + "_square", c2.getLocal("pOut"), tmpY),
          c2.call(prefixField + "_mul", c2.getLocal("pOut"), tmpY, tmpY),
          c2.call(prefixField + "_add", tmpY, c2.i32_const(pB), tmpY),
          c2.call(prefixField + "_sqrt", tmpY, tmpY),
          c2.call(prefixField + "_neg", tmpY, tmpX),
          c2.if(
            c2.i32_eq(
              c2.call(prefixField + "_sign", tmpY),
              c2.i32_const(-1)
            ),
            c2.if(
              c2.getLocal("greatest"),
              c2.call(prefixField + "_copy", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8))),
              c2.call(prefixField + "_neg", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
            ),
            c2.if(
              c2.getLocal("greatest"),
              c2.call(prefixField + "_neg", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8))),
              c2.call(prefixField + "_copy", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
            )
          )
        );
      }
      function buildInCurveAffine() {
        const f2 = module3.addFunction(prefix + "_inCurveAffine");
        f2.addParam("pIn", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("pIn");
        const y = c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8));
        const y2 = c2.i32_const(module3.alloc(n8));
        const x3b = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.call(prefixField + "_square", y, y2),
          c2.call(prefixField + "_square", x, x3b),
          c2.call(prefixField + "_mul", x, x3b, x3b),
          c2.call(prefixField + "_add", x3b, c2.i32_const(pB), x3b),
          c2.ret(
            c2.call(prefixField + "_eq", y2, x3b)
          )
        );
      }
      function buildInCurve() {
        const f2 = module3.addFunction(prefix + "_inCurve");
        f2.addParam("pIn", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module3.alloc(n8 * 2));
        f2.addCode(
          c2.call(prefix + "_toAffine", c2.getLocal("pIn"), aux),
          c2.ret(
            c2.call(prefix + "_inCurveAffine", aux)
          )
        );
      }
      buildIsZeroAffine();
      buildIsZero();
      buildZeroAffine();
      buildZero();
      buildCopyAffine();
      buildCopy();
      buildToJacobian();
      buildEqAffine();
      buildEqMixed();
      buildEq();
      buildDoubleAffine();
      buildDouble();
      buildAddAffine();
      buildAddMixed();
      buildAdd();
      buildNegAffine();
      buildNeg();
      buildSubAffine();
      buildSubMixed();
      buildSub();
      buildFromMontgomeryAffine();
      buildFromMontgomery();
      buildToMontgomeryAffine();
      buildToMontgomery();
      buildToAffine();
      buildInCurveAffine();
      buildInCurve();
      buildBatchToAffine();
      buildNormalize();
      buildReverseBytes();
      buildLEMtoU();
      buildLEMtoC();
      buildUtoLEM();
      buildCtoLEM();
      buildBatchConvertion(module3, prefix + "_batchLEMtoU", prefix + "_LEMtoU", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchLEMtoC", prefix + "_LEMtoC", n8 * 2, n8);
      buildBatchConvertion(module3, prefix + "_batchUtoLEM", prefix + "_UtoLEM", n8 * 2, n8 * 2);
      buildBatchConvertion(module3, prefix + "_batchCtoLEM", prefix + "_CtoLEM", n8, n8 * 2, true);
      buildBatchConvertion(module3, prefix + "_batchToJacobian", prefix + "_toJacobian", n8 * 2, n8 * 3, true);
      buildMultiexp2(module3, prefix, prefix + "_multiexp", prefix + "_add", n8 * 3);
      buildMultiexp2(module3, prefix, prefix + "_multiexpAffine", prefix + "_addMixed", n8 * 2);
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalar",
        n8 * 3,
        prefix + "_add",
        prefix + "_double",
        prefix + "_sub",
        prefix + "_copy",
        prefix + "_zero"
      );
      buildTimesScalarNAF(
        module3,
        prefix + "_timesScalarAffine",
        n8 * 2,
        prefix + "_addMixed",
        prefix + "_double",
        prefix + "_subMixed",
        prefix + "_copyAffine",
        prefix + "_zero"
      );
      module3.exportFunction(prefix + "_isZero");
      module3.exportFunction(prefix + "_isZeroAffine");
      module3.exportFunction(prefix + "_eq");
      module3.exportFunction(prefix + "_eqMixed");
      module3.exportFunction(prefix + "_eqAffine");
      module3.exportFunction(prefix + "_copy");
      module3.exportFunction(prefix + "_copyAffine");
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_zeroAffine");
      module3.exportFunction(prefix + "_double");
      module3.exportFunction(prefix + "_doubleAffine");
      module3.exportFunction(prefix + "_add");
      module3.exportFunction(prefix + "_addMixed");
      module3.exportFunction(prefix + "_addAffine");
      module3.exportFunction(prefix + "_neg");
      module3.exportFunction(prefix + "_negAffine");
      module3.exportFunction(prefix + "_sub");
      module3.exportFunction(prefix + "_subMixed");
      module3.exportFunction(prefix + "_subAffine");
      module3.exportFunction(prefix + "_fromMontgomery");
      module3.exportFunction(prefix + "_fromMontgomeryAffine");
      module3.exportFunction(prefix + "_toMontgomery");
      module3.exportFunction(prefix + "_toMontgomeryAffine");
      module3.exportFunction(prefix + "_timesScalar");
      module3.exportFunction(prefix + "_timesScalarAffine");
      module3.exportFunction(prefix + "_normalize");
      module3.exportFunction(prefix + "_LEMtoU");
      module3.exportFunction(prefix + "_LEMtoC");
      module3.exportFunction(prefix + "_UtoLEM");
      module3.exportFunction(prefix + "_CtoLEM");
      module3.exportFunction(prefix + "_batchLEMtoU");
      module3.exportFunction(prefix + "_batchLEMtoC");
      module3.exportFunction(prefix + "_batchUtoLEM");
      module3.exportFunction(prefix + "_batchCtoLEM");
      module3.exportFunction(prefix + "_toAffine");
      module3.exportFunction(prefix + "_toJacobian");
      module3.exportFunction(prefix + "_batchToAffine");
      module3.exportFunction(prefix + "_batchToJacobian");
      module3.exportFunction(prefix + "_inCurve");
      module3.exportFunction(prefix + "_inCurveAffine");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_fft.js
var require_build_fft = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_fft.js"(exports2, module2) {
    var { isOdd: isOdd3, modInv, modPow } = require_bigint();
    var utils2 = require_utils3();
    module2.exports = function buildFFT2(module3, prefix, gPrefix, fPrefix, opGtimesF) {
      const n64f = module3.modules[fPrefix].n64;
      const n8f = n64f * 8;
      const n64g = module3.modules[gPrefix].n64;
      const n8g = n64g * 8;
      const q = module3.modules[fPrefix].q;
      let rem = q - 1n;
      let maxBits = 0;
      while (!isOdd3(rem)) {
        maxBits++;
        rem = rem >> 1n;
      }
      let nr = 2n;
      while (modPow(nr, q >> 1n, q) === 1n) nr = nr + 1n;
      const w = new Array(maxBits + 1);
      w[maxBits] = modPow(nr, rem, q);
      let n3 = maxBits - 1;
      while (n3 >= 0) {
        w[n3] = modPow(w[n3 + 1], 2n, q);
        n3--;
      }
      const bytes2 = [];
      const R = (1n << BigInt(n8f * 8)) % q;
      for (let i = 0; i < w.length; i++) {
        const m = w[i] * R % q;
        bytes2.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const ROOTs = module3.alloc(bytes2);
      const i2 = new Array(maxBits + 1);
      i2[0] = 1n;
      for (let i = 1; i <= maxBits; i++) {
        i2[i] = i2[i - 1] * 2n;
      }
      const bytesi2 = [];
      for (let i = 0; i <= maxBits; i++) {
        const m = modInv(i2[i], q) * R % q;
        bytesi2.push(...utils2.bigInt2BytesLE(m, n8f));
      }
      const INV2 = module3.alloc(bytesi2);
      const shift = modPow(nr, 2n, q);
      const bytesShiftToSmallM = [];
      const bytesSConst = [];
      for (let i = 0; i <= maxBits; i++) {
        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);
        const sConst = modInv(q + 1n - shiftToSmallM, q);
        bytesShiftToSmallM.push(...utils2.bigInt2BytesLE(shiftToSmallM * R % q, n8f));
        bytesSConst.push(...utils2.bigInt2BytesLE(sConst * R % q, n8f));
      }
      const SHIFT_TO_M = module3.alloc(bytesShiftToSmallM);
      const SCONST = module3.alloc(bytesSConst);
      function rev(x) {
        let r2 = 0;
        for (let i = 0; i < 8; i++) {
          if (x & 1 << i) {
            r2 = r2 | 128 >> i;
          }
        }
        return r2;
      }
      const rtable = Array(256);
      for (let i = 0; i < 256; i++) {
        rtable[i] = rev(i);
      }
      const REVTABLE = module3.alloc(rtable);
      function buildLog2() {
        const f2 = module3.addFunction(prefix + "__log2");
        f2.addParam("n", "i32");
        f2.setReturnType("i32");
        f2.addLocal("bits", "i32");
        f2.addLocal("aux", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "aux",
            c2.i32_shr_u(
              c2.getLocal("n"),
              c2.i32_const(1)
            )
          )
        );
        f2.addCode(c2.setLocal("bits", c2.i32_const(0)));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i32_eqz(c2.getLocal("aux"))
          ),
          c2.setLocal(
            "aux",
            c2.i32_shr_u(
              c2.getLocal("aux"),
              c2.i32_const(1)
            )
          ),
          c2.setLocal(
            "bits",
            c2.i32_add(
              c2.getLocal("bits"),
              c2.i32_const(1)
            )
          ),
          c2.br(0)
        )));
        f2.addCode(c2.if(
          c2.i32_ne(
            c2.getLocal("n"),
            c2.i32_shl(
              c2.i32_const(1),
              c2.getLocal("bits")
            )
          ),
          c2.unreachable()
        ));
        f2.addCode(c2.if(
          c2.i32_gt_u(
            c2.getLocal("bits"),
            c2.i32_const(maxBits)
          ),
          c2.unreachable()
        ));
        f2.addCode(c2.getLocal("bits"));
      }
      function buildFFT3() {
        const f2 = module3.addFunction(prefix + "_fft");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("bits", "i32");
        const c2 = f2.getCodeBuilder();
        const One = c2.i32_const(module3.alloc(n8f));
        f2.addCode(
          c2.setLocal(
            "bits",
            c2.call(
              prefix + "__log2",
              c2.getLocal("n")
            )
          ),
          c2.call(fPrefix + "_one", One),
          c2.call(
            prefix + "_rawfft",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.i32_const(0),
            One
          )
        );
      }
      function buildIFFT() {
        const f2 = module3.addFunction(prefix + "_ifft");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("bits", "i32");
        f2.addLocal("pInv2", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "bits",
            c2.call(
              prefix + "__log2",
              c2.getLocal("n")
            )
          ),
          c2.setLocal(
            "pInv2",
            c2.i32_add(
              c2.i32_const(INV2),
              c2.i32_mul(
                c2.getLocal("bits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(
            prefix + "_rawfft",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.i32_const(1),
            c2.getLocal("pInv2")
          )
        );
      }
      function buildRawFFT() {
        const f2 = module3.addFunction(prefix + "_rawfft");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addParam("reverse", "i32");
        f2.addParam("mulFactor", "i32");
        f2.addLocal("s", "i32");
        f2.addLocal("k", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("mdiv2", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("pwm", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const T = c2.i32_const(module3.alloc(n8g));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.call(prefix + "__reversePermutation", c2.getLocal("px"), c2.getLocal("bits")),
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("s", c2.i32_const(1)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_gt_u(
                c2.getLocal("s"),
                c2.getLocal("bits")
              )
            ),
            c2.setLocal("m", c2.i32_shl(c2.i32_const(1), c2.getLocal("s"))),
            c2.setLocal(
              "pwm",
              c2.i32_add(
                c2.i32_const(ROOTs),
                c2.i32_mul(
                  c2.getLocal("s"),
                  c2.i32_const(n8f)
                )
              )
            ),
            c2.setLocal("k", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_ge_u(
                  c2.getLocal("k"),
                  c2.getLocal("n")
                )
              ),
              c2.call(fPrefix + "_one", W),
              c2.setLocal("mdiv2", c2.i32_shr_u(c2.getLocal("m"), c2.i32_const(1))),
              c2.setLocal("j", c2.i32_const(0)),
              c2.block(c2.loop(
                c2.br_if(
                  1,
                  c2.i32_ge_u(
                    c2.getLocal("j"),
                    c2.getLocal("mdiv2")
                  )
                ),
                c2.setLocal(
                  "idx1",
                  c2.i32_add(
                    c2.getLocal("px"),
                    c2.i32_mul(
                      c2.i32_add(
                        c2.getLocal("k"),
                        c2.getLocal("j")
                      ),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                c2.setLocal(
                  "idx2",
                  c2.i32_add(
                    c2.getLocal("idx1"),
                    c2.i32_mul(
                      c2.getLocal("mdiv2"),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                c2.call(
                  opGtimesF,
                  c2.getLocal("idx2"),
                  W,
                  T
                ),
                c2.call(
                  gPrefix + "_copy",
                  c2.getLocal("idx1"),
                  U
                ),
                c2.call(
                  gPrefix + "_add",
                  U,
                  T,
                  c2.getLocal("idx1")
                ),
                c2.call(
                  gPrefix + "_sub",
                  U,
                  T,
                  c2.getLocal("idx2")
                ),
                c2.call(
                  fPrefix + "_mul",
                  W,
                  c2.getLocal("pwm"),
                  W
                ),
                c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
                c2.br(0)
              )),
              c2.setLocal("k", c2.i32_add(c2.getLocal("k"), c2.getLocal("m"))),
              c2.br(0)
            )),
            c2.setLocal("s", c2.i32_add(c2.getLocal("s"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(
            prefix + "__fftFinal",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.getLocal("reverse"),
            c2.getLocal("mulFactor")
          )
        );
      }
      function buildFinalInverse() {
        const f2 = module3.addFunction(prefix + "__fftFinal");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addParam("reverse", "i32");
        f2.addParam("mulFactor", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("ndiv2", "i32");
        f2.addLocal("pInv2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("mask", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const T = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.if(
            c2.i32_and(
              c2.i32_eqz(c2.getLocal("reverse")),
              c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor"))
            ),
            c2.ret([])
          ),
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("mask", c2.i32_sub(c2.getLocal("n"), c2.i32_const(1))),
          c2.setLocal("i", c2.i32_const(1)),
          c2.setLocal(
            "ndiv2",
            c2.i32_shr_u(
              c2.getLocal("n"),
              c2.i32_const(1)
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_ge_u(
                c2.getLocal("i"),
                c2.getLocal("ndiv2")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.getLocal("n"),
                    c2.getLocal("i")
                  ),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.if(
              c2.getLocal("reverse"),
              c2.if(
                c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
                [
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T),
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx2"), c2.getLocal("idx1")),
                  ...c2.call(gPrefix + "_copy", T, c2.getLocal("idx2"))
                ],
                [
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T),
                  ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx1")),
                  ...c2.call(opGtimesF, T, c2.getLocal("mulFactor"), c2.getLocal("idx2"))
                ]
              ),
              c2.if(
                c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
                [
                  // Do nothing (It should not be here)
                ],
                [
                  ...c2.call(opGtimesF, c2.getLocal("idx1"), c2.getLocal("mulFactor"), c2.getLocal("idx1")),
                  ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx2"))
                ]
              )
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.if(
            c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
            [
              // Do nothing (It should not be here)
            ],
            [
              ...c2.call(opGtimesF, c2.getLocal("px"), c2.getLocal("mulFactor"), c2.getLocal("px")),
              ...c2.setLocal(
                "idx2",
                c2.i32_add(
                  c2.getLocal("px"),
                  c2.i32_mul(
                    c2.getLocal("ndiv2"),
                    c2.i32_const(n8g)
                  )
                )
              ),
              ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx2"))
            ]
          )
        );
      }
      function buildReversePermutation() {
        const f2 = module3.addFunction(prefix + "__reversePermutation");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("ri", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const T = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal("ri", c2.call(prefix + "__rev", c2.getLocal("i"), c2.getLocal("bits"))),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("ri"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.if(
              c2.i32_lt_u(
                c2.getLocal("i"),
                c2.getLocal("ri")
              ),
              [
                ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T),
                ...c2.call(gPrefix + "_copy", c2.getLocal("idx2"), c2.getLocal("idx1")),
                ...c2.call(gPrefix + "_copy", T, c2.getLocal("idx2"))
              ]
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildRev() {
        const f2 = module3.addFunction(prefix + "__rev");
        f2.addParam("x", "i32");
        f2.addParam("bits", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i32_rotl(
            c2.i32_add(
              c2.i32_add(
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.getLocal("x"),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(24)
                ),
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.i32_shr_u(
                        c2.getLocal("x"),
                        c2.i32_const(8)
                      ),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(16)
                )
              ),
              c2.i32_add(
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.i32_shr_u(
                        c2.getLocal("x"),
                        c2.i32_const(16)
                      ),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(8)
                ),
                c2.i32_load8_u(
                  c2.i32_and(
                    c2.i32_shr_u(
                      c2.getLocal("x"),
                      c2.i32_const(24)
                    ),
                    c2.i32_const(255)
                  ),
                  REVTABLE,
                  0
                )
              )
            ),
            c2.getLocal("bits")
          )
        );
      }
      function buildFFTJoin() {
        const f2 = module3.addFunction(prefix + "_fftJoin");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const T = c2.i32_const(module3.alloc(n8g));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W,
              T
            ),
            c2.call(
              gPrefix + "_copy",
              c2.getLocal("idx1"),
              U
            ),
            c2.call(
              gPrefix + "_add",
              U,
              T,
              c2.getLocal("idx1")
            ),
            c2.call(
              gPrefix + "_sub",
              U,
              T,
              c2.getLocal("idx2")
            ),
            c2.call(
              fPrefix + "_mul",
              W,
              c2.getLocal("inc"),
              W
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTJoinExt() {
        const f2 = module3.addFunction(prefix + "_fftJoinExt");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              gPrefix + "_add",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              U
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("pShiftToM"),
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_add",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W,
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_copy",
              U,
              c2.getLocal("idx1")
            ),
            c2.call(
              fPrefix + "_mul",
              W,
              c2.getLocal("inc"),
              W
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTJoinExtInv() {
        const f2 = module3.addFunction(prefix + "_fftJoinExtInv");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        f2.addLocal("pSConst", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal(
            "pSConst",
            c2.i32_add(
              c2.i32_const(SCONST),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W,
              U
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx1"),
              U,
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("pSConst"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pShiftToM"),
              c2.getLocal("idx1")
            ),
            c2.call(
              gPrefix + "_sub",
              U,
              c2.getLocal("idx1"),
              c2.getLocal("idx1")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pSConst"),
              c2.getLocal("idx1")
            ),
            c2.call(
              fPrefix + "_mul",
              W,
              c2.getLocal("inc"),
              W
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildPrepareLagrangeEvaluation() {
        const f2 = module3.addFunction(prefix + "_prepareLagrangeEvaluation");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        f2.addLocal("pSConst", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal(
            "pSConst",
            c2.i32_add(
              c2.i32_const(SCONST),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pShiftToM"),
              U
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx2"),
              U,
              U
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              U,
              c2.getLocal("pSConst"),
              c2.getLocal("idx1")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W,
              c2.getLocal("idx2")
            ),
            c2.call(
              fPrefix + "_mul",
              W,
              c2.getLocal("inc"),
              W
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTMix() {
        const f2 = module3.addFunction(prefix + "_fftMix");
        f2.addParam("pBuff", "i32");
        f2.addParam("n", "i32");
        f2.addParam("exp", "i32");
        f2.addLocal("nGroups", "i32");
        f2.addLocal("nPerGroup", "i32");
        f2.addLocal("nPerGroupDiv2", "i32");
        f2.addLocal("pairOffset", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("pwm", "i32");
        const c2 = f2.getCodeBuilder();
        const W = c2.i32_const(module3.alloc(n8f));
        const T = c2.i32_const(module3.alloc(n8g));
        const U = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal("nPerGroup", c2.i32_shl(c2.i32_const(1), c2.getLocal("exp"))),
          c2.setLocal("nPerGroupDiv2", c2.i32_shr_u(c2.getLocal("nPerGroup"), c2.i32_const(1))),
          c2.setLocal("nGroups", c2.i32_shr_u(c2.getLocal("n"), c2.getLocal("exp"))),
          c2.setLocal("pairOffset", c2.i32_mul(c2.getLocal("nPerGroupDiv2"), c2.i32_const(n8g))),
          c2.setLocal(
            "pwm",
            c2.i32_add(
              c2.i32_const(ROOTs),
              c2.i32_mul(
                c2.getLocal("exp"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("nGroups")
              )
            ),
            c2.call(fPrefix + "_one", W),
            c2.setLocal("j", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_eq(
                  c2.getLocal("j"),
                  c2.getLocal("nPerGroupDiv2")
                )
              ),
              c2.setLocal(
                "idx1",
                c2.i32_add(
                  c2.getLocal("pBuff"),
                  c2.i32_mul(
                    c2.i32_add(
                      c2.i32_mul(
                        c2.getLocal("i"),
                        c2.getLocal("nPerGroup")
                      ),
                      c2.getLocal("j")
                    ),
                    c2.i32_const(n8g)
                  )
                )
              ),
              c2.setLocal(
                "idx2",
                c2.i32_add(
                  c2.getLocal("idx1"),
                  c2.getLocal("pairOffset")
                )
              ),
              c2.call(
                opGtimesF,
                c2.getLocal("idx2"),
                W,
                T
              ),
              c2.call(
                gPrefix + "_copy",
                c2.getLocal("idx1"),
                U
              ),
              c2.call(
                gPrefix + "_add",
                U,
                T,
                c2.getLocal("idx1")
              ),
              c2.call(
                gPrefix + "_sub",
                U,
                T,
                c2.getLocal("idx2")
              ),
              c2.call(
                fPrefix + "_mul",
                W,
                c2.getLocal("pwm"),
                W
              ),
              c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTFinal() {
        const f2 = module3.addFunction(prefix + "_fftFinal");
        f2.addParam("pBuff", "i32");
        f2.addParam("n", "i32");
        f2.addParam("factor", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("ndiv2", "i32");
        const c2 = f2.getCodeBuilder();
        const T = c2.i32_const(module3.alloc(n8g));
        f2.addCode(
          c2.setLocal("ndiv2", c2.i32_shr_u(c2.getLocal("n"), c2.i32_const(1))),
          c2.if(
            c2.i32_and(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.call(
              opGtimesF,
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("ndiv2"),
                  c2.i32_const(n8g)
                )
              ),
              c2.getLocal("factor"),
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("ndiv2"),
                  c2.i32_const(n8g)
                )
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_ge_u(
                c2.getLocal("i"),
                c2.getLocal("ndiv2")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.i32_sub(
                      c2.getLocal("n"),
                      c2.i32_const(1)
                    ),
                    c2.getLocal("i")
                  ),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("factor"),
              T
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("factor"),
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_copy",
              T,
              c2.getLocal("idx1")
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      buildRev();
      buildReversePermutation();
      buildFinalInverse();
      buildRawFFT();
      buildLog2();
      buildFFT3();
      buildIFFT();
      buildFFTJoin();
      buildFFTJoinExt();
      buildFFTJoinExtInv();
      buildFFTMix();
      buildFFTFinal();
      buildPrepareLagrangeEvaluation();
      module3.exportFunction(prefix + "_fft");
      module3.exportFunction(prefix + "_ifft");
      module3.exportFunction(prefix + "_rawfft");
      module3.exportFunction(prefix + "_fftJoin");
      module3.exportFunction(prefix + "_fftJoinExt");
      module3.exportFunction(prefix + "_fftJoinExtInv");
      module3.exportFunction(prefix + "_fftMix");
      module3.exportFunction(prefix + "_fftFinal");
      module3.exportFunction(prefix + "_prepareLagrangeEvaluation");
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_pol.js
var require_build_pol = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_pol.js"(exports2, module2) {
    module2.exports = function buildPol(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildZero() {
        const f2 = module3.addFunction(prefix + "_zero");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("lastp", "i32");
        f2.addLocal("p", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal("p", c2.getLocal("px")),
          c2.setLocal(
            "lastp",
            c2.i32_add(
              c2.getLocal("px"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("p"),
                c2.getLocal("lastp")
              )
            ),
            c2.call(prefixField + "_zero", c2.getLocal("p")),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildConstructLC() {
        const f2 = module3.addFunction(prefix + "_constructLC");
        f2.addParam("ppolynomials", "i32");
        f2.addParam("psignals", "i32");
        f2.addParam("nSignals", "i32");
        f2.addParam("pres", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("pp", "i32");
        f2.addLocal("ps", "i32");
        f2.addLocal("pd", "i32");
        f2.addLocal("ncoefs", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.setLocal("i", c2.i32_const(0)),
          c2.setLocal("pp", c2.getLocal("ppolynomials")),
          c2.setLocal("ps", c2.getLocal("psignals")),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("nSignals")
              )
            ),
            c2.setLocal("ncoefs", c2.i32_load(c2.getLocal("pp"))),
            c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(4))),
            c2.setLocal("j", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_eq(
                  c2.getLocal("j"),
                  c2.getLocal("ncoefs")
                )
              ),
              c2.setLocal(
                "pd",
                c2.i32_add(
                  c2.getLocal("pres"),
                  c2.i32_mul(
                    c2.i32_load(c2.getLocal("pp")),
                    c2.i32_const(n8)
                  )
                )
              ),
              c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(4))),
              c2.call(
                prefixField + "_mul",
                c2.getLocal("ps"),
                c2.getLocal("pp"),
                aux
              ),
              c2.call(
                prefixField + "_add",
                aux,
                c2.getLocal("pd"),
                c2.getLocal("pd")
              ),
              c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(n8))),
              c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("ps", c2.i32_add(c2.getLocal("ps"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      buildZero();
      buildConstructLC();
      module3.exportFunction(prefix + "_zero");
      module3.exportFunction(prefix + "_constructLC");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_qap.js
var require_build_qap = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_qap.js"(exports2, module2) {
    module2.exports = function buildQAP(module3, prefix, prefixField) {
      const n64 = module3.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildBuildABC() {
        const f2 = module3.addFunction(prefix + "_buildABC");
        f2.addParam("pCoefs", "i32");
        f2.addParam("nCoefs", "i32");
        f2.addParam("pWitness", "i32");
        f2.addParam("pA", "i32");
        f2.addParam("pB", "i32");
        f2.addParam("pC", "i32");
        f2.addParam("offsetOut", "i32");
        f2.addParam("nOut", "i32");
        f2.addParam("offsetWitness", "i32");
        f2.addParam("nWitness", "i32");
        f2.addLocal("it", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("last", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("c", "i32");
        f2.addLocal("s", "i32");
        f2.addLocal("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          // Set output a and b to 0
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("nOut"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(prefixField + "_zero", c2.getLocal("ita")),
            c2.call(prefixField + "_zero", c2.getLocal("itb")),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.br(0)
          )),
          c2.setLocal("it", c2.getLocal("pCoefs")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pCoefs"),
              c2.i32_mul(
                c2.getLocal("nCoefs"),
                c2.i32_const(n8 + 12)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("it"),
                c2.getLocal("last")
              )
            ),
            c2.setLocal(
              "s",
              c2.i32_load(c2.getLocal("it"), 8)
            ),
            c2.if(
              c2.i32_or(
                c2.i32_lt_u(
                  c2.getLocal("s"),
                  c2.getLocal("offsetWitness")
                ),
                c2.i32_ge_u(
                  c2.getLocal("s"),
                  c2.i32_add(
                    c2.getLocal("offsetWitness"),
                    c2.getLocal("nWitness")
                  )
                )
              ),
              [
                ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                ...c2.br(1)
              ]
            ),
            c2.setLocal(
              "m",
              c2.i32_load(c2.getLocal("it"))
            ),
            c2.if(
              c2.i32_eq(c2.getLocal("m"), c2.i32_const(0)),
              c2.setLocal("pOut", c2.getLocal("pA")),
              c2.if(
                c2.i32_eq(c2.getLocal("m"), c2.i32_const(1)),
                c2.setLocal("pOut", c2.getLocal("pB")),
                [
                  ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                  ...c2.br(1)
                ]
              )
            ),
            c2.setLocal(
              "c",
              c2.i32_load(c2.getLocal("it"), 4)
            ),
            c2.if(
              c2.i32_or(
                c2.i32_lt_u(
                  c2.getLocal("c"),
                  c2.getLocal("offsetOut")
                ),
                c2.i32_ge_u(
                  c2.getLocal("c"),
                  c2.i32_add(
                    c2.getLocal("offsetOut"),
                    c2.getLocal("nOut")
                  )
                )
              ),
              [
                ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                ...c2.br(1)
              ]
            ),
            c2.setLocal(
              "pOut",
              c2.i32_add(
                c2.getLocal("pOut"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.getLocal("c"),
                    c2.getLocal("offsetOut")
                  ),
                  c2.i32_const(n8)
                )
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.i32_add(
                c2.getLocal("pWitness"),
                c2.i32_mul(
                  c2.i32_sub(c2.getLocal("s"), c2.getLocal("offsetWitness")),
                  c2.i32_const(n8)
                )
              ),
              c2.i32_add(c2.getLocal("it"), c2.i32_const(12)),
              aux
            ),
            c2.call(
              prefixField + "_add",
              c2.getLocal("pOut"),
              aux,
              c2.getLocal("pOut")
            ),
            c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
            c2.br(0)
          )),
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal("it", c2.getLocal("pC")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("nOut"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              c2.getLocal("it")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildJoinABC() {
        const f2 = module3.addFunction(prefix + "_joinABC");
        f2.addParam("pA", "i32");
        f2.addParam("pB", "i32");
        f2.addParam("pC", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pP", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("itc", "i32");
        f2.addLocal("itp", "i32");
        f2.addLocal("last", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal("itc", c2.getLocal("pC")),
          c2.setLocal("itp", c2.getLocal("pP")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              aux
            ),
            c2.call(
              prefixField + "_sub",
              aux,
              c2.getLocal("itc"),
              c2.getLocal("itp")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("itc", c2.i32_add(c2.getLocal("itc"), c2.i32_const(n8))),
            c2.setLocal("itp", c2.i32_add(c2.getLocal("itp"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildBatchAdd() {
        const f2 = module3.addFunction(prefix + "_batchAdd");
        f2.addParam("pa", "i32");
        f2.addParam("pb", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("itr", "i32");
        f2.addLocal("last", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal("ita", c2.getLocal("pa")),
          c2.setLocal("itb", c2.getLocal("pb")),
          c2.setLocal("itr", c2.getLocal("pr")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pa"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_add",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              c2.getLocal("itr")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("itr", c2.i32_add(c2.getLocal("itr"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      buildBuildABC();
      buildJoinABC();
      buildBatchAdd();
      module3.exportFunction(prefix + "_buildABC");
      module3.exportFunction(prefix + "_joinABC");
      module3.exportFunction(prefix + "_batchAdd");
      return prefix;
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_applykey.js
var require_build_applykey = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/build_applykey.js"(exports2, module2) {
    module2.exports = function buildApplyKey(module3, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
      const f2 = module3.addFunction(fnName);
      f2.addParam("pIn", "i32");
      f2.addParam("n", "i32");
      f2.addParam("pFirst", "i32");
      f2.addParam("pInc", "i32");
      f2.addParam("pOut", "i32");
      f2.addLocal("pOldFree", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("pFrom", "i32");
      f2.addLocal("pTo", "i32");
      const c2 = f2.getCodeBuilder();
      const t = c2.i32_const(module3.alloc(sizeF));
      f2.addCode(
        c2.setLocal("pFrom", c2.getLocal("pIn")),
        c2.setLocal("pTo", c2.getLocal("pOut"))
      );
      f2.addCode(
        c2.call(
          frPrefix + "_copy",
          c2.getLocal("pFirst"),
          t
        )
      );
      f2.addCode(
        c2.setLocal("i", c2.i32_const(0)),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
          c2.call(
            opGtimesF,
            c2.getLocal("pFrom"),
            t,
            c2.getLocal("pTo")
          ),
          c2.setLocal("pFrom", c2.i32_add(c2.getLocal("pFrom"), c2.i32_const(sizeGIn))),
          c2.setLocal("pTo", c2.i32_add(c2.getLocal("pTo"), c2.i32_const(sizeGOut))),
          // t = t* inc
          c2.call(
            frPrefix + "_mul",
            t,
            c2.getLocal("pInc"),
            t
          ),
          c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        ))
      );
      module3.exportFunction(fnName);
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bn128/build_bn128.js
var require_build_bn128 = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bn128/build_bn128.js"(exports2, module2) {
    var utils2 = require_utils3();
    var buildF1m = require_build_f1m();
    var buildF1 = require_build_f1();
    var buildF2m = require_build_f2m();
    var buildF3m = require_build_f3m();
    var buildCurve = require_build_curve_jacobian_a0();
    var buildFFT2 = require_build_fft();
    var buildPol = require_build_pol();
    var buildQAP = require_build_qap();
    var buildApplyKey = require_build_applykey();
    var { bitLength: bitLength3, modInv, isOdd: isOdd3, isNegative: isNegative3 } = require_bigint();
    module2.exports = function buildBN128(module3, _prefix) {
      const prefix = _prefix || "bn128";
      if (module3.modules[prefix]) return prefix;
      const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
      const r2 = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
      const n64 = Math.floor((bitLength3(q - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const frsize = n8;
      const f1size = n8;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r2, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m");
      buildF1(module3, r2, "fr", "frm");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(3n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT2(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f2 = module3.addFunction(fnName);
        f2.addParam("pG", "i32");
        f2.addParam("pFr", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8));
        f2.addCode(
          c2.call("frm_fromMontgomery", c2.getLocal("pFr"), AUX),
          c2.call(
            opMul,
            c2.getLocal("pG"),
            AUX,
            c2.i32_const(n8),
            c2.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT2(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT2(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
      function toMontgomery(a2) {
        return BigInt(a2) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        1n,
        2n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          10857046999023057135944570762232829481370756359578518086990519993285655852781n,
          11559732032986387107991004021392285783925812861821192530917403151452391805634n
        ],
        [
          8495653923123431417604973247489272438418190587263600148770280649306958101930n,
          4082367875863433681332203403145435568316851327593401208105741076214120093531n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0), f1size)
      ]);
      const pNonResidueF6 = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(9), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1), f1size)
      ]);
      const pTwoInv = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(modInv(2n, q)), f1size),
        ...utils2.bigInt2BytesLE(0n, f1size)
      ]);
      const pAltBn128Twist = pNonResidueF6;
      const pTwistCoefB = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      function build_mulNR6() {
        const f2 = module3.addFunction(prefix + "_mulNR6");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(
            f2mPrefix + "_mul",
            c2.i32_const(pNonResidueF6),
            c2.getLocal("x"),
            c2.getLocal("pr")
          )
        );
      }
      build_mulNR6();
      const f6mPrefix = buildF3m(module3, prefix + "_mulNR6", "f6m", "f2m");
      function build_mulNR12() {
        const f2 = module3.addFunction(prefix + "_mulNR12");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(
            f2mPrefix + "_mul",
            c2.i32_const(pNonResidueF6),
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8 * 4)),
            c2.getLocal("pr")
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.getLocal("x"),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8 * 2)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 4))
          )
        );
      }
      build_mulNR12();
      const ftmPrefix = buildF2m(module3, prefix + "_mulNR12", "ftm", f6mPrefix);
      const ateLoopCount = 29793968203157093288n;
      const ateLoopBitBytes = bits3(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = false;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b3) => acc + (b3 != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8;
      const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = false;
      module3.modules[prefix] = {
        n64,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        prePSize,
        preQSize,
        r: r2.toString(),
        q: q.toString()
      };
      const finalExpZ = 4965661367192848881n;
      function naf2(n3) {
        let E = n3;
        const res = [];
        while (E > 0n) {
          if (isOdd3(E)) {
            const z2 = 2 - Number(E % 4n);
            res.push(z2);
            E = E - BigInt(z2);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits3(n3) {
        let E = n3;
        const res = [];
        while (E > 0n) {
          if (isOdd3(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f2 = module3.addFunction(prefix + "_prepareG1");
        f2.addParam("pP", "i32");
        f2.addParam("ppreP", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(g1mPrefix + "_normalize", c2.getLocal("pP"), c2.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepAddStep() {
        const f2 = module3.addFunction(prefix + "_prepAddStep");
        f2.addParam("pQ", "i32");
        f2.addParam("pR", "i32");
        f2.addParam("pCoef", "i32");
        const c2 = f2.getCodeBuilder();
        const X2 = c2.getLocal("pQ");
        const Y2 = c2.i32_add(c2.getLocal("pQ"), c2.i32_const(f2size));
        const X1 = c2.getLocal("pR");
        const Y1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f2size));
        const Z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * f2size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const D = ELL_VW;
        const E = c2.i32_const(module3.alloc(f2size));
        const F = c2.i32_const(module3.alloc(f2size));
        const G = c2.i32_const(module3.alloc(f2size));
        const H = c2.i32_const(module3.alloc(f2size));
        const I = c2.i32_const(module3.alloc(f2size));
        const J = c2.i32_const(module3.alloc(f2size));
        const AUX = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          // D = X1 - X2*Z1
          c2.call(f2mPrefix + "_mul", X2, Z1, D),
          c2.call(f2mPrefix + "_sub", X1, D, D),
          // E = Y1 - Y2*Z1
          c2.call(f2mPrefix + "_mul", Y2, Z1, E),
          c2.call(f2mPrefix + "_sub", Y1, E, E),
          // F = D^2
          c2.call(f2mPrefix + "_square", D, F),
          // G = E^2
          c2.call(f2mPrefix + "_square", E, G),
          // H = D*F
          c2.call(f2mPrefix + "_mul", D, F, H),
          // I = X1 * F
          c2.call(f2mPrefix + "_mul", X1, F, I),
          // J = H + Z1*G - (I+I)
          c2.call(f2mPrefix + "_add", I, I, AUX),
          c2.call(f2mPrefix + "_mul", Z1, G, J),
          c2.call(f2mPrefix + "_add", H, J, J),
          c2.call(f2mPrefix + "_sub", J, AUX, J),
          // X3 (X1) = D*J
          c2.call(f2mPrefix + "_mul", D, J, X1),
          // Y3 (Y1) = E*(I-J)-(H*Y1)
          c2.call(f2mPrefix + "_mul", H, Y1, Y1),
          c2.call(f2mPrefix + "_sub", I, J, AUX),
          c2.call(f2mPrefix + "_mul", E, AUX, AUX),
          c2.call(f2mPrefix + "_sub", AUX, Y1, Y1),
          // Z3 (Z1) = Z1*H
          c2.call(f2mPrefix + "_mul", Z1, H, Z1),
          // ell_0 = xi * (E * X2 - D * Y2)
          c2.call(f2mPrefix + "_mul", D, Y2, AUX),
          c2.call(f2mPrefix + "_mul", E, X2, ELL_0),
          c2.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
          c2.call(f2mPrefix + "_mul", ELL_0, c2.i32_const(pAltBn128Twist), ELL_0),
          // ell_VV = - E (later: * xP)
          c2.call(f2mPrefix + "_neg", E, ELL_VV)
          // ell_VW = D (later: * yP    )
          // Already assigned
        );
      }
      function buildPrepDoubleStep() {
        const f2 = module3.addFunction(prefix + "_prepDblStep");
        f2.addParam("pR", "i32");
        f2.addParam("pCoef", "i32");
        const c2 = f2.getCodeBuilder();
        const X1 = c2.getLocal("pR");
        const Y1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f2size));
        const Z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * f2size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const A = c2.i32_const(module3.alloc(f2size));
        const B = c2.i32_const(module3.alloc(f2size));
        const C = c2.i32_const(module3.alloc(f2size));
        const D = c2.i32_const(module3.alloc(f2size));
        const E = c2.i32_const(module3.alloc(f2size));
        const F = c2.i32_const(module3.alloc(f2size));
        const G = c2.i32_const(module3.alloc(f2size));
        const H = c2.i32_const(module3.alloc(f2size));
        const I = c2.i32_const(module3.alloc(f2size));
        const J = c2.i32_const(module3.alloc(f2size));
        const E2 = c2.i32_const(module3.alloc(f2size));
        const AUX = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          // A = X1 * Y1 / 2
          c2.call(f2mPrefix + "_mul", Y1, c2.i32_const(pTwoInv), A),
          c2.call(f2mPrefix + "_mul", X1, A, A),
          // B = Y1^2
          c2.call(f2mPrefix + "_square", Y1, B),
          // C = Z1^2
          c2.call(f2mPrefix + "_square", Z1, C),
          // D = 3 * C
          c2.call(f2mPrefix + "_add", C, C, D),
          c2.call(f2mPrefix + "_add", D, C, D),
          // E = twist_b * D
          c2.call(f2mPrefix + "_mul", c2.i32_const(pTwistCoefB), D, E),
          // F = 3 * E
          c2.call(f2mPrefix + "_add", E, E, F),
          c2.call(f2mPrefix + "_add", E, F, F),
          // G = (B+F)/2
          c2.call(f2mPrefix + "_add", B, F, G),
          c2.call(f2mPrefix + "_mul", G, c2.i32_const(pTwoInv), G),
          // H = (Y1+Z1)^2-(B+C)
          c2.call(f2mPrefix + "_add", B, C, AUX),
          c2.call(f2mPrefix + "_add", Y1, Z1, H),
          c2.call(f2mPrefix + "_square", H, H),
          c2.call(f2mPrefix + "_sub", H, AUX, H),
          // I = E-B
          c2.call(f2mPrefix + "_sub", E, B, I),
          // J = X1^2
          c2.call(f2mPrefix + "_square", X1, J),
          // E_squared = E^2
          c2.call(f2mPrefix + "_square", E, E2),
          // X3 (X1) = A * (B-F)
          c2.call(f2mPrefix + "_sub", B, F, AUX),
          c2.call(f2mPrefix + "_mul", A, AUX, X1),
          // Y3 (Y1) = G^2 - 3*E^2
          c2.call(f2mPrefix + "_add", E2, E2, AUX),
          c2.call(f2mPrefix + "_add", E2, AUX, AUX),
          c2.call(f2mPrefix + "_square", G, Y1),
          c2.call(f2mPrefix + "_sub", Y1, AUX, Y1),
          // Z3 (Z1) = B * H
          c2.call(f2mPrefix + "_mul", B, H, Z1),
          // ell_0 = xi * I
          c2.call(f2mPrefix + "_mul", c2.i32_const(pAltBn128Twist), I, ELL_0),
          // ell_VW = - H (later: * yP)
          c2.call(f2mPrefix + "_neg", H, ELL_VW),
          // ell_VV = 3*J (later: * xP)
          c2.call(f2mPrefix + "_add", J, J, ELL_VV),
          c2.call(f2mPrefix + "_add", J, ELL_VV, ELL_VV)
        );
      }
      function buildMulByQ() {
        const f2 = module3.addFunction(prefix + "_mulByQ");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("p1");
        const y = c2.i32_add(c2.getLocal("p1"), c2.i32_const(f2size));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(f2size * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f2size));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f2size * 2));
        const MulByQX = c2.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
        ]));
        const MulByQY = c2.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
        ]));
        f2.addCode(
          // The frobeniusMap(1) in this field, is the conjugate
          c2.call(f2mPrefix + "_conjugate", x, x3),
          c2.call(f2mPrefix + "_mul", MulByQX, x3, x3),
          c2.call(f2mPrefix + "_conjugate", y, y3),
          c2.call(f2mPrefix + "_mul", MulByQY, y3, y3),
          c2.call(f2mPrefix + "_conjugate", z2, z3)
        );
      }
      function buildPrepareG2() {
        buildMulByQ();
        const f2 = module3.addFunction(prefix + "_prepareG2");
        f2.addParam("pQ", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const QX = c2.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c2.i32_const(pR);
        const RX = c2.i32_const(pR);
        const RY = c2.i32_const(pR + f2size);
        const RZ = c2.i32_const(pR + 2 * f2size);
        const cQX = c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(0));
        const cQY = c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size));
        const pQ1 = module3.alloc(f2size * 3);
        const Q1 = c2.i32_const(pQ1);
        const pQ2 = module3.alloc(f2size * 3);
        const Q2 = c2.i32_const(pQ2);
        const Q2Y = c2.i32_const(pQ2 + f2size);
        f2.addCode(
          c2.call(g2mPrefix + "_normalize", QX, cQX),
          // TODO Remove if already in affine
          c2.call(f2mPrefix + "_copy", cQX, RX),
          c2.call(f2mPrefix + "_copy", cQY, RY),
          c2.call(f2mPrefix + "_one", RZ)
        );
        f2.addCode(
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix + "_prepDblStep", R, c2.getLocal("pCoef")),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix + "_prepAddStep", cQX, R, c2.getLocal("pCoef")),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        f2.addCode(
          c2.call(prefix + "_mulByQ", cQX, Q1),
          c2.call(prefix + "_mulByQ", Q1, Q2)
        );
        if (isLoopNegative) {
          f2.addCode(
            c2.call(f2mPrefix + "_neg", RY, RY)
          );
        }
        f2.addCode(
          c2.call(f2mPrefix + "_neg", Q2Y, Q2Y),
          c2.call(prefix + "_prepAddStep", Q1, R, c2.getLocal("pCoef")),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
          c2.call(prefix + "_prepAddStep", Q2, R, c2.getLocal("pCoef")),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
        );
      }
      function buildMulBy024Old() {
        const f2 = module3.addFunction(prefix + "__mulBy024Old");
        f2.addParam("pEll0", "i32");
        f2.addParam("pEllVW", "i32");
        f2.addParam("pEllVV", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("pEll0");
        const x2 = c2.getLocal("pEllVV");
        const x4 = c2.getLocal("pEllVW");
        const z0 = c2.getLocal("pR");
        const pAUX12 = module3.alloc(ftsize);
        const AUX12 = c2.i32_const(pAUX12);
        const AUX12_0 = c2.i32_const(pAUX12);
        const AUX12_2 = c2.i32_const(pAUX12 + f2size);
        const AUX12_4 = c2.i32_const(pAUX12 + f2size * 2);
        const AUX12_6 = c2.i32_const(pAUX12 + f2size * 3);
        const AUX12_8 = c2.i32_const(pAUX12 + f2size * 4);
        const AUX12_10 = c2.i32_const(pAUX12 + f2size * 5);
        f2.addCode(
          c2.call(f2mPrefix + "_copy", x0, AUX12_0),
          c2.call(f2mPrefix + "_zero", AUX12_2),
          c2.call(f2mPrefix + "_copy", x2, AUX12_4),
          c2.call(f2mPrefix + "_zero", AUX12_6),
          c2.call(f2mPrefix + "_copy", x4, AUX12_8),
          c2.call(f2mPrefix + "_zero", AUX12_10),
          c2.call(ftmPrefix + "_mul", AUX12, z0, z0)
        );
      }
      function buildMulBy024() {
        const f2 = module3.addFunction(prefix + "__mulBy024");
        f2.addParam("pEll0", "i32");
        f2.addParam("pEllVW", "i32");
        f2.addParam("pEllVV", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("pEll0");
        const x2 = c2.getLocal("pEllVV");
        const x4 = c2.getLocal("pEllVW");
        const z0 = c2.getLocal("pR");
        const z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * n8));
        const z2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(4 * n8));
        const z3 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(6 * n8));
        const z4 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(8 * n8));
        const z5 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(10 * n8));
        const t0 = c2.i32_const(module3.alloc(f2size));
        const t1 = c2.i32_const(module3.alloc(f2size));
        const t2 = c2.i32_const(module3.alloc(f2size));
        const s0 = c2.i32_const(module3.alloc(f2size));
        const T32 = c2.i32_const(module3.alloc(f2size));
        const T42 = c2.i32_const(module3.alloc(f2size));
        const D0 = c2.i32_const(module3.alloc(f2size));
        const D2 = c2.i32_const(module3.alloc(f2size));
        const D4 = c2.i32_const(module3.alloc(f2size));
        const S12 = c2.i32_const(module3.alloc(f2size));
        const AUX = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          // D0 = z0 * x0;
          c2.call(f2mPrefix + "_mul", z0, x0, D0),
          // D2 = z2 * x2;
          c2.call(f2mPrefix + "_mul", z2, x2, D2),
          // D4 = z4 * x4;
          c2.call(f2mPrefix + "_mul", z4, x4, D4),
          // t2 = z0 + z4;
          c2.call(f2mPrefix + "_add", z0, z4, t2),
          // t1 = z0 + z2;
          c2.call(f2mPrefix + "_add", z0, z2, t1),
          // s0 = z1 + z3 + z5;
          c2.call(f2mPrefix + "_add", z1, z3, s0),
          c2.call(f2mPrefix + "_add", s0, z5, s0),
          // For z.a_.a_ = z0.
          // S1 = z1 * x2;
          c2.call(f2mPrefix + "_mul", z1, x2, S12),
          // T3 = S1 + D4;
          c2.call(f2mPrefix + "_add", S12, D4, T32),
          // T4 = my_Fp6::non_residue * T3 + D0;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T32, T42),
          c2.call(f2mPrefix + "_add", T42, D0, z0),
          // z0 = T4;
          // For z.a_.b_ = z1
          // T3 = z5 * x4;
          c2.call(f2mPrefix + "_mul", z5, x4, T32),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S12, T32, S12),
          // T3 = T3 + D2;
          c2.call(f2mPrefix + "_add", T32, D2, T32),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T32, T42),
          // T3 = z1 * x0;
          c2.call(f2mPrefix + "_mul", z1, x0, T32),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S12, T32, S12),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T42, T32, z1),
          // z1 = T4;
          // For z.a_.c_ = z2
          // t0 = x0 + x2;
          c2.call(f2mPrefix + "_add", x0, x2, t0),
          // T3 = t1 * t0 - D0 - D2;
          c2.call(f2mPrefix + "_mul", t1, t0, T32),
          c2.call(f2mPrefix + "_add", D0, D2, AUX),
          c2.call(f2mPrefix + "_sub", T32, AUX, T32),
          // T4 = z3 * x4;
          c2.call(f2mPrefix + "_mul", z3, x4, T42),
          // S1 = S1 + T4;
          c2.call(f2mPrefix + "_add", S12, T42, S12),
          // For z.b_.a_ = z3 (z3 needs z2)
          // t0 = z2 + z4;
          c2.call(f2mPrefix + "_add", z2, z4, t0),
          // T3 = T3 + T4;
          // z2 = T3;
          c2.call(f2mPrefix + "_add", T32, T42, z2),
          // t1 = x2 + x4;
          c2.call(f2mPrefix + "_add", x2, x4, t1),
          // T3 = t0 * t1 - D2 - D4;
          c2.call(f2mPrefix + "_mul", t1, t0, T32),
          c2.call(f2mPrefix + "_add", D2, D4, AUX),
          c2.call(f2mPrefix + "_sub", T32, AUX, T32),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T32, T42),
          // T3 = z3 * x0;
          c2.call(f2mPrefix + "_mul", z3, x0, T32),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S12, T32, S12),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T42, T32, z3),
          // z3 = T4;
          // For z.b_.b_ = z4
          // T3 = z5 * x2;
          c2.call(f2mPrefix + "_mul", z5, x2, T32),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S12, T32, S12),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T32, T42),
          // t0 = x0 + x4;
          c2.call(f2mPrefix + "_add", x0, x4, t0),
          // T3 = t2 * t0 - D0 - D4;
          c2.call(f2mPrefix + "_mul", t2, t0, T32),
          c2.call(f2mPrefix + "_add", D0, D4, AUX),
          c2.call(f2mPrefix + "_sub", T32, AUX, T32),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T42, T32, z4),
          // z4 = T4;
          // For z.b_.c_ = z5.
          // t0 = x0 + x2 + x4;
          c2.call(f2mPrefix + "_add", x0, x2, t0),
          c2.call(f2mPrefix + "_add", t0, x4, t0),
          // T3 = s0 * t0 - S1;
          c2.call(f2mPrefix + "_mul", s0, t0, T32),
          c2.call(f2mPrefix + "_sub", T32, S12, z5)
          // z5 = T3;
        );
      }
      function buildMillerLoop() {
        const f2 = module3.addFunction(prefix + "_millerLoop");
        f2.addParam("ppreP", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const preP_PX = c2.getLocal("ppreP");
        const preP_PY = c2.i32_add(c2.getLocal("ppreP"), c2.i32_const(f1size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const pVW = module3.alloc(f2size);
        const VW = c2.i32_const(pVW);
        const pVV = module3.alloc(f2size);
        const VV = c2.i32_const(pVV);
        const F = c2.getLocal("r");
        f2.addCode(
          c2.call(ftmPrefix + "_one", F),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(ftmPrefix + "_square", F, F),
            c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
            c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
            c2.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
                ...c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
                ...c2.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        if (isLoopNegative) {
          f2.addCode(
            c2.call(ftmPrefix + "_inverse", F, F)
          );
        }
        f2.addCode(
          c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c2.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
          c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c2.call(prefix + "__mulBy024", ELL_0, VW, VV, F),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
        );
      }
      function buildFrobeniusMap(n3) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
            [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
            [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
            [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
            [2203960485148121921418603742825762020974279258880205651967n, 0n],
            [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
          ],
          [
            [1n, 0n],
            [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
          ]
        ];
        const f2 = module3.addFunction(prefix + "__frobeniusMap" + n3);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c2.getLocal("x") : c2.i32_add(c2.getLocal("x"), c2.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(i * f2size + f1size));
          const R = i == 0 ? c2.getLocal("r") : c2.i32_add(c2.getLocal("r"), c2.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n3 % 12], F6[i % 3][n3 % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
          ]);
          if (n3 % 2 == 1) {
            f2.addCode(
              c2.call(f1mPrefix + "_copy", Xc0, Rc0),
              c2.call(f1mPrefix + "_neg", Xc1, Rc1),
              c2.call(f2mPrefix + "_mul", R, c2.i32_const(pCoef), R)
            );
          } else {
            f2.addCode(c2.call(f2mPrefix + "_mul", X, c2.i32_const(pCoef), R));
          }
        }
        function mul22(a2, b3) {
          const ac0 = BigInt(a2[0]);
          const ac1 = BigInt(a2[1]);
          const bc0 = BigInt(b3[0]);
          const bc1 = BigInt(b3[1]);
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative3(res[0])) res[0] = res[0] + q;
          return res;
        }
      }
      function buildFinalExponentiationFirstChunk() {
        const f2 = module3.addFunction(prefix + "__finalExponentiationFirstChunk");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const eltC0 = elt;
        const eltC1 = c2.i32_add(elt, c2.i32_const(n8 * 6));
        const r3 = c2.getLocal("r");
        const pA = module3.alloc(ftsize);
        const A = c2.i32_const(pA);
        const Ac0 = A;
        const Ac1 = c2.i32_const(pA + n8 * 6);
        const B = c2.i32_const(module3.alloc(ftsize));
        const C = c2.i32_const(module3.alloc(ftsize));
        const D = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);
          c2.call(f6mPrefix + "_copy", eltC0, Ac0),
          c2.call(f6mPrefix + "_neg", eltC1, Ac1),
          // const alt_bn128_Fq12 B = elt.inverse();
          c2.call(ftmPrefix + "_inverse", elt, B),
          // const alt_bn128_Fq12 C = A * B;
          c2.call(ftmPrefix + "_mul", A, B, C),
          // const alt_bn128_Fq12 D = C.Frobenius_map(2);
          c2.call(prefix + "__frobeniusMap2", C, D),
          // const alt_bn128_Fq12 result = D * C;
          c2.call(ftmPrefix + "_mul", C, D, r3)
        );
      }
      function buildCyclotomicSquare() {
        const f2 = module3.addFunction(prefix + "__cyclotomicSquare");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x4 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f2size));
        const x3 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f2size));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(3 * f2size));
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(4 * f2size));
        const x5 = c2.i32_add(c2.getLocal("x"), c2.i32_const(5 * f2size));
        const r0 = c2.getLocal("r");
        const r4 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f2size));
        const r3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f2size));
        const r22 = c2.i32_add(c2.getLocal("r"), c2.i32_const(3 * f2size));
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * f2size));
        const r5 = c2.i32_add(c2.getLocal("r"), c2.i32_const(5 * f2size));
        const t0 = c2.i32_const(module3.alloc(f2size));
        const t1 = c2.i32_const(module3.alloc(f2size));
        const t2 = c2.i32_const(module3.alloc(f2size));
        const t3 = c2.i32_const(module3.alloc(f2size));
        const t4 = c2.i32_const(module3.alloc(f2size));
        const t5 = c2.i32_const(module3.alloc(f2size));
        const tmp = c2.i32_const(module3.alloc(f2size));
        const AUX = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x0, x1, tmp),
          c2.call(f2mPrefix + "_mul", x1, c2.i32_const(pNonResidueF6), t0),
          c2.call(f2mPrefix + "_add", x0, t0, t0),
          c2.call(f2mPrefix + "_add", x0, x1, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t0, t0),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t0, AUX, t0),
          c2.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x2, x3, tmp),
          c2.call(f2mPrefix + "_mul", x3, c2.i32_const(pNonResidueF6), t2),
          c2.call(f2mPrefix + "_add", x2, t2, t2),
          c2.call(f2mPrefix + "_add", x2, x3, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t2, t2),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t2, AUX, t2),
          c2.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x4, x5, tmp),
          c2.call(f2mPrefix + "_mul", x5, c2.i32_const(pNonResidueF6), t4),
          c2.call(f2mPrefix + "_add", x4, t4, t4),
          c2.call(f2mPrefix + "_add", x4, x5, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t4, t4),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t4, AUX, t4),
          c2.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c2.call(f2mPrefix + "_sub", t0, x0, r0),
          c2.call(f2mPrefix + "_add", r0, r0, r0),
          c2.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c2.call(f2mPrefix + "_add", t1, x1, r1),
          c2.call(f2mPrefix + "_add", r1, r1, r1),
          c2.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c2.call(f2mPrefix + "_mul", t5, c2.i32_const(pAltBn128Twist), AUX),
          c2.call(f2mPrefix + "_add", AUX, x2, r22),
          c2.call(f2mPrefix + "_add", r22, r22, r22),
          c2.call(f2mPrefix + "_add", AUX, r22, r22),
          // z3 = 3 * t4 - 2 * z3
          c2.call(f2mPrefix + "_sub", t4, x3, r3),
          c2.call(f2mPrefix + "_add", r3, r3, r3),
          c2.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c2.call(f2mPrefix + "_sub", t2, x4, r4),
          c2.call(f2mPrefix + "_add", r4, r4, r4),
          c2.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c2.call(f2mPrefix + "_add", t3, x5, r5),
          c2.call(f2mPrefix + "_add", r5, r5, r5),
          c2.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf2(exponent).map((b3) => b3 == -1 ? 255 : b3);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f2 = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("bit", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("x");
        const res = c2.getLocal("r");
        const inverse = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          c2.call(ftmPrefix + "_conjugate", x, inverse),
          c2.call(ftmPrefix + "_one", res),
          c2.if(
            c2.teeLocal("bit", c2.i32_load8_s(c2.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c2.if(
              c2.i32_eq(
                c2.getLocal("bit"),
                c2.i32_const(1)
              ),
              c2.call(ftmPrefix + "_mul", res, x, res),
              c2.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c2.setLocal("i", c2.i32_const(exponentNafBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix + "__cyclotomicSquare", res, res),
            c2.if(
              c2.teeLocal("bit", c2.i32_load8_s(c2.getLocal("i"), pExponentNafBytes)),
              c2.if(
                c2.i32_eq(
                  c2.getLocal("bit"),
                  c2.i32_const(1)
                ),
                c2.call(ftmPrefix + "_mul", res, x, res),
                c2.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFinalExponentiationLastChunk() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, "w0");
        const f2 = module3.addFunction(prefix + "__finalExponentiationLastChunk");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const result = c2.getLocal("r");
        const A = c2.i32_const(module3.alloc(ftsize));
        const B = c2.i32_const(module3.alloc(ftsize));
        const C = c2.i32_const(module3.alloc(ftsize));
        const D = c2.i32_const(module3.alloc(ftsize));
        const E = c2.i32_const(module3.alloc(ftsize));
        const F = c2.i32_const(module3.alloc(ftsize));
        const G = c2.i32_const(module3.alloc(ftsize));
        const H = c2.i32_const(module3.alloc(ftsize));
        const I = c2.i32_const(module3.alloc(ftsize));
        const J = c2.i32_const(module3.alloc(ftsize));
        const K = c2.i32_const(module3.alloc(ftsize));
        const L = c2.i32_const(module3.alloc(ftsize));
        const M = c2.i32_const(module3.alloc(ftsize));
        const N3 = c2.i32_const(module3.alloc(ftsize));
        const O = c2.i32_const(module3.alloc(ftsize));
        const P = c2.i32_const(module3.alloc(ftsize));
        const Q = c2.i32_const(module3.alloc(ftsize));
        const R = c2.i32_const(module3.alloc(ftsize));
        const S2 = c2.i32_const(module3.alloc(ftsize));
        const T = c2.i32_const(module3.alloc(ftsize));
        const U = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          // A = exp_by_neg_z(elt)  // = elt^(-z)
          c2.call(prefix + "__cyclotomicExp_w0", elt, A),
          finalExpIsNegative ? [] : c2.call(ftmPrefix + "_conjugate", A, A),
          // B = A^2                // = elt^(-2*z)
          c2.call(prefix + "__cyclotomicSquare", A, B),
          // C = B^2                // = elt^(-4*z)
          c2.call(prefix + "__cyclotomicSquare", B, C),
          // D = C * B              // = elt^(-6*z)
          c2.call(ftmPrefix + "_mul", C, B, D),
          // E = exp_by_neg_z(D)    // = elt^(6*z^2)
          c2.call(prefix + "__cyclotomicExp_w0", D, E),
          finalExpIsNegative ? [] : c2.call(ftmPrefix + "_conjugate", E, E),
          // F = E^2                // = elt^(12*z^2)
          c2.call(prefix + "__cyclotomicSquare", E, F),
          // G = epx_by_neg_z(F)    // = elt^(-12*z^3)
          c2.call(prefix + "__cyclotomicExp_w0", F, G),
          finalExpIsNegative ? [] : c2.call(ftmPrefix + "_conjugate", G, G),
          // H = conj(D)            // = elt^(6*z)
          c2.call(ftmPrefix + "_conjugate", D, H),
          // I = conj(G)            // = elt^(12*z^3)
          c2.call(ftmPrefix + "_conjugate", G, I),
          // J = I * E              // = elt^(12*z^3 + 6*z^2)
          c2.call(ftmPrefix + "_mul", I, E, J),
          // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)
          c2.call(ftmPrefix + "_mul", J, H, K),
          // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)
          c2.call(ftmPrefix + "_mul", K, B, L),
          // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)
          c2.call(ftmPrefix + "_mul", K, E, M),
          // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)
          c2.call(ftmPrefix + "_mul", M, elt, N3),
          // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))
          c2.call(prefix + "__frobeniusMap1", L, O),
          // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", O, N3, P),
          // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))
          c2.call(prefix + "__frobeniusMap2", K, Q),
          // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", Q, P, R),
          // S = conj(elt)          // = elt^(-1)
          c2.call(ftmPrefix + "_conjugate", elt, S2),
          // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)
          c2.call(ftmPrefix + "_mul", S2, L, T),
          // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))
          c2.call(prefix + "__frobeniusMap3", T, U),
          // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", U, R, result)
          // result = V
        );
      }
      function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f2 = module3.addFunction(prefix + "_finalExponentiation");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const result = c2.getLocal("r");
        const eltToFirstChunk = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          c2.call(prefix + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
          c2.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result)
        );
      }
      function buildFinalExponentiationOld() {
        const f2 = module3.addFunction(prefix + "_finalExponentiationOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 352));
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(ftmPrefix + "_exp", c2.getLocal("x"), c2.i32_const(pExponent), c2.i32_const(352), c2.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f2 = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f2.addParam("p_" + i, "i32");
          f2.addParam("q_" + i, "i32");
        }
        f2.addParam("c", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module3.alloc(ftsize));
        const auxT = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(c2.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f2.addCode(c2.call(prefix + "_prepareG1", c2.getLocal("p_" + i), c2.i32_const(pPreP)));
          f2.addCode(c2.call(prefix + "_prepareG2", c2.getLocal("q_" + i), c2.i32_const(pPreQ)));
          f2.addCode(c2.call(prefix + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), auxT));
          f2.addCode(c2.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f2.addCode(c2.call(prefix + "_finalExponentiation", resT, resT));
        f2.addCode(c2.call(ftmPrefix + "_eq", resT, c2.getLocal("c")));
      }
      function buildPairing2() {
        const f2 = module3.addFunction(prefix + "_pairing");
        f2.addParam("p", "i32");
        f2.addParam("q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(c2.call(prefix + "_prepareG1", c2.getLocal("p"), c2.i32_const(pPreP)));
        f2.addCode(c2.call(prefix + "_prepareG2", c2.getLocal("q"), c2.i32_const(pPreQ)));
        f2.addCode(c2.call(prefix + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), resT));
        f2.addCode(c2.call(prefix + "_finalExponentiation", resT, c2.getLocal("r")));
      }
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMulBy024();
      buildMulBy024Old();
      buildMillerLoop();
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(prefix + "__frobeniusMap" + i);
      }
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing2();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__mulBy024");
      module3.exportFunction(prefix + "__mulBy024Old");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bls12381/build_bls12381.js
var require_build_bls12381 = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/src/bls12381/build_bls12381.js"(exports2, module2) {
    var utils2 = require_utils3();
    var buildF1m = require_build_f1m();
    var buildF1 = require_build_f1();
    var buildF2m = require_build_f2m();
    var buildF3m = require_build_f3m();
    var buildCurve = require_build_curve_jacobian_a0();
    var buildFFT2 = require_build_fft();
    var buildPol = require_build_pol();
    var buildQAP = require_build_qap();
    var buildApplyKey = require_build_applykey();
    var { bitLength: bitLength3, isOdd: isOdd3, isNegative: isNegative3 } = require_bigint();
    module2.exports = function buildBLS12381(module3, _prefix) {
      const prefix = _prefix || "bls12381";
      if (module3.modules[prefix]) return prefix;
      const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      const r2 = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
      const n64q = Math.floor((bitLength3(q - 1n) - 1) / 64) + 1;
      const n8q = n64q * 8;
      const f1size = n8q;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const n64r = Math.floor((bitLength3(r2 - 1n) - 1) / 64) + 1;
      const n8r = n64r * 8;
      const frsize = n8r;
      const pr = module3.alloc(utils2.bigInt2BytesLE(r2, frsize));
      const f1mPrefix = buildF1m(module3, q, "f1m", "intq");
      buildF1(module3, r2, "fr", "frm", "intr");
      const pG1b = module3.alloc(utils2.bigInt2BytesLE(toMontgomery(4n), f1size));
      const g1mPrefix = buildCurve(module3, "g1m", "f1m", pG1b);
      buildFFT2(module3, "frm", "frm", "frm", "frm_mul");
      buildPol(module3, "pol", "frm");
      buildQAP(module3, "qap", "frm");
      const f2mPrefix = buildF2m(module3, "f1m_neg", "f2m", "f1m");
      const pG2b = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(4n), f1size)
      ]);
      const g2mPrefix = buildCurve(module3, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f2 = module3.addFunction(fnName);
        f2.addParam("pG", "i32");
        f2.addParam("pFr", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module3.alloc(n8r));
        f2.addCode(
          c2.call("frm_fromMontgomery", c2.getLocal("pFr"), AUX),
          c2.call(
            opMul,
            c2.getLocal("pG"),
            AUX,
            c2.i32_const(n8r),
            c2.getLocal("pr")
          )
        );
        module3.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT2(module3, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT2(module3, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey(module3, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
      buildApplyKey(module3, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
      buildApplyKey(module3, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
      buildApplyKey(module3, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
      buildApplyKey(module3, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
      function toMontgomery(a2) {
        return BigInt(a2) * (1n << BigInt(f1size * 8)) % q;
      }
      const G1gen = [
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
        1n
      ];
      const pG1gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
          3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
        ],
        [
          1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
          927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module3.alloc(
        [
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(0n), f1size)
      ]);
      const pBls12381Twist = module3.alloc([
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils2.bigInt2BytesLE(toMontgomery(1n), f1size)
      ]);
      function build_mulNR2() {
        const f2 = module3.addFunction(f2mPrefix + "_mulNR");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x0c = c2.i32_const(module3.alloc(f1size));
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1size));
        const r0 = c2.getLocal("pr");
        const r1 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f1size));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, x0c),
          c2.call(f1mPrefix + "_sub", x0, x1, r0),
          c2.call(f1mPrefix + "_add", x0c, x1, r1)
        );
      }
      build_mulNR2();
      const f6mPrefix = buildF3m(module3, f2mPrefix + "_mulNR", "f6m", "f2m");
      function build_mulNR6() {
        const f2 = module3.addFunction(f6mPrefix + "_mulNR");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const c0copy = c2.i32_const(module3.alloc(f1size * 2));
        f2.addCode(
          c2.call(
            f2mPrefix + "_copy",
            c2.getLocal("x"),
            c0copy
          ),
          c2.call(
            f2mPrefix + "_mulNR",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8q * 4)),
            c2.getLocal("pr")
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8q * 2)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8q * 4))
          ),
          c2.call(
            f2mPrefix + "_copy",
            c0copy,
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8q * 2))
          )
        );
      }
      build_mulNR6();
      const ftmPrefix = buildF2m(module3, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
      const ateLoopCount = 0xd201000000010000n;
      const ateLoopBitBytes = bits3(ateLoopCount);
      const pAteLoopBitBytes = module3.alloc(ateLoopBitBytes);
      const isLoopNegative = true;
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b3) => acc + (b3 != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8q;
      const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = true;
      const finalExpZ = 15132376222941642752n;
      module3.modules[prefix] = {
        n64q,
        n64r,
        n8q,
        n8r,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module3.modules["f1m"].pq,
        pr,
        pOneT,
        r: r2,
        q,
        prePSize,
        preQSize
      };
      function naf2(n3) {
        let E = n3;
        const res = [];
        while (E > 0n) {
          if (isOdd3(E)) {
            const z2 = 2 - Number(E % 4n);
            res.push(z2);
            E = E - BigInt(z2);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function bits3(n3) {
        let E = n3;
        const res = [];
        while (E > 0n) {
          if (isOdd3(E)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E = E >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f2 = module3.addFunction(prefix + "_prepareG1");
        f2.addParam("pP", "i32");
        f2.addParam("ppreP", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(g1mPrefix + "_normalize", c2.getLocal("pP"), c2.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepDoubleStep() {
        const f2 = module3.addFunction(prefix + "_prepDblStep");
        f2.addParam("R", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const Rx = c2.getLocal("R");
        const Ry = c2.i32_add(c2.getLocal("R"), c2.i32_const(2 * n8q));
        const Rz = c2.i32_add(c2.getLocal("R"), c2.i32_const(4 * n8q));
        const t0 = c2.getLocal("r");
        const t3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * n8q));
        const t6 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * n8q));
        const zsquared = c2.i32_const(module3.alloc(f2size));
        const t1 = c2.i32_const(module3.alloc(f2size));
        const t2 = c2.i32_const(module3.alloc(f2size));
        const t4 = c2.i32_const(module3.alloc(f2size));
        const t5 = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          // tmp0 = r.x.square();
          c2.call(f2mPrefix + "_square", Rx, t0),
          // tmp1 = r.y.square();
          c2.call(f2mPrefix + "_square", Ry, t1),
          // tmp2 = tmp1.square();
          c2.call(f2mPrefix + "_square", t1, t2),
          // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;
          c2.call(f2mPrefix + "_add", t1, Rx, t3),
          c2.call(f2mPrefix + "_square", t3, t3),
          c2.call(f2mPrefix + "_sub", t3, t0, t3),
          c2.call(f2mPrefix + "_sub", t3, t2, t3),
          // tmp3 = tmp3 + tmp3;
          c2.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp4 = tmp0 + tmp0 + tmp0;
          c2.call(f2mPrefix + "_add", t0, t0, t4),
          c2.call(f2mPrefix + "_add", t4, t0, t4),
          // tmp6 = r.x + tmp4;
          c2.call(f2mPrefix + "_add", Rx, t4, t6),
          // tmp5 = tmp4.square();
          c2.call(f2mPrefix + "_square", t4, t5),
          // zsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, zsquared),
          // r.x = tmp5 - tmp3 - tmp3;
          c2.call(f2mPrefix + "_sub", t5, t3, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t3, Rx),
          // r.z = (r.z + r.y).square() - tmp1 - zsquared;
          c2.call(f2mPrefix + "_add", Rz, Ry, Rz),
          c2.call(f2mPrefix + "_square", Rz, Rz),
          c2.call(f2mPrefix + "_sub", Rz, t1, Rz),
          c2.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          // r.y = (tmp3 - r.x) * tmp4;
          c2.call(f2mPrefix + "_sub", t3, Rx, Ry),
          c2.call(f2mPrefix + "_mul", Ry, t4, Ry),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // r.y -= tmp2;
          c2.call(f2mPrefix + "_sub", Ry, t2, Ry),
          // tmp3 = tmp4 * zsquared;
          c2.call(f2mPrefix + "_mul", t4, zsquared, t3),
          // tmp3 = tmp3 + tmp3;
          c2.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp3 = -tmp3;
          c2.call(f2mPrefix + "_neg", t3, t3),
          // tmp6 = tmp6.square() - tmp0 - tmp5;
          c2.call(f2mPrefix + "_square", t6, t6),
          c2.call(f2mPrefix + "_sub", t6, t0, t6),
          c2.call(f2mPrefix + "_sub", t6, t5, t6),
          // tmp1 = tmp1 + tmp1;
          c2.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp1 = tmp1 + tmp1;
          c2.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp6 = tmp6 - tmp1;
          c2.call(f2mPrefix + "_sub", t6, t1, t6),
          // tmp0 = r.z * zsquared;
          c2.call(f2mPrefix + "_mul", Rz, zsquared, t0),
          // tmp0 = tmp0 + tmp0;
          c2.call(f2mPrefix + "_add", t0, t0, t0)
        );
      }
      function buildPrepAddStep() {
        const f2 = module3.addFunction(prefix + "_prepAddStep");
        f2.addParam("R", "i32");
        f2.addParam("Q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const Rx = c2.getLocal("R");
        const Ry = c2.i32_add(c2.getLocal("R"), c2.i32_const(2 * n8q));
        const Rz = c2.i32_add(c2.getLocal("R"), c2.i32_const(4 * n8q));
        const Qx = c2.getLocal("Q");
        const Qy = c2.i32_add(c2.getLocal("Q"), c2.i32_const(2 * n8q));
        const t10 = c2.getLocal("r");
        const t1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * n8q));
        const t9 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * n8q));
        const zsquared = c2.i32_const(module3.alloc(f2size));
        const ysquared = c2.i32_const(module3.alloc(f2size));
        const ztsquared = c2.i32_const(module3.alloc(f2size));
        const t0 = c2.i32_const(module3.alloc(f2size));
        const t2 = c2.i32_const(module3.alloc(f2size));
        const t3 = c2.i32_const(module3.alloc(f2size));
        const t4 = c2.i32_const(module3.alloc(f2size));
        const t5 = c2.i32_const(module3.alloc(f2size));
        const t6 = c2.i32_const(module3.alloc(f2size));
        const t7 = c2.i32_const(module3.alloc(f2size));
        const t8 = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          // zsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, zsquared),
          // ysquared = q.y.square();
          c2.call(f2mPrefix + "_square", Qy, ysquared),
          // t0 = zsquared * q.x;
          c2.call(f2mPrefix + "_mul", zsquared, Qx, t0),
          // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;
          c2.call(f2mPrefix + "_add", Qy, Rz, t1),
          c2.call(f2mPrefix + "_square", t1, t1),
          c2.call(f2mPrefix + "_sub", t1, ysquared, t1),
          c2.call(f2mPrefix + "_sub", t1, zsquared, t1),
          c2.call(f2mPrefix + "_mul", t1, zsquared, t1),
          // t2 = t0 - r.x;
          c2.call(f2mPrefix + "_sub", t0, Rx, t2),
          // t3 = t2.square();
          c2.call(f2mPrefix + "_square", t2, t3),
          // t4 = t3 + t3;
          c2.call(f2mPrefix + "_add", t3, t3, t4),
          // t4 = t4 + t4;
          c2.call(f2mPrefix + "_add", t4, t4, t4),
          // t5 = t4 * t2;
          c2.call(f2mPrefix + "_mul", t4, t2, t5),
          // t6 = t1 - r.y - r.y;
          c2.call(f2mPrefix + "_sub", t1, Ry, t6),
          c2.call(f2mPrefix + "_sub", t6, Ry, t6),
          // t9 = t6 * q.x;
          c2.call(f2mPrefix + "_mul", t6, Qx, t9),
          // t7 = t4 * r.x;
          c2.call(f2mPrefix + "_mul", t4, Rx, t7),
          // r.x = t6.square() - t5 - t7 - t7;
          c2.call(f2mPrefix + "_square", t6, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t5, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t7, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t7, Rx),
          // r.z = (r.z + t2).square() - zsquared - t3;
          c2.call(f2mPrefix + "_add", Rz, t2, Rz),
          c2.call(f2mPrefix + "_square", Rz, Rz),
          c2.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          c2.call(f2mPrefix + "_sub", Rz, t3, Rz),
          // t10 = q.y + r.z;
          c2.call(f2mPrefix + "_add", Qy, Rz, t10),
          // t8 = (t7 - r.x) * t6;
          c2.call(f2mPrefix + "_sub", t7, Rx, t8),
          c2.call(f2mPrefix + "_mul", t8, t6, t8),
          // t0 = r.y * t5;
          c2.call(f2mPrefix + "_mul", Ry, t5, t0),
          // t0 = t0 + t0;
          c2.call(f2mPrefix + "_add", t0, t0, t0),
          // r.y = t8 - t0;
          c2.call(f2mPrefix + "_sub", t8, t0, Ry),
          // t10 = t10.square() - ysquared;
          c2.call(f2mPrefix + "_square", t10, t10),
          c2.call(f2mPrefix + "_sub", t10, ysquared, t10),
          // ztsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, ztsquared),
          // t10 = t10 - ztsquared;
          c2.call(f2mPrefix + "_sub", t10, ztsquared, t10),
          // t9 = t9 + t9 - t10;
          c2.call(f2mPrefix + "_add", t9, t9, t9),
          c2.call(f2mPrefix + "_sub", t9, t10, t9),
          // t10 = r.z + r.z;
          c2.call(f2mPrefix + "_add", Rz, Rz, t10),
          // t6 = -t6;
          c2.call(f2mPrefix + "_neg", t6, t6),
          // t1 = t6 + t6;
          c2.call(f2mPrefix + "_add", t6, t6, t1)
        );
      }
      function buildPrepareG2() {
        const f2 = module3.addFunction(prefix + "_prepareG2");
        f2.addParam("pQ", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const Q = c2.getLocal("pQ");
        const pR = module3.alloc(f2size * 3);
        const R = c2.i32_const(pR);
        const base = c2.getLocal("ppreQ");
        f2.addCode(
          c2.call(g2mPrefix + "_normalize", Q, base),
          c2.if(
            c2.call(g2mPrefix + "_isZero", base),
            c2.ret([])
          ),
          c2.call(g2mPrefix + "_copy", base, R),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3)))
        );
        f2.addCode(
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix + "_prepDblStep", R, c2.getLocal("pCoef")),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix + "_prepAddStep", R, base, c2.getLocal("pCoef")),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildF6Mul1() {
        const f2 = module3.addFunction(f6mPrefix + "_mul1");
        f2.addParam("pA", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 2));
        const A_c2 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 4));
        const c1 = c2.getLocal("pC1");
        const t1 = c2.getLocal("pR");
        const t2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 2));
        const b_b = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 4));
        const Ac0_Ac1 = c2.i32_const(module3.alloc(f1size * 2));
        const Ac1_Ac2 = c2.i32_const(module3.alloc(f1size * 2));
        f2.addCode(
          c2.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c2.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
          // let b_b = self.c1 * c1;
          c2.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c2.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
          c2.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue();
          c2.call(f2mPrefix + "_mulNR", t1, t1),
          // let t2 = (self.c0 + self.c1) * c1 - b_b;
          c2.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
          c2.call(f2mPrefix + "_sub", t2, b_b, t2)
        );
      }
      buildF6Mul1();
      function buildF6Mul01() {
        const f2 = module3.addFunction(f6mPrefix + "_mul01");
        f2.addParam("pA", "i32");
        f2.addParam("pC0", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 2));
        const A_c2 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 4));
        const c0 = c2.getLocal("pC0");
        const c1 = c2.getLocal("pC1");
        const t1 = c2.getLocal("pR");
        const t2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 2));
        const t3 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 4));
        const a_a = c2.i32_const(module3.alloc(f1size * 2));
        const b_b = c2.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac1 = c2.i32_const(module3.alloc(f1size * 2));
        const Ac0_Ac2 = c2.i32_const(module3.alloc(f1size * 2));
        f2.addCode(
          // let a_a = self.c0 * c0;
          c2.call(f2mPrefix + "_mul", A_c0, c0, a_a),
          // let b_b = self.c1 * c1;
          c2.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          c2.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c2.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c2.call(f2mPrefix + "_add", A_c1, A_c2, t1),
          c2.call(f2mPrefix + "_mul", t1, c1, t1),
          c2.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue() + a_a;
          c2.call(f2mPrefix + "_mulNR", t1, t1),
          c2.call(f2mPrefix + "_add", t1, a_a, t1),
          // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;
          c2.call(f2mPrefix + "_add", c0, c1, t2),
          c2.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
          c2.call(f2mPrefix + "_sub", t2, a_a, t2),
          c2.call(f2mPrefix + "_sub", t2, b_b, t2),
          // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;
          c2.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
          c2.call(f2mPrefix + "_sub", t3, a_a, t3),
          c2.call(f2mPrefix + "_add", t3, b_b, t3)
        );
      }
      buildF6Mul01();
      function buildF12Mul014() {
        const f2 = module3.addFunction(ftmPrefix + "_mul014");
        f2.addParam("pA", "i32");
        f2.addParam("pC0", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pC4", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 6));
        const c0 = c2.getLocal("pC0");
        const c1 = c2.getLocal("pC1");
        const c4 = c2.getLocal("pC4");
        const aa = c2.i32_const(module3.alloc(f1size * 6));
        const bb = c2.i32_const(module3.alloc(f1size * 6));
        const o = c2.i32_const(module3.alloc(f1size * 2));
        const R_c0 = c2.getLocal("pR");
        const R_c1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 6));
        f2.addCode(
          // let aa = self.c0.mul_by_01(c0, c1);
          c2.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa),
          // let bb = self.c1.mul_by_1(c4);
          c2.call(f6mPrefix + "_mul1", A_c1, c4, bb),
          // let o = c1 + c4;
          c2.call(f2mPrefix + "_add", c1, c4, o),
          // let c1 = self.c1 + self.c0;
          c2.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
          // let c1 = c1.mul_by_01(c0, &o);
          c2.call(f6mPrefix + "_mul01", R_c1, c0, o, R_c1),
          // let c1 = c1 - aa - bb;
          c2.call(f6mPrefix + "_sub", R_c1, aa, R_c1),
          c2.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
          // let c0 = bb;
          c2.call(f6mPrefix + "_copy", bb, R_c0),
          // let c0 = c0.mul_by_nonresidue();
          c2.call(f6mPrefix + "_mulNR", R_c0, R_c0),
          // let c0 = c0 + aa;
          c2.call(f6mPrefix + "_add", R_c0, aa, R_c0)
        );
      }
      buildF12Mul014();
      function buildELL() {
        const f2 = module3.addFunction(prefix + "_ell");
        f2.addParam("pP", "i32");
        f2.addParam("pCoefs", "i32");
        f2.addParam("pF", "i32");
        const c2 = f2.getCodeBuilder();
        const Px = c2.getLocal("pP");
        const Py = c2.i32_add(c2.getLocal("pP"), c2.i32_const(n8q));
        const F = c2.getLocal("pF");
        const coef0_0 = c2.getLocal("pCoefs");
        const coef0_1 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size));
        const coef1_0 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 2));
        const coef1_1 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 3));
        const coef2 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 4));
        const pc0 = module3.alloc(f1size * 2);
        const c0 = c2.i32_const(pc0);
        const c0_c0 = c2.i32_const(pc0);
        const c0_c1 = c2.i32_const(pc0 + f1size);
        const pc1 = module3.alloc(f1size * 2);
        const c1 = c2.i32_const(pc1);
        const c1_c0 = c2.i32_const(pc1);
        const c1_c1 = c2.i32_const(pc1 + f1size);
        f2.addCode(
          //     let mut c0 = coeffs.0;
          //     let mut c1 = coeffs.1;
          //
          //    c0.c0 *= p.y;
          //    c0.c1 *= p.y;
          //
          //    c1.c0 *= p.x;
          //    c1.c1 *= p.x;
          //
          //     f.mul_by_014(&coeffs.2, &c1, &c0)
          c2.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
          c2.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
          c2.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
          c2.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
          c2.call(ftmPrefix + "_mul014", F, coef2, c1, c0, F)
        );
      }
      buildELL();
      function buildMillerLoop() {
        const f2 = module3.addFunction(prefix + "_millerLoop");
        f2.addParam("ppreP", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const preP = c2.getLocal("ppreP");
        const coefs = c2.getLocal("pCoef");
        const F = c2.getLocal("r");
        f2.addCode(
          c2.call(ftmPrefix + "_one", F),
          c2.if(
            c2.call(g1mPrefix + "_isZero", preP),
            c2.ret([])
          ),
          c2.if(
            c2.call(g1mPrefix + "_isZero", c2.getLocal("ppreQ")),
            c2.ret([])
          ),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix + "_ell", preP, coefs, F),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix + "_ell", preP, coefs, F),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.call(ftmPrefix + "_square", F, F),
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.i32_const(1))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(prefix + "_ell", preP, coefs, F)
        );
        if (isLoopNegative) {
          f2.addCode(
            c2.call(ftmPrefix + "_conjugate", F, F)
          );
        }
      }
      function buildFrobeniusMap(n3) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
            [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [0n, 1n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
          ],
          [
            [1n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
          ]
        ];
        const f2 = module3.addFunction(ftmPrefix + "_frobeniusMap" + n3);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i = 0; i < 6; i++) {
          const X = i == 0 ? c2.getLocal("x") : c2.i32_add(c2.getLocal("x"), c2.i32_const(i * f2size));
          const Xc0 = X;
          const Xc1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(i * f2size + f1size));
          const R = i == 0 ? c2.getLocal("r") : c2.i32_add(c2.getLocal("r"), c2.i32_const(i * f2size));
          const Rc0 = R;
          const Rc1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(i * f2size + f1size));
          const coef = mul22(F12[Math.floor(i / 3)][n3 % 12], F6[i % 3][n3 % 6]);
          const pCoef = module3.alloc([
            ...utils2.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
            ...utils2.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
          ]);
          if (n3 % 2 == 1) {
            f2.addCode(
              c2.call(f1mPrefix + "_copy", Xc0, Rc0),
              c2.call(f1mPrefix + "_neg", Xc1, Rc1),
              c2.call(f2mPrefix + "_mul", R, c2.i32_const(pCoef), R)
            );
          } else {
            f2.addCode(c2.call(f2mPrefix + "_mul", X, c2.i32_const(pCoef), R));
          }
        }
        function mul22(a2, b3) {
          const ac0 = a2[0];
          const ac1 = a2[1];
          const bc0 = b3[0];
          const bc1 = b3[1];
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q,
            (ac0 * bc1 + ac1 * bc0) % q
          ];
          if (isNegative3(res[0])) res[0] = res[0] + q;
          return res;
        }
      }
      function buildCyclotomicSquare() {
        const f2 = module3.addFunction(prefix + "__cyclotomicSquare");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x4 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f2size));
        const x3 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f2size));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(3 * f2size));
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(4 * f2size));
        const x5 = c2.i32_add(c2.getLocal("x"), c2.i32_const(5 * f2size));
        const r0 = c2.getLocal("r");
        const r4 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f2size));
        const r3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f2size));
        const r22 = c2.i32_add(c2.getLocal("r"), c2.i32_const(3 * f2size));
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * f2size));
        const r5 = c2.i32_add(c2.getLocal("r"), c2.i32_const(5 * f2size));
        const t0 = c2.i32_const(module3.alloc(f2size));
        const t1 = c2.i32_const(module3.alloc(f2size));
        const t2 = c2.i32_const(module3.alloc(f2size));
        const t3 = c2.i32_const(module3.alloc(f2size));
        const t4 = c2.i32_const(module3.alloc(f2size));
        const t5 = c2.i32_const(module3.alloc(f2size));
        const tmp = c2.i32_const(module3.alloc(f2size));
        const AUX = c2.i32_const(module3.alloc(f2size));
        f2.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x0, x1, tmp),
          c2.call(f2mPrefix + "_mulNR", x1, t0),
          c2.call(f2mPrefix + "_add", x0, t0, t0),
          c2.call(f2mPrefix + "_add", x0, x1, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t0, t0),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t0, AUX, t0),
          c2.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x2, x3, tmp),
          c2.call(f2mPrefix + "_mulNR", x3, t2),
          c2.call(f2mPrefix + "_add", x2, t2, t2),
          c2.call(f2mPrefix + "_add", x2, x3, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t2, t2),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t2, AUX, t2),
          c2.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x4, x5, tmp),
          c2.call(f2mPrefix + "_mulNR", x5, t4),
          c2.call(f2mPrefix + "_add", x4, t4, t4),
          c2.call(f2mPrefix + "_add", x4, x5, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t4, t4),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t4, AUX, t4),
          c2.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c2.call(f2mPrefix + "_sub", t0, x0, r0),
          c2.call(f2mPrefix + "_add", r0, r0, r0),
          c2.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c2.call(f2mPrefix + "_add", t1, x1, r1),
          c2.call(f2mPrefix + "_add", r1, r1, r1),
          c2.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c2.call(f2mPrefix + "_mul", t5, c2.i32_const(pBls12381Twist), AUX),
          c2.call(f2mPrefix + "_add", AUX, x2, r22),
          c2.call(f2mPrefix + "_add", r22, r22, r22),
          c2.call(f2mPrefix + "_add", AUX, r22, r22),
          // z3 = 3 * t4 - 2 * z3
          c2.call(f2mPrefix + "_sub", t4, x3, r3),
          c2.call(f2mPrefix + "_add", r3, r3, r3),
          c2.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c2.call(f2mPrefix + "_sub", t2, x4, r4),
          c2.call(f2mPrefix + "_add", r4, r4, r4),
          c2.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c2.call(f2mPrefix + "_add", t3, x5, r5),
          c2.call(f2mPrefix + "_add", r5, r5, r5),
          c2.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, isExpNegative, fnName) {
        const exponentNafBytes = naf2(exponent).map((b3) => b3 == -1 ? 255 : b3);
        const pExponentNafBytes = module3.alloc(exponentNafBytes);
        const f2 = module3.addFunction(prefix + "__cyclotomicExp_" + fnName);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("bit", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const x = c2.getLocal("x");
        const res = c2.getLocal("r");
        const inverse = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          c2.call(ftmPrefix + "_conjugate", x, inverse),
          c2.call(ftmPrefix + "_one", res),
          c2.if(
            c2.teeLocal("bit", c2.i32_load8_s(c2.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c2.if(
              c2.i32_eq(
                c2.getLocal("bit"),
                c2.i32_const(1)
              ),
              c2.call(ftmPrefix + "_mul", res, x, res),
              c2.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c2.setLocal("i", c2.i32_const(exponentNafBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix + "__cyclotomicSquare", res, res),
            c2.if(
              c2.teeLocal("bit", c2.i32_load8_s(c2.getLocal("i"), pExponentNafBytes)),
              c2.if(
                c2.i32_eq(
                  c2.getLocal("bit"),
                  c2.i32_const(1)
                ),
                c2.call(ftmPrefix + "_mul", res, x, res),
                c2.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        if (isExpNegative) {
          f2.addCode(
            c2.call(ftmPrefix + "_conjugate", res, res)
          );
        }
      }
      function buildFinalExponentiation() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
        const f2 = module3.addFunction(prefix + "_finalExponentiation");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const res = c2.getLocal("r");
        const t0 = c2.i32_const(module3.alloc(ftsize));
        const t1 = c2.i32_const(module3.alloc(ftsize));
        const t2 = c2.i32_const(module3.alloc(ftsize));
        const t3 = c2.i32_const(module3.alloc(ftsize));
        const t4 = c2.i32_const(module3.alloc(ftsize));
        const t5 = c2.i32_const(module3.alloc(ftsize));
        const t6 = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(
          // let mut t0 = f.frobenius_map(6)
          c2.call(ftmPrefix + "_frobeniusMap6", elt, t0),
          // let t1 = f.invert()
          c2.call(ftmPrefix + "_inverse", elt, t1),
          // let mut t2 = t0 * t1;
          c2.call(ftmPrefix + "_mul", t0, t1, t2),
          // t1 = t2.clone();
          c2.call(ftmPrefix + "_copy", t2, t1),
          // t2 = t2.frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap2", t2, t2),
          // t2 *= t1;
          c2.call(ftmPrefix + "_mul", t2, t1, t2),
          // t1 = cyclotomic_square(t2).conjugate();
          c2.call(prefix + "__cyclotomicSquare", t2, t1),
          c2.call(ftmPrefix + "_conjugate", t1, t1),
          // let mut t3 = cycolotomic_exp(t2);
          c2.call(prefix + "__cyclotomicExp_w0", t2, t3),
          // let mut t4 = cyclotomic_square(t3);
          c2.call(prefix + "__cyclotomicSquare", t3, t4),
          // let mut t5 = t1 * t3;
          c2.call(ftmPrefix + "_mul", t1, t3, t5),
          // t1 = cycolotomic_exp(t5);
          c2.call(prefix + "__cyclotomicExp_w0", t5, t1),
          // t0 = cycolotomic_exp(t1);
          c2.call(prefix + "__cyclotomicExp_w0", t1, t0),
          // let mut t6 = cycolotomic_exp(t0);
          c2.call(prefix + "__cyclotomicExp_w0", t0, t6),
          // t6 *= t4;
          c2.call(ftmPrefix + "_mul", t6, t4, t6),
          // t4 = cycolotomic_exp(t6);
          c2.call(prefix + "__cyclotomicExp_w0", t6, t4),
          // t5 = t5.conjugate();
          c2.call(ftmPrefix + "_conjugate", t5, t5),
          // t4 *= t5 * t2;
          c2.call(ftmPrefix + "_mul", t4, t5, t4),
          c2.call(ftmPrefix + "_mul", t4, t2, t4),
          // t5 = t2.conjugate();
          c2.call(ftmPrefix + "_conjugate", t2, t5),
          // t1 *= t2;
          c2.call(ftmPrefix + "_mul", t1, t2, t1),
          // t1 = t1.frobenius_map().frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap3", t1, t1),
          // t6 *= t5;
          c2.call(ftmPrefix + "_mul", t6, t5, t6),
          // t6 = t6.frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap1", t6, t6),
          // t3 *= t0;
          c2.call(ftmPrefix + "_mul", t3, t0, t3),
          // t3 = t3.frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap2", t3, t3),
          // t3 *= t1;
          c2.call(ftmPrefix + "_mul", t3, t1, t3),
          // t3 *= t6;
          c2.call(ftmPrefix + "_mul", t3, t6, t3),
          // f = t3 * t4;
          c2.call(ftmPrefix + "_mul", t3, t4, res)
        );
      }
      function buildFinalExponentiationOld() {
        const f2 = module3.addFunction(prefix + "_finalExponentiationOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
        const pExponent = module3.alloc(utils2.bigInt2BytesLE(exponent, 544));
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(ftmPrefix + "_exp", c2.getLocal("x"), c2.i32_const(pExponent), c2.i32_const(544), c2.getLocal("r"))
        );
      }
      const pPreP = module3.alloc(prePSize);
      const pPreQ = module3.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f2 = module3.addFunction(prefix + "_pairingEq" + nPairings);
        for (let i = 0; i < nPairings; i++) {
          f2.addParam("p_" + i, "i32");
          f2.addParam("q_" + i, "i32");
        }
        f2.addParam("c", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module3.alloc(ftsize));
        const auxT = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(c2.call(ftmPrefix + "_one", resT));
        for (let i = 0; i < nPairings; i++) {
          f2.addCode(c2.call(prefix + "_prepareG1", c2.getLocal("p_" + i), c2.i32_const(pPreP)));
          f2.addCode(c2.call(prefix + "_prepareG2", c2.getLocal("q_" + i), c2.i32_const(pPreQ)));
          f2.addCode(
            c2.if(
              c2.i32_eqz(c2.call(g1mPrefix + "_inGroupAffine", c2.i32_const(pPreP))),
              c2.ret(c2.i32_const(0))
            ),
            c2.if(
              c2.i32_eqz(c2.call(g2mPrefix + "_inGroupAffine", c2.i32_const(pPreQ))),
              c2.ret(c2.i32_const(0))
            )
          );
          f2.addCode(c2.call(prefix + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), auxT));
          f2.addCode(c2.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f2.addCode(c2.call(prefix + "_finalExponentiation", resT, resT));
        f2.addCode(c2.call(ftmPrefix + "_eq", resT, c2.getLocal("c")));
      }
      function buildPairing2() {
        const f2 = module3.addFunction(prefix + "_pairing");
        f2.addParam("p", "i32");
        f2.addParam("q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module3.alloc(ftsize));
        f2.addCode(c2.call(prefix + "_prepareG1", c2.getLocal("p"), c2.i32_const(pPreP)));
        f2.addCode(c2.call(prefix + "_prepareG2", c2.getLocal("q"), c2.i32_const(pPreQ)));
        f2.addCode(c2.call(prefix + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), resT));
        f2.addCode(c2.call(prefix + "_finalExponentiation", resT, c2.getLocal("r")));
      }
      function buildInGroupG2() {
        const f2 = module3.addFunction(g2mPrefix + "_inGroupAffine");
        f2.addParam("p", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const WINV = [
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
        ];
        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const FROB3Y = [
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
        ];
        const wInv = c2.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
        ]));
        const frob2X = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
        const frob3Y = c2.i32_const(module3.alloc([
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
          ...utils2.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
        ]));
        const z2 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE(finalExpZ, 8)));
        const px = c2.getLocal("p");
        const py = c2.i32_add(c2.getLocal("p"), c2.i32_const(f2size));
        const aux = c2.i32_const(module3.alloc(f1size));
        const x_winv = c2.i32_const(module3.alloc(f2size));
        const y_winv = c2.i32_const(module3.alloc(f2size));
        const pf2 = module3.alloc(f2size * 2);
        const f22 = c2.i32_const(pf2);
        const f2x = c2.i32_const(pf2);
        const f2x_c1 = c2.i32_const(pf2);
        const f2x_c2 = c2.i32_const(pf2 + f1size);
        const f2y = c2.i32_const(pf2 + f2size);
        const f2y_c1 = c2.i32_const(pf2 + f2size);
        const f2y_c2 = c2.i32_const(pf2 + f2size + f1size);
        const pf3 = module3.alloc(f2size * 3);
        const f3 = c2.i32_const(pf3);
        const f3x = c2.i32_const(pf3);
        const f3x_c1 = c2.i32_const(pf3);
        const f3x_c2 = c2.i32_const(pf3 + f1size);
        const f3y = c2.i32_const(pf3 + f2size);
        const f3y_c1 = c2.i32_const(pf3 + f2size);
        const f3y_c2 = c2.i32_const(pf3 + f2size + f1size);
        const f3z = c2.i32_const(pf3 + f2size * 2);
        f2.addCode(
          c2.if(
            c2.call(g2mPrefix + "_isZeroAffine", c2.getLocal("p")),
            c2.ret(c2.i32_const(1))
          ),
          c2.if(
            c2.i32_eqz(c2.call(g2mPrefix + "_inCurveAffine", c2.getLocal("p"))),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(f2mPrefix + "_mul", px, wInv, x_winv),
          c2.call(f2mPrefix + "_mul", py, wInv, y_winv),
          c2.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
          c2.call(f2mPrefix + "_neg", y_winv, f2y),
          c2.call(f2mPrefix + "_neg", x_winv, f3x),
          c2.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
          c2.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
          c2.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
          c2.call(f1mPrefix + "_copy", aux, f2x_c1),
          c2.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
          c2.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
          c2.call(f1mPrefix + "_copy", aux, f2y_c1),
          c2.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
          c2.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
          c2.call(f1mPrefix + "_copy", aux, f3x_c1),
          c2.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
          c2.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
          c2.call(f1mPrefix + "_copy", aux, f3y_c1),
          c2.call(f2mPrefix + "_one", f3z),
          c2.call(g2mPrefix + "_timesScalar", f3, z2, c2.i32_const(8), f3),
          c2.call(g2mPrefix + "_addMixed", f3, f22, f3),
          c2.ret(
            c2.call(g2mPrefix + "_eqMixed", f3, c2.getLocal("p"))
          )
        );
        const fInGroup = module3.addFunction(g2mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c22 = fInGroup.getCodeBuilder();
        const aux2 = c22.i32_const(module3.alloc(f2size * 2));
        fInGroup.addCode(
          c22.call(g2mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
          c22.ret(
            c22.call(g2mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      function buildInGroupG1() {
        const f2 = module3.addFunction(g1mPrefix + "_inGroupAffine");
        f2.addParam("p", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
        const beta = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA), n8q)));
        const beta2 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
        const z2m1d3 = c2.i32_const(module3.alloc(utils2.bigInt2BytesLE(Z2M1D3, 16)));
        const px = c2.getLocal("p");
        const py = c2.i32_add(c2.getLocal("p"), c2.i32_const(f1size));
        const psp = module3.alloc(f1size * 3);
        const sp = c2.i32_const(psp);
        const spx = c2.i32_const(psp);
        const spy = c2.i32_const(psp + f1size);
        const ps2p = module3.alloc(f1size * 2);
        const s2p = c2.i32_const(ps2p);
        const s2px = c2.i32_const(ps2p);
        const s2py = c2.i32_const(ps2p + f1size);
        f2.addCode(
          c2.if(
            c2.call(g1mPrefix + "_isZeroAffine", c2.getLocal("p")),
            c2.ret(c2.i32_const(1))
          ),
          c2.if(
            c2.i32_eqz(c2.call(g1mPrefix + "_inCurveAffine", c2.getLocal("p"))),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(f1mPrefix + "_mul", px, beta, spx),
          c2.call(f1mPrefix + "_copy", py, spy),
          c2.call(f1mPrefix + "_mul", px, beta2, s2px),
          c2.call(f1mPrefix + "_copy", py, s2py),
          c2.call(g1mPrefix + "_doubleAffine", sp, sp),
          c2.call(g1mPrefix + "_subMixed", sp, c2.getLocal("p"), sp),
          c2.call(g1mPrefix + "_subMixed", sp, s2p, sp),
          c2.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c2.i32_const(16), sp),
          c2.ret(
            c2.call(g1mPrefix + "_eqMixed", sp, s2p)
          )
        );
        const fInGroup = module3.addFunction(g1mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c22 = fInGroup.getCodeBuilder();
        const aux2 = c22.i32_const(module3.alloc(f1size * 2));
        fInGroup.addCode(
          c22.call(g1mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
          c22.ret(
            c22.call(g1mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      for (let i = 0; i < 10; i++) {
        buildFrobeniusMap(i);
        module3.exportFunction(ftmPrefix + "_frobeniusMap" + i);
      }
      buildInGroupG1();
      buildInGroupG2();
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMillerLoop();
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i = 1; i <= 5; i++) {
        buildPairingEquation(i);
        module3.exportFunction(prefix + "_pairingEq" + i);
      }
      buildPairing2();
      module3.exportFunction(prefix + "_pairing");
      module3.exportFunction(prefix + "_prepareG1");
      module3.exportFunction(prefix + "_prepareG2");
      module3.exportFunction(prefix + "_millerLoop");
      module3.exportFunction(prefix + "_finalExponentiation");
      module3.exportFunction(prefix + "_finalExponentiationOld");
      module3.exportFunction(prefix + "__cyclotomicSquare");
      module3.exportFunction(prefix + "__cyclotomicExp_w0");
      module3.exportFunction(f6mPrefix + "_mul1");
      module3.exportFunction(f6mPrefix + "_mul01");
      module3.exportFunction(ftmPrefix + "_mul014");
      module3.exportFunction(g1mPrefix + "_inGroupAffine");
      module3.exportFunction(g1mPrefix + "_inGroup");
      module3.exportFunction(g2mPrefix + "_inGroupAffine");
      module3.exportFunction(g2mPrefix + "_inGroup");
    };
  }
});

// ../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/index.js
var require_wasmcurves = __commonJS({
  "../../node_modules/.pnpm/wasmcurves@0.2.2/node_modules/wasmcurves/index.js"(exports2, module2) {
    module2.exports.buildBn128 = require_build_bn128();
    module2.exports.buildBls12381 = require_build_bls12381();
    module2.exports.buildF1m = require_build_f1m();
  }
});

// ../../node_modules/.pnpm/web-worker@1.2.0/node_modules/web-worker/cjs/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/web-worker@1.2.0/node_modules/web-worker/cjs/node.js"(exports2, module2) {
    var URL2 = require("url");
    var VM = require("vm");
    var threads = require("worker_threads");
    var WORKER = Symbol.for("worker");
    var EVENTS = Symbol.for("events");
    var EventTarget = class {
      constructor() {
        Object.defineProperty(this, EVENTS, {
          value: /* @__PURE__ */ new Map()
        });
      }
      dispatchEvent(event) {
        event.target = event.currentTarget = this;
        if (this["on" + event.type]) {
          try {
            this["on" + event.type](event);
          } catch (err) {
            console.error(err);
          }
        }
        const list = this[EVENTS].get(event.type);
        if (list == null) return;
        list.forEach((handler) => {
          try {
            handler.call(this, event);
          } catch (err) {
            console.error(err);
          }
        });
      }
      addEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (!events) this[EVENTS].set(type, events = []);
        events.push(fn);
      }
      removeEventListener(type, fn) {
        let events = this[EVENTS].get(type);
        if (events) {
          const index = events.indexOf(fn);
          if (index !== -1) events.splice(index, 1);
        }
      }
    };
    function Event(type, target) {
      this.type = type;
      this.timeStamp = Date.now();
      this.target = this.currentTarget = this.data = null;
    }
    module2.exports = threads.isMainThread ? mainThread() : workerThread();
    var baseUrl = URL2.pathToFileURL(process.cwd() + "/");
    function mainThread() {
      class Worker2 extends EventTarget {
        constructor(url, options) {
          super();
          const {
            name,
            type
          } = options || {};
          url += "";
          let mod3;
          if (/^data:/.test(url)) {
            mod3 = url;
          } else {
            mod3 = URL2.fileURLToPath(new URL2.URL(url, baseUrl));
          }
          const worker = new threads.Worker(__filename, {
            workerData: {
              mod: mod3,
              name,
              type
            }
          });
          Object.defineProperty(this, WORKER, {
            value: worker
          });
          worker.on("message", (data4) => {
            const event = new Event("message");
            event.data = data4;
            this.dispatchEvent(event);
          });
          worker.on("error", (error) => {
            error.type = "error";
            this.dispatchEvent(error);
          });
          worker.on("exit", () => {
            this.dispatchEvent(new Event("close"));
          });
        }
        postMessage(data4, transferList) {
          this[WORKER].postMessage(data4, transferList);
        }
        terminate() {
          this[WORKER].terminate();
        }
      }
      Worker2.prototype.onmessage = Worker2.prototype.onerror = Worker2.prototype.onclose = null;
      return Worker2;
    }
    function workerThread() {
      let {
        mod: mod3,
        name,
        type
      } = threads.workerData;
      const self2 = global.self = global;
      let q = [];
      function flush() {
        const buffered = q;
        q = null;
        buffered.forEach((event) => {
          self2.dispatchEvent(event);
        });
      }
      threads.parentPort.on("message", (data4) => {
        const event = new Event("message");
        event.data = data4;
        if (q == null) self2.dispatchEvent(event);
        else q.push(event);
      });
      threads.parentPort.on("error", (err) => {
        err.type = "Error";
        self2.dispatchEvent(err);
      });
      class WorkerGlobalScope extends EventTarget {
        postMessage(data4, transferList) {
          threads.parentPort.postMessage(data4, transferList);
        }
        // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close
        close() {
          process.exit();
        }
      }
      let proto = Object.getPrototypeOf(global);
      delete proto.constructor;
      Object.defineProperties(WorkerGlobalScope.prototype, proto);
      proto = Object.setPrototypeOf(global, new WorkerGlobalScope());
      ["postMessage", "addEventListener", "removeEventListener", "dispatchEvent"].forEach((fn) => {
        proto[fn] = proto[fn].bind(global);
      });
      global.name = name;
      const isDataUrl = /^data:/.test(mod3);
      if (type === "module") {
        import(mod3).catch((err) => {
          if (isDataUrl && err.message === "Not supported") {
            console.warn("Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.");
            return evaluateDataUrl(mod3, name);
          }
          console.error(err);
        }).then(flush);
      } else {
        try {
          if (/^data:/.test(mod3)) {
            evaluateDataUrl(mod3, name);
          } else {
            require(mod3);
          }
        } catch (err) {
          console.error(err);
        }
        Promise.resolve().then(flush);
      }
    }
    function evaluateDataUrl(url, name) {
      const {
        data: data4
      } = parseDataUrl(url);
      return VM.runInThisContext(data4, {
        filename: "worker.<" + (name || "data:") + ">"
      });
    }
    function parseDataUrl(url) {
      let [m, type, encoding, data4] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];
      if (!m) throw Error("Invalid Data URL.");
      if (encoding) switch (encoding.toLowerCase()) {
        case "base64":
          data4 = Buffer.from(data4, "base64").toString();
          break;
        default:
          throw Error('Unknown Data URL encoding "' + encoding + '"');
      }
      return {
        type,
        data: data4
      };
    }
  }
});

// ../../node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "../../node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js"(exports2, module2) {
    module2.exports = assert4;
    var AssertionError = class extends Error {
    };
    AssertionError.prototype.name = "AssertionError";
    function assert4(t, m) {
      if (!t) {
        var err = new AssertionError(m);
        if (Error.captureStackTrace) Error.captureStackTrace(err, assert4);
        throw err;
      }
    }
  }
});

// ../../node_modules/.pnpm/b4a@1.6.7/node_modules/b4a/index.js
var require_b4a = __commonJS({
  "../../node_modules/.pnpm/b4a@1.6.7/node_modules/b4a/index.js"(exports2, module2) {
    function isBuffer2(value) {
      return Buffer.isBuffer(value) || value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      return Buffer.isEncoding(encoding);
    }
    function alloc(size, fill2, encoding) {
      return Buffer.alloc(size, fill2, encoding);
    }
    function allocUnsafe(size) {
      return Buffer.allocUnsafe(size);
    }
    function allocUnsafeSlow(size) {
      return Buffer.allocUnsafeSlow(size);
    }
    function byteLength(string2, encoding) {
      return Buffer.byteLength(string2, encoding);
    }
    function compare(a2, b3) {
      return Buffer.compare(a2, b3);
    }
    function concat4(buffers, totalLength) {
      return Buffer.concat(buffers, totalLength);
    }
    function copy7(source, target, targetStart, start2, end) {
      return toBuffer(source).copy(target, targetStart, start2, end);
    }
    function equals(a2, b3) {
      return toBuffer(a2).equals(b3);
    }
    function fill(buffer, value, offset, end, encoding) {
      return toBuffer(buffer).fill(value, offset, end, encoding);
    }
    function from(value, encodingOrOffset, length) {
      return Buffer.from(value, encodingOrOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).includes(value, byteOffset, encoding);
    }
    function indexOf(buffer, value, byfeOffset, encoding) {
      return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
    }
    function swap16(buffer) {
      return toBuffer(buffer).swap16();
    }
    function swap32(buffer) {
      return toBuffer(buffer).swap32();
    }
    function swap64(buffer) {
      return toBuffer(buffer).swap64();
    }
    function toBuffer(buffer) {
      if (Buffer.isBuffer(buffer)) return buffer;
      return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function toString4(buffer, encoding, start2, end) {
      return toBuffer(buffer).toString(encoding, start2, end);
    }
    function write2(buffer, string2, offset, length, encoding) {
      return toBuffer(buffer).write(string2, offset, length, encoding);
    }
    function writeDoubleLE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleLE(value, offset);
    }
    function writeFloatLE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatLE(value, offset);
    }
    function writeUInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32LE(value, offset);
    }
    function writeInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32LE(value, offset);
    }
    function readDoubleLE(buffer, offset) {
      return toBuffer(buffer).readDoubleLE(offset);
    }
    function readFloatLE(buffer, offset) {
      return toBuffer(buffer).readFloatLE(offset);
    }
    function readUInt32LE(buffer, offset) {
      return toBuffer(buffer).readUInt32LE(offset);
    }
    function readInt32LE(buffer, offset) {
      return toBuffer(buffer).readInt32LE(offset);
    }
    function writeDoubleBE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleBE(value, offset);
    }
    function writeFloatBE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatBE(value, offset);
    }
    function writeUInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32BE(value, offset);
    }
    function writeInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32BE(value, offset);
    }
    function readDoubleBE(buffer, offset) {
      return toBuffer(buffer).readDoubleBE(offset);
    }
    function readFloatBE(buffer, offset) {
      return toBuffer(buffer).readFloatBE(offset);
    }
    function readUInt32BE2(buffer, offset) {
      return toBuffer(buffer).readUInt32BE(offset);
    }
    function readInt32BE(buffer, offset) {
      return toBuffer(buffer).readInt32BE(offset);
    }
    module2.exports = {
      isBuffer: isBuffer2,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat: concat4,
      copy: copy7,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString: toString4,
      write: write2,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE,
      writeDoubleBE,
      writeFloatBE,
      writeUInt32BE,
      writeInt32BE,
      readDoubleBE,
      readFloatBE,
      readUInt32BE: readUInt32BE2,
      readInt32BE
    };
  }
});

// ../../node_modules/.pnpm/blake2b-wasm@2.4.0/node_modules/blake2b-wasm/blake2b.js
var require_blake2b = __commonJS({
  "../../node_modules/.pnpm/blake2b-wasm@2.4.0/node_modules/blake2b-wasm/blake2b.js"(exports2, module2) {
    var __commonJS2 = (cb, mod3) => function __require() {
      return mod3 || (0, cb[Object.keys(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
    };
    var __toBinary = /* @__PURE__ */ (() => {
      var table = new Uint8Array(128);
      for (var i = 0; i < 64; i++)
        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      return (base64) => {
        var n3 = base64.length, bytes22 = new Uint8Array((n3 - (base64[n3 - 1] == "=") - (base64[n3 - 2] == "=")) * 3 / 4 | 0);
        for (var i2 = 0, j = 0; i2 < n3; ) {
          var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
          var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
          bytes22[j++] = c0 << 2 | c1 >> 4;
          bytes22[j++] = c1 << 4 | c2 >> 2;
          bytes22[j++] = c2 << 6 | c3;
        }
        return bytes22;
      };
    })();
    var require_blake2b2 = __commonJS2({
      "wasm-binary:./blake2b.wat"(exports22, module22) {
        module22.exports = __toBinary("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=");
      }
    });
    var bytes2 = require_blake2b2();
    var compiled = WebAssembly.compile(bytes2);
    module2.exports = async (imports) => {
      const instance = await WebAssembly.instantiate(await compiled, imports);
      return instance.exports;
    };
  }
});

// ../../node_modules/.pnpm/blake2b-wasm@2.4.0/node_modules/blake2b-wasm/index.js
var require_blake2b_wasm = __commonJS({
  "../../node_modules/.pnpm/blake2b-wasm@2.4.0/node_modules/blake2b-wasm/index.js"(exports2, module2) {
    var assert4 = require_nanoassert();
    var b4a = require_b4a();
    var wasm = null;
    var wasmPromise = typeof WebAssembly !== "undefined" && require_blake2b()().then((mod3) => {
      wasm = mod3;
    });
    var head = 64;
    var freeList = [];
    module2.exports = Blake2b16;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    function Blake2b16(digestLength, key, salt, personal, noAssert) {
      if (!(this instanceof Blake2b16)) return new Blake2b16(digestLength, key, salt, personal, noAssert);
      if (!wasm) throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
      if (!digestLength) digestLength = 32;
      if (noAssert !== true) {
        assert4(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
        assert4(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
        if (key != null) {
          assert4(key instanceof Uint8Array, "key must be Uint8Array or Buffer");
          assert4(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
          assert4(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
        }
        if (salt != null) {
          assert4(salt instanceof Uint8Array, "salt must be Uint8Array or Buffer");
          assert4(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        }
        if (personal != null) {
          assert4(personal instanceof Uint8Array, "personal must be Uint8Array or Buffer");
          assert4(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
        }
      }
      if (!freeList.length) {
        freeList.push(head);
        head += 216;
      }
      this.digestLength = digestLength;
      this.finalized = false;
      this.pointer = freeList.pop();
      this._memory = new Uint8Array(wasm.memory.buffer);
      this._memory.fill(0, 0, 64);
      this._memory[0] = this.digestLength;
      this._memory[1] = key ? key.length : 0;
      this._memory[2] = 1;
      this._memory[3] = 1;
      if (salt) this._memory.set(salt, 32);
      if (personal) this._memory.set(personal, 48);
      if (this.pointer + 216 > this._memory.length) this._realloc(this.pointer + 216);
      wasm.blake2b_init(this.pointer, this.digestLength);
      if (key) {
        this.update(key);
        this._memory.fill(0, head, head + key.length);
        this._memory[this.pointer + 200] = 128;
      }
    }
    Blake2b16.prototype._realloc = function(size) {
      wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)));
      this._memory = new Uint8Array(wasm.memory.buffer);
    };
    Blake2b16.prototype.update = function(input) {
      assert4(this.finalized === false, "Hash instance finalized");
      assert4(input instanceof Uint8Array, "input must be Uint8Array or Buffer");
      if (head + input.length > this._memory.length) this._realloc(head + input.length);
      this._memory.set(input, head);
      wasm.blake2b_update(this.pointer, head, head + input.length);
      return this;
    };
    Blake2b16.prototype.digest = function(enc) {
      assert4(this.finalized === false, "Hash instance finalized");
      this.finalized = true;
      freeList.push(this.pointer);
      wasm.blake2b_final(this.pointer);
      if (!enc || enc === "binary") {
        return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      if (typeof enc === "string") {
        return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      assert4(enc instanceof Uint8Array && enc.length >= this.digestLength, "input must be Uint8Array or Buffer");
      for (var i = 0; i < this.digestLength; i++) {
        enc[i] = this._memory[this.pointer + 128 + i];
      }
      return enc;
    };
    Blake2b16.prototype.final = Blake2b16.prototype.digest;
    Blake2b16.WASM = wasm;
    Blake2b16.SUPPORTED = typeof WebAssembly !== "undefined";
    Blake2b16.ready = function(cb) {
      if (!cb) cb = noop;
      if (!wasmPromise) return cb(new Error("WebAssembly not supported"));
      return wasmPromise.then(() => cb(), cb);
    };
    Blake2b16.prototype.ready = Blake2b16.ready;
    Blake2b16.prototype.getPartialHash = function() {
      return this._memory.slice(this.pointer, this.pointer + 216);
    };
    Blake2b16.prototype.setPartialHash = function(ph) {
      this._memory.set(ph, this.pointer);
    };
    function noop() {
    }
  }
});

// ../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/lib/utils.js"(exports2) {
    "use strict";
    var regExpChars = /[|\\{}()[\]^$+*?.]/g;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasOwn = function(obj, key) {
      return hasOwnProperty.apply(obj, [key]);
    };
    exports2.escapeRegExpChars = function(string2) {
      if (!string2) {
        return "";
      }
      return String(string2).replace(regExpChars, "\\$&");
    };
    var _ENCODE_HTML_RULES = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&#34;",
      "'": "&#39;"
    };
    var _MATCH_HTML = /[&<>'"]/g;
    function encode_char(c2) {
      return _ENCODE_HTML_RULES[c2] || c2;
    }
    var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
    exports2.escapeXML = function(markup) {
      return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
    };
    function escapeXMLToString() {
      return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
    }
    try {
      if (typeof Object.defineProperty === "function") {
        Object.defineProperty(exports2.escapeXML, "toString", { value: escapeXMLToString });
      } else {
        exports2.escapeXML.toString = escapeXMLToString;
      }
    } catch (err) {
      console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
    }
    exports2.shallowCopy = function(to, from) {
      from = from || {};
      if (to !== null && to !== void 0) {
        for (var p in from) {
          if (!hasOwn(from, p)) {
            continue;
          }
          if (p === "__proto__" || p === "constructor") {
            continue;
          }
          to[p] = from[p];
        }
      }
      return to;
    };
    exports2.shallowCopyFromList = function(to, from, list) {
      list = list || [];
      from = from || {};
      if (to !== null && to !== void 0) {
        for (var i = 0; i < list.length; i++) {
          var p = list[i];
          if (typeof from[p] != "undefined") {
            if (!hasOwn(from, p)) {
              continue;
            }
            if (p === "__proto__" || p === "constructor") {
              continue;
            }
            to[p] = from[p];
          }
        }
      }
      return to;
    };
    exports2.cache = {
      _data: {},
      set: function(key, val) {
        this._data[key] = val;
      },
      get: function(key) {
        return this._data[key];
      },
      remove: function(key) {
        delete this._data[key];
      },
      reset: function() {
        this._data = {};
      }
    };
    exports2.hyphenToCamel = function(str) {
      return str.replace(/-[a-z]/g, function(match) {
        return match[1].toUpperCase();
      });
    };
    exports2.createNullProtoObjWherePossible = function() {
      if (typeof Object.create == "function") {
        return function() {
          return /* @__PURE__ */ Object.create(null);
        };
      }
      if (!({ __proto__: null } instanceof Object)) {
        return function() {
          return { __proto__: null };
        };
      }
      return function() {
        return {};
      };
    }();
    exports2.hasOwnOnlyObject = function(obj) {
      var o = exports2.createNullProtoObjWherePossible();
      for (var p in obj) {
        if (hasOwn(obj, p)) {
          o[p] = obj[p];
        }
      }
      return o;
    };
  }
});

// ../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/package.json
var require_package2 = __commonJS({
  "../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/package.json"(exports2, module2) {
    module2.exports = {
      name: "ejs",
      description: "Embedded JavaScript templates",
      keywords: [
        "template",
        "engine",
        "ejs"
      ],
      version: "3.1.10",
      author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)",
      license: "Apache-2.0",
      bin: {
        ejs: "./bin/cli.js"
      },
      main: "./lib/ejs.js",
      jsdelivr: "ejs.min.js",
      unpkg: "ejs.min.js",
      repository: {
        type: "git",
        url: "git://github.com/mde/ejs.git"
      },
      bugs: "https://github.com/mde/ejs/issues",
      homepage: "https://github.com/mde/ejs",
      dependencies: {
        jake: "^10.8.5"
      },
      devDependencies: {
        browserify: "^16.5.1",
        eslint: "^6.8.0",
        "git-directory-deploy": "^1.5.1",
        jsdoc: "^4.0.2",
        "lru-cache": "^4.0.1",
        mocha: "^10.2.0",
        "uglify-js": "^3.3.16"
      },
      engines: {
        node: ">=0.10.0"
      },
      scripts: {
        test: "npx jake test"
      }
    };
  }
});

// ../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/lib/ejs.js
var require_ejs = __commonJS({
  "../../node_modules/.pnpm/ejs@3.1.10/node_modules/ejs/lib/ejs.js"(exports2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var utils2 = require_utils4();
    var scopeOptionWarned = false;
    var _VERSION_STRING = require_package2().version;
    var _DEFAULT_OPEN_DELIMITER = "<";
    var _DEFAULT_CLOSE_DELIMITER = ">";
    var _DEFAULT_DELIMITER = "%";
    var _DEFAULT_LOCALS_NAME = "locals";
    var _NAME = "ejs";
    var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
    var _OPTS_PASSABLE_WITH_DATA = [
      "delimiter",
      "scope",
      "context",
      "debug",
      "compileDebug",
      "client",
      "_with",
      "rmWhitespace",
      "strict",
      "filename",
      "async"
    ];
    var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
    var _BOM = /^\uFEFF/;
    var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
    exports2.cache = utils2.cache;
    exports2.fileLoader = fs2.readFileSync;
    exports2.localsName = _DEFAULT_LOCALS_NAME;
    exports2.promiseImpl = new Function("return this;")().Promise;
    exports2.resolveInclude = function(name, filename, isDir) {
      var dirname2 = path.dirname;
      var extname = path.extname;
      var resolve = path.resolve;
      var includePath = resolve(isDir ? filename : dirname2(filename), name);
      var ext = extname(name);
      if (!ext) {
        includePath += ".ejs";
      }
      return includePath;
    };
    function resolvePaths(name, paths) {
      var filePath;
      if (paths.some(function(v) {
        filePath = exports2.resolveInclude(name, v, true);
        return fs2.existsSync(filePath);
      })) {
        return filePath;
      }
    }
    function getIncludePath(path2, options) {
      var includePath;
      var filePath;
      var views = options.views;
      var match = /^[A-Za-z]+:\\|^\//.exec(path2);
      if (match && match.length) {
        path2 = path2.replace(/^\/*/, "");
        if (Array.isArray(options.root)) {
          includePath = resolvePaths(path2, options.root);
        } else {
          includePath = exports2.resolveInclude(path2, options.root || "/", true);
        }
      } else {
        if (options.filename) {
          filePath = exports2.resolveInclude(path2, options.filename);
          if (fs2.existsSync(filePath)) {
            includePath = filePath;
          }
        }
        if (!includePath && Array.isArray(views)) {
          includePath = resolvePaths(path2, views);
        }
        if (!includePath && typeof options.includer !== "function") {
          throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
        }
      }
      return includePath;
    }
    function handleCache(options, template) {
      var func;
      var filename = options.filename;
      var hasTemplate = arguments.length > 1;
      if (options.cache) {
        if (!filename) {
          throw new Error("cache option requires a filename");
        }
        func = exports2.cache.get(filename);
        if (func) {
          return func;
        }
        if (!hasTemplate) {
          template = fileLoader(filename).toString().replace(_BOM, "");
        }
      } else if (!hasTemplate) {
        if (!filename) {
          throw new Error("Internal EJS error: no file name or template provided");
        }
        template = fileLoader(filename).toString().replace(_BOM, "");
      }
      func = exports2.compile(template, options);
      if (options.cache) {
        exports2.cache.set(filename, func);
      }
      return func;
    }
    function tryHandleCache(options, data4, cb) {
      var result;
      if (!cb) {
        if (typeof exports2.promiseImpl == "function") {
          return new exports2.promiseImpl(function(resolve, reject) {
            try {
              result = handleCache(options)(data4);
              resolve(result);
            } catch (err) {
              reject(err);
            }
          });
        } else {
          throw new Error("Please provide a callback function");
        }
      } else {
        try {
          result = handleCache(options)(data4);
        } catch (err) {
          return cb(err);
        }
        cb(null, result);
      }
    }
    function fileLoader(filePath) {
      return exports2.fileLoader(filePath);
    }
    function includeFile(path2, options) {
      var opts = utils2.shallowCopy(utils2.createNullProtoObjWherePossible(), options);
      opts.filename = getIncludePath(path2, opts);
      if (typeof options.includer === "function") {
        var includerResult = options.includer(path2, opts.filename);
        if (includerResult) {
          if (includerResult.filename) {
            opts.filename = includerResult.filename;
          }
          if (includerResult.template) {
            return handleCache(opts, includerResult.template);
          }
        }
      }
      return handleCache(opts);
    }
    function rethrow(err, str, flnm, lineno, esc) {
      var lines = str.split("\n");
      var start2 = Math.max(lineno - 3, 0);
      var end = Math.min(lines.length, lineno + 3);
      var filename = esc(flnm);
      var context = lines.slice(start2, end).map(function(line, i) {
        var curr = i + start2 + 1;
        return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
      }).join("\n");
      err.path = filename;
      err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
      throw err;
    }
    function stripSemi(str) {
      return str.replace(/;(\s*$)/, "$1");
    }
    exports2.compile = function compile(template, opts) {
      var templ;
      if (opts && opts.scope) {
        if (!scopeOptionWarned) {
          console.warn("`scope` option is deprecated and will be removed in EJS 3");
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template, opts);
      return templ.compile();
    };
    exports2.render = function(template, d2, o) {
      var data4 = d2 || utils2.createNullProtoObjWherePossible();
      var opts = o || utils2.createNullProtoObjWherePossible();
      if (arguments.length == 2) {
        utils2.shallowCopyFromList(opts, data4, _OPTS_PASSABLE_WITH_DATA);
      }
      return handleCache(opts, template)(data4);
    };
    exports2.renderFile = function() {
      var args = Array.prototype.slice.call(arguments);
      var filename = args.shift();
      var cb;
      var opts = { filename };
      var data4;
      var viewOpts;
      if (typeof arguments[arguments.length - 1] == "function") {
        cb = args.pop();
      }
      if (args.length) {
        data4 = args.shift();
        if (args.length) {
          utils2.shallowCopy(opts, args.pop());
        } else {
          if (data4.settings) {
            if (data4.settings.views) {
              opts.views = data4.settings.views;
            }
            if (data4.settings["view cache"]) {
              opts.cache = true;
            }
            viewOpts = data4.settings["view options"];
            if (viewOpts) {
              utils2.shallowCopy(opts, viewOpts);
            }
          }
          utils2.shallowCopyFromList(opts, data4, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
        }
        opts.filename = filename;
      } else {
        data4 = utils2.createNullProtoObjWherePossible();
      }
      return tryHandleCache(opts, data4, cb);
    };
    exports2.Template = Template;
    exports2.clearCache = function() {
      exports2.cache.reset();
    };
    function Template(text, optsParam) {
      var opts = utils2.hasOwnOnlyObject(optsParam);
      var options = utils2.createNullProtoObjWherePossible();
      this.templateText = text;
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = "";
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || opts.escapeFunction || utils2.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.openDelimiter = opts.openDelimiter || exports2.openDelimiter || _DEFAULT_OPEN_DELIMITER;
      options.closeDelimiter = opts.closeDelimiter || exports2.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
      options.delimiter = opts.delimiter || exports2.delimiter || _DEFAULT_DELIMITER;
      options.strict = opts.strict || false;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      options.root = opts.root;
      options.includer = opts.includer;
      options.outputFunctionName = opts.outputFunctionName;
      options.localsName = opts.localsName || exports2.localsName || _DEFAULT_LOCALS_NAME;
      options.views = opts.views;
      options.async = opts.async;
      options.destructuredLocals = opts.destructuredLocals;
      options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
      if (options.strict) {
        options._with = false;
      } else {
        options._with = typeof opts._with != "undefined" ? opts._with : true;
      }
      this.opts = options;
      this.regex = this.createRegex();
    }
    Template.modes = {
      EVAL: "eval",
      ESCAPED: "escaped",
      RAW: "raw",
      COMMENT: "comment",
      LITERAL: "literal"
    };
    Template.prototype = {
      createRegex: function() {
        var str = _REGEX_STRING;
        var delim = utils2.escapeRegExpChars(this.opts.delimiter);
        var open2 = utils2.escapeRegExpChars(this.opts.openDelimiter);
        var close = utils2.escapeRegExpChars(this.opts.closeDelimiter);
        str = str.replace(/%/g, delim).replace(/</g, open2).replace(/>/g, close);
        return new RegExp(str);
      },
      compile: function() {
        var src;
        var fn;
        var opts = this.opts;
        var prepended = "";
        var appended = "";
        var escapeFn = opts.escapeFunction;
        var ctor;
        var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
        if (!this.source) {
          this.generateSource();
          prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
          if (opts.outputFunctionName) {
            if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
              throw new Error("outputFunctionName is not a valid JS identifier.");
            }
            prepended += "  var " + opts.outputFunctionName + " = __append;\n";
          }
          if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
            throw new Error("localsName is not a valid JS identifier.");
          }
          if (opts.destructuredLocals && opts.destructuredLocals.length) {
            var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
            for (var i = 0; i < opts.destructuredLocals.length; i++) {
              var name = opts.destructuredLocals[i];
              if (!_JS_IDENTIFIER.test(name)) {
                throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
              }
              if (i > 0) {
                destructuring += ",\n  ";
              }
              destructuring += name + " = __locals." + name;
            }
            prepended += destructuring + ";\n";
          }
          if (opts._with !== false) {
            prepended += "  with (" + opts.localsName + " || {}) {\n";
            appended += "  }\n";
          }
          appended += "  return __output;\n";
          this.source = prepended + this.source + appended;
        }
        if (opts.compileDebug) {
          src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
        } else {
          src = this.source;
        }
        if (opts.client) {
          src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
          if (opts.compileDebug) {
            src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
          }
        }
        if (opts.strict) {
          src = '"use strict";\n' + src;
        }
        if (opts.debug) {
          console.log(src);
        }
        if (opts.compileDebug && opts.filename) {
          src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
        }
        try {
          if (opts.async) {
            try {
              ctor = new Function("return (async function(){}).constructor;")();
            } catch (e2) {
              if (e2 instanceof SyntaxError) {
                throw new Error("This environment does not support async/await");
              } else {
                throw e2;
              }
            }
          } else {
            ctor = Function;
          }
          fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
        } catch (e2) {
          if (e2 instanceof SyntaxError) {
            if (opts.filename) {
              e2.message += " in " + opts.filename;
            }
            e2.message += " while compiling ejs\n\n";
            e2.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
            e2.message += "https://github.com/RyanZim/EJS-Lint";
            if (!opts.async) {
              e2.message += "\n";
              e2.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
            }
          }
          throw e2;
        }
        var returnedFn = opts.client ? fn : function anonymous(data4) {
          var include = function(path2, includeData) {
            var d2 = utils2.shallowCopy(utils2.createNullProtoObjWherePossible(), data4);
            if (includeData) {
              d2 = utils2.shallowCopy(d2, includeData);
            }
            return includeFile(path2, opts)(d2);
          };
          return fn.apply(
            opts.context,
            [data4 || utils2.createNullProtoObjWherePossible(), escapeFn, include, rethrow]
          );
        };
        if (opts.filename && typeof Object.defineProperty === "function") {
          var filename = opts.filename;
          var basename = path.basename(filename, path.extname(filename));
          try {
            Object.defineProperty(returnedFn, "name", {
              value: basename,
              writable: false,
              enumerable: false,
              configurable: true
            });
          } catch (e2) {
          }
        }
        return returnedFn;
      },
      generateSource: function() {
        var opts = this.opts;
        if (opts.rmWhitespace) {
          this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
        }
        this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
        var self2 = this;
        var matches = this.parseTemplateText();
        var d2 = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c2 = this.opts.closeDelimiter;
        if (matches && matches.length) {
          matches.forEach(function(line, index) {
            var closing;
            if (line.indexOf(o + d2) === 0 && line.indexOf(o + d2 + d2) !== 0) {
              closing = matches[index + 2];
              if (!(closing == d2 + c2 || closing == "-" + d2 + c2 || closing == "_" + d2 + c2)) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            self2.scanLine(line);
          });
        }
      },
      parseTemplateText: function() {
        var str = this.templateText;
        var pat = this.regex;
        var result = pat.exec(str);
        var arr = [];
        var firstPos;
        while (result) {
          firstPos = result.index;
          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }
          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }
        if (str) {
          arr.push(str);
        }
        return arr;
      },
      _addOutput: function(line) {
        if (this.truncate) {
          line = line.replace(/^(?:\r\n|\r|\n)/, "");
          this.truncate = false;
        }
        if (!line) {
          return line;
        }
        line = line.replace(/\\/g, "\\\\");
        line = line.replace(/\n/g, "\\n");
        line = line.replace(/\r/g, "\\r");
        line = line.replace(/"/g, '\\"');
        this.source += '    ; __append("' + line + '")\n';
      },
      scanLine: function(line) {
        var self2 = this;
        var d2 = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c2 = this.opts.closeDelimiter;
        var newLineCount = 0;
        newLineCount = line.split("\n").length - 1;
        switch (line) {
          case o + d2:
          case o + d2 + "_":
            this.mode = Template.modes.EVAL;
            break;
          case o + d2 + "=":
            this.mode = Template.modes.ESCAPED;
            break;
          case o + d2 + "-":
            this.mode = Template.modes.RAW;
            break;
          case o + d2 + "#":
            this.mode = Template.modes.COMMENT;
            break;
          case o + d2 + d2:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(o + d2 + d2, o + d2) + '")\n';
            break;
          case d2 + d2 + c2:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(d2 + d2 + c2, d2 + c2) + '")\n';
            break;
          case d2 + c2:
          case "-" + d2 + c2:
          case "_" + d2 + c2:
            if (this.mode == Template.modes.LITERAL) {
              this._addOutput(line);
            }
            this.mode = null;
            this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
            break;
          default:
            if (this.mode) {
              switch (this.mode) {
                case Template.modes.EVAL:
                case Template.modes.ESCAPED:
                case Template.modes.RAW:
                  if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                    line += "\n";
                  }
              }
              switch (this.mode) {
                // Just executing code
                case Template.modes.EVAL:
                  this.source += "    ; " + line + "\n";
                  break;
                // Exec, esc, and output
                case Template.modes.ESCAPED:
                  this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                  break;
                // Exec and output
                case Template.modes.RAW:
                  this.source += "    ; __append(" + stripSemi(line) + ")\n";
                  break;
                case Template.modes.COMMENT:
                  break;
                // Literal <%% mode, append as raw output
                case Template.modes.LITERAL:
                  this._addOutput(line);
                  break;
              }
            } else {
              this._addOutput(line);
            }
        }
        if (self2.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += "    ; __line = " + this.currentLine + "\n";
        }
      }
    };
    exports2.escapeXML = utils2.escapeXML;
    exports2.__express = exports2.renderFile;
    exports2.VERSION = _VERSION_STRING;
    exports2.name = _NAME;
    if (typeof window != "undefined") {
      window.ejs = exports2;
    }
  }
});

// ../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "../../node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits4, padding4, outputType) {
        return function(message) {
          return new Keccak2(bits4, padding4, bits4).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits4, padding4, outputType) {
        return function(message, outputBits) {
          return new Keccak2(bits4, padding4, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits4, padding4, outputType) {
        return function(message, outputBits, n3, s2) {
          return methods["cshake" + bits4].update(message, outputBits, n3, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits4, padding4, outputType) {
        return function(key, message, outputBits, s2) {
          return methods["kmac" + bits4].update(key, message, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits4, padding4) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits4, padding4, type);
        }
        return method;
      };
      var createMethod = function(bits4, padding4) {
        var method = createOutputMethod(bits4, padding4, "hex");
        method.create = function() {
          return new Keccak2(bits4, padding4, bits4);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits4, padding4);
      };
      var createShakeMethod = function(bits4, padding4) {
        var method = createShakeOutputMethod(bits4, padding4, "hex");
        method.create = function(outputBits) {
          return new Keccak2(bits4, padding4, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits4, padding4);
      };
      var createCshakeMethod = function(bits4, padding4) {
        var w = CSHAKE_BYTEPAD[bits4];
        var method = createCshakeOutputMethod(bits4, padding4, "hex");
        method.create = function(outputBits, n3, s2) {
          if (!n3 && !s2) {
            return methods["shake" + bits4].create(outputBits);
          } else {
            return new Keccak2(bits4, padding4, outputBits).bytepad([n3, s2], w);
          }
        };
        method.update = function(message, outputBits, n3, s2) {
          return method.create(outputBits, n3, s2).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits4, padding4);
      };
      var createKmacMethod = function(bits4, padding4) {
        var w = CSHAKE_BYTEPAD[bits4];
        var method = createKmacOutputMethod(bits4, padding4, "hex");
        method.create = function(key, outputBits, s2) {
          return new Kmac(bits4, padding4, outputBits).bytepad(["KMAC", s2], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s2) {
          return method.create(key, outputBits, s2).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits4, padding4);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits3 = algorithm.bits;
        for (var j = 0; j < bits3.length; ++j) {
          var methodName = algorithm.name + "_" + bits3[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits3[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits3[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak2(bits4, padding4, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding4;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits4 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak2.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s2[i2] ^= blocks[i2];
            }
            f2(s2);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak2.prototype.encode = function(x, right) {
        var o = x & 255, n3 = 1;
        var bytes2 = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes2.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n3;
        }
        if (right) {
          bytes2.push(n3);
        } else {
          bytes2.unshift(n3);
        }
        this.update(bytes2);
        return bytes2.length;
      };
      Keccak2.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes2 = 0, length = str.length;
        if (notString) {
          bytes2 = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes2 += 1;
            } else if (code < 2048) {
              bytes2 += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes2 += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes2 += 4;
            }
          }
        }
        bytes2 += this.encode(bytes2 * 8);
        this.update(str);
        return bytes2;
      };
      Keccak2.prototype.bytepad = function(strs, w) {
        var bytes2 = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes2 += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes2 % w;
        var zeros3 = [];
        zeros3.length = paddingBytes;
        this.update(zeros3);
        return this;
      };
      Keccak2.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s2[i2] ^= blocks[i2];
        }
        f2(s2);
      };
      Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex2 = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s2[i2];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f2(s2);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i2];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex2;
      };
      Keccak2.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes2 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes2);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s2[i2];
          }
          if (j2 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          array[i2] = s2[i2];
          buffer = buffer.slice(0, bytes2);
        }
        return buffer;
      };
      Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
      Keccak2.prototype.digest = Keccak2.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s2[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s2[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits4, padding4, outputBits) {
        Keccak2.call(this, bits4, padding4, outputBits);
      }
      Kmac.prototype = new Keccak2();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak2.prototype.finalize.call(this);
      };
      var f2 = function(s2) {
        var h, l, n3, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n3 = 0; n3 < 48; n3 += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h;
          s2[1] ^= l;
          s2[10] ^= h;
          s2[11] ^= l;
          s2[20] ^= h;
          s2[21] ^= l;
          s2[30] ^= h;
          s2[31] ^= l;
          s2[40] ^= h;
          s2[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h;
          s2[3] ^= l;
          s2[12] ^= h;
          s2[13] ^= l;
          s2[22] ^= h;
          s2[23] ^= l;
          s2[32] ^= h;
          s2[33] ^= l;
          s2[42] ^= h;
          s2[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h;
          s2[5] ^= l;
          s2[14] ^= h;
          s2[15] ^= l;
          s2[24] ^= h;
          s2[25] ^= l;
          s2[34] ^= h;
          s2[35] ^= l;
          s2[44] ^= h;
          s2[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h;
          s2[7] ^= l;
          s2[16] ^= h;
          s2[17] ^= l;
          s2[26] ^= h;
          s2[27] ^= l;
          s2[36] ^= h;
          s2[37] ^= l;
          s2[46] ^= h;
          s2[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h;
          s2[9] ^= l;
          s2[18] ^= h;
          s2[19] ^= l;
          s2[28] ^= h;
          s2[29] ^= l;
          s2[38] ^= h;
          s2[39] ^= l;
          s2[48] ^= h;
          s2[49] ^= l;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b22 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b222 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b22 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b222 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b22 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b222 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b22;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b222;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n3];
          s2[1] ^= RC[n3 + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream3(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data4 = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data4)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream3;
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/constants.js
var require_constants4 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/buffer-util.js
var require_buffer_util2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants4();
    function concat4(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask4, output2, offset, length) {
      for (let i = 0; i < length; i++) {
        output2[offset + i] = source[i] ^ mask4[i & 3];
      }
    }
    function _unmask(buffer, mask4) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask4[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data4) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data4)) return data4;
      let buf;
      if (data4 instanceof ArrayBuffer) {
        buf = Buffer.from(data4);
      } else if (ArrayBuffer.isView(data4)) {
        buf = Buffer.from(data4.buffer, data4.byteOffset, data4.byteLength);
      } else {
        buf = Buffer.from(data4);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      module2.exports = {
        concat: concat4,
        mask(source, mask4, output2, offset, length) {
          if (length < 48) _mask(source, mask4, output2, offset, length);
          else bufferUtil.mask(source, mask4, output2, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask4) {
          if (buffer.length < 32) _unmask(buffer, mask4);
          else bufferUtil.unmask(buffer, mask4);
        }
      };
    } catch (e2) {
      module2.exports = {
        concat: concat4,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/limiter.js
var require_limiter2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util2();
    var Limiter = require_limiter2();
    var { kStatusCode } = require_constants4();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data4, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data4, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data4, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data4, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data4, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data4);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data5 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data5);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data4, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data4);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data5 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) data5 = data5.slice(0, data5.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data5);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/validation.js
var require_validation4 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF8 = require("utf-8-validate");
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        },
        tokenChars
      };
    } catch (e2) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
    }
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants4();
    var { concat: concat4, toArrayBuffer, unmask } = require_buffer_util2();
    var { isValidStatusCode, isValidUTF8 } = require_validation4();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver3 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n3) {
        this._bufferedBytes -= n3;
        if (n3 === this._buffers[0].length) return this._buffers.shift();
        if (n3 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n3);
          return buf.slice(0, n3);
        }
        const dst = Buffer.allocUnsafe(n3);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n3;
          if (n3 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), offset);
            this._buffers[0] = buf.slice(n3);
          }
          n3 -= buf.length;
        } while (n3 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data4 = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data4 = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data4, this._mask);
          }
        }
        if (this._opcode > 7) return this.controlMessage(data4);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data4, cb);
          return;
        }
        if (data4.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data4);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data4, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data4, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data4;
            if (this._binaryType === "nodebuffer") {
              data4 = concat4(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data4 = toArrayBuffer(concat4(fragments, messageLength));
            } else {
              data4 = fragments;
            }
            this.emit("message", data4, true);
          } else {
            const buf = concat4(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data4) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data4.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data4.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data4.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data4.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data4);
        } else {
          this.emit("pong", data4);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver3;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/sender.js
var require_sender2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate2();
    var { EMPTY_BUFFER } = require_constants4();
    var { isValidStatusCode } = require_validation4();
    var { mask: applyMask, toBuffer } = require_buffer_util2();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender3 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data4, options) {
        let mask4;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask4 = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask4);
          } else {
            randomFillSync(mask4, 0, 4);
          }
          skipMasking = (mask4[0] | mask4[1] | mask4[2] | mask4[3]) === 0;
          offset = 6;
        }
        let dataLength4;
        if (typeof data4 === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength4 = options[kByteLength];
          } else {
            data4 = Buffer.from(data4);
            dataLength4 = data4.length;
          }
        } else {
          dataLength4 = data4.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength4;
        if (dataLength4 >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength4 > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength4 + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength4, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength4, 4, 6);
        }
        if (!options.mask) return [target, data4];
        target[1] |= 128;
        target[offset - 4] = mask4[0];
        target[offset - 3] = mask4[1];
        target[offset - 2] = mask4[2];
        target[offset - 1] = mask4[3];
        if (skipMasking) return [target, data4];
        if (merge) {
          applyMask(data4, mask4, target, offset, dataLength4);
          return [target];
        }
        applyMask(data4, mask4, data4, 0, dataLength4);
        return [target, data4];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data4, mask4, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data4 === void 0 || !data4.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data4);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data4 === "string") {
            buf.write(data4, 2);
          } else {
            buf.set(data4, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data4, mask4, cb) {
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data4, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data4, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data4, mask4, cb) {
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask4,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data4, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data4, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data4, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data4 === "string") {
          byteLength = Buffer.byteLength(data4);
          readOnly = false;
        } else {
          data4 = toBuffer(data4);
          byteLength = data4.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data4, this._compress, opts, cb]);
          } else {
            this.dispatch(data4, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data4, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data4, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data4, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data4, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender3;
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/event-target.js
var require_event_target2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants4();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data4, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data4 : data4.toString()
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = listener;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/extension.js
var require_extension2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation4();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start2 = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start2 !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start2, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start2 !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start2, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start2 = end = -1;
          } else if (code === 61 && start2 !== -1 && end === -1) {
            paramName = header.slice(start2, i);
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start2 === -1) start2 = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start2 === -1) start2 = i;
            } else if (code === 34 && start2 !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (start2 !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start2 === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start2, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start2 = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start2 === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start2, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https3 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes5, createHash: createHash2 } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate2();
    var Receiver3 = require_receiver2();
    var Sender3 = require_sender2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants4();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target2();
    var { format, parse } = require_extension2();
    var { toBuffer } = require_buffer_util2();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket3 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver3({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender3(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data4) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data4, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data4, mask4, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data4 === "function") {
          cb = data4;
          data4 = mask4 = void 0;
        } else if (typeof mask4 === "function") {
          cb = mask4;
          mask4 = void 0;
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        if (mask4 === void 0) mask4 = !this._isServer;
        this._sender.ping(data4 || EMPTY_BUFFER, mask4, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data4, mask4, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data4 === "function") {
          cb = data4;
          data4 = mask4 = void 0;
        } else if (typeof mask4 === "function") {
          cb = mask4;
          mask4 = void 0;
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        if (mask4 === void 0) mask4 = !this._isServer;
        this._sender.pong(data4 || EMPTY_BUFFER, mask4, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data4, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data4 === "number") data4 = data4.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data4, cb);
          return;
        }
        const opts = {
          binary: typeof data4 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data4 || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes5(16).toString("base64");
      const get = isSecure ? https3.get : http3.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalHost = parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (parsedUrl.host !== websocket._originalHost) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          delete opts.headers.host;
          opts.auth = void 0;
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING) return;
        req = websocket._req = null;
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data4, cb) {
      if (data4) {
        const length = toBuffer(data4).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data4, isBinary) {
      this[kWebSocket].emit("message", data4, isBinary);
    }
    function receiverOnPing(data4) {
      const websocket = this[kWebSocket];
      websocket.pong(data4, !websocket._isServer, NOOP);
      websocket.emit("ping", data4);
    }
    function receiverOnPong(data4) {
      this[kWebSocket].emit("pong", data4);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/subprotocol.js
var require_subprotocol2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation4();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start2 = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start2 === -1) start2 = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start2 !== -1) end = i;
        } else if (code === 44) {
          if (start2 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start2, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start2 = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start2 === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start2, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/websocket-server.js
var require_websocket_server2 = __commonJS({
  "../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http3 = require("http");
    var https3 = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash: createHash2 } = require("crypto");
    var extension = require_extension2();
    var PerMessageDeflate = require_permessage_deflate2();
    var subprotocol = require_subprotocol2();
    var WebSocket3 = require_websocket2();
    var { GUID, kWebSocket } = require_constants4();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer3 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http3.createServer((req, res) => {
            const body = http3.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"] : false;
        const version4 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version4 !== 8 && version4 !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer3;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http3.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
  }
});

// index.ts
var relayer_exports = {};
__export(relayer_exports, {
  router: () => router
});
module.exports = __toCommonJS(relayer_exports);
var import_fastify = __toESM(require_fastify());

// ../../node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object3) => {
    const keys = [];
    for (const key in object3) {
      if (Object.prototype.hasOwnProperty.call(object3, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data4) => {
  const t = typeof data4;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data4) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data4)) {
        return ZodParsedType.array;
      }
      if (data4 === null) {
        return ZodParsedType.null;
      }
      if (data4.then && typeof data4.then === "function" && data4.catch && typeof data4.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data4 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data4 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data4 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub2) => {
      this.issues = [...this.issues, sub2];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub2 of this.issues) {
      if (sub2.path.length > 0) {
        fieldErrors[sub2.path[0]] = fieldErrors[sub2.path[0]] || [];
        fieldErrors[sub2.path[0]].push(mapper(sub2));
      } else {
        formErrors.push(mapper(sub2));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data: data4, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data4, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data4, params) {
    const result = this.safeParse(data4, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data4, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data4,
      parsedType: getParsedType(data4)
    };
    const result = this._parseSync({ data: data4, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data4, params) {
    const result = await this.safeParseAsync(data4, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data4, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data4,
      parsedType: getParsedType(data4)
    };
    const maybeAsyncResult = this._parse({ data: data4, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data4) => {
          if (!data4) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data4) => regex.test(data4), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask4) {
    const shape = {};
    util.objectKeys(mask4).forEach((key) => {
      if (mask4[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask4) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask4[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask4) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask4 && !mask4[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask4) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask4 && !mask4[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b3) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b3);
  if (a2 === b3) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b3) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data4) => {
      return this._def.type.parseAsync(data4, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data4 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data4 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data4,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data4 = ctx.data;
    return this._def.type._parse({
      data: data4,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b3) {
    return new _ZodPipeline({
      in: a2,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data4) => {
      if (isValid(data4)) {
        data4.value = Object.freeze(data4.value);
      }
      return data4;
    };
    return isAsync(result) ? result.then((data4) => freeze(data4)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data4, ctx) => {
      var _a, _b;
      if (!check(data4)) {
        const p = typeof params === "function" ? params(data4) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data4) => data4 instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../../node_modules/.pnpm/@ts-rest+core@3.51.0_@types+node@20.17.9_zod@3.23.8/node_modules/@ts-rest/core/index.esm.mjs
var isZodType = (obj) => {
  return typeof (obj === null || obj === void 0 ? void 0 : obj.safeParse) === "function";
};
var isZodObjectStrict = (obj) => {
  return typeof (obj === null || obj === void 0 ? void 0 : obj.passthrough) === "function";
};
var zodMerge = (objectA, objectB) => {
  if (isZodObjectStrict(objectA)) {
    if (isZodObjectStrict(objectB)) {
      return objectA.merge(objectB);
    }
    return objectA;
  }
  if (isZodObjectStrict(objectB)) {
    return objectB;
  }
  return Object.assign({}, objectA, objectB);
};
var checkZodSchema = (data4, schema, { passThroughExtraKeys = false } = {}) => {
  if (isZodType(schema)) {
    const result = schema.safeParse(data4);
    if (result.success) {
      return {
        success: true,
        data: passThroughExtraKeys && typeof data4 === "object" ? { ...data4, ...result.data } : result.data
      };
    }
    return {
      success: false,
      error: result.error
    };
  }
  return {
    success: true,
    data: data4
  };
};
var ZodErrorSchema = z.object({
  name: z.literal("ZodError"),
  issues: z.array(z.object({
    path: z.array(z.union([z.string(), z.number()])),
    message: z.string().optional(),
    code: z.nativeEnum(z.ZodIssueCode)
  }).catchall(z.any()))
});
var ContractNoBody = Symbol("ContractNoBody");
var isAppRoute = (obj) => {
  return "method" in obj && "path" in obj;
};
var recursivelyApplyOptions = (router2, options) => {
  return Object.fromEntries(Object.entries(router2).map(([key, value]) => {
    var _a, _b, _c;
    if (isAppRoute(value)) {
      return [
        key,
        {
          ...value,
          path: (options === null || options === void 0 ? void 0 : options.pathPrefix) ? options.pathPrefix + value.path : value.path,
          headers: zodMerge(options === null || options === void 0 ? void 0 : options.baseHeaders, value.headers),
          strictStatusCodes: (_a = value.strictStatusCodes) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.strictStatusCodes,
          validateResponseOnClient: (_b = value.validateResponseOnClient) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.validateResponseOnClient,
          responses: {
            ...options === null || options === void 0 ? void 0 : options.commonResponses,
            ...value.responses
          },
          metadata: (options === null || options === void 0 ? void 0 : options.metadata) ? {
            ...options === null || options === void 0 ? void 0 : options.metadata,
            ...(_c = value.metadata) !== null && _c !== void 0 ? _c : {}
          } : value.metadata
        }
      ];
    } else {
      return [key, recursivelyApplyOptions(value, options)];
    }
  }));
};
var ContractPlainTypeRuntimeSymbol = Symbol("ContractPlainType");
var initContract = () => {
  return {
    // @ts-expect-error - this is a type error, but it's not clear how to fix it
    router: (endpoints, options) => recursivelyApplyOptions(endpoints, options),
    query: (args) => args,
    mutation: (args) => args,
    responses: (args) => args,
    response: () => ContractPlainTypeRuntimeSymbol,
    body: () => ContractPlainTypeRuntimeSymbol,
    type: () => ContractPlainTypeRuntimeSymbol,
    otherResponse: ({ contentType, body }) => ({
      contentType,
      body
    }),
    noBody: () => ContractNoBody
  };
};
var parseJsonQueryObject = (query) => {
  return Object.fromEntries(Object.entries(query).map(([key, value]) => {
    let parsedValue;
    try {
      parsedValue = JSON.parse(value);
    } catch {
      parsedValue = value;
    }
    return [key, parsedValue];
  }));
};
var ResponseValidationError = class extends Error {
  constructor(appRoute, cause) {
    super(`[ts-rest] Response validation failed for ${appRoute.method} ${appRoute.path}: ${cause.message}`);
    this.appRoute = appRoute;
    this.cause = cause;
  }
};
var isAppRouteResponse = (value) => {
  return value != null && typeof value === "object" && "status" in value && typeof value.status === "number";
};
var isAppRouteOtherResponse = (response) => {
  return response != null && typeof response === "object" && "contentType" in response;
};
var isAppRouteNoBody = (response) => {
  return response === ContractNoBody;
};
var validateResponse = ({ appRoute, response }) => {
  if (isAppRouteResponse(response)) {
    const responseType = appRoute.responses[response.status];
    const responseSchema = isAppRouteOtherResponse(responseType) ? responseType.body : responseType;
    const responseValidation = checkZodSchema(response.body, responseSchema);
    if (!responseValidation.success) {
      throw new ResponseValidationError(appRoute, responseValidation.error);
    }
    return {
      status: response.status,
      body: responseValidation.data
    };
  }
  return response;
};
var TsRestResponseError = class extends Error {
  constructor(route, response) {
    super();
    this.statusCode = response.status;
    this.body = response.body;
    this.name = this.constructor.name;
    if (typeof response.body === "string") {
      this.message = response.body;
    } else if (typeof response.body === "object" && response.body !== null && "message" in response.body && typeof response.body.message === "string") {
      this.message = response.body["message"];
    } else {
      this.message = "Error";
    }
  }
};

// ../../node_modules/.pnpm/@ts-rest+fastify@3.51.0_@ts-rest+core@3.51.0_@types+node@20.17.9_zod@3.23.8__fastify@5.1.0_zod@3.23.8/node_modules/@ts-rest/fastify/index.esm.mjs
var RequestValidationError = class extends Error {
  constructor(pathParams, headers, query, body) {
    super("[ts-rest] request validation failed");
    this.pathParams = pathParams;
    this.headers = headers;
    this.query = query;
    this.body = body;
  }
};
var RequestValidationErrorSchema = z.object({
  pathParameterErrors: ZodErrorSchema.nullable(),
  headerErrors: ZodErrorSchema.nullable(),
  queryParameterErrors: ZodErrorSchema.nullable(),
  bodyErrors: ZodErrorSchema.nullable()
});
var isAppRouteImplementation = (obj) => {
  return typeof obj === "function";
};
var validateRequest = (request, reply, schema, options) => {
  const paramsResult = checkZodSchema(request.params, schema.pathParams, {
    passThroughExtraKeys: true
  });
  const headersResult = checkZodSchema(request.headers, schema.headers, {
    passThroughExtraKeys: true
  });
  const queryResult = checkZodSchema(options.jsonQuery ? parseJsonQueryObject(request.query) : request.query, schema.query);
  const bodyResult = checkZodSchema(request.body, "body" in schema ? schema.body : null);
  if (!paramsResult.success || !headersResult.success || !queryResult.success || !bodyResult.success) {
    throw new RequestValidationError(paramsResult.success ? null : paramsResult.error, headersResult.success ? null : headersResult.error, queryResult.success ? null : queryResult.error, bodyResult.success ? null : bodyResult.error);
  }
  return {
    paramsResult,
    headersResult,
    queryResult,
    bodyResult
  };
};
var RouterEmbeddedContract = Symbol("RouterEmbeddedContract");
var initServer = () => ({
  router: (contract2, routes) => ({
    ...routes,
    [RouterEmbeddedContract]: contract2
  }),
  route: (route, implementation) => implementation,
  registerRouter: (contract2, routerImpl, app2, options = {
    logInitialization: true,
    jsonQuery: false,
    responseValidation: false,
    requestValidationErrorHandler: "combined"
  }) => {
    const { hooks = {}, ...restOfOptions } = options;
    Object.entries(hooks).forEach(([hookName, hookOrHookArray]) => {
      if (Array.isArray(hookOrHookArray)) {
        hookOrHookArray.forEach((hook) => {
          app2.addHook(hookName, hook);
        });
        return;
      } else {
        app2.addHook(hookName, hookOrHookArray);
      }
    });
    recursivelyRegisterRouter(routerImpl, contract2, [], app2, restOfOptions);
    app2.setErrorHandler(requestValidationErrorHandler(options.requestValidationErrorHandler));
  },
  plugin: (router2) => (app2, opts = {
    logInitialization: true,
    jsonQuery: false,
    responseValidation: false,
    requestValidationErrorHandler: "combined"
  }, done) => {
    const embeddedContract = router2[RouterEmbeddedContract];
    const { hooks = {}, ...restOfOptions } = opts;
    Object.entries(hooks).forEach(([hookName, hookOrHookArray]) => {
      if (Array.isArray(hookOrHookArray)) {
        hookOrHookArray.forEach((hook) => {
          app2.addHook(hookName, hook);
        });
        return;
      } else {
        app2.addHook(hookName, hookOrHookArray);
      }
    });
    recursivelyRegisterRouter(router2, embeddedContract, [], app2, restOfOptions);
    app2.setErrorHandler(requestValidationErrorHandler(opts.requestValidationErrorHandler));
    done();
  }
});
var requestValidationErrorHandler = (handler = "combined") => {
  return (err, request, reply) => {
    if (err instanceof RequestValidationError) {
      if (handler === "combined") {
        return reply.status(400).send({
          pathParameterErrors: err.pathParams,
          headerErrors: err.headers,
          queryParameterErrors: err.query,
          bodyErrors: err.body
        });
      } else {
        return handler(err, request, reply);
      }
    } else {
      return reply.send(err);
    }
  };
};
var registerRoute = (routeImpl, appRoute, app2, options) => {
  if (options.logInitialization) {
    app2.log.info(`[ts-rest] Initialized ${appRoute.method} ${appRoute.path}`);
  }
  const handler = isAppRouteImplementation(routeImpl) ? routeImpl : routeImpl.handler;
  const hooks = isAppRouteImplementation(routeImpl) ? {} : routeImpl.hooks || {};
  const route = {
    ...hooks,
    method: appRoute.method,
    url: appRoute.path,
    config: {
      tsRestRoute: appRoute
    },
    handler: async (request, reply) => {
      const validationResults = validateRequest(request, reply, appRoute, options);
      let result;
      try {
        result = await handler({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          params: validationResults.paramsResult.data,
          query: validationResults.queryResult.data,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          headers: validationResults.headersResult.data,
          request,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          body: validationResults.bodyResult.data,
          reply,
          appRoute
        });
      } catch (e2) {
        if (e2 instanceof TsRestResponseError) {
          result = {
            status: e2.statusCode,
            body: e2.body
          };
        } else {
          throw e2;
        }
      }
      const statusCode = result.status;
      let validatedResponseBody = result.body;
      if (options.responseValidation) {
        const response = validateResponse({
          appRoute,
          response: {
            status: statusCode,
            body: result.body
          }
        });
        validatedResponseBody = response.body;
      }
      const responseType = appRoute.responses[statusCode];
      if (isAppRouteNoBody(responseType)) {
        return reply.status(statusCode).send();
      }
      if (isAppRouteOtherResponse(responseType)) {
        reply.header("content-type", responseType.contentType);
      }
      return reply.status(statusCode).send(validatedResponseBody);
    }
  };
  app2.route(route);
};
var recursivelyRegisterRouter = (routerImpl, appRouter, path, fastify, options) => {
  if (typeof routerImpl === "object" && typeof (routerImpl === null || routerImpl === void 0 ? void 0 : routerImpl["handler"]) !== "function") {
    for (const key in routerImpl) {
      recursivelyRegisterRouter(routerImpl[key], appRouter[key], [...path, key], fastify, options);
    }
  } else if (typeof routerImpl === "function" || typeof (routerImpl === null || routerImpl === void 0 ? void 0 : routerImpl["handler"]) === "function") {
    registerRoute(routerImpl, appRouter, fastify, options);
  }
};

// contract.ts
var c = initContract();
var PostVoteSchema = z.object({
  groupId: z.string(),
  identityPk: z.string(),
  vote: z.string()
});
var contract = c.router({
  vote: {
    method: "POST",
    path: "/vote/",
    body: PostVoteSchema,
    responses: {
      200: null
    },
    summary: "Vote"
  }
});

// index.ts
var import_cors = __toESM(require_cors());

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  AbiCoder: () => AbiCoder,
  AbstractProvider: () => AbstractProvider,
  AbstractSigner: () => AbstractSigner,
  AlchemyProvider: () => AlchemyProvider,
  AnkrProvider: () => AnkrProvider,
  BaseContract: () => BaseContract,
  BaseWallet: () => BaseWallet,
  Block: () => Block,
  BrowserProvider: () => BrowserProvider,
  ChainstackProvider: () => ChainstackProvider,
  CloudflareProvider: () => CloudflareProvider,
  ConstructorFragment: () => ConstructorFragment,
  Contract: () => Contract,
  ContractEventPayload: () => ContractEventPayload,
  ContractFactory: () => ContractFactory,
  ContractTransactionReceipt: () => ContractTransactionReceipt,
  ContractTransactionResponse: () => ContractTransactionResponse,
  ContractUnknownEventPayload: () => ContractUnknownEventPayload,
  EnsPlugin: () => EnsPlugin,
  EnsResolver: () => EnsResolver,
  ErrorDescription: () => ErrorDescription,
  ErrorFragment: () => ErrorFragment,
  EtherSymbol: () => EtherSymbol,
  EtherscanPlugin: () => EtherscanPlugin,
  EtherscanProvider: () => EtherscanProvider,
  EventFragment: () => EventFragment,
  EventLog: () => EventLog,
  EventPayload: () => EventPayload,
  FallbackFragment: () => FallbackFragment,
  FallbackProvider: () => FallbackProvider,
  FeeData: () => FeeData,
  FeeDataNetworkPlugin: () => FeeDataNetworkPlugin,
  FetchCancelSignal: () => FetchCancelSignal,
  FetchRequest: () => FetchRequest,
  FetchResponse: () => FetchResponse,
  FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin,
  FixedNumber: () => FixedNumber,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  GasCostPlugin: () => GasCostPlugin,
  HDNodeVoidWallet: () => HDNodeVoidWallet,
  HDNodeWallet: () => HDNodeWallet,
  Indexed: () => Indexed,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  Interface: () => Interface,
  IpcSocketProvider: () => IpcSocketProvider,
  JsonRpcApiProvider: () => JsonRpcApiProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  LangEn: () => LangEn,
  Log: () => Log,
  LogDescription: () => LogDescription,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MessagePrefix: () => MessagePrefix,
  MinInt256: () => MinInt256,
  Mnemonic: () => Mnemonic,
  MulticoinProviderPlugin: () => MulticoinProviderPlugin,
  N: () => N,
  NamedFragment: () => NamedFragment,
  Network: () => Network,
  NetworkPlugin: () => NetworkPlugin,
  NonceManager: () => NonceManager,
  ParamType: () => ParamType,
  PocketProvider: () => PocketProvider,
  QuickNodeProvider: () => QuickNodeProvider,
  Result: () => Result,
  Signature: () => Signature,
  SigningKey: () => SigningKey,
  SocketBlockSubscriber: () => SocketBlockSubscriber,
  SocketEventSubscriber: () => SocketEventSubscriber,
  SocketPendingSubscriber: () => SocketPendingSubscriber,
  SocketProvider: () => SocketProvider,
  SocketSubscriber: () => SocketSubscriber,
  StructFragment: () => StructFragment,
  Transaction: () => Transaction,
  TransactionDescription: () => TransactionDescription,
  TransactionReceipt: () => TransactionReceipt,
  TransactionResponse: () => TransactionResponse,
  Typed: () => Typed,
  TypedDataEncoder: () => TypedDataEncoder,
  UndecodedEventLog: () => UndecodedEventLog,
  UnmanagedSubscriber: () => UnmanagedSubscriber,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  WebSocketProvider: () => WebSocketProvider,
  WeiPerEther: () => WeiPerEther,
  Wordlist: () => Wordlist,
  WordlistOwl: () => WordlistOwl,
  WordlistOwlA: () => WordlistOwlA,
  ZeroAddress: () => ZeroAddress,
  ZeroHash: () => ZeroHash,
  accessListify: () => accessListify,
  assert: () => assert,
  assertArgument: () => assertArgument,
  assertArgumentCount: () => assertArgumentCount,
  assertNormalize: () => assertNormalize,
  assertPrivate: () => assertPrivate,
  checkResultErrors: () => checkResultErrors,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  concat: () => concat,
  copyRequest: () => copyRequest,
  dataLength: () => dataLength,
  dataSlice: () => dataSlice,
  decodeBase58: () => decodeBase58,
  decodeBase64: () => decodeBase64,
  decodeBytes32String: () => decodeBytes32String,
  decodeRlp: () => decodeRlp,
  decryptCrowdsaleJson: () => decryptCrowdsaleJson,
  decryptKeystoreJson: () => decryptKeystoreJson,
  decryptKeystoreJsonSync: () => decryptKeystoreJsonSync,
  defaultPath: () => defaultPath2,
  defineProperties: () => defineProperties,
  dnsEncode: () => dnsEncode,
  encodeBase58: () => encodeBase58,
  encodeBase64: () => encodeBase64,
  encodeBytes32String: () => encodeBytes32String,
  encodeRlp: () => encodeRlp,
  encryptKeystoreJson: () => encryptKeystoreJson,
  encryptKeystoreJsonSync: () => encryptKeystoreJsonSync,
  ensNormalize: () => ensNormalize,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  fromTwos: () => fromTwos,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getBigInt: () => getBigInt,
  getBytes: () => getBytes,
  getBytesCopy: () => getBytesCopy,
  getCreate2Address: () => getCreate2Address,
  getCreateAddress: () => getCreateAddress,
  getDefaultProvider: () => getDefaultProvider,
  getIcapAddress: () => getIcapAddress,
  getIndexedAccountPath: () => getIndexedAccountPath,
  getNumber: () => getNumber,
  getUint: () => getUint,
  hashMessage: () => hashMessage,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isAddressable: () => isAddressable,
  isBytesLike: () => isBytesLike,
  isCallException: () => isCallException,
  isCrowdsaleJson: () => isCrowdsaleJson,
  isError: () => isError,
  isHexString: () => isHexString,
  isKeystoreJson: () => isKeystoreJson,
  isValidName: () => isValidName,
  keccak256: () => keccak256,
  lock: () => lock,
  makeError: () => makeError,
  mask: () => mask,
  namehash: () => namehash,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits,
  pbkdf2: () => pbkdf2,
  randomBytes: () => randomBytes3,
  recoverAddress: () => recoverAddress,
  resolveAddress: () => resolveAddress,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd1602,
  scrypt: () => scrypt2,
  scryptSync: () => scryptSync,
  sha256: () => sha2562,
  sha512: () => sha512,
  showThrottleMessage: () => showThrottleMessage,
  solidityPacked: () => solidityPacked,
  solidityPackedKeccak256: () => solidityPackedKeccak256,
  solidityPackedSha256: () => solidityPackedSha256,
  stripZerosLeft: () => stripZerosLeft,
  toBeArray: () => toBeArray,
  toBeHex: () => toBeHex,
  toBigInt: () => toBigInt,
  toNumber: () => toNumber,
  toQuantity: () => toQuantity,
  toTwos: () => toTwos,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  uuidV4: () => uuidV4,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  version: () => version,
  wordlists: () => wordlists2,
  zeroPadBytes: () => zeroPadBytes,
  zeroPadValue: () => zeroPadValue
});

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/_version.js
var version = "6.13.4";

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/properties.js
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/errors.js
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value, name, copy7) {
  if (value instanceof Uint8Array) {
    if (copy7) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
var HexCharacters = "0123456789abcdef";
function hexlify(data4) {
  const bytes2 = getBytes(data4);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d2) => hexlify(d2).substring(2)).join("");
}
function dataLength(data4) {
  if (isHexString(data4, true)) {
    return (data4.length - 2) / 2;
  }
  return getBytes(data4).length;
}
function dataSlice(data4, start2, end) {
  const bytes2 = getBytes(data4);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start2 == null ? 0 : start2, end == null ? bytes2.length : end));
}
function stripZerosLeft(data4) {
  let bytes2 = hexlify(data4).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data4, length, left) {
  const bytes2 = getBytes(data4);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data4, length) {
  return zeroPad(data4, length, true);
}
function zeroPadBytes(data4, length) {
  return zeroPad(data4, length, false);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/maths.js
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1) {
    const mask4 = (BN_1 << width) - BN_1;
    return -((~value & mask4) + BN_1);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask4 = (BN_1 << width) - BN_1;
    return (~value & mask4) + BN_1;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask(_value, _bits) {
  const value = getUint(_value, "value");
  const bits3 = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits3) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
var Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e2) {
        assertArgument(false, `invalid numeric string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex2 = value.toString(16);
  if (hex2.length % 2) {
    hex2 = "0" + hex2;
  }
  const result = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex2.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/base58.js
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
function encodeBase58(_value) {
  const bytes2 = getBytes(_value);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/base64.js
function decodeBase64(value) {
  return getBytesCopy(Buffer.from(value, "base64"));
}
function encodeBase64(data4) {
  return Buffer.from(getBytes(data4)).toString("base64");
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/events.js
var EventPayload = class {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2, output2, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c2 = bytes2[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/geturl.js
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_zlib = require("zlib");
function createGetUrl(options) {
  async function getUrl(req, signal) {
    assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options) {
      if (options.agent) {
        reqOptions.agent = options.agent;
      }
    }
    let abort = null;
    try {
      abort = new AbortController();
      reqOptions.abort = abort.signal;
    } catch (e2) {
      console.log(e2);
    }
    const request = (protocol === "http" ? import_http.default : import_https.default).request(req.url, reqOptions);
    request.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request.write(Buffer.from(body));
    }
    request.end();
    return new Promise((resolve, reject) => {
      if (signal) {
        signal.addListener(() => {
          if (abort) {
            abort.abort();
          }
          reject(makeError("request cancelled", "CANCELLED"));
        });
      }
      request.on("timeout", () => {
        reject(makeError("request timeout", "TIMEOUT"));
      });
      request.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
          let value = resp.headers[name] || "";
          if (Array.isArray(value)) {
            value = value.join(", ");
          }
          accum[name] = value;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error) {
              return reject(error);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          if (headers2["content-encoding"] === "gzip" && body2) {
            body2 = getBytes((0, import_zlib.gunzipSync)(body2));
          }
          resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
        });
        resp.on("error", (error) => {
          error.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject(error);
        });
      });
      request.on("error", (error) => {
        reject(error);
      });
    });
  }
  return getUrl;
}
var defaultGetUrl = createGetUrl({});

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var defaultGetUrlFunc = createGetUrl();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
var Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = /* @__PURE__ */ new WeakMap();
var FetchCancelSignal = class {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
};
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
var FetchRequest = class _FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    ;
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process2) {
    this.#process = process2;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert(getTime() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        ;
        if (error.stall >= 0) {
          delay2 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#throttle = Object.assign({}, this.#throttle);
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
var FetchResponse = class _FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall6) {
    if (stall6 == null) {
      stall6 = -1;
    } else {
      assertArgument(Number.isInteger(stall6) && stall6 >= 0, "invalid stall timeout", "stall", stall6);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall6, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e2) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/fixednumber.js
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}
function getTens(decimals) {
  let result = Zeros;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_12 << width - BN_12;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {
    } else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v = value;
    const check = (key, type, defaultValue) => {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
var FixedNumber = class _FixedNumber {
  /**
   *  The specific fixed-point arithmetic field for this value.
   */
  format;
  #format;
  // The actual value (accounting for decimals)
  #val;
  // A base-10 value to multiple values by to maintain the magnitude
  #tens;
  /**
   *  This is a property so console.log shows a human-meaningful value.
   *
   *  @private
   */
  _value;
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format) {
    assertPrivate(guard, _guard, "FixedNumber");
    this.#val = value;
    this.#format = format;
    const _value = toString(value, format.decimals);
    defineProperties(this, { format: format.name, _value });
    this.#tens = getTens(format.decimals);
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return this.#format.signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return this.#format.width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return this.#format.decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new _FixedNumber(_guard, val, this.#format);
  }
  #add(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val + o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return this.#add(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val - o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return this.#sub(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return this.#mul(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return this.#mul(other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert(value % this.#tens === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o, safeOp) {
    assert(o.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o);
    return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return this.#div(other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return this.#div(other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(other.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert(value % other.#val === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b3 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b3 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b3) {
      return -1;
    }
    if (a2 > b3) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = this.#val;
    if (this.#val < BN_03) {
      val -= this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_03) {
      val += this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, this.#format, "round");
    return new _FixedNumber(_guard, value, this.#format);
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return this.#val === BN_03;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return this.#val < BN_03;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format) {
    return _FixedNumber.fromString(this.toString(), format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format = getFormat(_format2);
    let value = getBigInt(_value, "value");
    const delta = decimals - format.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format, "fromValue");
    return new _FixedNumber(_guard, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value, _format2) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format.decimals) {
      decimal += Zeros;
    }
    assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format, "fromString");
    return new _FixedNumber(_guard, value, format);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value, _format2) {
    let value = toBigInt(getBytes(_value, "value"));
    const format = getFormat(_format2);
    if (format.signed) {
      value = fromTwos(value, format.width);
    }
    checkValue(value, format, "fromBytes");
    return new _FixedNumber(_guard, value, format);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data4, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data4[offset + i];
  }
  return result;
}
function _decodeChildren(data4, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data4, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data4,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data4, offset) {
  assert(data4.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data4,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data4.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data4,
      length: data4.length,
      offset: offset2
    });
  };
  if (data4[offset] >= 248) {
    const lengthLength = data4[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data4, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data4, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data4[offset] >= 192) {
    const length = data4[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data4, offset, offset + 1, length);
  } else if (data4[offset] >= 184) {
    const lengthLength = data4[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data4, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data4.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data4[offset] >= 128) {
    const length = data4[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data4.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data4[offset]) };
}
function decodeRlp(_data) {
  const data4 = getBytes(_data, "data");
  const decoded = _decode(data4, 0);
  assertArgument(decoded.consumed === data4.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object3) {
  if (Array.isArray(object3)) {
    let payload = [];
    object3.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data4 = Array.prototype.slice.call(getBytes(object3, "object"));
  if (data4.length === 1 && data4[0] <= 127) {
    return data4;
  } else if (data4.length <= 55) {
    data4.unshift(128 + data4.length);
    return data4;
  }
  const length = arrayifyInteger(data4.length);
  length.unshift(183 + length.length);
  return length.concat(data4);
}
var nibbles = "0123456789abcdef";
function encodeRlp(object3) {
  let result = "0x";
  for (const v of _encode(object3)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/units.js
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/utils/uuid.js
function uuidV4(randomBytes5) {
  const bytes2 = getBytes(randomBytes5, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard2 = {};
var resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
var Result = class _Result extends Array {
  // No longer used; but cannot be removed as it will remove the
  // #private field from the .d.ts which may break backwards
  // compatibility
  #names;
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard2) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      void this.#names;
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start2, end) {
    if (start2 == null) {
      start2 = 0;
    }
    if (start2 < 0) {
      start2 += this.length;
      if (start2 < 0) {
        start2 = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = start2; i < end; i++) {
      result.push(this[i]);
      names2.push(_names[i]);
    }
    return new _Result(_guard2, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names[i]);
      }
    }
    return new _Result(_guard2, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard2, items, keys);
  }
};
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object3) {
    if (!Array.isArray(object3)) {
      return;
    }
    for (let key in object3) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object3[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
var Coder = class {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
};
var Writer = class {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data4) {
    this.#data.push(data4);
    this.#dataLength += data4.length;
    return data4.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue(value);
    };
  }
};
var Reader = class _Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data4, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data4);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/crypto.js
var import_crypto = require("crypto");

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/hmac.js
var locked2 = false;
var _computeHmac = function(algorithm, key, data4) {
  return (0, import_crypto.createHmac)(algorithm, key).update(data4).digest();
};
var __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data4 = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data4));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_assert.js
function number(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error(`Wrong positive integer: ${n3}`);
}
function bytes(b3, ...lengths) {
  if (!(b3 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b3.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b3.length}`);
}
function hash(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash4.outputLen);
  number(hash4.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n3, le = false) {
  if (le)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotlSH = (h, l, s2) => h << s2 | l >>> 32 - s2;
var rotlSL = (h, l, s2) => l << s2 | h >>> 32 - s2;
var rotlBH = (h, l, s2) => l << s2 - 32 | h >>> 64 - s2;
var rotlBL = (h, l, s2) => h << s2 - 32 | l >>> 64 - s2;

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/cryptoNode.js
var nc = __toESM(require("node:crypto"), 1);
var crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js
var u8a = (a2) => a2 instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data4) {
  if (typeof data4 === "string")
    data4 = utf8ToBytes(data4);
  if (!u8a(data4))
    throw new Error(`expected Uint8Array, got ${typeof data4}`);
  return data4;
}
function concatBytes(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad);
    pad += a2.length;
  });
  return r2;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h, l, s2) => s2 > 32 ? rotlBH(h, l, s2) : rotlSH(h, l, s2);
var rotlL = (h, l, s2) => s2 > 32 ? rotlBL(h, l, s2) : rotlSL(h, l, s2);
function keccakP(s2, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s2[x] ^ s2[x + 10] ^ s2[x + 20] ^ s2[x + 30] ^ s2[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s2[x + y] ^= Th;
        s2[x + y + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s2[y + x];
      for (let x = 0; x < 10; x++)
        s2[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round];
    s2[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data4) {
    exists(this);
    const { blockLen, state } = this;
    data4 = toBytes(data4);
    const len = data4.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data4[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/keccak.js
var locked3 = false;
var _keccak256 = function(data4) {
  return keccak_256(data4);
};
var __keccak256 = _keccak256;
function keccak256(_data) {
  const data4 = getBytes(_data, "data");
  return hexlify(__keccak256(data4));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked3 = true;
};
keccak256.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data4) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data4 = toBytes(data4);
    const len = data4.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data4);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data4.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data4.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z2) {
  if (group === 0)
    return x ^ y ^ z2;
  else if (group === 1)
    return x & y | ~x & z2;
  else if (group === 2)
    return (x | ~y) ^ z2;
  else if (group === 3)
    return x & z2 | y & ~z2;
  else
    return x ^ (y | ~z2);
}
var BUF = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/ripemd160.js
var locked4 = false;
var _ripemd160 = function(data4) {
  return ripemd160(data4);
};
var __ripemd160 = _ripemd160;
function ripemd1602(_data) {
  const data4 = getBytes(_data, "data");
  return hexlify(__ripemd160(data4));
}
ripemd1602._ = _ripemd160;
ripemd1602.lock = function() {
  locked4 = true;
};
ripemd1602.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1602);

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/pbkdf2.js
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return (0, import_crypto.pbkdf2Sync)(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked5 = true;
};
pbkdf2.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/random.js
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array((0, import_crypto.randomBytes)(length));
};
var __randomBytes = _randomBytes;
function randomBytes3(length) {
  return __randomBytes(length);
}
randomBytes3._ = _randomBytes;
randomBytes3.lock = function() {
  locked6 = true;
};
randomBytes3.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes3);

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a2, b3, c2) => a2 & b3 ^ ~a2 & c2;
var Maj = (a2, b3, c2) => a2 & b3 ^ a2 & c2 ^ b3 & c2;
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T13 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T13 | 0;
      D = C;
      C = B;
      B = A;
      A = T13 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash4);
    const key = toBytes(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash4.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
hmac.create = (hash4, key) => new HMAC(hash4, key);

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash4, _password, _salt, _opts) {
  hash(hash4);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number(c2);
  number(dkLen);
  number(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash4, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf22(hash4, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash4, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/scrypt.js
var rotl2 = (a2, b3) => a2 << b3 | a2 >>> 32 - b3;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r2) {
  let head = oi + 0;
  let tail = oi + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N3, r: r2, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N3);
  number(r2);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N3 <= 1 || (N3 & N3 - 1) !== 0 || N3 >= 2 ** (blockSize / 8) || N3 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N3 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf22(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N3));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N3 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N3, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf22(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N: N3, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N3 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    for (let i = 0; i < N3; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N3;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N3, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N3 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    await asyncLoop(N3, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N3;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/scrypt.js
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N3, r2, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N3, r: r2, p, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N3, r2, p, dkLen) {
  return scrypt(passwd, salt, { N: N3, r: r2, p, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
async function scrypt2(_passwd, _salt, N3, r2, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N3, r2, p, dkLen, progress));
}
scrypt2._ = _scryptAsync;
scrypt2.lock = function() {
  lockedAsync = true;
};
scrypt2.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt2);
function scryptSync(_passwd, _salt, N3, r2, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N3, r2, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/sha2.js
var _sha256 = function(data4) {
  return (0, import_crypto.createHash)("sha256").update(data4).digest();
};
var _sha512 = function(data4) {
  return (0, import_crypto.createHash)("sha512").update(data4).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
function sha2562(_data) {
  const data4 = getBytes(_data, "data");
  return hexlify(__sha256(data4));
}
sha2562._ = _sha256;
sha2562.lock = function() {
  locked256 = true;
};
sha2562.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2562);
function sha512(_data) {
  const data4 = getBytes(_data, "data");
  return hexlify(__sha512(data4));
}
sha512._ = _sha512;
sha512.lock = function() {
  locked512 = true;
};
sha512.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2562);

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a2) => a2 instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += hexes[bytes2[i]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n3, len) {
  return hexToBytes(n3.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n3, len) {
  return numberToBytesBE(n3, len).reverse();
}
function numberToVarBytesBE(n3) {
  return hexToBytes(numberToHexUnpadded(n3));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (u8a2(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad = 0;
  arrays.forEach((a2) => {
    if (!u8a2(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad);
    pad += a2.length;
  });
  return r2;
}
function equalBytes(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b22[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n3) {
  let len;
  for (len = 0; n3 > _0n2; n3 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n3, pos) {
  return n3 >> BigInt(pos) & _1n2;
}
var bitSet = (n3, pos, value) => {
  return n3 | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n3) => (_2n2 << BigInt(n3 - 1)) - _1n2;
var u8n = (data4) => new Uint8Array(data4);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b3) => hmacFn(k, v, ...b3);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object3) => object3.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object3, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object3[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object3)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object3;
}

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a2, b3) {
  const result = a2 % b3;
  return result >= _0n3 ? result : b3 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b3 = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a2 !== _0n3) {
    const q = b3 / a2;
    const r2 = b3 % a2;
    const m = x - u * q;
    const n3 = y - v * q;
    b3 = a2, a2 = r2, x = u, y = v, u = m, v = n3;
  }
  const gcd = b3;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S2, Z;
  for (Q = P - _1n3, S2 = 0; Q % _2n3 === _0n3; Q /= _2n3, S2++)
    ;
  for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n3) {
    if (Fp2.pow(n3, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n3, Q1div2);
    let b3 = Fp2.pow(n3, Q);
    while (!Fp2.eql(b3, Fp2.ONE)) {
      if (Fp2.eql(b3, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b3); m < r2; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g2, _1n3 << BigInt(r2 - m - 1));
      g2 = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b3 = Fp2.mul(b3, g2);
      r2 = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n3) {
      const root = Fp2.pow(n3, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n3) {
      const n22 = Fp2.mul(n3, _2n3);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n3, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f2.ONE;
  if (power === _1n3)
    return num;
  let p = f2.ONE;
  let d2 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f2.mul(p, d2);
    d2 = f2.sqr(d2);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n3, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n3.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n3) => sqrtP(f2, n3)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b3, c2) => c2 ? b3 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength3 = fieldOrder.toString(2).length;
  return Math.ceil(bitLength3 / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c2, bits3) {
  const constTimeNegate = (condition, item) => {
    const neg2 = item.negate();
    return condition ? neg2 : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits3 / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n3) {
      let p = c2.ZERO;
      let d2 = elm;
      while (n3 > _0n4) {
        if (n3 & _1n4)
          p = p.add(d2);
        d2 = d2.double();
        n3 >>= _1n4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n3) {
      const { windows, windowSize } = opts(W);
      let p = c2.ZERO;
      let f2 = c2.BASE;
      const mask4 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n3 & mask4);
        n3 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n3 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n3, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n3);
    }
  };
}
function validateBasic(curve2) {
  validateField(curve2.Fp);
  validateObject(curve2, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve2.n, curve2.nBitLength),
    ...curve2,
    ...{ p: curve2.Fp.ORDER }
  });
}

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data4) {
    const { Err: E } = DER;
    if (data4.length < 2 || data4[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data4[1];
    const res = data4.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data4.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E } = DER;
    const data4 = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data4 instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data4.length;
    if (l < 2 || data4[0] != 48)
      throw new E("Invalid signature tag");
    if (data4[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data4.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s2 = slice(h(sig.s));
    const r2 = slice(h(sig.r));
    const shl2 = s2.length / 2;
    const rhl = r2.length / 2;
    const sl = h(shl2);
    const rl = h(rhl);
    return `30${h(rhl + shl2 + 4)}02${rl}${r2}02${sl}${s2}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a: a2, b: b3 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a2)), b3);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n3 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n3);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b3 } = CURVE;
      const b32 = Fp2.mul(b3, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b32, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b32, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, pointPrecomputes, n3, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n3) {
      const I = Point2.ZERO;
      if (n3 === _0n5)
        return I;
      assertGE(n3);
      if (n3 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n3);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d2);
        if (k2 & _1n5)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n3 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n3);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n3);
        point = p;
        fake = f2;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a2, b3) {
      const G = Point2.BASE;
      const mul3 = (P, a3) => a3 === _0n5 || a3 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a3) : P.multiply(a3);
      const sum = mul3(this, a2).add(mul3(Q, b3));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x = Fp2.toBytes(a2.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b3, from, to) => bytesToNumberBE(b3.slice(from, to));
  class Signature3 {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l * 2);
      return new Signature3(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature3(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature3(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s2 * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature3(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b3 = Point2.fromHex(publicB);
    return b3.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes5(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = modN(q.x);
      if (r2 === _0n5)
        return;
      const s2 = modN(ik * modN(m + r2 * d2));
      if (s2 === _0n5)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n5);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature3(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature3.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature3.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r3, s: s3 } = sg;
        _sig = new Signature3(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h * is);
    const u2 = modN(r2 * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature: Signature3,
    utils: utils2
  };
}

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash4) {
  return {
    hash: hash4,
    hmac: (key, ...msgs) => hmac(hash4, key, concatBytes(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
  return Object.freeze({ ...create(defHash), create });
}

// ../../node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a2, b3) => (a2 + b3 / _2n5) / b3;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y * y * y % P;
  const b3 = b22 * b22 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b22 % P;
  const b222 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b222, _22n, P) * b222 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b222 % P;
  const t2 = pow2(t1, _6n, P) * b22 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n3 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k, n3);
      const c2 = divNearest(-b1 * k, n3);
      let k1 = mod(k - c1 * a1 - c2 * a2, n3);
      let k2 = mod(-c1 * b1 - c2 * b22, n3);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n3 - k1;
      if (k2neg)
        k2 = n3 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol = "\u039E";
var MessagePrefix = "Ethereum Signed Message:\n";

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/signature.js
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
var Signature = class _Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    const value = hexlify(_value);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    this.#s = value;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return _Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r2, s2, v) {
    assertPrivate(guard, _guard3, "Signature");
    this.#r = r2;
    this.#s = s2;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard3, this.r, this.s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
    return (bv - BN_35) / BN_2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v);
    return bv & BN_13 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    ;
    if (sig == null) {
      return new _Signature(_guard3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        const v2 = s3[0] & 128 ? 28 : 27;
        s3[0] &= 127;
        return new _Signature(_guard3, r3, hexlify(s3), v2);
      }
      if (bytes2.length === 65) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        assertError((s3[0] & 128) === 0, "non-canonical s");
        const v2 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard3, r3, hexlify(s3), v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r2 = toUint256(_r);
    const s2 = function(s3, yParityAndS) {
      if (s3 != null) {
        return toUint256(s3);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s2)[0] & 128) == 0, "non-canonical s");
    const { networkV, v } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt(_v);
        return {
          networkV: v2 >= BN_35 ? v2 : void 0,
          v: _Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard3, r2, s2, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/signing-key.js
var SigningKey = class _SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/crypto/index.js
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf2.lock();
  randomBytes3.lock();
  ripemd1602.lock();
  scrypt2.lock();
  scryptSync.lock();
  sha2562.lock();
  sha512.lock();
  randomBytes3.lock();
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/address/address.js
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum7 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum7.length < 2) {
    checksum7 = "0" + checksum7;
  }
  return checksum7;
}
var Base36 = function() {
  ;
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_05;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/typed.js
var _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol = Symbol.for("_ethers_typed");
var Typed = class _Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new _Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new _Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new _Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new _Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "array", v, dynamic);
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "tuple", v, name);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
var ArrayCoder = class extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data4 = getBytesCopy(Typed.dereference(_value, this.type));
    if (data4.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data4);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/null.js
var Empty = new Uint8Array([]);
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var NumberCoder = class extends Coder {
  size;
  signed;
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder = class extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/hash/id.js
function id(value) {
  return keccak256(toUtf8Bytes(value));
}

// ../../node_modules/.pnpm/@adraffy+ens-normalize@1.10.1/node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N3 = 31;
  const FULL = 2 ** N3;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N3; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start2 = 0;
    let end = symbol_count;
    while (end - start2 > 1) {
      let mid = start2 + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start2 = mid;
      }
    }
    if (start2 == 0) break;
    symbols.push(start2);
    let a2 = low + Math.floor(range * acc[start2] / total);
    let b3 = low + Math.floor(range * acc[start2 + 1] / total) - 1;
    while (((a2 ^ b3) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b3 = b3 << 1 & MASK | 1;
    }
    while (a2 & ~b3 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b3 = (b3 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b3 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
function unsafe_atob(s2) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i) => lookup[c2.charCodeAt(0)] = i);
  let n3 = s2.length;
  let ret = new Uint8Array(6 * n3 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n3; i++) {
    carry = carry << 6 | lookup[s2.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n3, next) {
  let v = Array(n3);
  for (let i = 0, x = 0; i < n3; i++) v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n3 = next();
    if (!n3) break;
    prev += x;
    for (let i = 0; i < n3; i++) {
      ret.push(prev + i);
    }
    prev += n3 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length) return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n3, w, next) {
  let m = Array(n3).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n3, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n3 = 1 + next();
  let m = read_transposed(n3, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B, Q };
  }
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len = s2.length; pos < len; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a2, b3) {
  let n3 = a2.length;
  let c2 = n3 - b3.length;
  for (let i = 0; c2 == 0 && i < n3; i++) c2 = a2[i] - b3[i];
  return c2;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r2 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r2).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r2));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r2)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a2, b3] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b3, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a2, b3) {
  if (a2 >= L0 && a2 < L1 && b3 >= V0 && b3 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b3 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b3 > T0 && b3 < T1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b3 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b3);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);
function group_has_cp(g2, cp) {
  return g2.P.has(cp) || g2.Q.has(cp);
}
var Emoji = class extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
};
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r2 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r2);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r2));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r2);
  let unrestricted = r2();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N3 = read_array_while(r2).map((x) => x + 96);
    if (N3.length) {
      let R = i >= unrestricted;
      N3[0] -= 32;
      N3 = str_from_cps(N3);
      if (R) N3 = `Restricted[${N3}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r2();
      return { N: N3, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b3) => a2 - b3);
  wholes.forEach((cp, i) => {
    let d2 = r2();
    let w = wholes[i] = d2 ? wholes[i - d2] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g2) => group_has_cp(g2, cp));
      let rec = recs.find(({ G }) => gs.some((g2) => G.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g2) => !G.has(g2)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g2 of GROUPS) {
    for (let cp of g2.P) add_to_union(cp);
    for (let cp of g2.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r2).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s2) {
  return `"${s2}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n3 = cps.length;
  let last = -1;
  for (let i = 1; i < n3; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i) throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n3) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n3 = cps.length;
  for (let i = 0; i < n3; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n3)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split2(name, nfc, filter_fe0f));
}
function split2(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type = g2.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp) => group_has_cp(g2, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g2) => group_has_cp(g2, cp));
    if (!gs.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split3) {
  return split3.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g2, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g3) => g3.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g2, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g2, cp)) {
      throw error_group_member(g2, cp);
    }
  }
  if (g2.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e2 = decomposed2.length; i < e2; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e2 && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten) eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/hash/namehash.js
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d2 = bytes2[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros2;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b3) => a2.address.localeCompare(b3.address));
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/transaction/transaction.js
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;
function getVersionedHash(version4, hash4) {
  let versioned = version4.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2562(hash4).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  const value = getBigInt(_value, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data4) {
  const fields = decodeRlp(data4);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data4);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r2 = handleUint(fields[7], "r");
  const s2 = handleUint(fields[8], "s");
  if (r2 === BN_07 && s2 === BN_07) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue(fields[1], 32);
  const s2 = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r: r2, s: s2, yParity });
  tx.signature = signature;
}
function _parseEip1559(data4) {
  const fields = decodeRlp(getBytes(data4).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data4));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data4) {
  const fields = decodeRlp(getBytes(data4).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data4));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data4) {
  let fields = decodeRlp(getBytes(data4).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data4));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data4);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data4);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data4);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b3) => b3.data),
          blobs.map((b3) => b3.commitment),
          blobs.map((b3) => b3.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
var Transaction = class _Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_07;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b3) => Object.assign({}, b3));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs.length; i++) {
      const blob = _blobs[i];
      if (isBytesLike(blob)) {
        assert(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data4 = getBytes(blob);
        assertArgument(data4.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data4.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data4);
          data4 = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data4);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data4, commit));
        blobs.push({
          data: hexlify(data4),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    this.#kzg = kzg;
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_07;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_07;
    this.#chainId = BN_07;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#blobs = null;
    this.#kzg = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed2, sidecar) {
    assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed2 ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
    }
    assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return this.#getSerialized(true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s2 = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s2(this.gasLimit),
      gasPrice: s2(this.gasPrice),
      maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
      maxFeePerGas: s2(this.maxFeePerGas),
      value: s2(this.value),
      chainId: s2(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/hash/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed2 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray2) {
      size = 256;
    }
    if (signed2) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray2) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
function solidityPackedSha256(types, values) {
  return sha2562(solidityPacked(types, values));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/hash/typed-data.js
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2562, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
var TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n3) => parents.get(n3).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak256);
        }
        return keccak256(concat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b3) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b3.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var TokenString = class _TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new _TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new _TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset; i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
function lex(text) {
  const tokens = [];
  const throwError3 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError3("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard4 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";
var ParamType = class _ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard4, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process2));
    }
    return process2(this.type, value);
  }
  #walkAsync(promises, value, process2, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process2(this.type, value);
    if (result.then) {
      promises.push(async function() {
        setValue(await result);
      }());
    } else {
      setValue(result);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard4, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
};
var Fragment = class _Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard4, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e2) {
      }
      return _Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
};
var NamedFragment = class extends Fragment {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
};
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var ErrorFragment = class _ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _ErrorFragment(_guard4, name, inputs);
    }
    return new _ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
};
var EventFragment = class _EventFragment extends NamedFragment {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new _EventFragment(_guard4, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new _EventFragment(_guard4, name, inputs, anonymous);
    }
    return new _EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
};
var ConstructorFragment = class _ConstructorFragment extends Fragment {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
};
var FallbackFragment = class _FallbackFragment extends Fragment {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new _FallbackFragment(_guard4, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new _FallbackFragment(_guard4, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard4, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard4, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
};
var FunctionFragment = class _FunctionFragment extends NamedFragment {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new _FunctionFragment(_guard4, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
};
var StructFragment = class _StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return _StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _StructFragment(_guard4, name, inputs);
    }
    return new _StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons = /* @__PURE__ */ new Map();
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data4, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data4) {
    message = "execution reverted";
    const bytes2 = getBytes(data4);
    data4 = hexlify(data4);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data4,
    reason,
    transaction,
    invocation,
    revert
  });
}
var AbiCoder = class _AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c2) => this.#getCoder(c2)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data4, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data4, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data4) {
    return getBuiltinCallException(action, tx, data4, _AbiCoder.defaultAbiCoder());
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String(text) {
  const bytes2 = toUtf8Bytes(text);
  if (bytes2.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes2, 32);
}
function decodeBytes32String(_bytes) {
  const data4 = getBytes(_bytes, "bytes");
  if (data4.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data4[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data4[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data4.slice(0, length));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/abi/interface.js
var LogDescription = class {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
};
var TransactionDescription = class {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription = class {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
};
var Indexed = class {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash4) {
    defineProperties(this, { hash: hash4, _isIndexed: true });
  }
};
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var Interface = class _Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a2 of abi2) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi2 = this.fragments.map((f2) => f2.format(format));
    return abi2;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi2 = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi2.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#functions.get(name), i);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1; i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#events.get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#errors.get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data4) {
    return this.#abiCoder.decode(params, data4);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data4, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data4);
    return this._decodeParams(fragment.inputs, dataSlice(data4, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data4, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data4);
    return this._decodeParams(fragment.inputs, dataSlice(data4, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data4);
    if (bytes2.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data4 = getBytes(_data, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data4);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data4.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data4.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e2) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data4, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data4, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data4 = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data4.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data4.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data4) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data4) {
    const hexData = hexlify(data4);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider.js
var BN_09 = BigInt(0);
function getValue2(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
var FeeData = class {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue2(gasPrice),
      maxFeePerGas: getValue2(maxFeePerGas),
      maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
};
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b3) => {
      if (isBytesLike(b3)) {
        return hexlify(b3);
      }
      return Object.assign({}, b3);
    });
  }
  return result;
}
var Block = class {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  The latest RANDAO mix of the post beacon state of
   *  the previous block.
   */
  prevRandao;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue2(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue2(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue2(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash4, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash4,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash4 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash4) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash === hash4) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
};
var Log = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data: data4, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data: data4,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
};
var TransactionReceipt = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    }));
    let gasPrice = BN_09;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash4,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash4,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
};
var TransactionResponse = class _TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash4, type, to, from, nonce, data: data4, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data: data4,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash4,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash4 of block) {
          if (hash4 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
};
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog = class extends Log {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};
var UndecodedEventLog = class extends Log {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    defineProperties(this, { error });
  }
};
var ContractTransactionReceipt = class extends TransactionReceipt {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
};
var ContractTransactionResponse = class extends TransactionResponse {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
};
var ContractUnknownEventPayload = class extends EventPayload {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract2, listener, filter, log) {
    super(contract2, listener, filter);
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
};
var ContractEventPayload = class extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract2, listener, filter, fragment, _log) {
    super(contract2, listener, filter, new EventLog(_log, contract2.interface, fragment));
    const args = contract2.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/contract/contract.js
var BN_010 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
var PreparedTopicFilter = class {
  #filter;
  fragment;
  constructor(contract2, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract2.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract2.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
};
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract2) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract2.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract2.runner));
    }
    const iface = contract2.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract2.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract2.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract2.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract2.runner);
    return new ContractTransactionResponse(contract2.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract2.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract2,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract2, key) {
  const getFragment = function(...args) {
    const fragment = contract2.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract2.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract2.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract2.getAddress(),
      data: contract2.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract2.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract2.runner);
    return new ContractTransactionResponse(contract2.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract2.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract2.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract2.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract2.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract2.interface.getFunctionName(key),
    _contract: contract2,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract2.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract2, key) {
  const getFragment = function(...args) {
    const fragment = contract2.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract2, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract2.interface.getEventName(key),
    _contract: contract2,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract2.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract2, values) {
  internalValues.set(contract2[internal2], values);
}
function getInternal(contract2) {
  return internalValues.get(contract2[internal2]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract2, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract2.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e2) => {
      if (e2 == null) {
        return null;
      }
      if (Array.isArray(e2)) {
        return e2.map(topicHashify);
      }
      return topicHashify(e2);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract2.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract2, event) {
  const { subs } = getInternal(contract2);
  return subs.get((await getSubInfo(contract2, event)).tag) || null;
}
async function getSub(contract2, operation, event) {
  const provider = getProvider(contract2.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract2, event);
  const { addr, subs } = getInternal(contract2);
  let sub2 = subs.get(tag);
  if (!sub2) {
    const address = addr ? addr : contract2;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract2.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract2.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract2, event, args, (listener2) => {
          return new ContractEventPayload(contract2, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract2, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract2, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start2 = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub2 = { tag, listeners: [], start: start2, stop };
    subs.set(tag, sub2);
  }
  return sub2;
}
var lastEmit = Promise.resolve();
async function _emit(contract2, event, args, payloadFunc) {
  await lastEmit;
  const sub2 = await hasSub(contract2, event);
  if (!sub2) {
    return false;
  }
  const count = sub2.listeners.length;
  sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract2, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub2.listeners.length === 0) {
    sub2.stop();
    getInternal(contract2).subs.delete(sub2.tag);
  }
  return count > 0;
}
async function emit(contract2, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract2, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
var passProperties2 = ["then"];
var BaseContract = class _BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal2];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi2, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi2);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash4) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub2 = await getSub(this, "on", event);
    sub2.listeners.push({ listener, once: false });
    sub2.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub2 = await getSub(this, "once", event);
    sub2.listeners.push({ listener, once: true });
    sub2.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub2 = await hasSub(this, event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub2.listeners.length === 0) {
      sub2.stop();
      getInternal(this).subs.delete(sub2.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return this;
      }
      sub2.stop();
      getInternal(this).subs.delete(sub2.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi2) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi2, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi2, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract2 = new this(target, abi2, runner);
    return contract2;
  }
};
function _ContractBase() {
  return BaseContract;
}
var Contract = class extends _ContractBase() {
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/contract/factory.js
var ContractFactory = class _ContractFactory {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The Contract deployment bytecode. Often called the initcode.
   */
  bytecode;
  /**
   *  The ContractRunner to deploy the Contract as.
   */
  runner;
  /**
   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
   *  optionally connected to %%runner%%.
   *
   *  The %%bytecode%% may be the ``bytecode`` property within the
   *  standard Solidity JSON output.
   */
  constructor(abi2, bytecode2, runner) {
    const iface = Interface.from(abi2);
    if (bytecode2 instanceof Uint8Array) {
      bytecode2 = hexlify(getBytes(bytecode2));
    } else {
      if (typeof bytecode2 === "object") {
        bytecode2 = bytecode2.object;
      }
      if (!bytecode2.startsWith("0x")) {
        bytecode2 = "0x" + bytecode2;
      }
      bytecode2 = hexlify(getBytes(bytecode2));
    }
    defineProperties(this, {
      bytecode: bytecode2,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Resolves to the transaction to deploy the contract, passing %%args%%
   *  into the constructor.
   */
  async getDeployTransaction(...args) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
    const data4 = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data: data4 });
  }
  /**
   *  Resolves to the Contract deployed by passing %%args%% into the
   *  constructor.
   *
   *  This will resolve to the Contract before it has been deployed to the
   *  network, so the [[BaseContract-waitForDeployment]] should be used before
   *  sending any transactions to it.
   */
  async deploy(...args) {
    const tx = await this.getDeployTransaction(...args);
    assert(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address = getCreateAddress(sentTx);
    return new BaseContract(address, this.interface, this.runner, sentTx);
  }
  /**
   *  Return a new **ContractFactory** with the same ABI and bytecode,
   *  but connected to %%runner%%.
   */
  connect(runner) {
    return new _ContractFactory(this.interface, this.bytecode, runner);
  }
  /**
   *  Create a new **ContractFactory** from the standard Solidity JSON output.
   */
  static fromSolidity(output2, runner) {
    assertArgument(output2 != null, "bad compiler output", "output", output2);
    if (typeof output2 === "string") {
      output2 = JSON.parse(output2);
    }
    const abi2 = output2.abi;
    let bytecode2 = "";
    if (output2.bytecode) {
      bytecode2 = output2.bytecode;
    } else if (output2.evm && output2.evm.bytecode) {
      bytecode2 = output2.evm.bytecode;
    }
    return new this(abi2, bytecode2, runner);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
var MulticoinProviderPlugin = class {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data4) {
    throw new Error("unsupported coin");
  }
};
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var EnsResolver = class _EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data5 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data5, 20)) {
        return getAddress(data5);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data4 = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data4 == null || data4 === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data4);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data4 }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data4 = await this.#fetch("text(bytes32,string)", [key]);
    if (data4 == null || data4 === "0x") {
      return null;
    }
    return data4;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data4 = await this.#fetch("contenthash(bytes32)");
    if (data4 == null || data4 === "0x") {
      return null;
    }
    const ipfs = data4.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data4.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data4 }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract2 = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract2.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract2.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract2[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await _EnsResolver.getEnsAddress(provider);
    try {
      const contract2 = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract2.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await _EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/format.js
var BN_011 = BigInt(0);
function allowNull(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format, allowNull3) {
  return (array) => {
    if (allowNull3 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object(format, altNames) {
  return (value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
var _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
var _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_011) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
    result.blockHash = null;
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
var NetworkPlugin = class _NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new _NetworkPlugin(this.name);
  }
};
var GasCostPlugin = class _GasCostPlugin extends NetworkPlugin {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new _GasCostPlugin(this.effectiveBlock, this);
  }
};
var EnsPlugin = class _EnsPlugin extends NetworkPlugin {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new _EnsPlugin(this.address, this.targetNetwork);
  }
};
var FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new _FeeDataNetworkPlugin(this.#feeDataFunc);
  }
};
var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/network.js
var Networks = /* @__PURE__ */ new Map();
var Network = class _Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom2 = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom2;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
function parseUnits2(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits2(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
var injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var PollingBlockSubscriber = class {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b3 = this.#blockNumber + 1; b3 <= blockNumber; b3++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b3);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};
var OnBlockSubscriber = class {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
};
var PollingBlockTagSubscriber = class extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
};
var PollingOrphanSubscriber = class extends OnBlockSubscriber {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
};
var PollingTransactionSubscriber = class extends OnBlockSubscriber {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash4) {
    super(provider);
    this.#hash = hash4;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
};
var PollingEventSubscriber = class {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log of logs) {
      this.#provider.emit(this.#filter, log);
      this.#blockNumber = log.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_23 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
var UnmanagedSubscriber = class {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
};
function copy2(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash4 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash4 }), hash: hash4 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime2() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var defaultOptions = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var AbstractProvider = class {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data4 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data4);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data: data4, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b3) => toQuantity(b3 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
        const data4 = error.data;
        const txSender = await resolveAddress(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
        } catch (error2) {
          assert(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data: data4 }
          });
        }
        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data: data4,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash4, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash4) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block, includeTransactions) {
    if (isHexString(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash4) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash4 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash4) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash4 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash4 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash4) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash4 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash4, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash4);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash4);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime2() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub2 of this.#subs.values()) {
      func(sub2.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub2.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub2.type);
      case "event":
        return new PollingEventSubscriber(this, sub2.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub2.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub2.filter);
    }
    throw new Error(`unsupported event: ${sub2.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub2 of this.#subs.values()) {
      if (sub2.subscriber === oldSub) {
        if (sub2.started) {
          sub2.subscriber.stop();
        }
        sub2.subscriber = newSub;
        if (sub2.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub2 = await getSubscription(event, this);
    if (sub2.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub2 = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub2.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub2 = this.#subs.get(tag);
    if (!sub2) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub2 = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub2);
    }
    return sub2;
  }
  async on(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: false });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: true });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub2 = await this.#hasSub(event, args);
    if (!sub2 || sub2.listeners.length === 0) {
      return false;
    }
    ;
    const count = sub2.listeners.length;
    sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub2 = await this.#hasSub(event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (!listener || sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime2() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s2) => s2.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime2();
      setTimeout(timer.func, timeout);
    }
  }
};
function _parseString(result, start2) {
  try {
    const bytes2 = _parseBytes(result, start2);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start2) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start2, start2 + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
var empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data4 = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data4.length));
    result.push(bytesPad(data4));
    byteCount += 32 + Math.ceil(data4.length / 32) * 32;
  }
  return concat(result);
}
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data4) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data4) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data4, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data4, 32, 64));
    const urlsLength = getNumber(dataSlice(data4, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data4, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data4, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data4, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data4, 96, 100);
  try {
    const extraData = _parseBytes(data4, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
var AbstractSigner = class {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
};
var VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  The signer address.
   */
  address;
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/community.js
var shown = /* @__PURE__ */ new Set();
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy3(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var FilterIdSubscriber = class {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
};
var FilterIdEventSubscriber = class extends FilterIdSubscriber {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy3(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(this.#event, provider._wrapLog(result, provider._network));
    }
  }
};
var FilterIdPendingSubscriber = class extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions2 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var JsonRpcSigner = class extends AbstractSigner {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash4 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash4);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash4;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash4;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
};
var JsonRpcApiProvider = class extends AbstractProvider {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes2 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes2.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r2) => r2.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions2, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network.from(network);
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error) {
          this.#pendingDetectNetwork = null;
          throw error;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub2) {
    if (sub2.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub2.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub2.filter);
      }
      return new FilterIdEventSubscriber(this, sub2.filter);
    }
    if (sub2.type === "orphan" && sub2.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub2);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e2 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e2.info = { error, payload };
      return e2;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
};
var JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions2.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub2) {
    const subscriber = super._getSubscriber(sub2);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub2) => {
      if (isPollable(sub2)) {
        sub2.pollingInterval = this.#pollingInterval;
      }
    });
  }
};
var JsonRpcProvider = class extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
};
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-ankr.js
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var AnkrProvider = class _AnkrProvider extends JsonRpcProvider {
  /**
   *  The API key for the Ankr connection.
   */
  apiKey;
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const options = { polling: true, staticNetwork: network };
    const request = _AnkrProvider.getRequest(network, apiKey);
    super(request, network, options);
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AnkrProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%apiKey%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = new FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-alchemy.js
var defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost2(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var AlchemyProvider = class _AlchemyProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = _AlchemyProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AlchemyProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data4;
      let error = false;
      try {
        data4 = trace[0].result.output;
        error = trace[0].error === "Reverted";
      } catch (error2) {
      }
      if (data4) {
        assert(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data: data4,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
          // @TODO
        });
        return data4;
      }
      assert(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = new FetchRequest(`https://${getHost2(network.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-chainstack.js
function getApiKey(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument(false, "unsupported network", "network", name);
}
function getHost3(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var ChainstackProvider = class _ChainstackProvider extends JsonRpcProvider {
  /**
   *  The API key for the Chainstack connection.
   */
  apiKey;
  /**
   *  Creates a new **ChainstackProvider**.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = _ChainstackProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _ChainstackProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey(this._network.name);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%apiKey%% and %%projectSecret%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = new FetchRequest(`https://${getHost3(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === getApiKey(network.name)) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("ChainstackProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-cloudflare.js
var CloudflareProvider = class extends JsonRpcProvider {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    assertArgument(network.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network, { staticNetwork: network });
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-etherscan.js
var THROTTLE = 2e3;
function isPromise2(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
var EtherscanPlugin = class _EtherscanPlugin extends NetworkPlugin {
  /**
   *  The Etherscan API base URL.
   */
  baseUrl;
  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  constructor(baseUrl) {
    super(EtherscanPluginId);
    defineProperties(this, { baseUrl });
  }
  clone() {
    return new _EtherscanPlugin(this.baseUrl);
  }
};
var skipKeys = ["enableCcipRead"];
var nextId = 1;
var EtherscanProvider = class extends AbstractProvider {
  /**
   *  The connected network.
   */
  network;
  /**
   *  The API key or null if using the community provided bandwidth.
   */
  apiKey;
  #plugin;
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network = Network.from(_network);
    this.#plugin = network.getPlugin(EtherscanPluginId);
    defineProperties(this, { apiKey, network });
    this.getBaseUrl();
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  /**
   *  Returns the URL for the %%module%% and %%params%%.
   */
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module2}${query}${apiKey}`;
  }
  /**
   *  Returns the URL for using POST requests.
   */
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  /**
   *  Returns the parameters for using POST requests.
   */
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the result of calling %%module%% with %%params%%.
   *
   *  If %%post%%, the request is made as a POST request.
   */
  async fetch(module2, params, post) {
    const id3 = nextId++;
    const url = post ? this.getPostUrl() : this.getUrl(module2, params);
    const payload = post ? this.getPostData(module2, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url, payload });
    const request = new FetchRequest(url);
    request.setThrottleParams({ slotInterval: 1e3 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result2 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module2 === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result2 });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result2.result });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error) {
      this.emit("debug", { action: "receiveError", id: id3, error, reason: "assertOk" });
      assert(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result = JSON.parse(toUtf8String(response.body));
    if (module2 === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "invalid JSON-RPC" });
        assert(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "JSON-RPC error" });
        assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result });
        assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    }
  }
  /**
   *  Returns %%transaction%% normalized for the Etherscan API.
   */
  _getTransactionPostData(transaction) {
    const result = {};
    for (let key in transaction) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction[key] == null) {
        continue;
      }
      let value = transaction[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity(value);
      } else if (key === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value.length === 0) {
          continue;
        }
        assert(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction }
        });
      } else {
        value = hexlify(value);
      }
      result[key] = value;
    }
    return result;
  }
  /**
   *  Throws the normalized Etherscan error.
   */
  _checkError(req, error, transaction) {
    let message = "";
    if (isError(error, "SERVER_ERROR")) {
      try {
        message = error.info.result.error.message;
      } catch (e2) {
      }
      if (!message) {
        try {
          message = error.info.message;
        } catch (e2) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data4 = "";
        try {
          data4 = error.info.result.error.data;
        } catch (error2) {
        }
        const e2 = AbiCoder.getBuiltinCallException(req.method, req.transaction, data4);
        e2.info = { request: req, error };
        throw e2;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction2 = Transaction.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction2
          });
        }
        if (message.match(/insufficient funds/)) {
          assert(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction2
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction2
          });
        }
      }
    }
    throw error;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      /* Working with Etherscan to get this added:
      try {
          const test = await this.fetch("proxy", {
              action: "eth_maxPriorityFeePerGas"
          });
          console.log(test);
          return test;
      } catch (e) {
          console.log("DEBUG", e);
          throw e;
      }
      */
      /* This might be safe; but due to rounding neither myself
         or Etherscan are necessarily comfortable with this. :)
      try {
          const result = await this.fetch("gastracker", { action: "gasoracle" });
          console.log(result);
          const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
          const baseFee = parseUnits(result.suggestBaseFee, "gwei");
          const priorityFee = gasPrice - baseFee;
          if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
          return priorityFee;
      } catch (error) {
          console.log("DEBUG", error);
          throw error;
      }
      */
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error) => {
          return this._checkError(req, error, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      /*
                  case "getLogs": {
                      // Needs to complain if more than one address is passed in
                      const args: Record<string, any> = { action: "getLogs" }
      
                      if (params.filter.fromBlock) {
                          args.fromBlock = checkLogTag(params.filter.fromBlock);
                      }
      
                      if (params.filter.toBlock) {
                          args.toBlock = checkLogTag(params.filter.toBlock);
                      }
      
                      if (params.filter.address) {
                          args.address = params.filter.address;
                      }
      
                      // @TODO: We can handle slightly more complicated logs using the logs API
                      if (params.filter.topics && params.filter.topics.length > 0) {
                          if (params.filter.topics.length > 1) {
                              logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                          }
                          if (params.filter.topics.length === 1) {
                              const topic0 = params.filter.topics[0];
                              if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                  logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                              }
                              args.topic0 = topic0;
                          }
                      }
      
                      const logs: Array<any> = await this.fetch("logs", args);
      
                      // Cache txHash => blockHash
                      let blocks: { [tag: string]: string } = {};
      
                      // Add any missing blockHash to the logs
                      for (let i = 0; i < logs.length; i++) {
                          const log = logs[i];
                          if (log.blockHash != null) { continue; }
                          if (blocks[log.blockNumber] == null) {
                              const block = await this.getBlock(log.blockNumber);
                              if (block) {
                                  blocks[log.blockNumber] = block.hash;
                              }
                          }
      
                          log.blockHash = blocks[log.blockNumber];
                      }
      
                      return logs;
                  }
      */
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the current price of ether.
   *
   *  This returns ``0`` on any network other than ``mainnet``.
   */
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  /**
   *  Resolves to a [Contract]] for %%address%%, using the
   *  Etherscan API to retreive the Contract ABI.
   */
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise2(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi2 = JSON.parse(resp);
      return new Contract(address, abi2, this);
    } catch (error) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// ../../node_modules/.pnpm/ws@8.17.1/node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-socket.js
var SocketSubscriber = class {
  #provider;
  #filter;
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = JSON.stringify(filter);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      ;
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      if (this.#provider.destroyed) {
        return;
      }
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
};
var SocketBlockSubscriber = class extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
};
var SocketPendingSubscriber = class extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
};
var SocketEventSubscriber = class extends SocketSubscriber {
  #logFilter;
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  /**
   *  @_ignore:
   */
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    this.#logFilter = JSON.stringify(filter);
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
};
var SocketProvider = class extends JsonRpcApiProvider {
  #callbacks;
  // Maps each filterId to its subscriber
  #subs;
  // If any events come in before a subscriber has finished
  // registering, queue them
  #pending;
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    this.#callbacks = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#pending = /* @__PURE__ */ new Map();
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub2.filter);
      case "orphan":
        if (sub2.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub2);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = this.#callbacks.get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      this.#callbacks.delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-websocket.js
var WebSocketProvider = class extends SocketProvider {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url, network, options) {
    super(network, options);
    if (typeof url === "string") {
      this.#connect = () => {
        return new import_websocket.default(url);
      };
      this.#websocket = this.#connect();
    } else if (typeof url === "function") {
      this.#connect = url;
      this.#websocket = url();
    } else {
      this.#connect = null;
      this.#websocket = url;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-infura.js
var defaultProjectId = "84842078b09946638c03157f83405213";
function getHost4(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var InfuraWebSocketProvider = class extends WebSocketProvider {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network, projectId) {
    const provider = new InfuraProvider(network, projectId);
    const req = provider._getConnection();
    assert(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, provider._network);
    defineProperties(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class _InfuraProvider extends JsonRpcProvider {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider(network, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost4(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-quicknode.js
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost5(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var QuickNodeProvider = class _QuickNodeProvider extends JsonRpcProvider {
  /**
   *  The API token.
   */
  token;
  /**
   *  Creates a new **QuickNodeProvider**.
   */
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    const request = _QuickNodeProvider.getRequest(network, token);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new _QuickNodeProvider(chainId, this.token);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  /**
   *  Returns a new request prepared for %%network%% and the
   *  %%token%%.
   */
  static getRequest(network, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request = new FetchRequest(`https://${getHost5(network.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-fallback.js
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}
function stall2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getTime3() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stringify2(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
var defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
async function waitForSync(config, blockNumber) {
  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
    if (!config._updateNumber) {
      config._updateNumber = (async () => {
        try {
          const blockNumber2 = await config.provider.getBlockNumber();
          if (blockNumber2 > config.blockNumber) {
            config.blockNumber = blockNumber2;
          }
        } catch (error) {
          config.blockNumber = -2;
          config._lastFatalError = error;
          config._lastFatalErrorTimestamp = getTime3();
        }
        config._updateNumber = null;
      })();
    }
    await config._updateNumber;
    config.outOfSync++;
    if (config._lastFatalError) {
      break;
    }
  }
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    const error = value.error;
    return { tag: _normalize(error), value: error };
  }
  const result = value.result;
  return { tag: _normalize(result), value: result };
}
function checkQuorum(quorum, results) {
  const tally = /* @__PURE__ */ new Map();
  for (const { value, tag, weight } of results) {
    const t = tally.get(tag) || { value, weight: 0 };
    t.weight += weight;
    tally.set(tag, t);
  }
  let best = null;
  for (const r2 of tally.values()) {
    if (r2.weight >= quorum && (!best || r2.weight > best.weight)) {
      best = r2;
    }
  }
  if (best) {
    return best.value;
  }
  return void 0;
}
function getMedian(quorum, results) {
  let resultWeight = 0;
  const errorMap2 = /* @__PURE__ */ new Map();
  let bestError = null;
  const values = [];
  for (const { value, tag, weight } of results) {
    if (value instanceof Error) {
      const e2 = errorMap2.get(tag) || { value, weight: 0 };
      e2.weight += weight;
      errorMap2.set(tag, e2);
      if (bestError == null || e2.weight > bestError.weight) {
        bestError = e2;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return void 0;
  }
  values.sort((a2, b3) => a2 < b3 ? -1 : b3 > a2 ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_16) / BN_24;
}
function getAnyResult(quorum, results) {
  const result = checkQuorum(quorum, results);
  if (result !== void 0) {
    return result;
  }
  for (const r2 of results) {
    if (r2.value) {
      return r2.value;
    }
  }
  return void 0;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = /* @__PURE__ */ new Map();
  const add2 = (result, weight) => {
    const t = tally.get(result) || { result, weight: 0 };
    t.weight += weight;
    tally.set(result, t);
  };
  for (const { weight, value } of results) {
    const r2 = getNumber(value);
    add2(r2 - 1, weight);
    add2(r2, weight);
    add2(r2 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = void 0;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
}
var FallbackProvider = class extends AbstractProvider {
  /**
   *  The number of backends that must agree on a value before it is
   *  accpeted.
   */
  quorum;
  /**
   *  @_ignore:
   */
  eventQuorum;
  /**
   *  @_ignore:
   */
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  /**
   *  Creates a new **FallbackProvider** with %%providers%% connected to
   *  %%network%%.
   *
   *  If a [[Provider]] is included in %%providers%%, defaults are used
   *  for the configuration.
   */
  constructor(providers, network, options) {
    super(network, options);
    this.#configs = providers.map((p) => {
      if (p instanceof AbstractProvider) {
        return Object.assign({ provider: p }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {
        accum += config.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= this.#configs.reduce((a2, c2) => a2 + c2.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c2) => {
      const result = Object.assign({}, c2);
      for (const key in result) {
        if (key[0] === "_") {
          delete result[key];
        }
      }
      return result;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  // @TODO: Add support to select providers to be the event subscriber
  //_getSubscriber(sub: Subscription): Subscriber {
  //    throw new Error("@TODO");
  //}
  /**
   *  Transforms a %%req%% into the correct method call on %%provider%%.
   */
  async _translatePerform(provider, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider.getNetwork()).chainId;
      case "estimateGas":
        return await provider.estimateGas(req.transaction);
      case "getBalance":
        return await provider.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider.getBlockNumber();
      case "getCode":
        return await provider.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider.getLogs(req.filter);
      case "getStorage":
        return await provider.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider.getTransactionResult(req.hash);
    }
  }
  // Grab the next (random) config that is not already part of
  // the running set
  #getNextConfig(running) {
    const configs = Array.from(running).map((r2) => r2.config);
    const allConfigs = this.#configs.slice();
    shuffle(allConfigs);
    allConfigs.sort((a2, b3) => a2.priority - b3.priority);
    for (const config of allConfigs) {
      if (config._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config) === -1) {
        return config;
      }
    }
    return null;
  }
  // Adds a new runner (if available) to running.
  #addRunner(running, req) {
    const config = this.#getNextConfig(running);
    if (config == null) {
      return null;
    }
    const runner = {
      config,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime3();
    runner.perform = (async () => {
      try {
        config.requests++;
        const result = await this._translatePerform(config.provider, req);
        runner.result = { result };
      } catch (error) {
        config.errorResponses++;
        runner.result = { error };
      }
      const dt = getTime3() - now;
      config._totalTime += dt;
      config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall2(config.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  // Initializes the blockNumber and network for each runner and
  // blocks until initialized
  async #initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises = [];
      this.#configs.forEach((config) => {
        promises.push((async () => {
          await waitForSync(config, 0);
          if (!config._lastFatalError) {
            config._network = await config.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises);
        let chainId = null;
        for (const config of this.#configs) {
          if (config._lastFatalError) {
            continue;
          }
          const network = config._network;
          if (chainId == null) {
            chainId = network.chainId;
          } else if (network.chainId !== chainId) {
            assert(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async #checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag, value } = normalizeResult(runner.result);
        results.push({ tag, value, weight: runner.config.weight });
      }
    }
    if (results.reduce((a2, r2) => a2 + r2.weight, 0) < this.quorum) {
      return void 0;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c2) => !c2._lastFatalError).map((c2) => ({
            value: c2.blockNumber,
            tag: getNumber(c2.blockNumber).toString(),
            weight: c2.weight
          })))));
        }
        const mode = getFuzzyMode(this.quorum, results);
        if (mode === void 0) {
          return void 0;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "getPriorityFee":
      case "estimateGas":
        return getMedian(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult(this.quorum, results);
        }
        return checkQuorum(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult(this.quorum, results);
    }
    assert(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify2(req.method)})`
    });
  }
  async #waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value = await this.#checkQuorum(running, req);
    if (value !== void 0) {
      if (value instanceof Error) {
        throw value;
      }
      return value;
    }
    for (let i = 0; i < newRunners; i++) {
      this.#addRunner(running, req);
    }
    assert(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r2) => stringify2(r2.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = this.#configs.map((c2) => null);
      const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {
        try {
          const result3 = await provider._perform(req);
          results[index] = Object.assign(normalizeResult({ result: result3 }), { weight });
        } catch (error) {
          results[index] = Object.assign(normalizeResult({ error }), { weight });
        }
      });
      while (true) {
        const done = results.filter((r2) => r2 != null);
        for (const { value } of done) {
          if (!(value instanceof Error)) {
            return value;
          }
        }
        const result3 = checkQuorum(this.quorum, results.filter((r2) => r2 != null));
        if (isError(result3, "INSUFFICIENT_FUNDS")) {
          throw result3;
        }
        const waiting = broadcasts.filter((b3, i) => results[i] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result2 = getAnyResult(this.quorum, results);
      assert(result2 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify2) }
      });
      if (result2 instanceof Error) {
        throw result2;
      }
      return result2;
    }
    await this.#initialSync();
    const running = /* @__PURE__ */ new Set();
    let inflightQuorum = 0;
    while (true) {
      const runner = this.#addRunner(running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result;
  }
  async destroy() {
    for (const { provider } of this.#configs) {
      provider.destroy();
    }
    super.destroy();
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/default-provider.js
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
function getDefaultProvider(network, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new JsonRpcProvider(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
    return new WebSocketProvider(network);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network);
  } catch (error) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network, options.alchemy));
    } catch (error) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network, options.ankr));
    } catch (error) {
    }
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider(network, options.chainstack));
    } catch (error) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network));
    } catch (error) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network, options.etherscan));
    } catch (error) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = void 0;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network, projectId, projectSecret));
    } catch (error) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network, token));
    } catch (error) {
    }
  }
  assert(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, void 0, { quorum });
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/signer-noncemanager.js
var NonceManager = class _NonceManager extends AbstractSigner {
  /**
   *  The Signer being managed.
   */
  signer;
  #noncePromise;
  #delta;
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  constructor(signer) {
    super(signer.provider);
    defineProperties(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider) {
    return new _NonceManager(this.signer.connect(provider));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta = this.#delta;
      return await this.#noncePromise + delta;
    }
    return super.getNonce(blockTag);
  }
  /**
   *  Manually increment the nonce. This may be useful when managng
   *  offline transactions.
   */
  increment() {
    this.#delta++;
  }
  /**
   *  Resets the nonce, causing the **NonceManager** to reload the current
   *  nonce from the blockchain on the next transaction.
   */
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain, types, value) {
    return this.signer.signTypedData(domain, types, value);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-browser.js
var BrowserProvider = class extends JsonRpcApiPollingProvider {
  #request;
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options) {
    const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e2) {
        const error = new Error(e2.message);
        error.code = e2.code;
        error.data = e2.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    };
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e2) {
      return [{
        id: payload.id,
        error: { code: e2.code, data: e2.data, message: e2.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-pocket.js
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost6(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var PocketProvider = class _PocketProvider extends JsonRpcProvider {
  /**
   *  The Application ID for the Pocket connection.
   */
  applicationId;
  /**
   *  The Application Secret for making authenticated requests
   *  to the Pocket connection.
   */
  applicationSecret;
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network };
    const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
    super(request, network, options);
    defineProperties(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%applicationId%%.
   */
  static getRequest(network, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request = new FetchRequest(`https://${getHost6(network.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/providers/provider-ipcsocket.js
var import_net = require("net");
function splitBuffer(data4) {
  const messages = [];
  let lastStart = 0;
  while (true) {
    const nl = data4.indexOf(10, lastStart);
    if (nl === -1) {
      break;
    }
    messages.push(data4.subarray(lastStart, nl).toString().trim());
    lastStart = nl + 1;
  }
  return { messages, remaining: data4.subarray(lastStart) };
}
var IpcSocketProvider = class extends SocketProvider {
  #socket;
  /**
   *  The connected socket.
   */
  get socket() {
    return this.#socket;
  }
  constructor(path, network, options) {
    super(network, options);
    this.#socket = (0, import_net.connect)(path);
    this.socket.on("ready", async () => {
      try {
        await this._start();
      } catch (error) {
        console.log("failed to start IpcSocketProvider", error);
      }
    });
    let response = Buffer.alloc(0);
    this.socket.on("data", (data4) => {
      response = Buffer.concat([response, data4]);
      const { messages, remaining } = splitBuffer(response);
      messages.forEach((message) => {
        this._processMessage(message);
      });
      response = remaining;
    });
    this.socket.on("end", () => {
      this.emit("close");
      this.socket.destroy();
      this.socket.end();
    });
  }
  destroy() {
    this.socket.destroy();
    this.socket.end();
    super.destroy();
  }
  async _write(message) {
    this.socket.write(message);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/base-wallet.js
var BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  The wallet address.
   */
  address;
  #signingKey;
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return this.#signingKey;
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
      from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/decode-owl.js
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words7, sep) {
  let initial = 97;
  return words7.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data4, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data4 = data4.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data4.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data4) {
  assertArgument(data4[0] === "0", "unsupported auwl data", "data", data4);
  return decode(data4.substring(1 + 2 * subsChrs.length), data4.substring(1, 1 + 2 * subsChrs.length));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/wordlist.js
var Wordlist = class {
  locale;
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words7) {
    return words7.join(" ");
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
var WordlistOwl = class extends Wordlist {
  #data;
  #checksum;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data4, checksum7) {
    super(locale);
    this.#data = data4;
    this.#checksum = checksum7;
    this.#words = null;
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return this.#data;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words7 = this._decodeWords();
      const checksum7 = id(words7.join("\n") + "\n");
      if (checksum7 !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words7;
    }
    return this.#words;
  }
  getWord(index) {
    const words7 = this.#loadWords();
    assertArgument(index >= 0 && index < words7.length, `invalid word index: ${index}`, "index", index);
    return words7[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist = null;
var LangEn = class _LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new _LangEn();
    }
    return wordlist;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask(bits3) {
  return (1 << bits3) - 1 << 8 - bits3 & 255;
}
function getLowerMask(bits3) {
  return (1 << bits3) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist9) {
  assertNormalize("NFKD");
  if (wordlist9 == null) {
    wordlist9 = LangEn.wordlist();
  }
  const words7 = wordlist9.split(mnemonic);
  assertArgument(words7.length % 3 === 0 && words7.length >= 12 && words7.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words7.length / 8));
  let offset = 0;
  for (let i = 0; i < words7.length; i++) {
    let index = wordlist9.getWordIndex(words7[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words7.length / 3;
  const checksumBits = words7.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum7 = getBytes(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum7 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist9) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist9 == null) {
    wordlist9 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum7 = parseInt(sha2562(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum7 >> 8 - checksumBits;
  return wordlist9.join(indices.map((index) => wordlist9.getWord(index)));
}
var _guard5 = {};
var Mnemonic = class _Mnemonic {
  /**
   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
   *
   *  Use the [[wordlist]] ``split`` method to get the individual words.
   */
  phrase;
  /**
   *  The password used for this mnemonic. If no password is used this
   *  is the empty string (i.e. ``""``) as per the specification.
   */
  password;
  /**
   *  The wordlist for this mnemonic.
   */
  wordlist;
  /**
   *  The underlying entropy which the mnemonic encodes.
   */
  entropy;
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist9) {
    if (password == null) {
      password = "";
    }
    if (wordlist9 == null) {
      wordlist9 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard5, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist9, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist9) {
    const entropy = mnemonicToEntropy(phrase, wordlist9);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist9);
    return new _Mnemonic(_guard5, entropy, phrase, password, wordlist9);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist9) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist9);
    return new _Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist9);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist9) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist9);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist9) {
    return mnemonicToEntropy(phrase, wordlist9);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist9) {
    try {
      mnemonicToEntropy(phrase, wordlist9);
      return true;
    } catch (error) {
    }
    return false;
  }
};

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/aes.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
var AES = class _AES {
  get key() {
    return __classPrivateFieldGet2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof _AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet2(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r2, c2;
      while (i < KC && t < roundKeyCount) {
        r2 = t >> 2;
        c2 = t % 4;
        __classPrivateFieldGet2(this, _AES_Ke, "f")[r2][c2] = tk[i];
        __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds - r2][c2] = tk[i++];
        t++;
      }
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let c2 = 0; c2 < 4; c2++) {
        tt = __classPrivateFieldGet2(this, _AES_Kd, "f")[r2][c2];
        __classPrivateFieldGet2(this, _AES_Kd, "f")[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet2(this, _AES_Ke, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet2(this, _AES_Ke, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a2[i] = T12[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet2(this, _AES_Ke, "f")[r2][i];
      }
      t = a2.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet2(this, _AES_Kd, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet2(this, _AES_Kd, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a2[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet2(this, _AES_Kd, "f")[r2][i];
      }
      t = a2.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
};
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/mode.js
var ModeOfOperation = class {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
};

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv;
var _CBC_lastBlock;
var CBC = class _CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, _CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet3(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet3(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet3(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet3(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet3(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet3(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet3(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i + j] = block[j] ^ __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
};
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/mode-cfb.js
var __classPrivateFieldGet4 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CFB_instances;
var _CFB_iv;
var _CFB_shiftRegister;
var _CFB_shift;
_CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data4) {
  const segmentSize = this.segmentSize / 8;
  __classPrivateFieldGet4(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet4(this, _CFB_shiftRegister, "f").subarray(segmentSize));
  __classPrivateFieldGet4(this, _CFB_shiftRegister, "f").set(data4.subarray(0, segmentSize), 16 - segmentSize);
};

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet5 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;
var CTR = class _CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, _CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet4(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet5(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet4(this, _CTR_remaining, __classPrivateFieldGet5(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet4(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet5(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet5(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet5(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet5(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet5(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet5(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet5(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet4(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet5(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet4(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet5(this, _CTR_remaining, "f")[__classPrivateFieldSet4(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet5(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
};
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/mode-ofb.js
var _OFB_iv;
var _OFB_lastPrecipher;
var _OFB_lastPrecipherIndex;
_OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();

// ../../node_modules/.pnpm/aes-js@4.0.0-beta.5/node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data4) {
  if (data4.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data4[data4.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data4.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data4[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data4.subarray(0, length));
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object3, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object3;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/json-keystore.js
var defaultPath = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data4 = JSON.parse(json);
    const version4 = data4.version != null ? parseInt(data4.version) : 0;
    if (version4 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt(data4, key, ciphertext) {
  const cipher = spelunk(data4, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data4, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data4, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data4, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data4, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data4, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data4.address) {
    let check = data4.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data4.address);
  }
  const account = { address, privateKey };
  const version4 = spelunk(data4, "x-ethers.version:string");
  if (version4 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data4, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data4, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data4, "x-ethers.path:string") || defaultPath,
      locale: spelunk(data4, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data4) {
  const kdf = spelunk(data4, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data4, "crypto.kdfparams.salt:data!");
      const N3 = spelunk(data4, "crypto.kdfparams.n:int!");
      const r2 = spelunk(data4, "crypto.kdfparams.r:int!");
      const p = spelunk(data4, "crypto.kdfparams.p:int!");
      assertArgument(N3 > 0 && (N3 & N3 - 1) === 0, "invalid kdf.N", "kdf.N", N3);
      assertArgument(r2 > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data4, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N3, r: r2, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data4, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data4, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data4, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data4, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data4 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data4);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    return getAccount(data4, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N3, r: r2, p, dkLen } = params;
  const key = scryptSync(password, salt, N3, r2, p, dkLen);
  return getAccount(data4, key);
}
function stall3(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data4 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data4);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall3(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall3(0);
    }
    return getAccount(data4, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N3, r: r2, p, dkLen } = params;
  const key = await scrypt2(password, salt, N3, r2, p, dkLen, progress);
  return getAccount(data4, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
  let N3 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N3 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N3 === "number" && N3 > 0 && Number.isSafeInteger(N3) && (BigInt(N3) & BigInt(N3 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N3);
  assertArgument(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N3, r: r2, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data4 = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes3(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data4.address;
    data4["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data4);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/hdwallet.js
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
function zpad2(value, length) {
  let result = "";
  while (value) {
    result = Nibbles2[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha2562(sha2562(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
var _guard6 = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data4 = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data4.set(getBytes(privateKey), 1);
  } else {
    data4.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data4[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data4));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
var HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent fingerprint.
   */
  parentFingerprint;
  /**
   *  The mnemonic used to create this HD Node, if available.
   *
   *  Sources such as extended keys do not encode the mnemonic, in
   *  which case this will be ``null``.
   */
  mnemonic;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provide full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  encode it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate(guard, _guard6, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m = this.mnemonic;
    if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m.entropy
      };
    }
    return account;
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N2, 32));
    return new _HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new _HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist9) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist9 == null) {
      wordlist9 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist9);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    if (!path) {
      path = defaultPath2;
    }
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist9) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist9 == null) {
      wordlist9 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist9);
    return _HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    return _HDNodeWallet.#fromSeed(seed, null);
  }
};
var HDNodeVoidWallet = class _HDNodeVoidWallet extends VoidSigner {
  /**
   *  The compressed public key.
   */
  publicKey;
  /**
   *  The fingerprint.
   *
   *  A fingerprint allows quick qay to detect parent and child nodes,
   *  but developers should be prepared to deal with collisions as it
   *  is only 4 bytes.
   */
  fingerprint;
  /**
   *  The parent node fingerprint.
   */
  parentFingerprint;
  /**
   *  The chaincode, which is effectively a public key used
   *  to derive children.
   */
  chainCode;
  /**
   *  The derivation path of this wallet.
   *
   *  Since extended keys do not provider full path details, this
   *  may be ``null``, if instantiated from a source that does not
   *  enocde it.
   */
  path;
  /**
   *  The child index of this wallet. Values over ``2 *\* 31`` indicate
   *  the node is hardened.
   */
  index;
  /**
   *  The depth of this wallet, which is the number of components
   *  in its path.
   */
  depth;
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    assertPrivate(guard, _guard6, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new _HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new _HDNodeVoidWallet(_guard6, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
};
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json) {
  try {
    const data4 = JSON.parse(json);
    if (data4.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data4 = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data4, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data4, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wallet/wallet.js
function stall4(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
var Wallet = class _Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new _Wallet(this.signingKey, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new _Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall4(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall4(0);
      }
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return _Wallet.#fromAccount(account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/bit-reader.js
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function decodeBits(width, data4) {
  const maxValue4 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits3 = 0, flood = 0;
  for (let i = 0; i < data4.length; i++) {
    accum = accum << 6 | Base64.indexOf(data4[i]);
    bits3 += 6;
    while (bits3 >= width) {
      const value = accum >> bits3 - width;
      accum &= (1 << bits3 - width) - 1;
      bits3 -= width;
      if (value === 0) {
        flood += maxValue4;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data4, accents3) {
  let words7 = decodeOwl(data4).join(",");
  accents3.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents3);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words7 = words7.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words7.split(",");
}

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
var WordlistOwlA = class extends WordlistOwl {
  #accent;
  /**
   *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
   *  and %%accent%% data and validated against the %%checksum%%.
   */
  constructor(locale, data4, accent, checksum7) {
    super(locale, data4, checksum7);
    this.#accent = accent;
  }
  /**
   *  The OWLA-encoded accent data.
   */
  get _accent() {
    return this.#accent;
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-cz.js
var words2 = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
var checksum2 = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
var wordlist2 = null;
var LangCz = class _LangCz extends WordlistOwl {
  /**
   *  Creates a new instance of the Czech language Wordlist.
   *
   *  Using the constructor should be unnecessary, instead use the
   *  [[wordlist]] singleton method.
   *
   *  @_ignore:
   */
  constructor() {
    super("cz", words2, checksum2);
  }
  /**
   *  Returns a singleton instance of a ``LangCz``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist2 == null) {
      wordlist2 = new _LangCz();
    }
    return wordlist2;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-es.js
var words3 = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
var accents = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
var checksum3 = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
var wordlist3 = null;
var LangEs = class _LangEs extends WordlistOwlA {
  /**
   *  Creates a new instance of the Spanish language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEs]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("es", words3, accents, checksum3);
  }
  /**
   *  Returns a singleton instance of a ``LangEs``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist3 == null) {
      wordlist3 = new _LangEs();
    }
    return wordlist3;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-fr.js
var words4 = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
var accents2 = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
var checksum4 = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
var wordlist4 = null;
var LangFr = class _LangFr extends WordlistOwlA {
  /**
   *  Creates a new instance of the French language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langFr]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("fr", words4, accents2, checksum4);
  }
  /**
   *  Returns a singleton instance of a ``LangFr``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist4 == null) {
      wordlist4 = new _LangFr();
    }
    return wordlist4;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-ja.js
var data = [
  // 4-kana words
  "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
  // 5-kana words
  "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
  // 6-kana words
  "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
  // 7-kana words
  "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
  // 8-kana words
  "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
  // 9-kana words
  "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
  // 10-kana words
  "IJBEJqXZJ"
];
var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
var _wordlist = null;
function hex(word) {
  return hexlify(toUtf8Bytes(word));
}
var KiYoKu = "0xe3818de38284e3818f";
var KyoKu = "0xe3818de38283e3818f";
function toString2(data4) {
  return toUtf8String(new Uint8Array(data4));
}
function loadWords() {
  if (_wordlist !== null) {
    return _wordlist;
  }
  const wordlist9 = [];
  const transform = {};
  transform[toString2([227, 130, 154])] = false;
  transform[toString2([227, 130, 153])] = false;
  transform[toString2([227, 130, 133])] = toString2([227, 130, 134]);
  transform[toString2([227, 129, 163])] = toString2([227, 129, 164]);
  transform[toString2([227, 130, 131])] = toString2([227, 130, 132]);
  transform[toString2([227, 130, 135])] = toString2([227, 130, 136]);
  function normalize2(word) {
    let result = "";
    for (let i = 0; i < word.length; i++) {
      let kana = word[i];
      const target = transform[kana];
      if (target === false) {
        continue;
      }
      if (target) {
        kana = target;
      }
      result += kana;
    }
    return result;
  }
  function sortJapanese(a2, b3) {
    a2 = normalize2(a2);
    b3 = normalize2(b3);
    if (a2 < b3) {
      return -1;
    }
    if (a2 > b3) {
      return 1;
    }
    return 0;
  }
  for (let length = 3; length <= 9; length++) {
    const d2 = data[length - 3];
    for (let offset = 0; offset < d2.length; offset += length) {
      const word = [];
      for (let i = 0; i < length; i++) {
        const k = mapping.indexOf(d2[offset + i]);
        word.push(227);
        word.push(k & 64 ? 130 : 129);
        word.push((k & 63) + 128);
      }
      wordlist9.push(toString2(word));
    }
  }
  wordlist9.sort(sortJapanese);
  if (hex(wordlist9[442]) === KiYoKu && hex(wordlist9[443]) === KyoKu) {
    const tmp = wordlist9[442];
    wordlist9[442] = wordlist9[443];
    wordlist9[443] = tmp;
  }
  const checksum7 = id(wordlist9.join("\n") + "\n");
  if (checksum7 !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
    throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
  }
  _wordlist = wordlist9;
  return wordlist9;
}
var wordlist5 = null;
var LangJa = class _LangJa extends Wordlist {
  /**
   *  Creates a new instance of the Japanese language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langJa]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("ja");
  }
  getWord(index) {
    const words7 = loadWords();
    assertArgument(index >= 0 && index < words7.length, `invalid word index: ${index}`, "index", index);
    return words7[index];
  }
  getWordIndex(word) {
    return loadWords().indexOf(word);
  }
  split(phrase) {
    return phrase.split(/(?:\u3000| )+/g);
  }
  join(words7) {
    return words7.join("\u3000");
  }
  /**
   *  Returns a singleton instance of a ``LangJa``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist5 == null) {
      wordlist5 = new _LangJa();
    }
    return wordlist5;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-ko.js
var data2 = [
  "OYAa",
  "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
  "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
  "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
  "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
  "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
  "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
  "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
];
var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
function getHangul(code) {
  if (code >= 40) {
    code = code + 168 - 40;
  } else if (code >= 19) {
    code = code + 97 - 19;
  }
  return toUtf8String(new Uint8Array([225, (code >> 6) + 132, (code & 63) + 128]));
}
var _wordlist2 = null;
function loadWords2() {
  if (_wordlist2 != null) {
    return _wordlist2;
  }
  const wordlist9 = [];
  data2.forEach((data4, length) => {
    length += 4;
    for (let i = 0; i < data4.length; i += length) {
      let word = "";
      for (let j = 0; j < length; j++) {
        word += getHangul(codes.indexOf(data4[i + j]));
      }
      wordlist9.push(word);
    }
  });
  wordlist9.sort();
  const checksum7 = id(wordlist9.join("\n") + "\n");
  if (checksum7 !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
    throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
  }
  _wordlist2 = wordlist9;
  return wordlist9;
}
var wordlist6 = null;
var LangKo = class _LangKo extends Wordlist {
  /**
   *  Creates a new instance of the Korean language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langKo]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("ko");
  }
  getWord(index) {
    const words7 = loadWords2();
    assertArgument(index >= 0 && index < words7.length, `invalid word index: ${index}`, "index", index);
    return words7[index];
  }
  getWordIndex(word) {
    return loadWords2().indexOf(word);
  }
  /**
   *  Returns a singleton instance of a ``LangKo``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist6 == null) {
      wordlist6 = new _LangKo();
    }
    return wordlist6;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-it.js
var words5 = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
var checksum5 = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
var wordlist7 = null;
var LangIt = class _LangIt extends WordlistOwl {
  /**
   *  Creates a new instance of the Italian language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langIt]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("it", words5, checksum5);
  }
  /**
   *  Returns a singleton instance of a ``LangIt``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist7 == null) {
      wordlist7 = new _LangIt();
    }
    return wordlist7;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-pt.js
var words6 = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
var checksum6 = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
var wordlist8 = null;
var LangPt = class _LangPt extends WordlistOwl {
  /**
   *  Creates a new instance of the Portuguese language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langPt]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("pt", words6, checksum6);
  }
  /**
   *  Returns a singleton instance of a ``LangPt``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist8 == null) {
      wordlist8 = new _LangPt();
    }
    return wordlist8;
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/lang-zh.js
var data3 = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
var _wordlist3 = {
  zh_cn: null,
  zh_tw: null
};
var Checks = {
  zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
  zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
};
var codes2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
function loadWords3(locale) {
  if (_wordlist3[locale] != null) {
    return _wordlist3[locale];
  }
  const wordlist9 = [];
  let deltaOffset = 0;
  for (let i = 0; i < 2048; i++) {
    const s2 = style.indexOf(data3[i * 3]);
    const bytes2 = [
      228 + (s2 >> 2),
      128 + codes2.indexOf(data3[i * 3 + 1]),
      128 + codes2.indexOf(data3[i * 3 + 2])
    ];
    if (locale === "zh_tw") {
      const common = s2 % 4;
      for (let i2 = common; i2 < 3; i2++) {
        bytes2[i2] = codes2.indexOf(deltaData[deltaOffset++]) + (i2 == 0 ? 228 : 128);
      }
    }
    wordlist9.push(toUtf8String(new Uint8Array(bytes2)));
  }
  const checksum7 = id(wordlist9.join("\n") + "\n");
  if (checksum7 !== Checks[locale]) {
    throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);
  }
  _wordlist3[locale] = wordlist9;
  return wordlist9;
}
var wordlists = {};
var LangZh = class _LangZh extends Wordlist {
  /**
   *  Creates a new instance of the Chinese language Wordlist for
   *  the %%dialect%%, either ``"cn"`` or ``"tw"`` for simplified
   *  or traditional, respectively.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langZhCn]] and [[langZhTw]] should suffice.
   *
   *  @_ignore:
   */
  constructor(dialect) {
    super("zh_" + dialect);
  }
  getWord(index) {
    const words7 = loadWords3(this.locale);
    assertArgument(index >= 0 && index < words7.length, `invalid word index: ${index}`, "index", index);
    return words7[index];
  }
  getWordIndex(word) {
    return loadWords3(this.locale).indexOf(word);
  }
  split(phrase) {
    phrase = phrase.replace(/(?:\u3000| )+/g, "");
    return phrase.split("");
  }
  /**
   *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,
   *  creating it if this is the first time being called.
   *
   *  Use the %%dialect%% ``"cn"`` or ``"tw"`` for simplified or
   *  traditional, respectively.
   */
  static wordlist(dialect) {
    if (wordlists[dialect] == null) {
      wordlists[dialect] = new _LangZh(dialect);
    }
    return wordlists[dialect];
  }
};

// ../../node_modules/.pnpm/ethers@6.13.4/node_modules/ethers/lib.esm/wordlists/wordlists.js
var wordlists2 = {
  cz: LangCz.wordlist(),
  en: LangEn.wordlist(),
  es: LangEs.wordlist(),
  fr: LangFr.wordlist(),
  it: LangIt.wordlist(),
  pt: LangPt.wordlist(),
  ja: LangJa.wordlist(),
  ko: LangKo.wordlist(),
  zh_cn: LangZh.wordlist("cn"),
  zh_tw: LangZh.wordlist("tw")
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/base/SemaphoreGroups__factory.ts
var _abi = [
  {
    inputs: [],
    name: "LeafDoesNotExist",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotTheGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotThePendingGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupDoesNotExist",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminPending",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "GroupCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MembersAdded",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getGroupAdmin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeDepth",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeRoot",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeSize",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "hasMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "indexOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var SemaphoreGroups__factory = class {
  static {
    this.abi = _abi;
  }
  static createInterface() {
    return new Interface(_abi);
  }
  static connect(address, runner) {
    return new Contract(address, _abi, runner);
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/base/SemaphoreVerifier__factory.ts
var _abi2 = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "actual",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expected",
        type: "uint256"
      }
    ],
    name: "Semaphore__VKPtBytesMaxDepthInvariantViolated",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256[2]",
        name: "_pA",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[2][2]",
        name: "_pB",
        type: "uint256[2][2]"
      },
      {
        internalType: "uint256[2]",
        name: "_pC",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[4]",
        name: "_pubSignals",
        type: "uint256[4]"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode = "0x60806040523480156200001157600080fd5b506200002460206200002a60201b60201c565b62000197565b60006020600e8360ff166200004091906200010e565b6200004c91906200010e565b90508060405180613820016040528061380081526020016200412c61380091395114620000d15760405180613820016040528061380081526020016200412c613800913951816040517fbd6021b5000000000000000000000000000000000000000000000000000000008152600401620000c89291906200016a565b60405180910390fd5b5050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006200011b82620000d5565b91506200012883620000d5565b92508282026200013881620000d5565b91508282048414831517620001525762000151620000df565b5b5092915050565b6200016481620000d5565b82525050565b600060408201905062000181600083018562000159565b62000190602083018462000159565b9392505050565b613f8580620001a76000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a23f019914610030575b600080fd5b61004a600480360381019061004591906105c2565b610060565b604051610057919061065b565b60405180910390f35b60008061006c83610469565b9050610405565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000181106100a4576000805260206000f35b50565b600060405183815284602082015285604082015260408160608360076107d05a03fa9150816100da576000805260206000f35b825160408201526020830151606082015260408360808360066107d05a03fa91508161010a576000805260206000f35b505050505050565b600060808601600087016080890151815260a08901516020820152610145600088013560e08b015160c08c0151846100a7565b61015f60208801356101208b01516101008c0151846100a7565b61017960408801356101608b01516101408c0151846100a7565b61019360608801356101a08b01516101808c0151846100a7565b833582527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760208501357f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4703066020830152843560408301526020850135606083015260408501356080830152606085013560a08301527f245229d9b076b3c0e8a4d70bde8c1cccffa08a9fae7557b165b3b0dbd653e2c760c08301527f253ec85988dbb84e46e94b5efa3373b47a000b4ac6c86b2d4b798d274a18230260e08301527f07090a82e8fabbd39299be24705b92cf208ee8b3487f6f2b39ff27978a29a1db6101008301527f2424bcc1f60a5472685fd50705b2809626e170120acaf441e133a2bd5e61d2446101208301527f0ae1135cffdaf227c5dc266740607aa930bc3bd92ddc2b135086d9da2dfd3e2a6101408301527f2b86859fd3d55c9d150fb3f0aeba798826493dd73d357ab0f9fdaced9fc81829610160830152600088015161018083015260206000018801516101a08301527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26101c08301527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6101e08301527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b6102008301527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa61022083015285356102408301526020860135610260830152885161028083015260208901516102a083015260408901516102c083015260608901516102e08301526020826103008460086107d05a03fa8251811693505050509695505050505050565b604051610380810160405261041d6000860135610073565b61042a6020860135610073565b6104376040860135610073565b6104446060860135610073565b6104516080860135610073565b61045f828287898b8d610112565b8060005260206000f35b6104716104f9565b600060405180613820016040528061380081526020016107506138009139905060006020600e6001866104a491906106a5565b6104ae91906106d9565b6104b891906106d9565b60206104c4919061071b565b905060005b600e8110156104f15760208102820183015160208202850181815250508060010190506104c9565b505050919050565b604051806101c00160405280600e90602082028036833780820191505090505090565b600080fd5b600080fd5b60008190508260206002028201111561054257610541610521565b5b92915050565b60008190508260406002028201111561056457610563610521565b5b92915050565b60008190508260206004028201111561058657610585610521565b5b92915050565b6000819050919050565b61059f8161058c565b81146105aa57600080fd5b50565b6000813590506105bc81610596565b92915050565b60008060008060006101a086880312156105df576105de61051c565b5b60006105ed88828901610526565b95505060406105fe88828901610548565b94505060c061060f88828901610526565b9350506101006106218882890161056a565b925050610180610633888289016105ad565b9150509295509295909350565b60008115159050919050565b61065581610640565b82525050565b6000602082019050610670600083018461064c565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006106b08261058c565b91506106bb8361058c565b92508282039050818111156106d3576106d2610676565b5b92915050565b60006106e48261058c565b91506106ef8361058c565b92508282026106fd8161058c565b9150828204841483151761071457610713610676565b5b5092915050565b60006107268261058c565b91506107318361058c565b925082820190508082111561074957610748610676565b5b9291505056fe289691d7705934b5504ae4bd7be283f3465af66f62fc7f1e66f03876b445efdd22a0bebada6ba60c3e190e9e8c2b1420244a14c9e02868b862c7945667416f9a036ab5249fee75e0644ed259d45fbbd0142b638e421b948f5dc00cf3ff14a5301bcf8d4f8bf886d2c7960badc94b3abf6beb4e43571d2b4b0f14928c10e0d5942d8c51b7fa4ea9ea16765377aaae4ae0a416a89b600fc0b8ec35e9e6e56219761f2c636b4954a865946d69fed3ecd2bb60a61af38fa31f2a290ae28915d1f6e10b412b14d9dddf3f9031ffb51eb3f73602b9e49cfa9bec4a02ec9c0e3020ccc30ae9889ae5f4f6021af9e16dd1f2c445ed863fd6a374b329337f2fef4715350d07f75b300b401d2435b96459d2b64f6f848411f246d8478199dd2351a35c1b5e195a26806d907b6d9a9a9c235e09a48e94f8eb8da80f0d40bc4143e3d006e6d22d0006337513747c51f8f3e87364d2852113a83e586ef629c88cee6d4cbd422f257aeaec24103ea15e4592c32d0ad9846ff1a2f3a836e0c19947980912b9006b294bead7a3378f80183af735f6bc8529ddc73d9e0a35d594dcf93524403c9e3e0cf84e9163744a9a65520f4b8cbb4ca35c428d1c4a5789e11f42636c6d19747321f43b1ffa301d565dbc37ef1eb2ef669b8a1876e3754b79657b26fe43c845ce1e558b2ca618dfa02f0d640fdd45f56492a577154989cd09523829b5e15f2d6204db437b7b4fa0f6eea95403dd25c6a674b3e81be98ad4532affe8507ec0538020376c16b97ad98b8dfaa6f10d42a3c5e264c56018d32b0e8af528db157eb60d234219fd49f941520883c13c1f01ff7b2f7f512a3046f91d33cdc3900ffb9de91d754d84438f79e6b701f7d665d59755a7bcd0b63f7c2da94b737606c16de1d3287a08af195521f756271ec64bdc4ca8a7a95fae892c0fd2cf0c148d6c0cb6530e16af35936b356d5974b385528f6d9a873568eda614ed0e54be4494c2acdefd0fae7f745efa5884dc82f1595b5c10d931ed6da07b5dc4bd6f99dd5318c7c2a821f41494c6685503d748b45672c65d059260bb205113882458c86f6da7ea38131ec11e919c80981c8a905161c48caab360994e8f31cfe88536c5ad8b2c36003914f32ba1f584bafc3aa283f79d5d65e97a6a280c7c51cec192ee9e48d593a2be0cec3b3618ebb60152be2987b910940e79a421d666a71764f25ded99159de90f075a80d650b5c6f8a0b3261ae5ec4c5a1b53762f30c559aaa6c501e207c2514f026c5d81cf4e6cbade3622323c4ee3b4568333e79504044d2ad4d2ba01abefc5286bacad6fb92895c85483e837d7c821d3f7bd612ddd932c16d618455ee62a4511a11b68cb7aa85f42325a3d0fa45e0887719f05c9cd472183b1c7c78eabd0ef0674f14710e453bc1f9255babc8d2aeb3b2e321c68e6871b54c285e71456be4d11bf8be1878d5dee6820ec405b079360da81da7b79f29aa54096ae195ea1108d2a02d0a645dcfcafb2235e7f9ed37df27c3f7cbd5ad11ee831fa17cb36881d3f1e2338342dcdeec5d3ebd82d4b767ed93989d9147ac711dd07d8aebac0962c20174c21361611783b0dc90d87a6128cd4d7e427cca10db1d713495d8281ce3dac22654673d8af40026294acb3c0e51f0f367576d83a554bd9ad72de06a796095e08f410159146e32feb7a585ad437c4a48ff2109d7f74f58e709b66c292e1c690160928e9343db00c99255a53ea3948b547d0bb68332069c2d5ca632156a53ac81b8e0ca895ea976f5d42029c964ea52d622388e90f947cba08b3924b470d84a02f21e5bcc52e6d794afbf44a0dcb938554c7c94fbde66c1b7965ebb2d266d6be106d51a9231260949c37fcb7c8296c246566259829e98ef52683900a433ad7d71f0691902d412d4afe6e49f546ad03d739f42a159af9530d717c01a3e9bc86b726c15552cf455e161693ea7f01601fed166f79653153fb5beec9e8393c1efde50223f9fa8192ae6be752d29b47e8b8a75e2172fbd4c89cfec400a9766e1430a8100341a4e94a5cfffa3c6cfa1be6ac3bf6b0c4fe578f8c99cc4f67e4d7bf48861a9194b8c654ebf4f3cbb607c8bff2ddebaff87b8bdec06745ad4ed802728a6f0a7e869e75859fe47e51b3b79ad155670af4e6780d3edd3c13812db0197854d30ef4a576b0bef4d037549aa24282378e13b438fc9bf49efcfd65cf3aa8935d28199af24c0e98e72c37d87bfb9386003c2a0192ccf015be777c4305d5eaaf0e8106e7f2d897f05617580ccc132040f3b83f3fe1a496354b33f39d27b15fb2a5fe07968d5b67877cf32da7858c85479a891164a19b1ddc26fdb2772d294addf3b61b4dc215f06081e276803f1650d67324801c0a4f48d4b4fac9f6650d2fcd901c0c5a5f0969147d312118768cd73a762e53d3984088be93e46d8433d1299394271a948b5fcbf5918fad1f3c69d9d58c2df72cd9a15ff57a35c86c9e5082ee40900532f7499522ad56592a815a303b33b648fe170e0c2f47d831255298200cd77522cce52f921a79b56993baaa1854b37ea74caf7e6f2d957048fe5e5d1e536ce21ca9ca03dcd6b6539118fc036663b6deae0bdb0df258f18e23613f4e80bd5bca2f7a2d324bace30583592592d82bb970ed33f9753d03dcd3b54a44af04a0f1c00f6008b6f13bcf8f2663e7392e2538406a7cdf15ad387e2eda92bb1de03f74f006e30762808351c935656ddd7ac3499a2b497991d02f54c178277fce024ce89b1a087e883f78b0e1ecbc92dbe9d82258e4c91baac53d71836902953f8e5a69610d35fd011b125ac12fd1d7c655fbb7b1ebc9eb47008676c750907f7768f6d644183a077e1a0a2dba1ffcf7e2a490859a5f60d5d04b3599506249b6d534848ba224230c1864237bf6dc8d6b3e40bb277c02dab92e86aa515aaa62b1ad496b8290075a995ae152c5f9737f6848a2d5ef93a8e7809981a06834ef8b6843904560112dcfb2766574efd57331146186055ee967cdd14d5efac43389a29605d13d561c05a4a1353e53e1b5622a2200ee1fb2e1a8e224a8ec5554bb670bb377505cb615064cb205829acdaf1af3d45060ffa3433c02d3a7ae61b66ece50967b97e1f04a1af278018cfd4d2edc11dd77454ed0cc4ef3ca1dba5b0ba96bb2bdc43f1e8ef023e7488f10d910e129d466443a7adb99fad7ac0b0bb37a51c9d0f1b7c527a98d29594b068af04ce6fe6b248aeb06051d6f66a39d9f3d13cdde5b343f31ec16ea1e63fabe17ec748ba86bf78cd84029d23ca6c543ee800179dad25964fae41cca2acc46fb9f4ba2abecc49ddb33c0314c7a940bfa021c07d44a73614599995ea10d520400f15c87d18376ebfc03c8ed06b9ed713a654a0024cf310b64175d1064188ef3fd8a2134f2d4237dd7657f410ba5172ae081a6ca117dc21c7ffe71d6bf06a71b093737f1ebae5924f2d5f47b8b14526c4831c50f9e9c7c032dc011e511175921f58fb9fd90e2a1d2cf951ad606104a1676c9d2e6fc8fee6ea105239035236859cb45dff68ffa2524619936a9cb457d2c0defe59b5863607e439369f31628e0e101f6b62767f587d7dd8e0a4d4e32fbed3fc65c940d8aa8509bd826e33f0158d4f5cd5085c6e4ae2fd1330a52435eb0745d54c7c8a6ad5b7a3cf5333a7a05dfca18855acba1a5409f714a77297952277658af5e7d5e3a05bacd0b8005d11edb9f2871655c1418f9c7b5851dd8b1713d1f9d7d78c9b915b2d3ecb62e756910d33c3349ddff796b66b2c800a9fdf51d44235d14d74def1b2c112bf88647d00e55341297ed43dfa1312685a260ec51b42ed6c24e46b79900549fd0234412820a1654efc1b702b4ffbcd21a9e0e3323a40e4a136bfa0cf81cf01bd89d433c56148f5bd214818a2b59ed67a8d79e54a048f357989e2046b3e7b587dc4893896b24d21716ac3c7fa8d8945b7b04479a0b397b8fe46e3424c0db7e1d7d824e40de2830e9e432e9bc3e8dc48c98c12ee9081273f5be246347769d0a34e2f0e7ec3f012e850e98e970f096522ef6f4f537529f296f7f3ec9ade921780c45fca74e571eb45ad2eccb950133aec7d4da6d03c301cebe782ba71e3533d5a0879bd6d0c71ce082f6108befc4c6133865cdf1b35a587868b99c36f59811bd3771a75c375321d1d3327b86bcb2514eac6f11a77867856f5a2cb24ff4f72f65742854baa0a3072a1c2e8d55ba7a49807bbf09ad71e000d67b09bba8ea2ec6009086342753a71c9b7142435f0c29a9ad5549dcb9ac289104f48d39d4e196025268dfa1b6a25500e7f5e830053d6bd9dbd5a2546f2b38820b7ec18b55b638f189c2cb865982880ab8a2d0b81f7a40ac8a6a8bed4df0643df2a4dd4606194c8508595e116f39f3166b4f313145815f8ab8a09e6fac91e3cfa404438c8c430dda4d121eef70a9bc0937ff264a4c22904c66b8466165d9302052f5687326970486277a54f458717b23d014ce251eb044d74105355f1ae0b5dcdf0ef73fece10777328b86b0bb4d07276c1c219fdc62892dd095536db3525c18d0409121171197c99bdd8a95eb2f5a235d6ab6cef9830493b2c71bacd3782d67eeffacf4aed5bc07c2524203344cd31ad0bb296be4e478c61149c736ad66168c2d0ba4410e05513c1af1ebe644b0760360722094dd4a26a16d8f12264b25accafdc6a3f55736f0de1e55dbdb28d02a088b276813522c901c6ac134a1ffa00cd61276e1221bbd7ff377d1dba5e1beb1243cd531b8f9fcb0cd9e8d9418c6e9306b89d96e0136eeaa66ebdb248bfd08f402a12915178a6e7d4a612dbc3a878db9ce7153bdc9130d3df7308c13b2e97fb005819bfdd569b0009e9bd1f9a41c7eb23ec33d8cd37d5d05b705b4511dc09f0e05d2260582a4a391c8180a17189b98a53b831ebced724333194f2f6809571401185017332cad227b54dca48915a4a78875967f8ed352fd96d5446946a64b429708192db4386fcba811f000733a6f28b929be4f9aa1d2140ccc3f9616f82f34cc1281dc4a2838c70842102a997a6bc26a737209d42266e815738ec3943516e150279e9dd39bd768a08ad9ceca41993b8e8408d025affd64237b5985ed9a37d52a11bee6efbee9ff1ffe2f060d79bd751d43bfdec4d5fa5e323582f8d735f44c7b1bb75e2ad0bf3e1f255a9e983428b9baa96cfae8bf71d1aa4d3a786235e2106528941f264db478bce46c697bc574a5dc0b956d033eb29194de103a9a70bccdeb19d5cfb9c2ace7ec529ea27438d22668f09c2acbdc9c099bbd5554a6f3ae145a29fbde88fcb5e46ca563fad42cc7e26ddbdc0e655f88057a8a8f6e51354f74db1dd99423b0d860b8ee34e292b4616f7c870094c265f52cc450f98a575323872e2400a80de9d38f539c9b0b9580ccb9ae2e382f3092a657ff50a83ea03a4ba7d620a5b9553d48bdf8ff66139e723e6a1655823b62add790b62e605d90044bec0e196df524c0987fe4b832add37f546b835dd259e7c03de7226a43a6a062b4e61c2ea4e4d02236497c570aeac4ea1896e1e3a19343f6e50eadb273cb5a7becdad20800ed797700c5e269e0c1edf4947c65348976d4a67e16ee547c6c870c36e3d709df4796e7cc0d89f1fc722c7d967d4c0baa823f93f9c4d6c7913edd185bc11c23442bab611ff64c7eb49ab07f32f52008673d80ba54e04bbc5c61ca1f0c38362f5baea6ca93f7a41762a2b4f5b6c31c4e0d140e422fbe379f2686522dccb035288e0e05b537a48d5470921b9d724c26fb8d2900dc7d6f0741ba2c1a35138c1724584003a84247aeb78b30e2d8fb4cf7147785647ddeb68a7df6a79ff84fb008219b35214df5048253b823fcaf329a45a2ae7f959af6539ae7753e3554d2899621795fa4312815b80472036b9f35c1495378f172c7157a9440e62ee46692ace61052d93c57b9902620b22e1c29b9106ad076f25f69fed4106736de133d72ecb71948cc83425a81e7f7c6486e0f08b4b412724759ce41f950d65fa5283c31a4c226769518d0ab71ba583b0022557cddceec3566637a6c1c519999523b44d953ba13a68997032013798fc580d466367a6a04502f500f7dcf4c2e6e03e7774849082668cc07461b1088861db6bf4c03528227a20d2b473e088aff34daa78be838000bed18cab0f02716c9ee5e68f2434a241e6784ba03ca69df0edd97dd72038b6c2e04d93cc4f54309390fe572d6affd4cbb1989ddcf410fb476e3a8681656efaf18b0b7c0a137e1454dd3ca510d220987b5aaa51124e157fa372ec6099a03a7140354150d34ffc1b4ea2bcc2d705f72e2bfac4619f6ba35de7a5c08d5d7ec34b712c1195df5fc75284ebe217430760ab4862de0255f75dbe24f4fe60f90c3419d03630b0da0e292c1088354c075dd1e00694fc14db1878a5cfacf2b7b797742e516d451a52d64de482f4bf60beb30fa565a4e29904042fe36288002bb84325d5a0664003075b0ef9bfd1573f70b84f7b75ce76563169be92df533d5aeb47ffbe70b41ef4deb720d4d2fe7dc11b4483b3d0b226ef5cfd8ba9a4e46bea1018fbb64298c7227e27ecf7291ff64ebbab81169202697e8e76afbe9fe1504243b4077b30cddb62d67cbb120c38a93a9d10466381bcc71a202ee0a75f1bf952ac1c61a001f251e0231fb968a4b39bd089704ca99438b645cfc29920e0f8f4988f77e95970ec2e8e1aa9376bd31702a93e024f654ed26a324bf744d53271e510a1f7cc2ff1155f64822affa2c0d2fcd555aa5dad8698731fca61bd3a3d072cf33c1a8d9f815699cea496017d4bf9fcf96e5a384e7c105d2ac074571e600afd0e9b4e7e8b21e85323381cf7d3ba3431e64e894ce4d693f0c463b6d104dd33dedd7f1b9f081004b64f1d7c848aa7c28d6a815b7ec34ff2bb76d2d8c25f93265ad8b20b7140b0dd34779b2145df8b131bfb71ffed5c835d2b696299ed813bb472be2f3a880ea0e1abda56faf0df6daf6b166c95c5edc97bac1f73d539a4e419e36cae7ee1d9211c1659cf668bedf75fe21edb2ff2b1fc695bbd538c1331845f24839897b620021bdf685c361d30014b4396b358599cefdc9d5f3b464d67a54c9cb29789257101b7153446f1040fd153236c214b0b502ccb8c202c54ddfa527132962133d398819a23ee53b40796801a094627b87364921ae981e57f9f478ddb3fe9e3050dbf30c3793885e6423402d09a54736d9a0fab9f8e5edf858b7be1710b5ee2a46c8ae1dad8846162762182f95a6360199cd0ccad756cea2e4fbb6f17bf7bb643cc6ea0185b530295447254ce398130e4f1bac6a4135c8b9be462422bb6ed88d7d81560cc09061f82989f499b935c855c6446ee4c02f2b5ec74205bb2681a3d39cae951e785e3c3ce8c5a93d9a16f466e1df548f855d70d18613fe8dd861f3e4f486c604715136d512b998cab28f4cada627caf8da082e1b11e2438ae4f8ed17b259ec16b21b75881cfd9f0ae30c2ebb472bcfafd4c09ff390f3a381e2098d9b057cf11ce1a91c61b317ca6f871105d6034a1ae73832671555965c2deeb24c5da51ce21382891a3df8d5ba54ddcbd4a9061a4574b0a4813c7d5fd49797bcd8ebbda4b628b1699345f2327ed7e3a35dbcac11e9704a2d019568e273b2ddbbdda61b96f11875cf03eaefd3c4a503d2499a9524ba9c8e8b1906511a4a85800ee21ad424b32d1b12c661616bf91e9616cf0dd1823f5e33799035dd1bcb92bbb8bd7b9fb5cd1764a79b21973a65541bb9bf58bae57a63de6e20a207369f85b0ece77b1da38822852209e2034dac637154e40c26004c7d2f8d6b0f2f649fe920d916a0b9608b19bad11fd19291c1d7aba146796c8bc076303184293b05257a2e95aa1b35be93017ede6c3a4fadb0c3b384fc1bb3ba2515ede2ddf470bbc5279817dccba8486f20dc05e84fe2b3674dbf6cfbc4ea1888a95c385a682b198665ea24fe875f91820c6eb30738c6c686153cef7a45b97d5da153ed62a67f725af666c8f5454143261b2e0303ea261450c0505cdcf6d8c5a1fe7c840287ff532d632de4cd4b899b0725d247a3eaf394fba18917bc67089efdf773445090ab333538b9db6dd2aa34bc0189a235ce7315920cc9633d5dc1c072cad0ebe0e95a07a0a7f6152bb14345c5118ec9dfcdb51980db3cdbc0b4917ecc57a03dd0c8586ed23145fb8af86e64f92af16757fe4fb59efbf68b60493d51df19d06df73ff34828b9b0805b3a12512c0649e85e611b0ea226cd5195e88f479ca348748e3aceb994208fdeca397d1c930d13a131ca0eb5a309eed385c046002c368bc570ea227bb02cc92be5e30820fd2444558ba0ba9ab3e990299dc09f450bae4c4c92829a42c6943c451cc858e34624e06233837107b33fc5cb27ac7baf78d48735d71cabebf68bbe8437ec15e57a1f5903dfda34ef89110f00cc07959025cf325ee02f81046cc48105d3e5930bfc20093ac8cbfca0030d78cc010018beb1b3e689d52956baa0c54ceaf858488e222ee9cc8d4c5e47162bf7386e4325e3a513e6d4f4458f5e01fc343e340124c0fd1e2f5897ab3f2279bc761e37a8c20cf48a6bb27fb6da5bf0a5f67fca6ad93e1a0e9ae19d75c9f500b45f68de80244090eb66f42dab81886a78645cb1bfb279310f78e982ab46a572920bb2e18383e1427da1df92db1f3665498c719a7af869d222c0107166bb0aa5b0885983712566f8e0b4471e69d88ebdb7d0173345a2cee80d8d1c4837d9de3b2d429fe96aa4f29fce440e52141ae4571cb1f1d7735af86c07240e3b2aa1472c3c81dbc49bfb3e866b43f778158a3fd6641a773da5241474037cb0fc644b2a88c90ee66cc4ddb962336347ccaecd1f4fa8eb567c0454465511badee113262abf691cc75f28c0236812d76537940e970f4488fbce2ccb46e70e0fec7749cda728fb17b5b1ff968bd3b6433dd6dd6cc619e8ab2eae099ffb4828f906c82568287d2256b56129e8b83944f9ee180627afbc9d510fdb7b392458129e691ecb7b6fe77c01d70bf2628fe69e5f6e962f1029ce626a0d18886241452f8d1c3dddbd8cb59cbec15b623aa1309d12221f7c62d956815c924114ec867727db4f836bee8aa950940cc1732aa52d0e741ae355a8c3621ad068c043f77cff2005b28ce7c5532ebf6b7e51d10c344c9a9b00836e4fc37f7eb1176d640c19060aa65efff54d1d497ece96910f6661001fb199d24c3cf997ce1e401788a382ac17dbdc878bd81276bd23b35fe31d93f4d7cb65b722e65d58fe039d126524bb4b26dadd32b90572e617c96576afcb2fcd9605b1d898b2366fd9a7cd0c23769da92e46b7b8c48234c4466b0be922a9525a8896b2d6cc9651b2f6f291cf2bd72b8504523ff71405a30800020b61ac9a1e6b61ca68f9859f6bf1106f2a0fb66d5da305a3e48cdcb56d89222f017078cf35af105ab2b2e2cdb7adc3d71de732d2f22008d6aec49dcb622b4b6033438a7b990f6e08a2d41909392a890d6ab2970c4fcb2de53850b4466695b93e50172ffcc6ff47c882aa9444bb09652ee9f5a4f43e8219963fd677971a8f8f1fe5d09bd27ad0676c59c6b99cc2c46d8a886716e16a0a2b0e85311370de1c8442d4216cb8ccff3d36a6765addb8a188408eff04a488a630620acc22c938e923607f077ab953afc8412ab4cd325b812e18b36db9ea03c21a2fd212df4bf20f8e47cfe5c5285a3706f8ab9863ea128054bafa1fe192afc228dad5eeef0e864876e671e4a960e451d5cb11204eb0f7dedb1d1bea322aeaad09ce122c5b6d149f0192436aeccf959f73db3968cbe69f6c2dc955c1a8644eff00b33c6fe57db259f1f62f8df50692e8d8c36a22c77234e0d81dea745254adbf2b5b16738d4e4e8f30d8073c01e34d8a784bc6b41ec8e2afa5c8d2347b145ed40ce970cfdbc28f9bb3195dd2fb274f9895a29a996aadbdaa4cee11b546cfdfdb0822416fe28cab89c713f9ab14d28a3d22a7033c1ada634ce7928681369e9b6115d6ee8f939ad0609d6eb842084c6ca07a055e83ae2d1a0109498f8b7ee9bbf024cd8f5ffaa9da4f482d9efec43b3e1c77e8eab2f44007269b14614c932ebdd02093e404029042625197d41362d07884031eb192890e18ac0b1e4237afe7402006c7641b87a6aff30a7828f5a61b6b79949489013a23ae8f138bb6458a72798011945363118e8c1728e09565b5ba8e9c322b281d50c81d9ff94a18612ac41f7e1e0557a57f3b98074694b3bc37edf005f0129ba8ab7aeef1346dc1b94cc283ef2be1c91a0c0747ed6b472d5a6103ca79844f6fac466e756e51599951b0ad1c8b0f4dca5aaa01292e52a8a19a994dfb8ae96163872353ec485ccf1a2c6bf2b0a316be623636b1118ec0511c5c0aa630833c542c80ca87898c8d8a0c9c6432f9200dfe1f87f83f760e4779993ebb87b600763a78a1e0022f2a3c083730c09930e2185bb62bd0f1e1ec17991ed4246cbcadc9d17af7f85d2583b555b293b85cb3ba103959d3005c53566ecf636f2d99b94266ae10f20d7941d94ab52b1e66c99a2a24903de01d4c24236f18e0a72f1485b8e8e0eba5385dd2ccf3da36f42f29f29c0b5c24e7cd6e5d92ca2e92b79c3cd608a0cbfe8b2940aca50db477bbbf676188191656e0acf10df4d56c25255747160742762fc2d37e507e563b9c2b2158231c24fda5b8762d28c2cb390432cce54693def5c5d8cf3f1a820bff33763673116e0bb80254eea5b1630deb61300db47c2e3e9d43c0ae79ac6d8d8e5dacb30b421c0e88460520595dd83aefc1ea925bc7b76faabbd79339a6862c8b8ae500e61ad9244cffc3946a184f713d5239638a2e1d795aeee5ee445c9f9aab6409e735b88f021554cd4ee080447d929f96556906a5504df942919385bc5e64cedbf2ae394d27ace9d675fc4a5fbaa1418f1420ae54e57c8343a69843ac97c5ebcc817820320e5d6c9eda47e171d3f5a2edb52448f00acda78580b066fc588b39aa09638a850a2a0dcb9dd824a85d72255623c47308a71ac9c4b4f6bda9d273b1c1f88b629c2d80cf2b46f3ac5285aad169e96b067b01de824253f4156311196ba6e4bc21040cf1b3cc75b68e63af37eb275714561af525bfbb82497cd4730215975d8a3cd61df43394141f318ee9571c1ed93198d282288da8bcb5b33e3c6f1e9269a763041064a0d92da154a1b43895e1833b6bac67e096996e0db5bc1447c30bbdcb5bc30253f837b9e9f89777891e37357c8654e1a5d5ea0262afd58136f1c1c969d3950173e90b1dc6b589a510c7364be31128cacd0baf495fbb9161024b880c18e97e2a3395c5515973f8ebbdf18b8fb573eb46a4e8fc88c2f159cc6be94c7aa35e0d1be4bfc35f47cd93bee0e1adc16a0957f824a9e24f31a32c372e97b6a2f9a71d147f33857a0febcfe896dc770f9a2a86a7089b55a396afffe4bb21d5321e1d7a1230faf580d4ac8a0a7d8f3fcf457f63ab27cc54c5820739bf6437bc43eaecbb2cbf7af588268ced22cad9f5a9254d95c5f47127387655ee36dc94d70d1392960825e78b37cc551183bcb25b98363522c0a801206000c6ded60985718b46ab2400ad0b22c9addd5f71d90a7578913c0da692d7bb9230c78d6f6273114df69d73210957b327089cd3495ba001efc730c8f84d824fdf9448c277d02379b694d0bd1a4012ba18c18efb60b94d7fb0fb750ba948a5c73e55ffe464ebf7acbd04fb8124a0432f67e42bc4409433b85588fa6d16dc93432fb633ec1170e1de3d258e7e287d7479896cec61832a3e7e5e257209609c6af97c315bb08473de27be705f831301c5336b7f37607888212f40b73bd0aea535cc7148be0f9cddeef1f397b8dc1c1bd11368695d776b6d4f51d8b9a3ff091dc23b438ad3a8e00f435768543c9520ed4fde81fe5b8cde1b1b005cc5a470003b8a12d74d4178d03351cfd620c9a41861979a4209de561feab4faa20b540fafe14a2f47815d1d6f756882735645e30f50fe0714b48545aad0aa47edf4cf85b77edef8420cadbb2ab055537896841d009bb5d21aeb5bf32e1a0a2c6d2f7a0044c7bae33fa95f6264135534b5aa1a1710398fce470a822d6e5bf4a572fc5aa091e664335a8f0e5f4b82ba80dbd25d8d050d8d517b496e2067860366e267a33cceafe24e53584565511927952e43f160218634834c0bd7a41a100548c68c54d6d47e30ba6841925ce0afeb3aea68385600156ed62144c5a67173008b02d76e28126ca00a2819c0bb3eb4cc92c196f8932b0efd5fccfbbd5f77198a0d800e01d63679db7ee5dc4213c4a1e82b47ce07ca040540c023f617d52c1ccbd2d9e825d8f60a2f6cc6c7e0230f8c259659cdc08211739844b03202e6faab271c897dfa7bef337a5b0672ab13ebe547f572a089fe304aeed0c9d0c871f87128dbbb634322c5449164a13028e7f8e46ea7eaf5861a1eb1cdadf95c5ae983ef642bfb86f103558afc4571483cb7585a00715580fdd806c4f741b7246e5655a575e85661422ec7b71e79535db2ab86ca6105124a2f1428d9f82f7cf626d8bf29d5a074bf2e8a64a11e8b415465ec3366cc0e4af15eb00af3afb40024843ffe9126a492594cff90682e2c4afa7237bc901e70a081e68a01e0d9ee7d4bfb5b07b2d9102409de25c281bbbdd10f2bbdb04adf4a2e467df3108a7206cd0ab67ebc298481ce73bbff082a5434b01e26d8ec53ea69f7dddf6b08619279b0aa0c5e4f7e0ba18b37dfcb3ab7762debd778e1675539e2023fe00026df8a6518857f2cf15a8dd27eb05fd4854710b80ae479cc3dbb4963dbb6140129ebe07739ab8b1f23d828751d533ea3630788c03835c7ade9de2fc725639be627448ecbcaa51b958aee7c6415c041b815de8940e427fe2152c77639f3c5e7db0699e2a03a056f4a0323541d174c4d8c1d71a7b04c664aeea06aaf2f978496231f2c0d82e6d3dbd8f29d81dcba037666a0567564fed3a90a34f4c2a0864fe6a118678798666318a2f6c93fc93d788c258f01c5aa450b65f4927ba6308f7a99ab0fae315f1aa96516b51b9a35b0bf04a303290f7a4b0f107434e88c9b897d8ef32dbea8b90191f27ec6c6a71c3b576ccc10b6945a2d651b526b36c86929d7dab3195b1cd7777a95a1dccfab7ad95d9815d143fc6d86f974cd07417038811e143f157f37337b54b492a344d0bdd2d2dfd3f27a74d529898ae3243bd532983b58d22337c69e87af024d6cb0d8f29c96ee48114d2e7b2c1535ad6b00e178977380bb17569028d04252e77d46764676068c2e1d43bee814688c6881424210bee531ef156682b6b037656dd8a82fd83ca1924074f752a207b2585ae4c9ea6f4c78c75d1ed96542fc65f19260e0a755919c2e24659105c4c9df00ded15f93f442f6887c12fadbd7a3c4fe425a3f30f0ddb2f375e471a373f27e43c8a494d9678e8e60931292950805f2f6b9f28b3182436c2a975dd365a59195dc4df585e87395c7c3a4236a0085c40b7af8c4448e830057b33fe8df95a33647c37c55b225bd5f8b1c591db855703240e2f49d63e43c62f8c30b2a39b67bea6e9a9481146c046af276d611b6ed9c39e7cc8f66dc7f9b386ba00528af573aea6d008433d39881470fb56429fde8616fbc9e483e1222d447832cb7bc58170c7ec86e8f4de9070e07eacaf608aaaf73c42c827990cd0c64687ae8cfa0b373da849a767ef3b63ca08327663a0c85a554dd2ecef748e891cbd90386b5737d945603b56c887986f9a306d7de4b18564645c2a77acd8cde744455ead6f28819282b59f662f7da89dec13b7623df1b44633048278c6435e1449517b0235bc9f4c2cf39aaf34908726c3dd3a07a1b29aa41f4a0e91cec6a4481c3280a94398f6ff1b0b07b39ab0e6668dde438308209a6e0f5ddbfbb30481e978e215f67468f31eaf930dca350f0fc53bee83f988b04310eb11496a8955d0a91b51aead8dcd1703cdc4b0e7f2f4674ae3e588b595b2a10a00f88b3abcfdb5d1c8dc9f8727d16373ae7fd05b239f7e5bc22909682d90901653987feda97752895523e956cffbcaa8d3f088d280cb19cf4d71f010a671d8b1d6227e7d72dbea884042ee1324bd31a5fbb7ed49b79f04e834245a552b5157fdd0e905e98e890291c69bdcdf6307771876bb8288809b44e63bdc934710e039909b2ef090b39137e7420aa7ef195656037f3482b4fc10e554341d68ec93d2294fcb6a8d69542b31f9942a59c4f4503e188912dd1cff39640cc2217e1cc871865202fa3c02e817f2fcf395c446a3eecac5d97950a44ffe1e8d299e064e5512aab2c1581a7dde08e01d9efd6c7fdc561b8c7e6fa75020b9534f2d3b35afc0b0e550b117eb8b4be6223be3b32b3367819c099e5cee581ef44a2cc483073514b0c317541eccfeb5a470e62a4a7183b1b22839e1a1c23bf58b6ee43d1fe87fa100c1bba8cab5dc7f68592841c2f9cee4e068d6791e55f4dd54edf7ecf336cef3510f331f64e0bfe4a9226e772e395f992634eeb6219cc239dd5d8e03cbe1f45810bd16714d1d83b871586d6c721608db6150796aa7d942a7d6b7f37e1fe54d5910ff184c75453103ce3e832ab21e3f16110827890bdeaef035641417fcb9b2c3c142549f5302f25b6f4fd1abb1b586555dec7abb108c3d988222356f8845157a91a934f239cf4d919aa5a54e5706f63ccaedaa2a523aa75b6cb425fccd9b302760f63efea5bb28d9047c8ef3d06ef698f6eb8d69cc2968256b56ba2c6b1aa325007ccc054bd8707ae6a7e1136a7d734ca437bc91640e819bdb1161db6285b848209f695c935d12262fc81ea65c312cab7c604cebf8a7a8e32199912d3fc172f2d0c39e4c9610d79d226d090265c7f961ce63aeab2e824e029ce1b89601913496a0dc3486866c4ae74c9f7227bb2bc821fe2ea1a265a34e961cfe8e0548f0b2ff629b111d35a7ba7b41a2e65e5412dcceb796b31d0d87b9f1a4d24b028f2377d5201ebd6d03eef5c45e78c52247c3282fcf64558e43ff15e1d39533389bd7a86f4037518906b748ee732531e22b29338f4a4f42a0f216226011632c4fc7a59287208482ad4d100cefeb5679cb8b4f6af5aa6b87f87d0a7815aebb30da0d927d3e613ba71984e13a4480217ff47b1055dbef0ed7333ff8403935f10785b4d212031267080070a80b5f94ea5c4363d2d971036e8446f2c055ca49495145eca1ae9fe2992670c4c90a20991d63058dd4a885b9ec25f2307e6dfb364be99f0ab596b560e91d00167f0fcdc484e4510cea659d39a58ea6d94188082c301d82be3a5beaa06007fd0fb2de248dbc4fe010a14285eb1c67ab1035575cfe2c4a46e7169be0224093f309708216779d4be610fbad6c37027359a6cd9af3253023c94bab2500927dca5e53ccf2bcfabd9f056b2381845a855bf7947d600e6f85117b69e57ab64124efae3d5bf327ab6ba6d4526a495aa613a1c141b4ccbe97dce4d2174af49751a32d049a2624f7c385673c88d7fea82a5c517b7fac655774c395cdce73099b60602b40c9255dbac3b084808ab31e76a1f050751bb6775dbada5d84691d2765327ca9346b73ccb979a8d2890fd43bf51eedcd0a78af072f64ee41abb954bacfb0b59bbaf1fcc4321f763a03b112189c055a31078afd0954b7d7ccf311615d3d01712fa34ac64c32e7ba17168f04876190ff32077be969a20cf83be9d04ecc5ba2287f65a7cb3a473300d133636ba395a1cfe1b9cfbe68f106f114d46d453ac6e058d32c610ee7b8e0025aa2f8fa532b3a6a45214fd7df4c35ad5112f545fbde314772040257c0366286283200970b7ee56d048cf3f6725fc8d9651a8234a6594149de5e4a643c98e7261b75a27baeb89147605258f470c0291bf22880e6a900612c1e251dddced6445c3dcdcfcccc1c36736068f9e1f7bbc4063895df782b11510427a865028d998dcea094cc2f8d0fa2efbd0040d0b118e4415dae71c92cfa31dced774d8572bfb42107f480682ff1c5ef95f657787a06997f53061d44cee6b2033fe9a65b025cd7e27764e34562fbc6391cf8d31623f31b68f03d6a1d1404d04b8c60cbb003fd65b2886da9263ee92021683e1af25189631d1725df8c163572d5f76b195591eca401fbd5d43e2992245ea9a4009a8ed600fcb0962ea5b845a18cd73d9f8a31eab2560b9f00b08cc4517309f7100c34df4c3aeccbb3df8eb49244478321b4748aef75677808a6a5d92a6964f298eb5e5337621398b0c1a43550700ca5f97215da057c3a4a16a260471ca887e12ab3a9fbaac6a61c67c38fb9b1c8b2eec6c0535832e1ea214b890bcc72682c5bddb39f4ddf34500a5cb9a81aa2d3d9f09f802a02b7324b79e9681debd2833f6238b22ae6622ba1a64e744f79029e3aef42dc679892840c82352fa28d9140106d6c2ba6ada66fae52bff965eb40eb54e3e94c92cd24f6ec52eab577e80d8c8e9f2d39d6b8d69503967d9809fd21036bd833a94dd6a85559c519bb7a2769b6486b00d34996da228c08994f285b22f7362c30b976680185fcb2d6c1a9fc47ce47e77d3af5b773534e2ce7c2063dc0f148ba271ab4c9b17837d44c14d231fe85b7644462249299a68b506bff87f4d23eee74e2f9b8ee256ebaa6e03b545afa196f22ef7e96d7255f5e79bbb786c1c165a455c205655a47926176b91f2d2c02ac5c00ad29b467bfdbd51b0768b35290d4bbf22a70348d22efdd5235eb6e682385197b4e17330c46c44ca6d5dfc67912841ddb730006e521446f952117b78effc601d10372438c4ba4f6e2608e9a51021960d7a065af49c4c06053d32596d990c1a43cac1658dad807ae48de098e4172a749e9fc0fea8a55e57cdb05166ad9692c00bf103ac30881c6ea8c6b86c244a0792663fbe195bacf4bffe700777c5fb07db9bcf94404ce90d0ed74a50febf9e2b4d7bb4c6dae168809b1e8687e2e668d2680f40733b7d6877b27eaaa2021daa212f5c9650237c6013810fbf50f8c160395a487a5cd535ddcc85437383d7fd401e42318881baf153d5c6a0f3ae7c933daff9cd10c89c0f7d9c1253e65995e7af082ba05d83761cb163b4ca9d55e5dbb43c74bf3f456988438da2b3e62a90097a188bb1d3cfb110267f28a328777328ee715c575923e5517216a551b7e4bca46426c9def697692dbd245316df1b3d3ebc23d2e7f26282bb8c3c77383b633d1fee09e269116a30414bd9701c5e0878caadf29773b5e4c010a7f519d6c8ed4ab64a0b0dd617d9c5b993d32b538129fa4404c7371453aec2448ad60caedef25217742955e9b0087cc084f3750b6474cf9ccc1b91b93088093fb9b65512bb41c7fe1325742cb05d49c540c0db2fe8cecba3202fa75c3652f8a0632c901284718de2f0197e4469bc4e63f957318e61dfc0b47f3612c833faa62fbbc758bea7747a919c10434862eebeac7e95316632cb2a81e786f3148d551e82d4b5f3952dac0e84a81a35b2d833ae99e441f064acd0efe3ec75d0180f0dc898edb2ec4e6104c43d9121095529dcc976329670baf3bc91051208b4d62984741144c2795189811c35d41cb3ed4bbd682aa625880beac8855c5fea04d41e00eab4f0d06318c229f650e10fdb194388dbc4bbbe4e95fd302d9cf15deba158f7c686da98f0c51b56a9c3bf2355c510225e1b58ab2af9314c08bd8adff1ada7c9a457c0c1deb47b814f2c2f2c04d7711fd02ba586d4a50ad99a1723e5bf2916b4b5ecba863947a98fbbbb300bbfceff43f6717beb8ca8fcefb59c672661fb46da69df22870a4c52fa4cd0f22bcca13d376d46c173fc2901c265dc09ad688e67b9726845e03944ee966ec01b285bd066f7c5357304cec840041d33e776badbda4e0007a505004e070b9520ed0794a82f878b218f741d0cb293956b5273b429c885d893d1113d73aa26c1d423271b72ec18a3db9d3d0e838edd70c2ce3869f8dfa7a2990839b8dd9e1172e87b0a636a0eaaf2172cf943d025179ff1617471d89f89258b34a3bbca00641a9cd81a528d6c2a802448da3ad3d59f777313c16a671482e39b8cb7da9ac35c1ff2d818c053d772d3b5a8a648244ccc209c808ebe141ba2f9d5650d0da14819aadde11048336a6121c302669d43eec43639872901bf281af7a1688aa3d3928ebdd90712c4211198d7728995d57f5bcc090cf7beca8045d513deb1b175ebb36796f0e41834db39abc7b5ecd1a514dcb9228530e81361aea5811ca208a650daf968e6d810ec1c14ddd45f0d5cc72b4bb6c9b567381cd3f8ff34d9591c48f845ea50846b056e828c137df3632d6225d8c3c7df355ea62f2e0d113a7e36852b6764afb9f11759ab5b4dc7063a18dd2b491a4a3d073bfdf8f4d33df3f339a83e3ba2953d7f09876c8f4e48e48b158ea3f41eb7f19716f44512bf7cdaaeb3915798ce22707b1a45579944f3cb644003ac2430ac63799964bce8f0125b487e5e84f986f46a8314921030ad6e51af6e9a654d191b8562e8acab6542844de111650de2ce37659f29baa8a03a66a40d48856ec10f47f554e884258e4eff26ce0f15c6b5171f95812f14a2b03d6b68f4bf5be1acb77702105951d5f13a423c1b21960b0c129fa99d1a8dc9e0aba8f76e0f8bf6db5523758d5ec321d0857a2df1134b5dae2faccf3b2373925e13c17f70c80783a3664e984c082f251bbe3c4698dff5daf3c70e5fdf14c66f792e18c3133a0ec195583065986f5d8f297f5750ed78aee7b7fb6efaa11546abb4feb014cf7206953bcb52e5f16ac8d232723683674bc02854efa9c8112dd9d7b31522a6b7fb653afd18e987a926fbd5377b5b0e415cf2614bdf0c26350102b6d8a26892985e76fd744ab01d06b524f57d634fc0b69a5d91355398d6ac1ec5b7588982ece0b103edde74a6f327e6ccf694bc534195fe0effc7483f13a12b278acb099ad84fbc96b27d36269ba06a660e2bc9093059a2acb1998cf3f1fe129253e64f00669a4cf7480180edd5c242544581499b9a233f0ce088acf1e4db14f35ce5d343461157dbe0adb07355d95d2cd5aa6dba222b6a702af1e325d2bc2d106ec5d71809dff7aec68762661bdfd5dbfe456cba5a7c150c73da2510f75216ed7e6f631af32c7e9c7884b0ab0cf71a834ddc4c825748eb5d35451d8092402dd68235d74c633a111bd167dec9a6371b137ae89530106a928c87743b38be3d0076cc22cae0c2544d7e6d49cb00182253dab5dfcf6cbdb378f56b0714b9d4bf2af75f56bee1cdbf00f1a0af44ee6ca3d7f8b3b42d38f87bf1da869240dc6477092f4b09a0af31220825e29d275eeb08977e8d3a6a934cc16a6d562b2eca001a04cb8d5ffe9fe85b21a785e261721288e9b5b75b400545a31d0d53270608b10408287f21c644121d27ec9aa9f50ccbce17e7ebe37a9858da78ca1d207bd9d63708d64375d1c8b872172ed0e50612b60c4b049e807f23d6fa8f4e61e06d52047a034d11c3fb63ed48fc75af072a1084b3d0982b796c9dbb70c295e4c938688dd603457e18852f8480e869f8aa0665890d85a78c5458b77f682cbde6b7954b55d82cdc590f35d097cd61fc65b0dbaac9cd05916c807ec0e318de09c55d6facb6370f2b077d67767da3df753109cb25329348253b3bb8a474b8f2383d269e7af7d31188362ee1c47b51ae57ee87cdc133d212b205f43ad871011e82684b3251a16817b80922192c7ef6e95042838827e749bc017d1a96c6e69f4d945f6a40c8067809380df1270bf5638a0dd4f2c7b7af4a5798b4280a4c98abd97c99272b34488d055c100b6e332bb5d2bf6ba8f3f5945bd877926df3eaab055c5d42be090db0bf02cc36716e8608d8ddd908e019707e77d50ecaae8f83a61fac66303fe0d980381913d591367d4749326ea822b20c1f015974fcd5ec6d659aedeac7b56f6fb7891706e619141f6b4a93840023bb2342e759da6438e07ed974a5f1e3d506144c960bbe067b718cb861fe927716cba85cfc466eed0e9d2c1067bc7f9e356bc5d23c1094541933220c2bef5ec7afe91782ec245208d58f93a08ec25eb59710a7362303daf04d7a256119a10ba5f6653564dff54f8eb78577360ac477abab5ce87bf70cce5000e4686fab8ca621f1c65dda94eb8b5892b1aff79a9a5eb0a2e65efd5314e0969768884cab782cafd4b81555a818559c4835fb6821ec46fd08ea418ac61ff343732becbc72450b2faedef7112b951edf2ee03bebe4b71365755e6d551810e06fbbc2176bff93433750bcbfec05aea120f193a1e4c5bf5993e098916f96a2646970667358221220cd4c5554420ba67939f7e38671b6ab3931688cd7f2f483a45b145bcf379f1adc64736f6c63430008170033289691d7705934b5504ae4bd7be283f3465af66f62fc7f1e66f03876b445efdd22a0bebada6ba60c3e190e9e8c2b1420244a14c9e02868b862c7945667416f9a036ab5249fee75e0644ed259d45fbbd0142b638e421b948f5dc00cf3ff14a5301bcf8d4f8bf886d2c7960badc94b3abf6beb4e43571d2b4b0f14928c10e0d5942d8c51b7fa4ea9ea16765377aaae4ae0a416a89b600fc0b8ec35e9e6e56219761f2c636b4954a865946d69fed3ecd2bb60a61af38fa31f2a290ae28915d1f6e10b412b14d9dddf3f9031ffb51eb3f73602b9e49cfa9bec4a02ec9c0e3020ccc30ae9889ae5f4f6021af9e16dd1f2c445ed863fd6a374b329337f2fef4715350d07f75b300b401d2435b96459d2b64f6f848411f246d8478199dd2351a35c1b5e195a26806d907b6d9a9a9c235e09a48e94f8eb8da80f0d40bc4143e3d006e6d22d0006337513747c51f8f3e87364d2852113a83e586ef629c88cee6d4cbd422f257aeaec24103ea15e4592c32d0ad9846ff1a2f3a836e0c19947980912b9006b294bead7a3378f80183af735f6bc8529ddc73d9e0a35d594dcf93524403c9e3e0cf84e9163744a9a65520f4b8cbb4ca35c428d1c4a5789e11f42636c6d19747321f43b1ffa301d565dbc37ef1eb2ef669b8a1876e3754b79657b26fe43c845ce1e558b2ca618dfa02f0d640fdd45f56492a577154989cd09523829b5e15f2d6204db437b7b4fa0f6eea95403dd25c6a674b3e81be98ad4532affe8507ec0538020376c16b97ad98b8dfaa6f10d42a3c5e264c56018d32b0e8af528db157eb60d234219fd49f941520883c13c1f01ff7b2f7f512a3046f91d33cdc3900ffb9de91d754d84438f79e6b701f7d665d59755a7bcd0b63f7c2da94b737606c16de1d3287a08af195521f756271ec64bdc4ca8a7a95fae892c0fd2cf0c148d6c0cb6530e16af35936b356d5974b385528f6d9a873568eda614ed0e54be4494c2acdefd0fae7f745efa5884dc82f1595b5c10d931ed6da07b5dc4bd6f99dd5318c7c2a821f41494c6685503d748b45672c65d059260bb205113882458c86f6da7ea38131ec11e919c80981c8a905161c48caab360994e8f31cfe88536c5ad8b2c36003914f32ba1f584bafc3aa283f79d5d65e97a6a280c7c51cec192ee9e48d593a2be0cec3b3618ebb60152be2987b910940e79a421d666a71764f25ded99159de90f075a80d650b5c6f8a0b3261ae5ec4c5a1b53762f30c559aaa6c501e207c2514f026c5d81cf4e6cbade3622323c4ee3b4568333e79504044d2ad4d2ba01abefc5286bacad6fb92895c85483e837d7c821d3f7bd612ddd932c16d618455ee62a4511a11b68cb7aa85f42325a3d0fa45e0887719f05c9cd472183b1c7c78eabd0ef0674f14710e453bc1f9255babc8d2aeb3b2e321c68e6871b54c285e71456be4d11bf8be1878d5dee6820ec405b079360da81da7b79f29aa54096ae195ea1108d2a02d0a645dcfcafb2235e7f9ed37df27c3f7cbd5ad11ee831fa17cb36881d3f1e2338342dcdeec5d3ebd82d4b767ed93989d9147ac711dd07d8aebac0962c20174c21361611783b0dc90d87a6128cd4d7e427cca10db1d713495d8281ce3dac22654673d8af40026294acb3c0e51f0f367576d83a554bd9ad72de06a796095e08f410159146e32feb7a585ad437c4a48ff2109d7f74f58e709b66c292e1c690160928e9343db00c99255a53ea3948b547d0bb68332069c2d5ca632156a53ac81b8e0ca895ea976f5d42029c964ea52d622388e90f947cba08b3924b470d84a02f21e5bcc52e6d794afbf44a0dcb938554c7c94fbde66c1b7965ebb2d266d6be106d51a9231260949c37fcb7c8296c246566259829e98ef52683900a433ad7d71f0691902d412d4afe6e49f546ad03d739f42a159af9530d717c01a3e9bc86b726c15552cf455e161693ea7f01601fed166f79653153fb5beec9e8393c1efde50223f9fa8192ae6be752d29b47e8b8a75e2172fbd4c89cfec400a9766e1430a8100341a4e94a5cfffa3c6cfa1be6ac3bf6b0c4fe578f8c99cc4f67e4d7bf48861a9194b8c654ebf4f3cbb607c8bff2ddebaff87b8bdec06745ad4ed802728a6f0a7e869e75859fe47e51b3b79ad155670af4e6780d3edd3c13812db0197854d30ef4a576b0bef4d037549aa24282378e13b438fc9bf49efcfd65cf3aa8935d28199af24c0e98e72c37d87bfb9386003c2a0192ccf015be777c4305d5eaaf0e8106e7f2d897f05617580ccc132040f3b83f3fe1a496354b33f39d27b15fb2a5fe07968d5b67877cf32da7858c85479a891164a19b1ddc26fdb2772d294addf3b61b4dc215f06081e276803f1650d67324801c0a4f48d4b4fac9f6650d2fcd901c0c5a5f0969147d312118768cd73a762e53d3984088be93e46d8433d1299394271a948b5fcbf5918fad1f3c69d9d58c2df72cd9a15ff57a35c86c9e5082ee40900532f7499522ad56592a815a303b33b648fe170e0c2f47d831255298200cd77522cce52f921a79b56993baaa1854b37ea74caf7e6f2d957048fe5e5d1e536ce21ca9ca03dcd6b6539118fc036663b6deae0bdb0df258f18e23613f4e80bd5bca2f7a2d324bace30583592592d82bb970ed33f9753d03dcd3b54a44af04a0f1c00f6008b6f13bcf8f2663e7392e2538406a7cdf15ad387e2eda92bb1de03f74f006e30762808351c935656ddd7ac3499a2b497991d02f54c178277fce024ce89b1a087e883f78b0e1ecbc92dbe9d82258e4c91baac53d71836902953f8e5a69610d35fd011b125ac12fd1d7c655fbb7b1ebc9eb47008676c750907f7768f6d644183a077e1a0a2dba1ffcf7e2a490859a5f60d5d04b3599506249b6d534848ba224230c1864237bf6dc8d6b3e40bb277c02dab92e86aa515aaa62b1ad496b8290075a995ae152c5f9737f6848a2d5ef93a8e7809981a06834ef8b6843904560112dcfb2766574efd57331146186055ee967cdd14d5efac43389a29605d13d561c05a4a1353e53e1b5622a2200ee1fb2e1a8e224a8ec5554bb670bb377505cb615064cb205829acdaf1af3d45060ffa3433c02d3a7ae61b66ece50967b97e1f04a1af278018cfd4d2edc11dd77454ed0cc4ef3ca1dba5b0ba96bb2bdc43f1e8ef023e7488f10d910e129d466443a7adb99fad7ac0b0bb37a51c9d0f1b7c527a98d29594b068af04ce6fe6b248aeb06051d6f66a39d9f3d13cdde5b343f31ec16ea1e63fabe17ec748ba86bf78cd84029d23ca6c543ee800179dad25964fae41cca2acc46fb9f4ba2abecc49ddb33c0314c7a940bfa021c07d44a73614599995ea10d520400f15c87d18376ebfc03c8ed06b9ed713a654a0024cf310b64175d1064188ef3fd8a2134f2d4237dd7657f410ba5172ae081a6ca117dc21c7ffe71d6bf06a71b093737f1ebae5924f2d5f47b8b14526c4831c50f9e9c7c032dc011e511175921f58fb9fd90e2a1d2cf951ad606104a1676c9d2e6fc8fee6ea105239035236859cb45dff68ffa2524619936a9cb457d2c0defe59b5863607e439369f31628e0e101f6b62767f587d7dd8e0a4d4e32fbed3fc65c940d8aa8509bd826e33f0158d4f5cd5085c6e4ae2fd1330a52435eb0745d54c7c8a6ad5b7a3cf5333a7a05dfca18855acba1a5409f714a77297952277658af5e7d5e3a05bacd0b8005d11edb9f2871655c1418f9c7b5851dd8b1713d1f9d7d78c9b915b2d3ecb62e756910d33c3349ddff796b66b2c800a9fdf51d44235d14d74def1b2c112bf88647d00e55341297ed43dfa1312685a260ec51b42ed6c24e46b79900549fd0234412820a1654efc1b702b4ffbcd21a9e0e3323a40e4a136bfa0cf81cf01bd89d433c56148f5bd214818a2b59ed67a8d79e54a048f357989e2046b3e7b587dc4893896b24d21716ac3c7fa8d8945b7b04479a0b397b8fe46e3424c0db7e1d7d824e40de2830e9e432e9bc3e8dc48c98c12ee9081273f5be246347769d0a34e2f0e7ec3f012e850e98e970f096522ef6f4f537529f296f7f3ec9ade921780c45fca74e571eb45ad2eccb950133aec7d4da6d03c301cebe782ba71e3533d5a0879bd6d0c71ce082f6108befc4c6133865cdf1b35a587868b99c36f59811bd3771a75c375321d1d3327b86bcb2514eac6f11a77867856f5a2cb24ff4f72f65742854baa0a3072a1c2e8d55ba7a49807bbf09ad71e000d67b09bba8ea2ec6009086342753a71c9b7142435f0c29a9ad5549dcb9ac289104f48d39d4e196025268dfa1b6a25500e7f5e830053d6bd9dbd5a2546f2b38820b7ec18b55b638f189c2cb865982880ab8a2d0b81f7a40ac8a6a8bed4df0643df2a4dd4606194c8508595e116f39f3166b4f313145815f8ab8a09e6fac91e3cfa404438c8c430dda4d121eef70a9bc0937ff264a4c22904c66b8466165d9302052f5687326970486277a54f458717b23d014ce251eb044d74105355f1ae0b5dcdf0ef73fece10777328b86b0bb4d07276c1c219fdc62892dd095536db3525c18d0409121171197c99bdd8a95eb2f5a235d6ab6cef9830493b2c71bacd3782d67eeffacf4aed5bc07c2524203344cd31ad0bb296be4e478c61149c736ad66168c2d0ba4410e05513c1af1ebe644b0760360722094dd4a26a16d8f12264b25accafdc6a3f55736f0de1e55dbdb28d02a088b276813522c901c6ac134a1ffa00cd61276e1221bbd7ff377d1dba5e1beb1243cd531b8f9fcb0cd9e8d9418c6e9306b89d96e0136eeaa66ebdb248bfd08f402a12915178a6e7d4a612dbc3a878db9ce7153bdc9130d3df7308c13b2e97fb005819bfdd569b0009e9bd1f9a41c7eb23ec33d8cd37d5d05b705b4511dc09f0e05d2260582a4a391c8180a17189b98a53b831ebced724333194f2f6809571401185017332cad227b54dca48915a4a78875967f8ed352fd96d5446946a64b429708192db4386fcba811f000733a6f28b929be4f9aa1d2140ccc3f9616f82f34cc1281dc4a2838c70842102a997a6bc26a737209d42266e815738ec3943516e150279e9dd39bd768a08ad9ceca41993b8e8408d025affd64237b5985ed9a37d52a11bee6efbee9ff1ffe2f060d79bd751d43bfdec4d5fa5e323582f8d735f44c7b1bb75e2ad0bf3e1f255a9e983428b9baa96cfae8bf71d1aa4d3a786235e2106528941f264db478bce46c697bc574a5dc0b956d033eb29194de103a9a70bccdeb19d5cfb9c2ace7ec529ea27438d22668f09c2acbdc9c099bbd5554a6f3ae145a29fbde88fcb5e46ca563fad42cc7e26ddbdc0e655f88057a8a8f6e51354f74db1dd99423b0d860b8ee34e292b4616f7c870094c265f52cc450f98a575323872e2400a80de9d38f539c9b0b9580ccb9ae2e382f3092a657ff50a83ea03a4ba7d620a5b9553d48bdf8ff66139e723e6a1655823b62add790b62e605d90044bec0e196df524c0987fe4b832add37f546b835dd259e7c03de7226a43a6a062b4e61c2ea4e4d02236497c570aeac4ea1896e1e3a19343f6e50eadb273cb5a7becdad20800ed797700c5e269e0c1edf4947c65348976d4a67e16ee547c6c870c36e3d709df4796e7cc0d89f1fc722c7d967d4c0baa823f93f9c4d6c7913edd185bc11c23442bab611ff64c7eb49ab07f32f52008673d80ba54e04bbc5c61ca1f0c38362f5baea6ca93f7a41762a2b4f5b6c31c4e0d140e422fbe379f2686522dccb035288e0e05b537a48d5470921b9d724c26fb8d2900dc7d6f0741ba2c1a35138c1724584003a84247aeb78b30e2d8fb4cf7147785647ddeb68a7df6a79ff84fb008219b35214df5048253b823fcaf329a45a2ae7f959af6539ae7753e3554d2899621795fa4312815b80472036b9f35c1495378f172c7157a9440e62ee46692ace61052d93c57b9902620b22e1c29b9106ad076f25f69fed4106736de133d72ecb71948cc83425a81e7f7c6486e0f08b4b412724759ce41f950d65fa5283c31a4c226769518d0ab71ba583b0022557cddceec3566637a6c1c519999523b44d953ba13a68997032013798fc580d466367a6a04502f500f7dcf4c2e6e03e7774849082668cc07461b1088861db6bf4c03528227a20d2b473e088aff34daa78be838000bed18cab0f02716c9ee5e68f2434a241e6784ba03ca69df0edd97dd72038b6c2e04d93cc4f54309390fe572d6affd4cbb1989ddcf410fb476e3a8681656efaf18b0b7c0a137e1454dd3ca510d220987b5aaa51124e157fa372ec6099a03a7140354150d34ffc1b4ea2bcc2d705f72e2bfac4619f6ba35de7a5c08d5d7ec34b712c1195df5fc75284ebe217430760ab4862de0255f75dbe24f4fe60f90c3419d03630b0da0e292c1088354c075dd1e00694fc14db1878a5cfacf2b7b797742e516d451a52d64de482f4bf60beb30fa565a4e29904042fe36288002bb84325d5a0664003075b0ef9bfd1573f70b84f7b75ce76563169be92df533d5aeb47ffbe70b41ef4deb720d4d2fe7dc11b4483b3d0b226ef5cfd8ba9a4e46bea1018fbb64298c7227e27ecf7291ff64ebbab81169202697e8e76afbe9fe1504243b4077b30cddb62d67cbb120c38a93a9d10466381bcc71a202ee0a75f1bf952ac1c61a001f251e0231fb968a4b39bd089704ca99438b645cfc29920e0f8f4988f77e95970ec2e8e1aa9376bd31702a93e024f654ed26a324bf744d53271e510a1f7cc2ff1155f64822affa2c0d2fcd555aa5dad8698731fca61bd3a3d072cf33c1a8d9f815699cea496017d4bf9fcf96e5a384e7c105d2ac074571e600afd0e9b4e7e8b21e85323381cf7d3ba3431e64e894ce4d693f0c463b6d104dd33dedd7f1b9f081004b64f1d7c848aa7c28d6a815b7ec34ff2bb76d2d8c25f93265ad8b20b7140b0dd34779b2145df8b131bfb71ffed5c835d2b696299ed813bb472be2f3a880ea0e1abda56faf0df6daf6b166c95c5edc97bac1f73d539a4e419e36cae7ee1d9211c1659cf668bedf75fe21edb2ff2b1fc695bbd538c1331845f24839897b620021bdf685c361d30014b4396b358599cefdc9d5f3b464d67a54c9cb29789257101b7153446f1040fd153236c214b0b502ccb8c202c54ddfa527132962133d398819a23ee53b40796801a094627b87364921ae981e57f9f478ddb3fe9e3050dbf30c3793885e6423402d09a54736d9a0fab9f8e5edf858b7be1710b5ee2a46c8ae1dad8846162762182f95a6360199cd0ccad756cea2e4fbb6f17bf7bb643cc6ea0185b530295447254ce398130e4f1bac6a4135c8b9be462422bb6ed88d7d81560cc09061f82989f499b935c855c6446ee4c02f2b5ec74205bb2681a3d39cae951e785e3c3ce8c5a93d9a16f466e1df548f855d70d18613fe8dd861f3e4f486c604715136d512b998cab28f4cada627caf8da082e1b11e2438ae4f8ed17b259ec16b21b75881cfd9f0ae30c2ebb472bcfafd4c09ff390f3a381e2098d9b057cf11ce1a91c61b317ca6f871105d6034a1ae73832671555965c2deeb24c5da51ce21382891a3df8d5ba54ddcbd4a9061a4574b0a4813c7d5fd49797bcd8ebbda4b628b1699345f2327ed7e3a35dbcac11e9704a2d019568e273b2ddbbdda61b96f11875cf03eaefd3c4a503d2499a9524ba9c8e8b1906511a4a85800ee21ad424b32d1b12c661616bf91e9616cf0dd1823f5e33799035dd1bcb92bbb8bd7b9fb5cd1764a79b21973a65541bb9bf58bae57a63de6e20a207369f85b0ece77b1da38822852209e2034dac637154e40c26004c7d2f8d6b0f2f649fe920d916a0b9608b19bad11fd19291c1d7aba146796c8bc076303184293b05257a2e95aa1b35be93017ede6c3a4fadb0c3b384fc1bb3ba2515ede2ddf470bbc5279817dccba8486f20dc05e84fe2b3674dbf6cfbc4ea1888a95c385a682b198665ea24fe875f91820c6eb30738c6c686153cef7a45b97d5da153ed62a67f725af666c8f5454143261b2e0303ea261450c0505cdcf6d8c5a1fe7c840287ff532d632de4cd4b899b0725d247a3eaf394fba18917bc67089efdf773445090ab333538b9db6dd2aa34bc0189a235ce7315920cc9633d5dc1c072cad0ebe0e95a07a0a7f6152bb14345c5118ec9dfcdb51980db3cdbc0b4917ecc57a03dd0c8586ed23145fb8af86e64f92af16757fe4fb59efbf68b60493d51df19d06df73ff34828b9b0805b3a12512c0649e85e611b0ea226cd5195e88f479ca348748e3aceb994208fdeca397d1c930d13a131ca0eb5a309eed385c046002c368bc570ea227bb02cc92be5e30820fd2444558ba0ba9ab3e990299dc09f450bae4c4c92829a42c6943c451cc858e34624e06233837107b33fc5cb27ac7baf78d48735d71cabebf68bbe8437ec15e57a1f5903dfda34ef89110f00cc07959025cf325ee02f81046cc48105d3e5930bfc20093ac8cbfca0030d78cc010018beb1b3e689d52956baa0c54ceaf858488e222ee9cc8d4c5e47162bf7386e4325e3a513e6d4f4458f5e01fc343e340124c0fd1e2f5897ab3f2279bc761e37a8c20cf48a6bb27fb6da5bf0a5f67fca6ad93e1a0e9ae19d75c9f500b45f68de80244090eb66f42dab81886a78645cb1bfb279310f78e982ab46a572920bb2e18383e1427da1df92db1f3665498c719a7af869d222c0107166bb0aa5b0885983712566f8e0b4471e69d88ebdb7d0173345a2cee80d8d1c4837d9de3b2d429fe96aa4f29fce440e52141ae4571cb1f1d7735af86c07240e3b2aa1472c3c81dbc49bfb3e866b43f778158a3fd6641a773da5241474037cb0fc644b2a88c90ee66cc4ddb962336347ccaecd1f4fa8eb567c0454465511badee113262abf691cc75f28c0236812d76537940e970f4488fbce2ccb46e70e0fec7749cda728fb17b5b1ff968bd3b6433dd6dd6cc619e8ab2eae099ffb4828f906c82568287d2256b56129e8b83944f9ee180627afbc9d510fdb7b392458129e691ecb7b6fe77c01d70bf2628fe69e5f6e962f1029ce626a0d18886241452f8d1c3dddbd8cb59cbec15b623aa1309d12221f7c62d956815c924114ec867727db4f836bee8aa950940cc1732aa52d0e741ae355a8c3621ad068c043f77cff2005b28ce7c5532ebf6b7e51d10c344c9a9b00836e4fc37f7eb1176d640c19060aa65efff54d1d497ece96910f6661001fb199d24c3cf997ce1e401788a382ac17dbdc878bd81276bd23b35fe31d93f4d7cb65b722e65d58fe039d126524bb4b26dadd32b90572e617c96576afcb2fcd9605b1d898b2366fd9a7cd0c23769da92e46b7b8c48234c4466b0be922a9525a8896b2d6cc9651b2f6f291cf2bd72b8504523ff71405a30800020b61ac9a1e6b61ca68f9859f6bf1106f2a0fb66d5da305a3e48cdcb56d89222f017078cf35af105ab2b2e2cdb7adc3d71de732d2f22008d6aec49dcb622b4b6033438a7b990f6e08a2d41909392a890d6ab2970c4fcb2de53850b4466695b93e50172ffcc6ff47c882aa9444bb09652ee9f5a4f43e8219963fd677971a8f8f1fe5d09bd27ad0676c59c6b99cc2c46d8a886716e16a0a2b0e85311370de1c8442d4216cb8ccff3d36a6765addb8a188408eff04a488a630620acc22c938e923607f077ab953afc8412ab4cd325b812e18b36db9ea03c21a2fd212df4bf20f8e47cfe5c5285a3706f8ab9863ea128054bafa1fe192afc228dad5eeef0e864876e671e4a960e451d5cb11204eb0f7dedb1d1bea322aeaad09ce122c5b6d149f0192436aeccf959f73db3968cbe69f6c2dc955c1a8644eff00b33c6fe57db259f1f62f8df50692e8d8c36a22c77234e0d81dea745254adbf2b5b16738d4e4e8f30d8073c01e34d8a784bc6b41ec8e2afa5c8d2347b145ed40ce970cfdbc28f9bb3195dd2fb274f9895a29a996aadbdaa4cee11b546cfdfdb0822416fe28cab89c713f9ab14d28a3d22a7033c1ada634ce7928681369e9b6115d6ee8f939ad0609d6eb842084c6ca07a055e83ae2d1a0109498f8b7ee9bbf024cd8f5ffaa9da4f482d9efec43b3e1c77e8eab2f44007269b14614c932ebdd02093e404029042625197d41362d07884031eb192890e18ac0b1e4237afe7402006c7641b87a6aff30a7828f5a61b6b79949489013a23ae8f138bb6458a72798011945363118e8c1728e09565b5ba8e9c322b281d50c81d9ff94a18612ac41f7e1e0557a57f3b98074694b3bc37edf005f0129ba8ab7aeef1346dc1b94cc283ef2be1c91a0c0747ed6b472d5a6103ca79844f6fac466e756e51599951b0ad1c8b0f4dca5aaa01292e52a8a19a994dfb8ae96163872353ec485ccf1a2c6bf2b0a316be623636b1118ec0511c5c0aa630833c542c80ca87898c8d8a0c9c6432f9200dfe1f87f83f760e4779993ebb87b600763a78a1e0022f2a3c083730c09930e2185bb62bd0f1e1ec17991ed4246cbcadc9d17af7f85d2583b555b293b85cb3ba103959d3005c53566ecf636f2d99b94266ae10f20d7941d94ab52b1e66c99a2a24903de01d4c24236f18e0a72f1485b8e8e0eba5385dd2ccf3da36f42f29f29c0b5c24e7cd6e5d92ca2e92b79c3cd608a0cbfe8b2940aca50db477bbbf676188191656e0acf10df4d56c25255747160742762fc2d37e507e563b9c2b2158231c24fda5b8762d28c2cb390432cce54693def5c5d8cf3f1a820bff33763673116e0bb80254eea5b1630deb61300db47c2e3e9d43c0ae79ac6d8d8e5dacb30b421c0e88460520595dd83aefc1ea925bc7b76faabbd79339a6862c8b8ae500e61ad9244cffc3946a184f713d5239638a2e1d795aeee5ee445c9f9aab6409e735b88f021554cd4ee080447d929f96556906a5504df942919385bc5e64cedbf2ae394d27ace9d675fc4a5fbaa1418f1420ae54e57c8343a69843ac97c5ebcc817820320e5d6c9eda47e171d3f5a2edb52448f00acda78580b066fc588b39aa09638a850a2a0dcb9dd824a85d72255623c47308a71ac9c4b4f6bda9d273b1c1f88b629c2d80cf2b46f3ac5285aad169e96b067b01de824253f4156311196ba6e4bc21040cf1b3cc75b68e63af37eb275714561af525bfbb82497cd4730215975d8a3cd61df43394141f318ee9571c1ed93198d282288da8bcb5b33e3c6f1e9269a763041064a0d92da154a1b43895e1833b6bac67e096996e0db5bc1447c30bbdcb5bc30253f837b9e9f89777891e37357c8654e1a5d5ea0262afd58136f1c1c969d3950173e90b1dc6b589a510c7364be31128cacd0baf495fbb9161024b880c18e97e2a3395c5515973f8ebbdf18b8fb573eb46a4e8fc88c2f159cc6be94c7aa35e0d1be4bfc35f47cd93bee0e1adc16a0957f824a9e24f31a32c372e97b6a2f9a71d147f33857a0febcfe896dc770f9a2a86a7089b55a396afffe4bb21d5321e1d7a1230faf580d4ac8a0a7d8f3fcf457f63ab27cc54c5820739bf6437bc43eaecbb2cbf7af588268ced22cad9f5a9254d95c5f47127387655ee36dc94d70d1392960825e78b37cc551183bcb25b98363522c0a801206000c6ded60985718b46ab2400ad0b22c9addd5f71d90a7578913c0da692d7bb9230c78d6f6273114df69d73210957b327089cd3495ba001efc730c8f84d824fdf9448c277d02379b694d0bd1a4012ba18c18efb60b94d7fb0fb750ba948a5c73e55ffe464ebf7acbd04fb8124a0432f67e42bc4409433b85588fa6d16dc93432fb633ec1170e1de3d258e7e287d7479896cec61832a3e7e5e257209609c6af97c315bb08473de27be705f831301c5336b7f37607888212f40b73bd0aea535cc7148be0f9cddeef1f397b8dc1c1bd11368695d776b6d4f51d8b9a3ff091dc23b438ad3a8e00f435768543c9520ed4fde81fe5b8cde1b1b005cc5a470003b8a12d74d4178d03351cfd620c9a41861979a4209de561feab4faa20b540fafe14a2f47815d1d6f756882735645e30f50fe0714b48545aad0aa47edf4cf85b77edef8420cadbb2ab055537896841d009bb5d21aeb5bf32e1a0a2c6d2f7a0044c7bae33fa95f6264135534b5aa1a1710398fce470a822d6e5bf4a572fc5aa091e664335a8f0e5f4b82ba80dbd25d8d050d8d517b496e2067860366e267a33cceafe24e53584565511927952e43f160218634834c0bd7a41a100548c68c54d6d47e30ba6841925ce0afeb3aea68385600156ed62144c5a67173008b02d76e28126ca00a2819c0bb3eb4cc92c196f8932b0efd5fccfbbd5f77198a0d800e01d63679db7ee5dc4213c4a1e82b47ce07ca040540c023f617d52c1ccbd2d9e825d8f60a2f6cc6c7e0230f8c259659cdc08211739844b03202e6faab271c897dfa7bef337a5b0672ab13ebe547f572a089fe304aeed0c9d0c871f87128dbbb634322c5449164a13028e7f8e46ea7eaf5861a1eb1cdadf95c5ae983ef642bfb86f103558afc4571483cb7585a00715580fdd806c4f741b7246e5655a575e85661422ec7b71e79535db2ab86ca6105124a2f1428d9f82f7cf626d8bf29d5a074bf2e8a64a11e8b415465ec3366cc0e4af15eb00af3afb40024843ffe9126a492594cff90682e2c4afa7237bc901e70a081e68a01e0d9ee7d4bfb5b07b2d9102409de25c281bbbdd10f2bbdb04adf4a2e467df3108a7206cd0ab67ebc298481ce73bbff082a5434b01e26d8ec53ea69f7dddf6b08619279b0aa0c5e4f7e0ba18b37dfcb3ab7762debd778e1675539e2023fe00026df8a6518857f2cf15a8dd27eb05fd4854710b80ae479cc3dbb4963dbb6140129ebe07739ab8b1f23d828751d533ea3630788c03835c7ade9de2fc725639be627448ecbcaa51b958aee7c6415c041b815de8940e427fe2152c77639f3c5e7db0699e2a03a056f4a0323541d174c4d8c1d71a7b04c664aeea06aaf2f978496231f2c0d82e6d3dbd8f29d81dcba037666a0567564fed3a90a34f4c2a0864fe6a118678798666318a2f6c93fc93d788c258f01c5aa450b65f4927ba6308f7a99ab0fae315f1aa96516b51b9a35b0bf04a303290f7a4b0f107434e88c9b897d8ef32dbea8b90191f27ec6c6a71c3b576ccc10b6945a2d651b526b36c86929d7dab3195b1cd7777a95a1dccfab7ad95d9815d143fc6d86f974cd07417038811e143f157f37337b54b492a344d0bdd2d2dfd3f27a74d529898ae3243bd532983b58d22337c69e87af024d6cb0d8f29c96ee48114d2e7b2c1535ad6b00e178977380bb17569028d04252e77d46764676068c2e1d43bee814688c6881424210bee531ef156682b6b037656dd8a82fd83ca1924074f752a207b2585ae4c9ea6f4c78c75d1ed96542fc65f19260e0a755919c2e24659105c4c9df00ded15f93f442f6887c12fadbd7a3c4fe425a3f30f0ddb2f375e471a373f27e43c8a494d9678e8e60931292950805f2f6b9f28b3182436c2a975dd365a59195dc4df585e87395c7c3a4236a0085c40b7af8c4448e830057b33fe8df95a33647c37c55b225bd5f8b1c591db855703240e2f49d63e43c62f8c30b2a39b67bea6e9a9481146c046af276d611b6ed9c39e7cc8f66dc7f9b386ba00528af573aea6d008433d39881470fb56429fde8616fbc9e483e1222d447832cb7bc58170c7ec86e8f4de9070e07eacaf608aaaf73c42c827990cd0c64687ae8cfa0b373da849a767ef3b63ca08327663a0c85a554dd2ecef748e891cbd90386b5737d945603b56c887986f9a306d7de4b18564645c2a77acd8cde744455ead6f28819282b59f662f7da89dec13b7623df1b44633048278c6435e1449517b0235bc9f4c2cf39aaf34908726c3dd3a07a1b29aa41f4a0e91cec6a4481c3280a94398f6ff1b0b07b39ab0e6668dde438308209a6e0f5ddbfbb30481e978e215f67468f31eaf930dca350f0fc53bee83f988b04310eb11496a8955d0a91b51aead8dcd1703cdc4b0e7f2f4674ae3e588b595b2a10a00f88b3abcfdb5d1c8dc9f8727d16373ae7fd05b239f7e5bc22909682d90901653987feda97752895523e956cffbcaa8d3f088d280cb19cf4d71f010a671d8b1d6227e7d72dbea884042ee1324bd31a5fbb7ed49b79f04e834245a552b5157fdd0e905e98e890291c69bdcdf6307771876bb8288809b44e63bdc934710e039909b2ef090b39137e7420aa7ef195656037f3482b4fc10e554341d68ec93d2294fcb6a8d69542b31f9942a59c4f4503e188912dd1cff39640cc2217e1cc871865202fa3c02e817f2fcf395c446a3eecac5d97950a44ffe1e8d299e064e5512aab2c1581a7dde08e01d9efd6c7fdc561b8c7e6fa75020b9534f2d3b35afc0b0e550b117eb8b4be6223be3b32b3367819c099e5cee581ef44a2cc483073514b0c317541eccfeb5a470e62a4a7183b1b22839e1a1c23bf58b6ee43d1fe87fa100c1bba8cab5dc7f68592841c2f9cee4e068d6791e55f4dd54edf7ecf336cef3510f331f64e0bfe4a9226e772e395f992634eeb6219cc239dd5d8e03cbe1f45810bd16714d1d83b871586d6c721608db6150796aa7d942a7d6b7f37e1fe54d5910ff184c75453103ce3e832ab21e3f16110827890bdeaef035641417fcb9b2c3c142549f5302f25b6f4fd1abb1b586555dec7abb108c3d988222356f8845157a91a934f239cf4d919aa5a54e5706f63ccaedaa2a523aa75b6cb425fccd9b302760f63efea5bb28d9047c8ef3d06ef698f6eb8d69cc2968256b56ba2c6b1aa325007ccc054bd8707ae6a7e1136a7d734ca437bc91640e819bdb1161db6285b848209f695c935d12262fc81ea65c312cab7c604cebf8a7a8e32199912d3fc172f2d0c39e4c9610d79d226d090265c7f961ce63aeab2e824e029ce1b89601913496a0dc3486866c4ae74c9f7227bb2bc821fe2ea1a265a34e961cfe8e0548f0b2ff629b111d35a7ba7b41a2e65e5412dcceb796b31d0d87b9f1a4d24b028f2377d5201ebd6d03eef5c45e78c52247c3282fcf64558e43ff15e1d39533389bd7a86f4037518906b748ee732531e22b29338f4a4f42a0f216226011632c4fc7a59287208482ad4d100cefeb5679cb8b4f6af5aa6b87f87d0a7815aebb30da0d927d3e613ba71984e13a4480217ff47b1055dbef0ed7333ff8403935f10785b4d212031267080070a80b5f94ea5c4363d2d971036e8446f2c055ca49495145eca1ae9fe2992670c4c90a20991d63058dd4a885b9ec25f2307e6dfb364be99f0ab596b560e91d00167f0fcdc484e4510cea659d39a58ea6d94188082c301d82be3a5beaa06007fd0fb2de248dbc4fe010a14285eb1c67ab1035575cfe2c4a46e7169be0224093f309708216779d4be610fbad6c37027359a6cd9af3253023c94bab2500927dca5e53ccf2bcfabd9f056b2381845a855bf7947d600e6f85117b69e57ab64124efae3d5bf327ab6ba6d4526a495aa613a1c141b4ccbe97dce4d2174af49751a32d049a2624f7c385673c88d7fea82a5c517b7fac655774c395cdce73099b60602b40c9255dbac3b084808ab31e76a1f050751bb6775dbada5d84691d2765327ca9346b73ccb979a8d2890fd43bf51eedcd0a78af072f64ee41abb954bacfb0b59bbaf1fcc4321f763a03b112189c055a31078afd0954b7d7ccf311615d3d01712fa34ac64c32e7ba17168f04876190ff32077be969a20cf83be9d04ecc5ba2287f65a7cb3a473300d133636ba395a1cfe1b9cfbe68f106f114d46d453ac6e058d32c610ee7b8e0025aa2f8fa532b3a6a45214fd7df4c35ad5112f545fbde314772040257c0366286283200970b7ee56d048cf3f6725fc8d9651a8234a6594149de5e4a643c98e7261b75a27baeb89147605258f470c0291bf22880e6a900612c1e251dddced6445c3dcdcfcccc1c36736068f9e1f7bbc4063895df782b11510427a865028d998dcea094cc2f8d0fa2efbd0040d0b118e4415dae71c92cfa31dced774d8572bfb42107f480682ff1c5ef95f657787a06997f53061d44cee6b2033fe9a65b025cd7e27764e34562fbc6391cf8d31623f31b68f03d6a1d1404d04b8c60cbb003fd65b2886da9263ee92021683e1af25189631d1725df8c163572d5f76b195591eca401fbd5d43e2992245ea9a4009a8ed600fcb0962ea5b845a18cd73d9f8a31eab2560b9f00b08cc4517309f7100c34df4c3aeccbb3df8eb49244478321b4748aef75677808a6a5d92a6964f298eb5e5337621398b0c1a43550700ca5f97215da057c3a4a16a260471ca887e12ab3a9fbaac6a61c67c38fb9b1c8b2eec6c0535832e1ea214b890bcc72682c5bddb39f4ddf34500a5cb9a81aa2d3d9f09f802a02b7324b79e9681debd2833f6238b22ae6622ba1a64e744f79029e3aef42dc679892840c82352fa28d9140106d6c2ba6ada66fae52bff965eb40eb54e3e94c92cd24f6ec52eab577e80d8c8e9f2d39d6b8d69503967d9809fd21036bd833a94dd6a85559c519bb7a2769b6486b00d34996da228c08994f285b22f7362c30b976680185fcb2d6c1a9fc47ce47e77d3af5b773534e2ce7c2063dc0f148ba271ab4c9b17837d44c14d231fe85b7644462249299a68b506bff87f4d23eee74e2f9b8ee256ebaa6e03b545afa196f22ef7e96d7255f5e79bbb786c1c165a455c205655a47926176b91f2d2c02ac5c00ad29b467bfdbd51b0768b35290d4bbf22a70348d22efdd5235eb6e682385197b4e17330c46c44ca6d5dfc67912841ddb730006e521446f952117b78effc601d10372438c4ba4f6e2608e9a51021960d7a065af49c4c06053d32596d990c1a43cac1658dad807ae48de098e4172a749e9fc0fea8a55e57cdb05166ad9692c00bf103ac30881c6ea8c6b86c244a0792663fbe195bacf4bffe700777c5fb07db9bcf94404ce90d0ed74a50febf9e2b4d7bb4c6dae168809b1e8687e2e668d2680f40733b7d6877b27eaaa2021daa212f5c9650237c6013810fbf50f8c160395a487a5cd535ddcc85437383d7fd401e42318881baf153d5c6a0f3ae7c933daff9cd10c89c0f7d9c1253e65995e7af082ba05d83761cb163b4ca9d55e5dbb43c74bf3f456988438da2b3e62a90097a188bb1d3cfb110267f28a328777328ee715c575923e5517216a551b7e4bca46426c9def697692dbd245316df1b3d3ebc23d2e7f26282bb8c3c77383b633d1fee09e269116a30414bd9701c5e0878caadf29773b5e4c010a7f519d6c8ed4ab64a0b0dd617d9c5b993d32b538129fa4404c7371453aec2448ad60caedef25217742955e9b0087cc084f3750b6474cf9ccc1b91b93088093fb9b65512bb41c7fe1325742cb05d49c540c0db2fe8cecba3202fa75c3652f8a0632c901284718de2f0197e4469bc4e63f957318e61dfc0b47f3612c833faa62fbbc758bea7747a919c10434862eebeac7e95316632cb2a81e786f3148d551e82d4b5f3952dac0e84a81a35b2d833ae99e441f064acd0efe3ec75d0180f0dc898edb2ec4e6104c43d9121095529dcc976329670baf3bc91051208b4d62984741144c2795189811c35d41cb3ed4bbd682aa625880beac8855c5fea04d41e00eab4f0d06318c229f650e10fdb194388dbc4bbbe4e95fd302d9cf15deba158f7c686da98f0c51b56a9c3bf2355c510225e1b58ab2af9314c08bd8adff1ada7c9a457c0c1deb47b814f2c2f2c04d7711fd02ba586d4a50ad99a1723e5bf2916b4b5ecba863947a98fbbbb300bbfceff43f6717beb8ca8fcefb59c672661fb46da69df22870a4c52fa4cd0f22bcca13d376d46c173fc2901c265dc09ad688e67b9726845e03944ee966ec01b285bd066f7c5357304cec840041d33e776badbda4e0007a505004e070b9520ed0794a82f878b218f741d0cb293956b5273b429c885d893d1113d73aa26c1d423271b72ec18a3db9d3d0e838edd70c2ce3869f8dfa7a2990839b8dd9e1172e87b0a636a0eaaf2172cf943d025179ff1617471d89f89258b34a3bbca00641a9cd81a528d6c2a802448da3ad3d59f777313c16a671482e39b8cb7da9ac35c1ff2d818c053d772d3b5a8a648244ccc209c808ebe141ba2f9d5650d0da14819aadde11048336a6121c302669d43eec43639872901bf281af7a1688aa3d3928ebdd90712c4211198d7728995d57f5bcc090cf7beca8045d513deb1b175ebb36796f0e41834db39abc7b5ecd1a514dcb9228530e81361aea5811ca208a650daf968e6d810ec1c14ddd45f0d5cc72b4bb6c9b567381cd3f8ff34d9591c48f845ea50846b056e828c137df3632d6225d8c3c7df355ea62f2e0d113a7e36852b6764afb9f11759ab5b4dc7063a18dd2b491a4a3d073bfdf8f4d33df3f339a83e3ba2953d7f09876c8f4e48e48b158ea3f41eb7f19716f44512bf7cdaaeb3915798ce22707b1a45579944f3cb644003ac2430ac63799964bce8f0125b487e5e84f986f46a8314921030ad6e51af6e9a654d191b8562e8acab6542844de111650de2ce37659f29baa8a03a66a40d48856ec10f47f554e884258e4eff26ce0f15c6b5171f95812f14a2b03d6b68f4bf5be1acb77702105951d5f13a423c1b21960b0c129fa99d1a8dc9e0aba8f76e0f8bf6db5523758d5ec321d0857a2df1134b5dae2faccf3b2373925e13c17f70c80783a3664e984c082f251bbe3c4698dff5daf3c70e5fdf14c66f792e18c3133a0ec195583065986f5d8f297f5750ed78aee7b7fb6efaa11546abb4feb014cf7206953bcb52e5f16ac8d232723683674bc02854efa9c8112dd9d7b31522a6b7fb653afd18e987a926fbd5377b5b0e415cf2614bdf0c26350102b6d8a26892985e76fd744ab01d06b524f57d634fc0b69a5d91355398d6ac1ec5b7588982ece0b103edde74a6f327e6ccf694bc534195fe0effc7483f13a12b278acb099ad84fbc96b27d36269ba06a660e2bc9093059a2acb1998cf3f1fe129253e64f00669a4cf7480180edd5c242544581499b9a233f0ce088acf1e4db14f35ce5d343461157dbe0adb07355d95d2cd5aa6dba222b6a702af1e325d2bc2d106ec5d71809dff7aec68762661bdfd5dbfe456cba5a7c150c73da2510f75216ed7e6f631af32c7e9c7884b0ab0cf71a834ddc4c825748eb5d35451d8092402dd68235d74c633a111bd167dec9a6371b137ae89530106a928c87743b38be3d0076cc22cae0c2544d7e6d49cb00182253dab5dfcf6cbdb378f56b0714b9d4bf2af75f56bee1cdbf00f1a0af44ee6ca3d7f8b3b42d38f87bf1da869240dc6477092f4b09a0af31220825e29d275eeb08977e8d3a6a934cc16a6d562b2eca001a04cb8d5ffe9fe85b21a785e261721288e9b5b75b400545a31d0d53270608b10408287f21c644121d27ec9aa9f50ccbce17e7ebe37a9858da78ca1d207bd9d63708d64375d1c8b872172ed0e50612b60c4b049e807f23d6fa8f4e61e06d52047a034d11c3fb63ed48fc75af072a1084b3d0982b796c9dbb70c295e4c938688dd603457e18852f8480e869f8aa0665890d85a78c5458b77f682cbde6b7954b55d82cdc590f35d097cd61fc65b0dbaac9cd05916c807ec0e318de09c55d6facb6370f2b077d67767da3df753109cb25329348253b3bb8a474b8f2383d269e7af7d31188362ee1c47b51ae57ee87cdc133d212b205f43ad871011e82684b3251a16817b80922192c7ef6e95042838827e749bc017d1a96c6e69f4d945f6a40c8067809380df1270bf5638a0dd4f2c7b7af4a5798b4280a4c98abd97c99272b34488d055c100b6e332bb5d2bf6ba8f3f5945bd877926df3eaab055c5d42be090db0bf02cc36716e8608d8ddd908e019707e77d50ecaae8f83a61fac66303fe0d980381913d591367d4749326ea822b20c1f015974fcd5ec6d659aedeac7b56f6fb7891706e619141f6b4a93840023bb2342e759da6438e07ed974a5f1e3d506144c960bbe067b718cb861fe927716cba85cfc466eed0e9d2c1067bc7f9e356bc5d23c1094541933220c2bef5ec7afe91782ec245208d58f93a08ec25eb59710a7362303daf04d7a256119a10ba5f6653564dff54f8eb78577360ac477abab5ce87bf70cce5000e4686fab8ca621f1c65dda94eb8b5892b1aff79a9a5eb0a2e65efd5314e0969768884cab782cafd4b81555a818559c4835fb6821ec46fd08ea418ac61ff343732becbc72450b2faedef7112b951edf2ee03bebe4b71365755e6d551810e06fbbc2176bff93433750bcbfec05aea120f193a1e4c5bf5993e098916f96";
var isSuperArgs = (xs) => xs.length > 1;
var SemaphoreVerifier__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi2, _bytecode, args[0]);
    }
  }
  getDeployTransaction(overrides) {
    return super.getDeployTransaction(overrides || {});
  }
  deploy(overrides) {
    return super.deploy(overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode;
  }
  static {
    this.abi = _abi2;
  }
  static createInterface() {
    return new Interface(_abi2);
  }
  static connect(address, runner) {
    return new Contract(address, _abi2, runner);
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/base/SemaphoreVerifierKeyPts__factory.ts
var _abi3 = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "actual",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expected",
        type: "uint256"
      }
    ],
    name: "Semaphore__VKPtBytesMaxDepthInvariantViolated",
    type: "error"
  }
];
var _bytecode2 = "0x60566050600b82828239805160001a6073146043577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220449beb5e91ea3c696875a17dce7d443ed14ac07b90f0a96ef98a0e6340dadfd664736f6c63430008170033";
var isSuperArgs2 = (xs) => xs.length > 1;
var SemaphoreVerifierKeyPts__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs2(args)) {
      super(...args);
    } else {
      super(_abi3, _bytecode2, args[0]);
    }
  }
  getDeployTransaction(overrides) {
    return super.getDeployTransaction(overrides || {});
  }
  deploy(overrides) {
    return super.deploy(overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode2;
  }
  static {
    this.abi = _abi3;
  }
  static createInterface() {
    return new Interface(_abi3);
  }
  static connect(address, runner) {
    return new Contract(
      address,
      _abi3,
      runner
    );
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/interfaces/ISemaphore__factory.ts
var _abi4 = [
  {
    inputs: [],
    name: "Semaphore__GroupHasNoMembers",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__InvalidProof",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeDepthIsNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsNotPartOfTheGroup",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__YouAreUsingTheSameNullifierTwice",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMerkleTreeDuration",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "GroupMerkleTreeDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nullifier",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "message",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "scope",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[8]",
        name: "points",
        type: "uint256[8]"
      }
    ],
    name: "ProofValidated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "acceptGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      }
    ],
    name: "addMembers",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "groupCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "updateGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "updateGroupMerkleTreeDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "oldIdentityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "updateMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "validateProof",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ISemaphore__factory = class {
  static {
    this.abi = _abi4;
  }
  static createInterface() {
    return new Interface(_abi4);
  }
  static connect(address, runner) {
    return new Contract(address, _abi4, runner);
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/interfaces/ISemaphoreGroups__factory.ts
var _abi5 = [
  {
    inputs: [],
    name: "Semaphore__CallerIsNotTheGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotThePendingGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupDoesNotExist",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminPending",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "GroupCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MembersAdded",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getGroupAdmin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeDepth",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeRoot",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeSize",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "hasMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "indexOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ISemaphoreGroups__factory = class {
  static {
    this.abi = _abi5;
  }
  static createInterface() {
    return new Interface(_abi5);
  }
  static connect(address, runner) {
    return new Contract(address, _abi5, runner);
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/interfaces/ISemaphoreVerifier__factory.ts
var _abi6 = [
  {
    inputs: [
      {
        internalType: "uint256[2]",
        name: "_pA",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[2][2]",
        name: "_pB",
        type: "uint256[2][2]"
      },
      {
        internalType: "uint256[2]",
        name: "_pC",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[4]",
        name: "_pubSignals",
        type: "uint256[4]"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ISemaphoreVerifier__factory = class {
  static {
    this.abi = _abi6;
  }
  static createInterface() {
    return new Interface(_abi6);
  }
  static connect(address, runner) {
    return new Contract(address, _abi6, runner);
  }
};

// ../contracts/typechain-types/factories/@semaphore-protocol/contracts/Semaphore__factory.ts
var _abi7 = [
  {
    inputs: [
      {
        internalType: "contract ISemaphoreVerifier",
        name: "_verifier",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "LeafAlreadyExists",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafCannotBeZero",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafDoesNotExist",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafGreaterThanSnarkScalarField",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotTheGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotThePendingGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupDoesNotExist",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupHasNoMembers",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__InvalidProof",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeDepthIsNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsNotPartOfTheGroup",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__YouAreUsingTheSameNullifierTwice",
    type: "error"
  },
  {
    inputs: [],
    name: "WrongSiblingNodes",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminPending",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "GroupCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMerkleTreeDuration",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "GroupMerkleTreeDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MembersAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nullifier",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "message",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "scope",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[8]",
        name: "points",
        type: "uint256[8]"
      }
    ],
    name: "ProofValidated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "acceptGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      }
    ],
    name: "addMembers",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getGroupAdmin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeDepth",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeRoot",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeSize",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "groupCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "groups",
    outputs: [
      {
        internalType: "uint256",
        name: "merkleTreeDuration",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "hasMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "indexOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "updateGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "updateGroupMerkleTreeDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "updateMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "validateProof",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "verifier",
    outputs: [
      {
        internalType: "contract ISemaphoreVerifier",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode3 = "0x60806040523480156200001157600080fd5b50604051620034c0380380620034c08339818101604052810190620000379190620000fd565b80600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200012f565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620000b18262000084565b9050919050565b6000620000c582620000a4565b9050919050565b620000d781620000b8565b8114620000e357600080fd5b50565b600081519050620000f781620000cc565b92915050565b6000602082840312156200011657620001156200007f565b5b60006200012684828501620000e6565b91505092915050565b613381806200013f6000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c80636389e107116100b8578063a9961c941161007c578063a9961c9414610384578063d0d898dd146103b4578063d24924fe146103d0578063da3cda52146103ee578063dabc4d511461040a578063fcf0b6ec1461043a57610137565b80636389e107146102a85780636cdd32fe146102d85780637ee35a0c146102f457806390509d441461032457806396324bd41461035457610137565b80634178c4d5116100ff5780634178c4d5146101f2578063456f41881461020e578063568ee8261461023e578063575185ed1461025a5780635c3f3b601461027857610137565b8063042453711461013c57806306dd8485146101585780631783efc3146101885780632b7ac3f3146101a45780632c880363146101c2575b600080fd5b6101566004803603810190610151919061265b565b610456565b005b610172600480360381019061016d91906126bb565b610497565b60405161017f919061270a565b60405180910390f35b6101a2600480360381019061019d91906126bb565b6104c5565b005b6101ac610504565b6040516101b991906127a4565b60405180910390f35b6101dc60048036038101906101d791906127fd565b61052a565b6040516101e9919061270a565b60405180910390f35b61020c6004803603810190610207919061283d565b610570565b005b610228600480360381019061022391906128ea565b6105b5565b6040516102359190612946565b60405180910390f35b61025860048036038101906102539190612961565b610a00565b005b610262610a0e565b60405161026f919061270a565b60405180910390f35b610292600480360381019061028d91906129a1565b610a53565b60405161029f919061270a565b60405180910390f35b6102c260048036038101906102bd91906129ce565b610a9a565b6040516102cf919061270a565b60405180910390f35b6102f260048036038101906102ed91906129fb565b610ab9565b005b61030e600480360381019061030991906129ce565b610afc565b60405161031b919061270a565b60405180910390f35b61033e600480360381019061033991906126bb565b610b1b565b60405161034b9190612946565b60405180910390f35b61036e600480360381019061036991906129ce565b610b49565b60405161037b919061270a565b60405180910390f35b61039e600480360381019061039991906129ce565b610b67565b6040516103ab9190612a7e565b60405180910390f35b6103ce60048036038101906103c991906128ea565b610ba4565b005b6103d8610cf3565b6040516103e5919061270a565b60405180910390f35b610408600480360381019061040391906129ce565b610cf9565b005b610424600480360381019061041f91906129ce565b610d05565b604051610431919061270a565b60405180910390f35b610454600480360381019061044f91906126bb565b610d28565b005b6000610463848484610e37565b9050426004600086815260200190815260200160002060010160008381526020019081526020016000208190555050505050565b60006104bd82600080868152602001908152602001600020610f4e90919063ffffffff16565b905092915050565b60006104d18383610fc8565b90504260046000858152602001908152602001600020600101600083815260200190815260200160002081905550505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006005600081548092919061053f90612ac8565b91905055905061054f81846110da565b81600460008381526020019081526020016000206000018190555092915050565b600061057f86868686866111b9565b90504260046000888152602001908152602001600020600101600083815260200190815260200160002081905550505050505050565b600082600073ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603610651576040517f029f057900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600160ff168360000135108061066e5750602060ff168360000135115b156106a5576040517fecf64f1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006106b085610afc565b9050600081036106ec576040517fc8b02e0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006106f786610d05565b9050808560200135146107d15760006004600088815260200190815260200160002060010160008760200135815260200190815260200160002054905060006004600089815260200190815260200160002060000154905060008203610789576040517f4d32958600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80826107959190612b10565b4211156107ce576040517f9581a99000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a23f019960405180604001604052808860a00160006008811061083157610830612b44565b5b602002013581526020018860a00160016008811061085257610851612b44565b5b6020020135815250604051806040016040528060405180604001604052808b60a00160026008811061088757610886612b44565b5b602002013581526020018b60a0016003600881106108a8576108a7612b44565b5b6020020135815250815260200160405180604001604052808b60a0016004600881106108d7576108d6612b44565b5b602002013581526020018b60a0016005600881106108f8576108f7612b44565b5b602002013581525081525060405180604001604052808a60a00160066008811061092557610924612b44565b5b602002013581526020018a60a00160076008811061094657610945612b44565b5b602002013581525060405180608001604052808b6020013581526020018b60400135815260200161097a8c606001356112f1565b815260200161098c8c608001356112f1565b8152508a600001356040518663ffffffff1660e01b81526004016109b4959493929190612da0565b602060405180830381865afa1580156109d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f59190612e22565b935050505092915050565b610a0a8282611328565b5050565b600060056000815480929190610a2390612ac8565b919050559050610a3381336110da565b610e10600460008381526020019081526020016000206000018190555090565b600060056000815480929190610a6890612ac8565b919050559050610a7881836110da565b610e106004600083815260200190815260200160002060000181905550919050565b6000806000838152602001908152602001600020600101549050919050565b6000610ac785858585611473565b905042600460008781526020019081526020016000206001016000838152602001908152602001600020819055505050505050565b6000806000838152602001908152602001600020600001549050919050565b6000610b41826000808681526020019081526020016000206115a690919063ffffffff16565b905092915050565b60046020528060005260406000206000915090508060000154905081565b60006001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b6004600083815260200190815260200160002060020160008260400135815260200190815260200160002060009054906101000a900460ff1615610c14576040517f208b15e800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c1e82826105b5565b610c54576040517f4aa6bc4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60016004600084815260200190815260200160002060020160008360400135815260200190815260200160002060006101000a81548160ff02191690831515021790555080608001358160200135837f0c32e14cfe81a05d371c248d22de6b7ae849e981b76a1f8842e7b6da73fc405a8460000135856040013586606001358760a001604051610ce79493929190612e69565b60405180910390a45050565b60055481565b610d02816115c9565b50565b6000610d21600080848152602001908152602001600020611780565b9050919050565b813373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610dc1576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600060046000858152602001908152602001600020600001549050826004600086815260200190815260200160002060000181905550837f264b2a8f6763c084235fe832ba903482b2ef1a521336881fc75b987c2dfd29c58285604051610e29929190612eaf565b60405180910390a250505050565b6000833373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610ed2576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610edd86610afc565b9050610f0585856000808a81526020019081526020016000206117a39092919063ffffffff16565b9250857f61e5e8054e3daf084a0c6c646c065e8bf5e7ca4d5567bda942309bd1652f349d82878787604051610f3d9493929190612f4a565b60405180910390a250509392505050565b6000808360030160008481526020019081526020016000205403610f9e576040517f7204756c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600183600301600084815260200190815260200160002054610fc09190612f8a565b905092915050565b6000823373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611063576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061106e85610afc565b905061109484600080888152602001908152602001600020611d8790919063ffffffff16565b9250847f19239b3f93cd10558aaf11423af70c77763bf54f52bcc75bfa74d4d13548cde98286866040516110ca93929190612fbe565b60405180910390a2505092915050565b806001600084815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550817ff0adfb94eab6daf835deb69c5738fe636150c3dfd08094a76f39b963dc8cb05a60405160405180910390a28073ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff16837f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e360405160405180910390a45050565b6000853373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611254576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061127a876000808b8152602001908152602001600020610f4e90919063ffffffff16565b90506112a6878787876000808e8152602001908152602001600020611fe690949392919063ffffffff16565b9250877fea3588e4a2a0c93d6a0e69dfeaf7496f43ccccf02ad9ce0a5b7627cbca4b61b1828989876040516112de9493929190612ff5565b60405180910390a2505095945050505050565b6000600882604051602001611306919061305b565b6040516020818303038152906040528051906020012060001c901c9050919050565b813373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146113c1576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816002600085815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16847f1018365553cce55d9cb02ef73e18cc9311894f3fe1d1eafd235ac2d26cd8ba5860405160405180910390a4505050565b6000843373ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461150e576040517fbb9bf27800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611534866000808a8152602001908152602001600020610f4e90919063ffffffff16565b905061155e8686866000808c815260200190815260200160002061259c909392919063ffffffff16565b9250867f3108849c053c77b8073a11256dffb5ffd5b55e93e105a355e1c9061db890d87182888660405161159493929190612fbe565b60405180910390a25050949350505050565b600080836003016000848152602001908152602001600020541415905092915050565b3373ffffffffffffffffffffffffffffffffffffffff166002600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611661576040517f34c4245d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050336001600084815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506002600083815260200190815260200160002060006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690553373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16837f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e360405160405180910390a45050565b600081600201600083600101548152602001908152602001600020549050919050565b6000808460000154905060005b8484905081101561192f577f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018585838181106117ef576117ee612b44565b5b905060200201351061182d576040517fc380a82e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600085858381811061184257611841612b44565b5b9050602002013503611880576040517f29691be200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6118a38686868481811061189757611896612b44565b5b905060200201356115a6565b156118da576040517f258a195a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806001836118e89190612b10565b6118f29190612b10565b86600301600087878581811061190b5761190a612b44565b5b905060200201358152602001908152602001600020819055508060010190506117b0565b506060848480806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505090506000866001015490505b858590508361198f9190612b10565b81600261199c91906131a9565b10156119b357806119ac90612ac8565b9050611980565b8087600101819055506000839050600087879050856119d29190612b10565b90506000600183901c905060006001806001856119ef9190612f8a565b901c6119fb9190612b10565b905060005b85811015611d0e5760008383611a169190612f8a565b905060008167ffffffffffffffff811115611a3457611a336131f4565b5b604051908082528060200260200182016040528015611a625781602001602082028036833780820191505090505b50905060005b82811015611c355760008860028884611a819190612b10565b611a8b9190613223565b1015611aae578f6002016000868152602001908152602001600020549050611aee565b8a8960028985611abe9190612b10565b611ac89190613223565b611ad29190612f8a565b81518110611ae357611ae2612b44565b5b602002602001015190505b600088600160028a86611b019190612b10565b611b0b9190613223565b611b159190612b10565b1015611b67578b8a600160028b87611b2d9190612b10565b611b379190613223565b611b419190612b10565b611b4b9190612f8a565b81518110611b5c57611b5b612b44565b5b602002602001015190505b6000808214611c035773__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe6040518060400160405280868152602001858152506040518263ffffffff1660e01b8152600401611bbb91906132ee565b602060405180830381865af4158015611bd8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bfc919061331e565b9050611c07565b8290505b80858581518110611c1b57611c1a612b44565b5b602002602001018181525050836001019350505050611a68565b50600180871603611c86578860018a51611c4f9190612f8a565b81518110611c6057611c5f612b44565b5b60200260200101518e600201600085815260200190815260200160002081905550611cd3565b600189511115611cd2578860028a51611c9f9190612f8a565b81518110611cb057611caf612b44565b5b60200260200101518e6002016000858152602001908152602001600020819055505b5b849650600185901c9450809850839550600180600186611cf39190612f8a565b901c611cff9190612b10565b93508260010192505050611a00565b508989905087611d1e9190612b10565b8b6000018190555085600081518110611d3a57611d39612b44565b5b60200260200101518b60020160008781526020019081526020016000208190555085600081518110611d6f57611d6e612b44565b5b60200260200101519750505050505050509392505050565b60007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018210611de2576040517fc380a82e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008203611e1c576040517f29691be200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611e2683836115a6565b15611e5d576040517f258a195a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600083600001549050600084600101549050600182611e7c9190612b10565b816002611e8991906131a9565b1015611e9c5780611e9990612ac8565b90505b808560010181905550600084905060005b82811015611f90576001808286901c1603611f6a5773__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808a6002016000868152602001908152602001600020548152602001858152506040518263ffffffff1660e01b8152600401611f2291906132ee565b602060405180830381865af4158015611f3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f63919061331e565b9150611f85565b81876002016000838152602001908152602001600020819055505b806001019050611ead565b5082611f9b90612ac8565b92508286600001819055508086600201600084815260200190815260200160002081905550828660030160008781526020019081526020016000208190555080935050505092915050565b60007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018410612041576040517fc380a82e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61204b86866115a6565b612081576040517f7204756c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61208b86856115a6565b156120c2576040517f258a195a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006120ce8787610f4e565b905060008590506000879050600060018a600001546120ed9190612f8a565b90506000808b60010154905060005b818110156124db576001808289901c16036122dc577f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018a8a8581811061214557612144612b44565b5b9050602002013510612183576040517fc380a82e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d888181106121bb576121ba612b44565b5b905060200201358152602001898152506040518263ffffffff1660e01b81526004016121e791906132ee565b602060405180830381865af4158015612204573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612228919061331e565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d8881811061226257612261612b44565b5b905060200201358152602001888152506040518263ffffffff1660e01b815260040161228e91906132ee565b602060405180830381865af41580156122ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122cf919061331e565b94508260010192506124d0565b8084901c8188901c146124b4577f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018a8a8581811061231d5761231c612b44565b5b905060200201351061235b576040517fc380a82e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808981526020018d8d8881811061239957612398612b44565b5b905060200201358152506040518263ffffffff1660e01b81526004016123bf91906132ee565b602060405180830381865af41580156123dc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612400919061331e565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808881526020018d8d888181106124405761243f612b44565b5b905060200201358152506040518263ffffffff1660e01b815260040161246691906132ee565b602060405180830381865af4158015612483573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124a7919061331e565b94508260010192506124cf565b858d6002016000858152602001908152602001600020819055505b5b8060010190506120fc565b506124e58c611780565b841461251d576040517f3fa930c600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b848c60020160008381526020019081526020016000208190555060008a1461256f578b60030160008c8152602001908152602001600020548c60030160008c8152602001908152602001600020819055505b60008c60030160008d81526020019081526020016000208190555084965050505050505095945050505050565b60006125ac858560008686611fe6565b9050949350505050565b600080fd5b600080fd5b6000819050919050565b6125d3816125c0565b81146125de57600080fd5b50565b6000813590506125f0816125ca565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f84011261261b5761261a6125f6565b5b8235905067ffffffffffffffff811115612638576126376125fb565b5b60208301915083602082028301111561265457612653612600565b5b9250929050565b600080600060408486031215612674576126736125b6565b5b6000612682868287016125e1565b935050602084013567ffffffffffffffff8111156126a3576126a26125bb565b5b6126af86828701612605565b92509250509250925092565b600080604083850312156126d2576126d16125b6565b5b60006126e0858286016125e1565b92505060206126f1858286016125e1565b9150509250929050565b612704816125c0565b82525050565b600060208201905061271f60008301846126fb565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061276a61276561276084612725565b612745565b612725565b9050919050565b600061277c8261274f565b9050919050565b600061278e82612771565b9050919050565b61279e81612783565b82525050565b60006020820190506127b96000830184612795565b92915050565b60006127ca82612725565b9050919050565b6127da816127bf565b81146127e557600080fd5b50565b6000813590506127f7816127d1565b92915050565b60008060408385031215612814576128136125b6565b5b6000612822858286016127e8565b9250506020612833858286016125e1565b9150509250929050565b600080600080600060808688031215612859576128586125b6565b5b6000612867888289016125e1565b9550506020612878888289016125e1565b9450506040612889888289016125e1565b935050606086013567ffffffffffffffff8111156128aa576128a96125bb565b5b6128b688828901612605565b92509250509295509295909350565b600080fd5b60006101a082840312156128e1576128e06128c5565b5b81905092915050565b6000806101c08385031215612902576129016125b6565b5b6000612910858286016125e1565b9250506020612921858286016128ca565b9150509250929050565b60008115159050919050565b6129408161292b565b82525050565b600060208201905061295b6000830184612937565b92915050565b60008060408385031215612978576129776125b6565b5b6000612986858286016125e1565b9250506020612997858286016127e8565b9150509250929050565b6000602082840312156129b7576129b66125b6565b5b60006129c5848285016127e8565b91505092915050565b6000602082840312156129e4576129e36125b6565b5b60006129f2848285016125e1565b91505092915050565b60008060008060608587031215612a1557612a146125b6565b5b6000612a23878288016125e1565b9450506020612a34878288016125e1565b935050604085013567ffffffffffffffff811115612a5557612a546125bb565b5b612a6187828801612605565b925092505092959194509250565b612a78816127bf565b82525050565b6000602082019050612a936000830184612a6f565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612ad3826125c0565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612b0557612b04612a99565b5b600182019050919050565b6000612b1b826125c0565b9150612b26836125c0565b9250828201905080821115612b3e57612b3d612a99565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060029050919050565b600081905092915050565b6000819050919050565b612b9c816125c0565b82525050565b6000612bae8383612b93565b60208301905092915050565b6000602082019050919050565b612bd081612b73565b612bda8184612b7e565b9250612be582612b89565b8060005b83811015612c16578151612bfd8782612ba2565b9650612c0883612bba565b925050600181019050612be9565b505050505050565b600060029050919050565b600081905092915050565b6000819050919050565b600081905092915050565b612c5281612b73565b612c5c8184612c3e565b9250612c6782612b89565b8060005b83811015612c98578151612c7f8782612ba2565b9650612c8a83612bba565b925050600181019050612c6b565b505050505050565b6000612cac8383612c49565b60408301905092915050565b6000602082019050919050565b612cce81612c1e565b612cd88184612c29565b9250612ce382612c34565b8060005b83811015612d14578151612cfb8782612ca0565b9650612d0683612cb8565b925050600181019050612ce7565b505050505050565b600060049050919050565b600081905092915050565b6000819050919050565b6000602082019050919050565b612d5281612d1c565b612d5c8184612d27565b9250612d6782612d32565b8060005b83811015612d98578151612d7f8782612ba2565b9650612d8a83612d3c565b925050600181019050612d6b565b505050505050565b60006101a082019050612db66000830188612bc7565b612dc36040830187612cc5565b612dd060c0830186612bc7565b612dde610100830185612d49565b612dec6101808301846126fb565b9695505050505050565b612dff8161292b565b8114612e0a57600080fd5b50565b600081519050612e1c81612df6565b92915050565b600060208284031215612e3857612e376125b6565b5b6000612e4684828501612e0d565b91505092915050565b82818337505050565b612e656101008383612e4f565b5050565b600061016082019050612e7f60008301876126fb565b612e8c60208301866126fb565b612e9960408301856126fb565b612ea66060830184612e58565b95945050505050565b6000604082019050612ec460008301856126fb565b612ed160208301846126fb565b9392505050565b600082825260208201905092915050565b600080fd5b6000612efa8385612ed8565b93507f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115612f2d57612f2c612ee9565b5b602083029250612f3e838584612e4f565b82840190509392505050565b6000606082019050612f5f60008301876126fb565b8181036020830152612f72818587612eee565b9050612f8160408301846126fb565b95945050505050565b6000612f95826125c0565b9150612fa0836125c0565b9250828203905081811115612fb857612fb7612a99565b5b92915050565b6000606082019050612fd360008301866126fb565b612fe060208301856126fb565b612fed60408301846126fb565b949350505050565b600060808201905061300a60008301876126fb565b61301760208301866126fb565b61302460408301856126fb565b61303160608301846126fb565b95945050505050565b6000819050919050565b613055613050826125c0565b61303a565b82525050565b60006130678284613044565b60208201915081905092915050565b60008160011c9050919050565b6000808291508390505b60018511156130cd578086048111156130a9576130a8612a99565b5b60018516156130b85780820291505b80810290506130c685613076565b945061308d565b94509492505050565b6000826130e657600190506131a2565b816130f457600090506131a2565b816001811461310a576002811461311457613143565b60019150506131a2565b60ff84111561312657613125612a99565b5b8360020a91508482111561313d5761313c612a99565b5b506131a2565b5060208310610133831016604e8410600b84101617156131785782820a90508381111561317357613172612a99565b5b6131a2565b6131858484846001613083565b9250905081840481111561319c5761319b612a99565b5b81810290505b9392505050565b60006131b4826125c0565b91506131bf836125c0565b92506131ec7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846130d6565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600061322e826125c0565b9150613239836125c0565b9250828202613247816125c0565b9150828204841483151761325e5761325d612a99565b5b5092915050565b600081905092915050565b613279816125c0565b82525050565b600061328b8383613270565b60208301905092915050565b6132a081612b73565b6132aa8184613265565b92506132b582612b89565b8060005b838110156132e65781516132cd878261327f565b96506132d883612bba565b9250506001810190506132b9565b505050505050565b60006040820190506133036000830184613297565b92915050565b600081519050613318816125ca565b92915050565b600060208284031215613334576133336125b6565b5b600061334284828501613309565b9150509291505056fea2646970667358221220e0f259e7be711c29fc8aadbf33345fe5bae95c2962e3b174dddc3afd896283a864736f6c63430008170033";
var isSuperArgs3 = (xs) => {
  return typeof xs[0] === "string" || Array.isArray(xs[0]) || "_isInterface" in xs[0];
};
var Semaphore__factory = class _Semaphore__factory extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs3(args)) {
      super(...args);
    } else {
      const [linkLibraryAddresses, signer] = args;
      super(
        _abi7,
        _Semaphore__factory.linkBytecode(linkLibraryAddresses),
        signer
      );
    }
  }
  static linkBytecode(linkLibraryAddresses) {
    let linkedBytecode = _bytecode3;
    linkedBytecode = linkedBytecode.replace(
      new RegExp("__\\$75f79a42d9bcbdbb69ad79ebd80f556f39\\$__", "g"),
      linkLibraryAddresses["poseidon-solidity/PoseidonT3.sol:PoseidonT3"].replace(/^0x/, "").toLowerCase()
    );
    return linkedBytecode;
  }
  getDeployTransaction(_verifier, overrides) {
    return super.getDeployTransaction(_verifier, overrides || {});
  }
  deploy(_verifier, overrides) {
    return super.deploy(_verifier, overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode3;
  }
  static {
    this.abi = _abi7;
  }
  static createInterface() {
    return new Interface(_abi7);
  }
  static connect(address, runner) {
    return new Contract(address, _abi7, runner);
  }
};

// ../contracts/typechain-types/factories/contracts/Evaluation.sol/EvaluationPlatform__factory.ts
var _abi8 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_semaphore",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "addParticipant",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "createEvaluation",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "creatorAddressEvaluations",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "evaluations",
    outputs: [
      {
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "voteCount",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "finalized",
        type: "bool"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "evaluationId",
        type: "uint256"
      }
    ],
    name: "finalizeEvaluation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "creatorAddress",
        type: "address"
      }
    ],
    name: "getCreatorEvaluationList",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "voteCount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "finalized",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "groupId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          }
        ],
        internalType: "struct EvaluationPlatform.EvaluationListItem[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "evaluationId",
        type: "uint256"
      }
    ],
    name: "getEvaluation",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "creator",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "voteCount",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "participantList",
            type: "uint256[]"
          },
          {
            internalType: "bool",
            name: "finalized",
            type: "bool"
          }
        ],
        internalType: "struct EvaluationPlatform.EvaluationData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identityCommit",
        type: "uint256"
      }
    ],
    name: "getParticipantEvaluationList",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "voteCount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "finalized",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "groupId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          }
        ],
        internalType: "struct EvaluationPlatform.EvaluationListItem[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "evaluationId",
        type: "uint256"
      }
    ],
    name: "getParticipantList",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "participantICEvaluation",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "semaphore",
    outputs: [
      {
        internalType: "contract ISemaphore",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "nullifierHash",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feedback",
        type: "uint256"
      },
      {
        internalType: "uint256[8]",
        name: "points",
        type: "uint256[8]"
      }
    ],
    name: "vote",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var _bytecode4 = "0x60806040523480156200001157600080fd5b50604051620023f4380380620023f48339818101604052810190620000379190620000e8565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200011a565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620000b08262000083565b9050919050565b620000c281620000a3565b8114620000ce57600080fd5b50565b600081519050620000e281620000b7565b92915050565b6000602082840312156200010157620001006200007e565b5b60006200011184828501620000d1565b91505092915050565b6122ca806200012a6000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806390a3a74e1161007157806390a3a74e146101b6578063ad5ee392146101e6578063c23d4c8514610202578063cb2f066814610232578063ea7870e214610262578063f70778fa14610292576100b4565b806333c63b17146100b957806349c803af146100ec57806378ddae1114610108578063796787ad146101385780637b5d25341461016857806380a1a7f014610186575b600080fd5b6100d360048036038101906100ce91906112a7565b6102ae565b6040516100e394939291906113cf565b60405180910390f35b61010660048036038101906101019190611442565b610393565b005b610122600480360381019061011d91906114d0565b6105f9565b60405161012f9190611510565b60405180910390f35b610152600480360381019061014d9190611557565b61062a565b60405161015f9190611510565b60405180910390f35b61017061065b565b60405161017d91906115f6565b60405180910390f35b6101a0600480360381019061019b91906112a7565b61067f565b6040516101ad919061179e565b60405180910390f35b6101d060048036038101906101cb91906117c0565b610892565b6040516101dd919061179e565b60405180910390f35b61020060048036038101906101fb91906112a7565b610ad1565b005b61021c600480360381019061021791906112a7565b610ba6565b604051610229919061190e565b60405180910390f35b61024c60048036038101906102479190611a65565b610c91565b6040516102599190611510565b60405180910390f35b61027c600480360381019061027791906112a7565b610e7c565b6040516102899190611b1d565b60405180910390f35b6102ac60048036038101906102a791906114d0565b610eea565b005b60016020528060005260406000206000915090508060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010154908060040160009054906101000a900460ff169080600501805461031090611b6e565b80601f016020809104026020016040519081016040528092919081815260200182805461033c90611b6e565b80156103895780601f1061035e57610100808354040283529160200191610389565b820191906000526020600020905b81548152906001019060200180831161036c57829003601f168201915b5050505050905084565b60006001600088815260200190815260200160002090508060040160009054906101000a900460ff16156103fc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103f390611beb565b60405180910390fd5b60006040518060c00160405280888152602001878152602001868152602001858152602001898152602001846008806020026040519081016040528092919082600860200280828437600081840152601f19601f820116905080830192505050505050815250905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663456f41888a846040518363ffffffff1660e01b81526004016104c2929190611d0b565b602060405180830381865afa1580156104df573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105039190611d61565b905080610545576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161053c90611dda565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0d898dd8a846040518363ffffffff1660e01b81526004016105a0929190611d0b565b600060405180830381600087803b1580156105ba57600080fd5b505af11580156105ce573d6000803e3d6000fd5b5050505060018360010160008282546105e79190611e29565b92505081905550505050505050505050565b6003602052816000526040600020818154811061061557600080fd5b90600052602060002001600091509150505481565b6002602052816000526040600020818154811061064657600080fd5b90600052602060002001600091509150505481565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60606000600360008481526020019081526020016000208054806020026020016040519081016040528092919081815260200182805480156106e057602002820191906000526020600020905b8154815260200190600101908083116106cc575b505050505090506000815167ffffffffffffffff8111156107045761070361193a565b5b60405190808252806020026020018201604052801561073d57816020015b61072a6111e9565b8152602001906001900390816107225790505b50905060005b82518110156108875760006001600085848151811061076557610764611e5d565b5b6020026020010151815260200190815260200160002090506040518060800160405280826001015481526020018260040160009054906101000a900460ff16151581526020018584815181106107be576107bd611e5d565b5b602002602001015181526020018260050180546107da90611b6e565b80601f016020809104026020016040519081016040528092919081815260200182805461080690611b6e565b80156108535780601f1061082857610100808354040283529160200191610853565b820191906000526020600020905b81548152906001019060200180831161083657829003601f168201915b505050505081525083838151811061086e5761086d611e5d565b5b6020026020010181905250508080600101915050610743565b508092505050919050565b60606000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080548060200260200160405190810160405280929190818152602001828054801561091f57602002820191906000526020600020905b81548152602001906001019080831161090b575b505050505090506000815167ffffffffffffffff8111156109435761094261193a565b5b60405190808252806020026020018201604052801561097c57816020015b6109696111e9565b8152602001906001900390816109615790505b50905060005b8251811015610ac6576000600160008584815181106109a4576109a3611e5d565b5b6020026020010151815260200190815260200160002090506040518060800160405280826001015481526020018260040160009054906101000a900460ff16151581526020018584815181106109fd576109fc611e5d565b5b60200260200101518152602001826005018054610a1990611b6e565b80601f0160208091040260200160405190810160405280929190818152602001828054610a4590611b6e565b8015610a925780601f10610a6757610100808354040283529160200191610a92565b820191906000526020600020905b815481529060010190602001808311610a7557829003601f168201915b5050505050815250838381518110610aad57610aac611e5d565b5b6020026020010181905250508080600101915050610982565b508092505050919050565b6001600082815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610b75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b6c90611ed8565b60405180910390fd5b600180600083815260200190815260200160002060040160006101000a81548160ff02191690831515021790555050565b610bae611213565b600060016000848152602001908152602001600020905060405180608001604052808260000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018260010154815260200182600301805480602002602001604051908101604052809291908181526020018280548015610c6857602002820191906000526020600020905b815481526020019060010190808311610c54575b505050505081526020018260040160009054906101000a900460ff161515815250915050919050565b60008060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663575185ed6040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610d01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d259190611f0d565b9050610d656040518060400160405280601281526020017f6372656174654576616c756174696f6e3a20000000000000000000000000000081525061110a565b336001600083815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006001600083815260200190815260200160002060040160006101000a81548160ff02191690831515021790555082600160008381526020019081526020016000206005019081610e0c91906120dc565b50600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081908060018154018082558091505060019003906000526020600020016000909190919091505580915050919050565b606060016000838152602001908152602001600020600301805480602002602001604051908101604052809291908181526020018280548015610ede57602002820191906000526020600020905b815481526020019060010190808311610eca575b50505050509050919050565b60016000838152602001908152602001600020600201600082815260200190815260200160002060009054906101000a900460ff1615610f5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f56906121fa565b60405180910390fd5b6001600083815260200190815260200160002060040160009054906101000a900460ff1615610fc3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fba90611beb565b60405180910390fd5b6001806000848152602001908152602001600020600201600083815260200190815260200160002060006101000a81548160ff021916908315150217905550600160008381526020019081526020016000206003018190806001815401808255809150506001900390600052602060002001600090919091909150556003600082815260200190815260200160002082908060018154018082558091505060019003906000526020600020016000909190919091505560008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631783efc383836040518363ffffffff1660e01b81526004016110d492919061221a565b600060405180830381600087803b1580156110ee57600080fd5b505af1158015611102573d6000803e3d6000fd5b505050505050565b6111a08160405160240161111e9190612243565b6040516020818303038152906040527f41304fac000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506111a3565b50565b6111ba816111b26111bd6111de565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b611253819050919050565b60405180608001604052806000815260200160001515815260200160008152602001606081525090565b6040518060800160405280600073ffffffffffffffffffffffffffffffffffffffff16815260200160008152602001606081526020016000151581525090565b61125b612265565b565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b61128481611271565b811461128f57600080fd5b50565b6000813590506112a18161127b565b92915050565b6000602082840312156112bd576112bc611267565b5b60006112cb84828501611292565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006112ff826112d4565b9050919050565b61130f816112f4565b82525050565b61131e81611271565b82525050565b60008115159050919050565b61133981611324565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561137957808201518184015260208101905061135e565b60008484015250505050565b6000601f19601f8301169050919050565b60006113a18261133f565b6113ab818561134a565b93506113bb81856020860161135b565b6113c481611385565b840191505092915050565b60006080820190506113e46000830187611306565b6113f16020830186611315565b6113fe6040830185611330565b81810360608301526114108184611396565b905095945050505050565b600080fd5b60008190508260206008028201111561143c5761143b61141b565b5b92915050565b6000806000806000806101a087890312156114605761145f611267565b5b600061146e89828a01611292565b965050602061147f89828a01611292565b955050604061149089828a01611292565b94505060606114a189828a01611292565b93505060806114b289828a01611292565b92505060a06114c389828a01611420565b9150509295509295509295565b600080604083850312156114e7576114e6611267565b5b60006114f585828601611292565b925050602061150685828601611292565b9150509250929050565b60006020820190506115256000830184611315565b92915050565b611534816112f4565b811461153f57600080fd5b50565b6000813590506115518161152b565b92915050565b6000806040838503121561156e5761156d611267565b5b600061157c85828601611542565b925050602061158d85828601611292565b9150509250929050565b6000819050919050565b60006115bc6115b76115b2846112d4565b611597565b6112d4565b9050919050565b60006115ce826115a1565b9050919050565b60006115e0826115c3565b9050919050565b6115f0816115d5565b82525050565b600060208201905061160b60008301846115e7565b92915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61164681611271565b82525050565b61165581611324565b82525050565b600082825260208201905092915050565b60006116778261133f565b611681818561165b565b935061169181856020860161135b565b61169a81611385565b840191505092915050565b60006080830160008301516116bd600086018261163d565b5060208301516116d0602086018261164c565b5060408301516116e3604086018261163d565b50606083015184820360608601526116fb828261166c565b9150508091505092915050565b600061171483836116a5565b905092915050565b6000602082019050919050565b600061173482611611565b61173e818561161c565b9350836020820285016117508561162d565b8060005b8581101561178c578484038952815161176d8582611708565b94506117788361171c565b925060208a01995050600181019050611754565b50829750879550505050505092915050565b600060208201905081810360008301526117b88184611729565b905092915050565b6000602082840312156117d6576117d5611267565b5b60006117e484828501611542565b91505092915050565b6117f6816112f4565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000611834838361163d565b60208301905092915050565b6000602082019050919050565b6000611858826117fc565b6118628185611807565b935061186d83611818565b8060005b8381101561189e5781516118858882611828565b975061189083611840565b925050600181019050611871565b5085935050505092915050565b60006080830160008301516118c360008601826117ed565b5060208301516118d6602086018261163d565b50604083015184820360408601526118ee828261184d565b9150506060830151611903606086018261164c565b508091505092915050565b6000602082019050818103600083015261192881846118ab565b905092915050565b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61197282611385565b810181811067ffffffffffffffff821117156119915761199061193a565b5b80604052505050565b60006119a461125d565b90506119b08282611969565b919050565b600067ffffffffffffffff8211156119d0576119cf61193a565b5b6119d982611385565b9050602081019050919050565b82818337600083830152505050565b6000611a08611a03846119b5565b61199a565b905082815260208101848484011115611a2457611a23611935565b5b611a2f8482856119e6565b509392505050565b600082601f830112611a4c57611a4b611930565b5b8135611a5c8482602086016119f5565b91505092915050565b600060208284031215611a7b57611a7a611267565b5b600082013567ffffffffffffffff811115611a9957611a9861126c565b5b611aa584828501611a37565b91505092915050565b600082825260208201905092915050565b6000611aca826117fc565b611ad48185611aae565b9350611adf83611818565b8060005b83811015611b10578151611af78882611828565b9750611b0283611840565b925050600181019050611ae3565b5085935050505092915050565b60006020820190508181036000830152611b378184611abf565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611b8657607f821691505b602082108103611b9957611b98611b3f565b5b50919050565b7f4576616c756174696f6e2069732066696e616c697a6564000000000000000000600082015250565b6000611bd560178361134a565b9150611be082611b9f565b602082019050919050565b60006020820190508181036000830152611c0481611bc8565b9050919050565b600060089050919050565b600081905092915050565b6000819050919050565b6000602082019050919050565b611c4181611c0b565b611c4b8184611c16565b9250611c5682611c21565b8060005b83811015611c87578151611c6e8782611828565b9650611c7983611c2b565b925050600181019050611c5a565b505050505050565b6101a082016000820151611ca6600085018261163d565b506020820151611cb9602085018261163d565b506040820151611ccc604085018261163d565b506060820151611cdf606085018261163d565b506080820151611cf2608085018261163d565b5060a0820151611d0560a0850182611c38565b50505050565b60006101c082019050611d216000830185611315565b611d2e6020830184611c8f565b9392505050565b611d3e81611324565b8114611d4957600080fd5b50565b600081519050611d5b81611d35565b92915050565b600060208284031215611d7757611d76611267565b5b6000611d8584828501611d4c565b91505092915050565b7f496e76616c69642070726f6f66206f7220616c726561647920766f7465640000600082015250565b6000611dc4601e8361134a565b9150611dcf82611d8e565b602082019050919050565b60006020820190508181036000830152611df381611db7565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611e3482611271565b9150611e3f83611271565b9250828201905080821115611e5757611e56611dfa565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4f6e6c792063726561746f722063616e2066696e616c697a6500000000000000600082015250565b6000611ec260198361134a565b9150611ecd82611e8c565b602082019050919050565b60006020820190508181036000830152611ef181611eb5565b9050919050565b600081519050611f078161127b565b92915050565b600060208284031215611f2357611f22611267565b5b6000611f3184828501611ef8565b91505092915050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302611f9c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82611f5f565b611fa68683611f5f565b95508019841693508086168417925050509392505050565b6000611fd9611fd4611fcf84611271565b611597565b611271565b9050919050565b6000819050919050565b611ff383611fbe565b612007611fff82611fe0565b848454611f6c565b825550505050565b600090565b61201c61200f565b612027818484611fea565b505050565b5b8181101561204b57612040600082612014565b60018101905061202d565b5050565b601f8211156120905761206181611f3a565b61206a84611f4f565b81016020851015612079578190505b61208d61208585611f4f565b83018261202c565b50505b505050565b600082821c905092915050565b60006120b360001984600802612095565b1980831691505092915050565b60006120cc83836120a2565b9150826002028217905092915050565b6120e58261133f565b67ffffffffffffffff8111156120fe576120fd61193a565b5b6121088254611b6e565b61211382828561204f565b600060209050601f8311600181146121465760008415612134578287015190505b61213e85826120c0565b8655506121a6565b601f19841661215486611f3a565b60005b8281101561217c57848901518255600182019150602085019450602081019050612157565b868310156121995784890151612195601f8916826120a2565b8355505b6001600288020188555050505b505050505050565b7f5061727469636970616e7420616c726561647920616464656400000000000000600082015250565b60006121e460198361134a565b91506121ef826121ae565b602082019050919050565b60006020820190508181036000830152612213816121d7565b9050919050565b600060408201905061222f6000830185611315565b61223c6020830184611315565b9392505050565b6000602082019050818103600083015261225d8184611396565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fdfea264697066735822122087ab8cfd2e1e9ba1ed55b0da55cc464b034dcc54f96846454518ad734549a25f64736f6c63430008170033";
var isSuperArgs4 = (xs) => xs.length > 1;
var EvaluationPlatform__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs4(args)) {
      super(...args);
    } else {
      super(_abi8, _bytecode4, args[0]);
    }
  }
  getDeployTransaction(_semaphore, overrides) {
    return super.getDeployTransaction(_semaphore, overrides || {});
  }
  deploy(_semaphore, overrides) {
    return super.deploy(_semaphore, overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode4;
  }
  static {
    this.abi = _abi8;
  }
  static createInterface() {
    return new Interface(_abi8);
  }
  static connect(address, runner) {
    return new Contract(address, _abi8, runner);
  }
};

// ../contracts/typechain-types/factories/contracts/Feedback__factory.ts
var _abi9 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "semaphoreAddress",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "groupId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "joinGroup",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "semaphore",
    outputs: [
      {
        internalType: "contract ISemaphore",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "nullifier",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feedback",
        type: "uint256"
      },
      {
        internalType: "uint256[8]",
        name: "points",
        type: "uint256[8]"
      }
    ],
    name: "sendFeedback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var _bytecode5 = "0x608060405234801561001057600080fd5b5060405161081238038061081283398181016040528101906100329190610172565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663575185ed6040518163ffffffff1660e01b81526004016020604051808303816000875af11580156100df573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061010391906101d5565b60018190555050610202565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061013f82610114565b9050919050565b61014f81610134565b811461015a57600080fd5b50565b60008151905061016c81610146565b92915050565b6000602082840312156101885761018761010f565b5b60006101968482850161015d565b91505092915050565b6000819050919050565b6101b28161019f565b81146101bd57600080fd5b50565b6000815190506101cf816101a9565b92915050565b6000602082840312156101eb576101ea61010f565b5b60006101f9848285016101c0565b91505092915050565b610601806102116000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80637b5d2534146100515780637b85d27a1461006f578063a0f44c921461008b578063eed02e4b146100a9575b600080fd5b6100596100c5565b6040516100669190610301565b60405180910390f35b6100896004803603810190610084919061037e565b6100e9565b005b6100936101ea565b6040516100a09190610409565b60405180910390f35b6100c360048036038101906100be9190610424565b6101f0565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006040518060c001604052808781526020018681526020018581526020018481526020016001548152602001836008806020026040519081016040528092919082600860200280828437600081840152601f19601f820116905080830192505050505050815250905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0d898dd600154836040518363ffffffff1660e01b81526004016101b0929190610578565b600060405180830381600087803b1580156101ca57600080fd5b505af11580156101de573d6000803e3d6000fd5b50505050505050505050565b60015481565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631783efc3600154836040518363ffffffff1660e01b815260040161024d9291906105a2565b600060405180830381600087803b15801561026757600080fd5b505af115801561027b573d6000803e3d6000fd5b5050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006102c76102c26102bd84610282565b6102a2565b610282565b9050919050565b60006102d9826102ac565b9050919050565b60006102eb826102ce565b9050919050565b6102fb816102e0565b82525050565b600060208201905061031660008301846102f2565b92915050565b600080fd5b6000819050919050565b61033481610321565b811461033f57600080fd5b50565b6000813590506103518161032b565b92915050565b600080fd5b60008190508260206008028201111561037857610377610357565b5b92915050565b6000806000806000610180868803121561039b5761039a61031c565b5b60006103a988828901610342565b95505060206103ba88828901610342565b94505060406103cb88828901610342565b93505060606103dc88828901610342565b92505060806103ed8882890161035c565b9150509295509295909350565b61040381610321565b82525050565b600060208201905061041e60008301846103fa565b92915050565b60006020828403121561043a5761043961031c565b5b600061044884828501610342565b91505092915050565b61045a81610321565b82525050565b600060089050919050565b600081905092915050565b6000819050919050565b600061048c8383610451565b60208301905092915050565b6000602082019050919050565b6104ae81610460565b6104b8818461046b565b92506104c382610476565b8060005b838110156104f45781516104db8782610480565b96506104e683610498565b9250506001810190506104c7565b505050505050565b6101a0820160008201516105136000850182610451565b5060208201516105266020850182610451565b5060408201516105396040850182610451565b50606082015161054c6060850182610451565b50608082015161055f6080850182610451565b5060a082015161057260a08501826104a5565b50505050565b60006101c08201905061058e60008301856103fa565b61059b60208301846104fc565b9392505050565b60006040820190506105b760008301856103fa565b6105c460208301846103fa565b939250505056fea2646970667358221220699891167c8c174371c9c3d85f92ba25b22a3b8bb3fa73dc2a4a4107ba9bb51064736f6c63430008170033";
var isSuperArgs5 = (xs) => xs.length > 1;
var Feedback__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs5(args)) {
      super(...args);
    } else {
      super(_abi9, _bytecode5, args[0]);
    }
  }
  getDeployTransaction(semaphoreAddress, overrides) {
    return super.getDeployTransaction(semaphoreAddress, overrides || {});
  }
  deploy(semaphoreAddress, overrides) {
    return super.deploy(semaphoreAddress, overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode5;
  }
  static {
    this.abi = _abi9;
  }
  static createInterface() {
    return new Interface(_abi9);
  }
  static connect(address, runner) {
    return new Contract(address, _abi9, runner);
  }
};

// ../contracts/typechain-types/factories/poseidon-solidity/PoseidonT3__factory.ts
var _abi10 = [
  {
    inputs: [
      {
        internalType: "uint256[2]",
        name: "",
        type: "uint256[2]"
      }
    ],
    name: "hash",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "pure",
    type: "function"
  }
];
var _bytecode6 = "0x615dc862000054600b82828239805160001a607314610047577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c8063561558fe1461003a575b600080fd5b610054600480360381019061004f9190615d3b565b61006a565b6040516100619190615d77565b60405180910390f35b60007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d7f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa7f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e07ef1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e8648460805106017f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f58560a05106018582830986838883840909925086828309905086828883840909915086868309877f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085097f2229fe5e63f56eef4bfba02c26292de10ac2b2b045e6184acff16e4660c05f6b01017f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d001905086858309877f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385097f2949435275a29cdbffe3e4101a45669873f9408a5d11e21b4ec6edf8501eee4d01017f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf20187858409887f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291186097f20c290a7269657965092ef5700a447f5bc2c41dfca932f527cb2600ac9bcfefb01017f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa018883840989848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb78019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc63201945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d428019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f6019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c01915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de559019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f6019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be828019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa6019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d09019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea565019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017e5032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b5019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d60280019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec0019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c460019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f8448019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c88701915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c8019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf1019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da5301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017e81c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a735206019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c91019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c0750019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a70092393311019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da9019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c4565529019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c50201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b54019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd804019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd649019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017eef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff1019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d3019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba8901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af1019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f100019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c2967019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e401915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b02019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b646019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc6019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da4019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea0654626019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b3758019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f2019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003501945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b147019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac2019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6901945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d1019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c785019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7701945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a67019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c71727019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017e2e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d2019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017eb9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c351201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017e248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda9019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a80801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae1019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e64973019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f0901945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af38019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828401915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee466019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c8225145086019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c3019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb6019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e7019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c98591019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d40019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d4019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e50423301945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b168873019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc001915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f9326478875019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f019019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d5901915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a8019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f8894801945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d14201915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f23019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c001945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b5019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a5801915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f2019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d0101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b1019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb2019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc79201945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e36860019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea611101915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c711019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa33601945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf1860019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d601915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45101945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c556019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f70019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf7701915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc63001945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd78019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc01915089848509905089848b838409099350898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d60019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f01945089818209935089818b868709099050898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a4019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f1019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc01915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf08019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb24100019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c232001945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898986098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e088098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b840901017f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad870019350898886098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2388098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771840901017f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba019250898786098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291188098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7840901017f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f801915089848509905089848b83840909935089838409905089838b83840909925089828309905089828b838409099150898983098a7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e085098b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b870901017f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab1019050898883098a7f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2385098b7f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771870901017f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d22019550898783098a7f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee291185098b7f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7870901017f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516101945089818209935089818b86870909905089868709935089868b86870909955089858609935089858b868709099450898a8a87098b7f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e089098c7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b850901010660005260206000f35b6000604051905090565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b615c0c82615bc3565b810181811067ffffffffffffffff82111715615c2b57615c2a615bd4565b5b80604052505050565b6000615c3e615baf565b9050615c4a8282615c03565b919050565b600067ffffffffffffffff821115615c6a57615c69615bd4565b5b602082029050919050565b600080fd5b6000819050919050565b615c8d81615c7a565b8114615c9857600080fd5b50565b600081359050615caa81615c84565b92915050565b6000615cc3615cbe84615c4f565b615c34565b90508060208402830185811115615cdd57615cdc615c75565b5b835b81811015615d065780615cf28882615c9b565b845260208401935050602081019050615cdf565b5050509392505050565b600082601f830112615d2557615d24615bbe565b5b6002615d32848285615cb0565b91505092915050565b600060408284031215615d5157615d50615bb9565b5b6000615d5f84828501615d10565b91505092915050565b615d7181615c7a565b82525050565b6000602082019050615d8c6000830184615d68565b9291505056fea2646970667358221220677136c9d0708daecd30873a192ec7cbd5b7c67c63053cf059d415c628d6c13664736f6c63430008170033";
var isSuperArgs6 = (xs) => xs.length > 1;
var PoseidonT3__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs6(args)) {
      super(...args);
    } else {
      super(_abi10, _bytecode6, args[0]);
    }
  }
  getDeployTransaction(overrides) {
    return super.getDeployTransaction(overrides || {});
  }
  deploy(overrides) {
    return super.deploy(overrides || {});
  }
  connect(runner) {
    return super.connect(runner);
  }
  static {
    this.bytecode = _bytecode6;
  }
  static {
    this.abi = _abi10;
  }
  static createInterface() {
    return new Interface(_abi10);
  }
  static connect(address, runner) {
    return new Contract(address, _abi10, runner);
  }
};

// ../contracts/deployed_addresses.json
var EVALUATION_CONTRACT_ADDRESS = "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9";
var SEMAPHORE_CONTRACT_ADDRESS = "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0";

// ../contracts/clients/ethers/evaluation.ts
var evaluationContractPlatform = {
  getRpcContract: () => {
    const rpcProvider = new ethers_exports.JsonRpcProvider("http://localhost:8545");
    const ethereumPrivateKey = "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d";
    const wallet = new ethers_exports.Wallet(ethereumPrivateKey, rpcProvider);
    const rpcContract = EvaluationPlatform__factory.connect(
      EVALUATION_CONTRACT_ADDRESS,
      wallet
    );
    return {
      rpcContract,
      rpcProvider
    };
  },
  getBrowserContract: () => {
    if (!window?.ethereum) {
      throw new Error("No ethereum provider found");
    }
    const browserProvider = new ethers_exports.BrowserProvider(window?.ethereum);
    const browserContract = EvaluationPlatform__factory.connect(
      EVALUATION_CONTRACT_ADDRESS,
      browserProvider
    );
    return {
      browserContract,
      browserProvider
    };
  }
};

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js
var import_buffer2 = require("buffer");

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js
var import_buffer = require("buffer");
var supportedTypes = [
  "number",
  "string",
  "function",
  "Array",
  "Uint8Array",
  "Buffer",
  "object",
  "bigint",
  "stringified-bigint",
  "hexadecimal",
  "bignumber",
  "bignumberish"
];
function isDefined(value) {
  return typeof value !== "undefined";
}
function isNumber(value) {
  return typeof value === "number";
}
function isString(value) {
  return typeof value === "string";
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object";
}
function isArray(value) {
  return isObject(value) && Array.isArray(value);
}
function isUint8Array(value) {
  return value instanceof Uint8Array;
}
function isBuffer(value) {
  return import_buffer.Buffer.isBuffer(value);
}
function isBigInt(value) {
  return typeof value === "bigint";
}
function isStringifiedBigInt(value) {
  if (!isString(value)) {
    return false;
  }
  try {
    BigInt(value);
    return true;
  } catch {
    return false;
  }
}
function isHexadecimal(value, prefix = true) {
  if (!isString(value)) {
    return false;
  }
  if (prefix) {
    return /^(0x|0X)[0-9a-fA-F]+$/.test(value);
  }
  return /^[0-9a-fA-F]+$/.test(value);
}
function isBigNumber(value) {
  return isBigInt(value) || isStringifiedBigInt(value);
}
function isBigNumberish(value) {
  return isNumber(value) || isBigInt(value) || isStringifiedBigInt(value) || isHexadecimal(value) || isBuffer(value) || isUint8Array(value);
}
function isType(value, type) {
  switch (type) {
    case "number":
      return isNumber(value);
    case "string":
      return isString(value);
    case "function":
      return isFunction(value);
    case "Array":
      return isArray(value);
    case "Uint8Array":
      return isUint8Array(value);
    case "Buffer":
      return isBuffer(value);
    case "object":
      return isObject(value);
    case "bigint":
      return isBigInt(value);
    case "stringified-bigint":
      return isStringifiedBigInt(value);
    case "hexadecimal":
      return isHexadecimal(value);
    case "bignumber":
      return isBigNumber(value);
    case "bignumberish":
      return isBigNumberish(value);
    default:
      return false;
  }
}
function isSupportedType(type) {
  return supportedTypes.includes(type);
}

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js
function requireDefined(parameterValue, parameterName) {
  if (!isDefined(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not defined`);
  }
}
function requireNumber(parameterValue, parameterName) {
  if (!isNumber(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);
  }
}
function requireString(parameterValue, parameterName) {
  if (!isString(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);
  }
}
function requireFunction(parameterValue, parameterName) {
  if (!isFunction(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);
  }
}
function requireArray(parameterValue, parameterName) {
  if (!isArray(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);
  }
}
function requireObject(parameterValue, parameterName) {
  if (!isObject(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);
  }
}
function requireBigInt(parameterValue, parameterName) {
  if (!isBigInt(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);
  }
}
function requireBigNumberish(parameterValue, parameterName) {
  if (!isBigNumberish(parameterValue)) {
    throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);
  }
}
function requireTypes(parameterValue, parameterName, types) {
  for (const type of types) {
    if (!isSupportedType(type)) {
      throw new Error(`Type '${type}' is not supported`);
    }
  }
  for (const type of types) {
    if (isType(parameterValue, type)) {
      return;
    }
  }
  throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(", ")}`);
}

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js
function bigIntToHexadecimal(value) {
  requireBigInt(value, "value");
  let hex2 = value.toString(16);
  if (hex2.length % 2 !== 0) {
    hex2 = `0${hex2}`;
  }
  return hex2;
}
function beBufferToBigInt(value) {
  requireTypes(value, "value", ["Buffer", "Uint8Array"]);
  return BigInt(`0x${import_buffer2.Buffer.from(value).toString("hex")}`);
}
function leBufferToBigInt(value) {
  requireTypes(value, "value", ["Buffer", "Uint8Array"]);
  return BigInt(`0x${import_buffer2.Buffer.from(value).reverse().toString("hex")}`);
}
function bufferToBigInt(value) {
  return beBufferToBigInt(value);
}
function leBigIntToBuffer(value, size) {
  const hex2 = bigIntToHexadecimal(value);
  const minSize = Math.ceil(hex2.length / 2);
  if (!size) {
    size = minSize;
  } else if (size < minSize) {
    throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);
  }
  const buffer = import_buffer2.Buffer.alloc(size, 0);
  const fromHex = import_buffer2.Buffer.from(hex2, "hex").reverse();
  fromHex.copy(buffer, 0);
  return buffer;
}
function bigNumberishToBigInt(value) {
  requireBigNumberish(value, "value");
  if (isBuffer(value) || isUint8Array(value)) {
    return bufferToBigInt(value);
  }
  return BigInt(value);
}
function bufferToBase64(value) {
  requireTypes(value, "value", ["Buffer", "Uint8Array"]);
  return import_buffer2.Buffer.from(value).toString("base64");
}
function base64ToBuffer(value) {
  requireString(value, "value");
  return import_buffer2.Buffer.from(value, "base64");
}
function textToBase64(value) {
  requireString(value, "value");
  return import_buffer2.Buffer.from(value, "utf8").toString("base64");
}

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js
function isZero(a2) {
  return !a2;
}
function isOdd(a2) {
  return (a2 & BigInt(1)) === BigInt(1);
}
function shiftRight(a2, n3) {
  return a2 >> n3;
}
function mul(a2, b3) {
  return a2 * b3;
}
function bits(n3) {
  const res = [];
  let E = n3;
  while (E) {
    if (E & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E >>= BigInt(1);
  }
  return res;
}

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js
var F1Field = class {
  constructor(order2) {
    this.one = 1n;
    this.zero = 0n;
    this._order = order2;
    this._half = order2 >> this.one;
    this._negone = this._order - this.one;
  }
  /**
   * Ensures a given result falls within the field by applying modular reduction.
   * This method also handles negative inputs, correctly mapping them into the field.
   * @param res The result to be normalized to the field.
   * @returns The equivalent value within the field.
   */
  e(res) {
    res %= this._order;
    return res < 0 ? res + this._order : res;
  }
  /**
   * Performs modular multiplication of two bigint values within the field.
   * @param a The first value.
   * @param b The second value.
   * @returns The product of 'a' and 'b' modulo the field's order.
   */
  mul(a2, b3) {
    return a2 * b3 % this._order;
  }
  /**
   * Subtracts one bigint from another under modulus.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The value from which to subtract.
   * @param b The value to be subtracted.
   * @returns The difference of 'a' and 'b' modulo the field's order.
   */
  sub(a2, b3) {
    return a2 >= b3 ? a2 - b3 : this._order - b3 + a2;
  }
  /**
   * Adds two bigint values together under modulus.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The first value.
   * @param b The second value.
   * @returns The sum of 'a' and 'b' modulo the field's order.
   */
  add(a2, b3) {
    const res = a2 + b3;
    return res >= this._order ? res - this._order : res;
  }
  /**
   * Computes the multiplicative inverse of a given value within the field.
   * This method uses the Extended Euclidean Algorithm to find the inverse,
   * ensuring the result is always a positive value less than the field's order.
   * If the input value is zero, which has no inverse, an error is thrown.
   * @param a The value for which to compute the inverse.
   * @returns The multiplicative inverse of 'a' modulo the field's order.
   * @throws if 'a' is zero.
   */
  inv(a2) {
    if (a2 === this.zero) {
      throw new Error("Zero has no inverse");
    }
    let t = this.zero;
    let r2 = this._order;
    let newt = this.one;
    let newr = a2 % this._order;
    while (newr) {
      const q = r2 / newr;
      [t, newt] = [newt, t - q * newt];
      [r2, newr] = [newr, r2 - q * newr];
    }
    if (t < this.zero) {
      t += this._order;
    }
    return t;
  }
  /**
   * Divides one bigint by another within the field by multiplying the first value
   * by the multiplicative inverse of the second.
   * @param a The dividend.
   * @param b The divisor.
   * @returns The result of the division of 'a' by 'b' modulo the field's order.
   */
  div(a2, b3) {
    return this.mul(a2, this.inv(b3));
  }
  /**
   * Checks if two bigint values are equal within the context of the field.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The first value to compare.
   * @param b The second value to compare.
   * @returns True if 'a' equals 'b', false otherwise.
   */
  eq(a2, b3) {
    return a2 === b3;
  }
  /**
   * Squares a bigint value within the field.
   * This is a specific case of multiplication where the value is multiplied by itself,
   * optimized for performance where applicable.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The value to square.
   * @returns The square of 'a' modulo the field's order.
   */
  square(a2) {
    return a2 * a2 % this._order;
  }
  /**
   * Compares two bigint values to determine if the first is less than the second,
   * taking into account the field's order for modular comparison.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The first value to compare.
   * @param b The second value to compare.
   * @returns True if 'a' is less than 'b', false otherwise.
   */
  lt(a2, b3) {
    const aa = a2 > this._half ? a2 - this._order : a2;
    const bb = b3 > this._half ? b3 - this._order : b3;
    return aa < bb;
  }
  /**
   * Compares two bigint values to determine if the first is greater than or equal to the second,
   * considering the field's modular context.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The first value to compare.
   * @param b The second value to compare.
   * @returns True if 'a' is greater than or equal to 'b', false otherwise.
   */
  geq(a2, b3) {
    const aa = a2 > this._half ? a2 - this._order : a2;
    const bb = b3 > this._half ? b3 - this._order : b3;
    return aa >= bb;
  }
  /**
   * Computes the negation of a bigint value within the field.
   * The result is the modular additive inverse that, when added to the original value,
   * yields zero in the field's modulus.
   * It ensures the result is within the field if and only if the input values are within the field.
   * @param a The value to negate.
   * @returns The negation of 'a' modulo the field's order.
   */
  neg(a2) {
    return a2 ? this._order - a2 : a2;
  }
  /**
   * Checks if a bigint value is zero within the context of the field.
   * @param a The value to check.
   * @returns True if 'a' is zero, false otherwise.
   */
  isZero(a2) {
    return a2 === this.zero;
  }
  /**
   * Raises a base to an exponent within the field, efficiently computing
   * scalar exponentiation using the square-and-multiply algorithm.
   * Supports both positive and negative exponents through the use of the `inv` method for negatives.
   * @param base The base to be exponentiated.
   * @param e The exponent.
   * @returns The result of raising 'base' to the power 'e' modulo the field's order.
   */
  pow(base, e2) {
    if (isZero(e2)) {
      return this.one;
    }
    if (e2 < 0n) {
      base = this.inv(base);
      e2 = -e2;
    }
    const n3 = bits(e2);
    if (n3.length === 0) {
      return this.one;
    }
    let res = base;
    for (let i = n3.length - 2; i >= 0; i -= 1) {
      res = this.square(res);
      if (n3[i]) {
        res = this.mul(res, base);
      }
    }
    return res;
  }
};

// ../../node_modules/.pnpm/@zk-kit+baby-jubjub@1.0.3/node_modules/@zk-kit/baby-jubjub/dist/index.js
var r = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var Fr = new F1Field(r);
var Base8 = [
  Fr.e(BigInt("5299619240641551281634865583518297030282874472190772894086521144482721001553")),
  Fr.e(BigInt("16950150798460657717958625567821834550301663161624707787222815936182638968203"))
];
var a = Fr.e(BigInt("168700"));
var d = Fr.e(BigInt("168696"));
var order = BigInt("21888242871839275222246405745257275088614511777268538073601725287587578984328");
var subOrder = shiftRight(order, BigInt(3));
function addPoint(p1, p2) {
  const beta = Fr.mul(p1[0], p2[1]);
  const gamma = Fr.mul(p1[1], p2[0]);
  const delta = Fr.mul(Fr.sub(p1[1], Fr.mul(a, p1[0])), Fr.add(p2[0], p2[1]));
  const tau = Fr.mul(beta, gamma);
  const dtau = Fr.mul(d, tau);
  const p3x = Fr.div(Fr.add(beta, gamma), Fr.add(Fr.one, dtau));
  const p3y = Fr.div(Fr.add(delta, Fr.sub(Fr.mul(a, beta), gamma)), Fr.sub(Fr.one, dtau));
  return [p3x, p3y];
}
function mulPointEscalar(base, e2) {
  let res = [Fr.e(BigInt(0)), Fr.e(BigInt(1))];
  let rem = e2;
  let exp3 = base;
  while (!isZero(rem)) {
    if (isOdd(rem)) {
      res = addPoint(res, exp3);
    }
    exp3 = addPoint(exp3, exp3);
    rem = shiftRight(rem, BigInt(1));
  }
  return res;
}
function inCurve(p) {
  const x1 = BigInt(p[0]);
  const y1 = BigInt(p[1]);
  const x2 = Fr.square(x1);
  const y2 = Fr.square(y1);
  return Fr.eq(Fr.add(Fr.mul(a, x2), y2), Fr.add(Fr.one, Fr.mul(Fr.mul(x2, y2), d)));
}
function packPoint(unpackedPoint) {
  const buffer = leBigIntToBuffer(unpackedPoint[1], 32);
  if (Fr.lt(unpackedPoint[0], Fr.zero)) {
    buffer[31] |= 128;
  }
  return leBufferToBigInt(buffer);
}

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/index.node.js
var import_crypto24 = require("crypto");
function getRandomValues(size) {
  if (size <= 0)
    throw Error(`size ${size} is too small, need at least 1`);
  const buffer = (0, import_crypto24.randomBytes)(size);
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
var crypto_node = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getRandomValues
});

// ../../node_modules/.pnpm/@zk-kit+eddsa-poseidon@1.0.4/node_modules/@zk-kit/eddsa-poseidon/dist/index.js
var import_buffer3 = require("buffer");
var import_poseidon5 = __toESM(require_poseidon5(), 1);
var zo = import_buffer3.Buffer.from([1]);
var oo = import_buffer3.Buffer.from([129]);
var sigma = [
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],
  [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],
  [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],
  [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],
  [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]
];
var u512 = [
  608135816,
  2242054355,
  320440878,
  57701188,
  2752067618,
  698298832,
  137296536,
  3964562569,
  1160258022,
  953160567,
  3193202383,
  887688300,
  3232508343,
  3380367581,
  1065670069,
  3041331479,
  2450970073,
  2306472731,
  3509652390,
  2564797868,
  805139163,
  3491422135,
  3101798381,
  1780907670,
  3128725573,
  4046225305,
  614570311,
  3012652279,
  134345442,
  2240740374,
  1667834072,
  1901547113
];
var padding2 = import_buffer3.Buffer.from([
  128,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function rot(v, i, j, n3) {
  let hi = v[i * 2] ^ v[j * 2];
  let lo = v[i * 2 + 1] ^ v[j * 2 + 1];
  if (n3 >= 32) {
    lo ^= hi;
    hi ^= lo;
    lo ^= hi;
    n3 -= 32;
  }
  if (n3 === 0) {
    v[i * 2] = hi >>> 0;
    v[i * 2 + 1] = lo >>> 0;
  } else {
    v[i * 2] = (hi >>> n3 | lo << 32 - n3) >>> 0;
    v[i * 2 + 1] = (lo >>> n3 | hi << 32 - n3) >>> 0;
  }
}
function g(v, m, i, a2, b3, c2, d2, e2) {
  let lo;
  lo = v[a2 * 2 + 1] + ((m[sigma[i][e2] * 2 + 1] ^ u512[sigma[i][e2 + 1] * 2 + 1]) >>> 0) + v[b3 * 2 + 1];
  v[a2 * 2] = v[a2 * 2] + ((m[sigma[i][e2] * 2] ^ u512[sigma[i][e2 + 1] * 2]) >>> 0) + v[b3 * 2] + ~~(lo / 4294967296) >>> 0;
  v[a2 * 2 + 1] = lo >>> 0;
  rot(v, d2, a2, 32);
  lo = v[c2 * 2 + 1] + v[d2 * 2 + 1];
  v[c2 * 2] = v[c2 * 2] + v[d2 * 2] + ~~(lo / 4294967296) >>> 0;
  v[c2 * 2 + 1] = lo >>> 0;
  rot(v, b3, c2, 25);
  lo = v[a2 * 2 + 1] + ((m[sigma[i][e2 + 1] * 2 + 1] ^ u512[sigma[i][e2] * 2 + 1]) >>> 0) + v[b3 * 2 + 1];
  v[a2 * 2] = v[a2 * 2] + ((m[sigma[i][e2 + 1] * 2] ^ u512[sigma[i][e2] * 2]) >>> 0) + v[b3 * 2] + ~~(lo / 4294967296) >>> 0;
  v[a2 * 2 + 1] = lo >>> 0;
  rot(v, d2, a2, 16);
  lo = v[c2 * 2 + 1] + v[d2 * 2 + 1];
  v[c2 * 2] = v[c2 * 2] + v[d2 * 2] + ~~(lo / 4294967296) >>> 0;
  v[c2 * 2 + 1] = lo >>> 0;
  rot(v, b3, c2, 11);
}
function lengthCarry(arr) {
  for (let j = 0; j < arr.length; j += 1) {
    if (arr[j] < 4294967296)
      break;
    arr[j] -= 4294967296;
    arr[j + 1] += 1;
  }
}
var Blake512 = class {
  /**
   * Initializes a new Blake-512 hash instance with the default parameters.
   */
  constructor() {
    this._h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this._s = [0, 0, 0, 0, 0, 0, 0, 0];
    this._block = import_buffer3.Buffer.alloc(128);
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._nullt = false;
    this._zo = zo;
    this._oo = oo;
  }
  /**
   * The core compression function for Blake-512. It transforms the internal
   * state based on the input block and the current hash parameters.
   */
  _compress() {
    const v = new Array(32);
    const m = new Array(32);
    let i;
    for (i = 0; i < 32; i += 1)
      m[i] = this._block.readUInt32BE(i * 4);
    for (i = 0; i < 16; i += 1)
      v[i] = this._h[i] >>> 0;
    for (i = 16; i < 24; i += 1)
      v[i] = (this._s[i - 16] ^ u512[i - 16]) >>> 0;
    for (i = 24; i < 32; i += 1)
      v[i] = u512[i - 16];
    if (!this._nullt) {
      v[24] = (v[24] ^ this._length[1]) >>> 0;
      v[25] = (v[25] ^ this._length[0]) >>> 0;
      v[26] = (v[26] ^ this._length[1]) >>> 0;
      v[27] = (v[27] ^ this._length[0]) >>> 0;
      v[28] = (v[28] ^ this._length[3]) >>> 0;
      v[29] = (v[29] ^ this._length[2]) >>> 0;
      v[30] = (v[30] ^ this._length[3]) >>> 0;
      v[31] = (v[31] ^ this._length[2]) >>> 0;
    }
    for (i = 0; i < 16; i += 1) {
      g(v, m, i, 0, 4, 8, 12, 0);
      g(v, m, i, 1, 5, 9, 13, 2);
      g(v, m, i, 2, 6, 10, 14, 4);
      g(v, m, i, 3, 7, 11, 15, 6);
      g(v, m, i, 0, 5, 10, 15, 8);
      g(v, m, i, 1, 6, 11, 12, 10);
      g(v, m, i, 2, 7, 8, 13, 12);
      g(v, m, i, 3, 4, 9, 14, 14);
    }
    for (i = 0; i < 16; i += 1) {
      this._h[i % 8 * 2] = (this._h[i % 8 * 2] ^ v[i * 2]) >>> 0;
      this._h[i % 8 * 2 + 1] = (this._h[i % 8 * 2 + 1] ^ v[i * 2 + 1]) >>> 0;
    }
    for (i = 0; i < 8; i += 1) {
      this._h[i * 2] = (this._h[i * 2] ^ this._s[i % 4 * 2]) >>> 0;
      this._h[i * 2 + 1] = (this._h[i * 2 + 1] ^ this._s[i % 4 * 2 + 1]) >>> 0;
    }
  }
  /**
   * Adds padding to the message as per the Blake-512 specification, ensuring
   * the message length is a multiple of the block size.
   */
  _padding() {
    const len = this._length.slice();
    len[0] += this._blockOffset * 8;
    lengthCarry(len);
    const msglen = import_buffer3.Buffer.alloc(16);
    for (let i = 0; i < 4; i += 1)
      msglen.writeUInt32BE(len[3 - i], i * 4);
    if (this._blockOffset === 111) {
      this._length[0] -= 8;
      this.update(this._oo);
    } else {
      if (this._blockOffset < 111) {
        if (this._blockOffset === 0)
          this._nullt = true;
        this._length[0] -= (111 - this._blockOffset) * 8;
        this.update(padding2.subarray(0, 111 - this._blockOffset));
      } else {
        this._length[0] -= (128 - this._blockOffset) * 8;
        this.update(padding2.subarray(0, 128 - this._blockOffset));
        this._length[0] -= 111 * 8;
        this.update(padding2.subarray(1, 1 + 111));
        this._nullt = true;
      }
      this.update(this._zo);
      this._length[0] -= 8;
    }
    this._length[0] -= 128;
    this.update(msglen);
  }
  /**
   * Completes the hash computation and returns the final hash value.
   * This method applies the necessary padding, performs the final compression,
   * and returns the hash output.
   * @returns The Blake-512 hash of the input data.
   */
  digest() {
    this._padding();
    const buffer = import_buffer3.Buffer.alloc(64);
    for (let i = 0; i < 16; i += 1)
      buffer.writeUInt32BE(this._h[i], i * 4);
    return buffer;
  }
  /**
   * Updates the hash with new data. This method can be called multiple
   * times to incrementally add data to the hash computation.
   * @param data The data to add to the hash.
   * @returns This instance, to allow method chaining.
   */
  update(data4) {
    const block = this._block;
    let offset = 0;
    while (this._blockOffset + data4.length - offset >= block.length) {
      for (let i = this._blockOffset; i < block.length; )
        block[i++] = data4[offset++];
      this._length[0] += block.length * 8;
      lengthCarry(this._length);
      this._compress();
      this._blockOffset = 0;
    }
    while (offset < data4.length)
      block[this._blockOffset++] = data4[offset++];
    return this;
  }
};
function pruneBuffer(buff) {
  buff[0] &= 248;
  buff[31] &= 127;
  buff[31] |= 64;
  return buff;
}
function isPoint(point) {
  return isArray(point) && point.length === 2 && isBigNumber(point[0]) && isBigNumber(point[1]);
}
function isSignature(signature) {
  return isObject(signature) && Object.prototype.hasOwnProperty.call(signature, "R8") && Object.prototype.hasOwnProperty.call(signature, "S") && isPoint(signature.R8) && isBigNumber(signature.S);
}
function checkPrivateKey(privateKey) {
  requireTypes(privateKey, "privateKey", ["Buffer", "Uint8Array", "string"]);
  return import_buffer3.Buffer.from(privateKey);
}
function checkMessage(message) {
  requireTypes(message, "message", ["bignumberish", "string"]);
  if (isBigNumberish(message)) {
    return bigNumberishToBigInt(message);
  }
  return bufferToBigInt(import_buffer3.Buffer.from(message));
}
function hash2(message) {
  const engine = new Blake512();
  engine.update(import_buffer3.Buffer.from(message));
  return engine.digest();
}
function deriveSecretScalar(privateKey) {
  privateKey = checkPrivateKey(privateKey);
  let hash$1 = hash2(privateKey);
  hash$1 = hash$1.slice(0, 32);
  hash$1 = pruneBuffer(hash$1);
  return shiftRight(leBufferToBigInt(hash$1), BigInt(3)) % subOrder;
}
function derivePublicKey(privateKey) {
  const s2 = deriveSecretScalar(privateKey);
  return mulPointEscalar(Base8, s2);
}
function signMessage(privateKey, message) {
  privateKey = checkPrivateKey(privateKey);
  message = checkMessage(message);
  const hash$1 = hash2(privateKey);
  const sBuff = pruneBuffer(hash$1.slice(0, 32));
  const s2 = leBufferToBigInt(sBuff);
  const A = mulPointEscalar(Base8, shiftRight(s2, BigInt(3)));
  const msgBuff = leBigIntToBuffer(message, 32);
  const rBuff = hash2(import_buffer3.Buffer.concat([hash$1.slice(32, 64), msgBuff]));
  const Fr2 = new F1Field(subOrder);
  const r2 = Fr2.e(leBufferToBigInt(rBuff));
  const R8 = mulPointEscalar(Base8, r2);
  const hm = (0, import_poseidon5.poseidon5)([R8[0], R8[1], A[0], A[1], message]);
  const S2 = Fr2.add(r2, Fr2.mul(hm, s2));
  return { R8, S: S2 };
}
function verifySignature(message, signature, publicKey) {
  if (!isPoint(publicKey) || !isSignature(signature) || !inCurve(signature.R8) || !inCurve(publicKey) || BigInt(signature.S) >= subOrder) {
    return false;
  }
  message = checkMessage(message);
  const _signature = {
    R8: [BigInt(signature.R8[0]), BigInt(signature.R8[1])],
    S: BigInt(signature.S)
  };
  const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];
  const hm = (0, import_poseidon5.poseidon5)([signature.R8[0], signature.R8[1], publicKey[0], publicKey[1], message]);
  const pLeft = mulPointEscalar(Base8, BigInt(signature.S));
  let pRight = mulPointEscalar(_publicKey, mul(hm, BigInt(8)));
  pRight = addPoint(_signature.R8, pRight);
  return Fr.eq(pLeft[0], pRight[0]) && Fr.eq(pLeft[1], pRight[1]);
}
function packPublicKey(publicKey) {
  if (!isPoint(publicKey) || !inCurve(publicKey)) {
    throw new Error("Invalid public key");
  }
  const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];
  return packPoint(_publicKey);
}
var EdDSAPoseidon = class {
  /**
   * Initializes a new instance, deriving necessary cryptographic parameters from the provided private key.
   * If the private key is not passed as a parameter, a random 32-byte hexadecimal key is generated.
   *
   * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to
   * generate entropy and there is no limit in size.
   * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.
   * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.
   * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.
   *
   * @param privateKey The private key used for signing and public key derivation.
   */
  constructor(privateKey = crypto_node.getRandomValues(32)) {
    this.privateKey = privateKey;
    this.secretScalar = deriveSecretScalar(privateKey);
    this.publicKey = derivePublicKey(privateKey);
    this.packedPublicKey = packPublicKey(this.publicKey);
  }
  /**
   * Signs a given message using the private key and returns the signature.
   * @param message The message to be signed.
   * @returns The signature of the message.
   */
  signMessage(message) {
    return signMessage(this.privateKey, message);
  }
  /**
   * Verifies a signature against a message and the public key stored in this instance.
   * @param message The message whose signature is to be verified.
   * @param signature The signature to be verified.
   * @returns True if the signature is valid for the message and public key, false otherwise.
   */
  verifySignature(message, signature) {
    return verifySignature(message, signature, this.publicKey);
  }
};

// ../../node_modules/.pnpm/@semaphore-protocol+identity@4.7.0/node_modules/@semaphore-protocol/identity/dist/index.js
var import_poseidon2 = __toESM(require_poseidon2(), 1);
var Identity = class _Identity {
  /**
   * Initializes the class attributes based on a given private key, which must be text or a buffer.
   * If the private key is not passed as a parameter, a random private key will be generated.
   * The EdDSAPoseidon class is used to generate the secret scalar and the public key.
   * Additionally, the constructor computes a commitment of the public key using a hash function (Poseidon).
   *
   * @example
   * // Generates an identity.
   * const { privateKey, publicKey, commitment } = new Identity("private-key")
   * @example
   * // Generates an identity with a random private key.
   * const { privateKey, publicKey, commitment } = new Identity()
   *
   * @param privateKey The private key used to derive the public key (hexadecimal or string).
   */
  constructor(privateKey) {
    const eddsa = new EdDSAPoseidon(privateKey);
    this._privateKey = eddsa.privateKey;
    this._secretScalar = eddsa.secretScalar;
    this._publicKey = eddsa.publicKey;
    this._commitment = (0, import_poseidon2.poseidon2)(this._publicKey);
  }
  /**
   * Returns the private key.
   * @returns The private key as a buffer or text.
   */
  get privateKey() {
    return this._privateKey;
  }
  /**
   * Returns the secret scalar.
   * @returns The secret scalar as a string.
   */
  get secretScalar() {
    return this._secretScalar;
  }
  /**
   * Returns the public key as a Baby Jubjub {@link https://zkkit.pse.dev/types/_zk_kit_baby_jubjub.Point.html | Point}.
   * @returns The public key as a point.
   */
  get publicKey() {
    return this._publicKey;
  }
  /**
   * Returns the commitment hash of the public key.
   * @returns The commitment as a string.
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * Returns the private key encoded as a base64 string.
   * @returns The private key as a base64 string.
   */
  export() {
    if (isString(this._privateKey)) {
      return textToBase64(this._privateKey);
    }
    return bufferToBase64(this.privateKey);
  }
  /**
   * Returns a Semaphore identity based on a private key encoded as a base64 string.
   * The private key will be converted to a buffer, regardless of its original type.
   * @param privateKey The private key as a base64 string.
   * @returns The Semaphore identity.
   */
  static import(privateKey) {
    return new _Identity(base64ToBuffer(privateKey));
  }
  /**
   * Generates a signature for a given message using the private key.
   * This method demonstrates how to sign a message and could be used
   * for authentication or data integrity.
   *
   * @example
   * const identity = new Identity()
   * const signature = identity.signMessage("message")
   *
   * @param message The message to be signed.
   * @returns A {@link https://zkkit.pse.dev/types/_zk_kit_eddsa_poseidon.Signature.html | Signature} object containing the signature components.
   */
  signMessage(message) {
    return signMessage(this.privateKey, message);
  }
  /**
   * Verifies a signature against a given message and public key.
   * This static method allows for the verification of signatures without needing
   * an instance of the Identity class. It's useful for cases where you only have
   * the public key, the message and a signature, and need to verify if they match.
   *
   * @example
   * const identity = new Identity()
   * const signature = identity.signMessage("message")
   * Identity.verifySignature("message", signature, identity.publicKey)
   *
   * @param message The message that was signed.
   * @param signature The signature to verify.
   * @param publicKey The public key to use for verification.
   * @returns A boolean indicating whether the signature is valid.
   */
  static verifySignature(message, signature, publicKey) {
    return verifySignature(message, signature, publicKey);
  }
  /**
   * Generates the commitment from the given public key.
   * This static method is particularly useful after signature verification,
   * as it allows retrieval of the corresponding commitment associated with the public key.
   *
   * @example
   * const identity = new Identity()
   * Identity.generateCommitment(identity.publicKey)
   *
   * @param publicKey The public key to generate the commitment.
   * @returns The Semaphore identity commitment.
   */
  static generateCommitment(publicKey) {
    return (0, import_poseidon2.poseidon2)(publicKey);
  }
};

// ../../node_modules/.pnpm/@zk-kit+lean-imt@2.2.1/node_modules/@zk-kit/lean-imt/dist/index.js
var LeanIMT = class _LeanIMT {
  /**
   * It initializes the tree with a given hash function and an optional list of leaves.
   * @param hash The hash function used to create nodes.
   * @param leaves The list of leaves.
   */
  constructor(hash4, leaves = []) {
    requireDefined(hash4, "hash");
    requireFunction(hash4, "hash");
    requireArray(leaves, "leaves");
    this._nodes = [[]];
    this._hash = hash4;
    if (leaves.length > 0) {
      this.insertMany(leaves);
    }
  }
  /**
   * The root of the tree. This value doesn't need to be stored as
   * it is always the first and unique element of the last level of the tree.
   * Its value can be retrieved in {@link LeanIMT#_nodes}.
   * @returns The root hash of the tree.
   */
  get root() {
    return this._nodes[this.depth][0];
  }
  /**
   * The depth of the tree, which equals the number of levels - 1.
   * @returns The depth of the tree.
   */
  get depth() {
    return this._nodes.length - 1;
  }
  /**
   * The leaves of the tree. They can be retrieved from the first
   * level of the tree using {@link LeanIMT#_nodes}. The returned
   * value is a copy of the array and not the original object.
   * @returns The list of tree leaves.
   */
  get leaves() {
    return this._nodes[0].slice();
  }
  /**
   * The size of the tree, which the number of its leaves.
   * It's the length of the first level's list.
   * @returns The number of leaves of the tree.
   */
  get size() {
    return this._nodes[0].length;
  }
  /**
   * It returns the index of a leaf. If the leaf does not exist it returns -1.
   * @param leaf A leaf of the tree.
   * @returns The index of the leaf.
   */
  indexOf(leaf) {
    requireDefined(leaf, "leaf");
    return this._nodes[0].indexOf(leaf);
  }
  /**
   * It returns true if the leaf exists, and false otherwise
   * @param leaf A leaf of the tree.
   * @returns True if the tree has the leaf, and false otherwise.
   */
  has(leaf) {
    requireDefined(leaf, "leaf");
    return this._nodes[0].includes(leaf);
  }
  /**
   * The leaves are inserted incrementally. If 'i' is the index of the last
   * leaf, the new one will be inserted at position 'i + 1'. Every time a
   * new leaf is inserted, the nodes that separate the new leaf from the root
   * of the tree are created or updated if they already exist, from bottom to top.
   * When a node has only one child (the left one), its value takes on the value
   * of the child. Otherwise, the hash of the children is calculated.
   * @param leaf The new leaf to be inserted in the tree.
   */
  insert(leaf) {
    requireDefined(leaf, "leaf");
    if (this.depth < Math.ceil(Math.log2(this.size + 1))) {
      this._nodes.push([]);
    }
    let node = leaf;
    let index = this.size;
    for (let level = 0; level < this.depth; level += 1) {
      this._nodes[level][index] = node;
      if (index & 1) {
        const sibling = this._nodes[level][index - 1];
        node = this._hash(sibling, node);
      }
      index >>= 1;
    }
    this._nodes[this.depth] = [node];
  }
  /**
   * This function is useful when you want to insert N leaves all at once.
   * It is more efficient than using the {@link LeanIMT#insert} method N times because it
   * significantly reduces the number of cases where a node has only one
   * child, which is a common occurrence in gradual insertion.
   * @param leaves The list of leaves to be inserted.
   */
  insertMany(leaves) {
    requireDefined(leaves, "leaves");
    requireArray(leaves, "leaves");
    if (leaves.length === 0) {
      throw new Error("There are no leaves to add");
    }
    let startIndex = this.size >> 1;
    this._nodes[0].push(...leaves);
    const numberOfNewLevels = Math.ceil(Math.log2(this.size)) - this.depth;
    for (let i = 0; i < numberOfNewLevels; i += 1) {
      this._nodes.push([]);
    }
    for (let level = 0; level < this.depth; level += 1) {
      const numberOfNodes = Math.ceil(this._nodes[level].length / 2);
      for (let index = startIndex; index < numberOfNodes; index += 1) {
        const rightNode = this._nodes[level][index * 2 + 1];
        const leftNode = this._nodes[level][index * 2];
        const parentNode = rightNode ? this._hash(leftNode, rightNode) : leftNode;
        this._nodes[level + 1][index] = parentNode;
      }
      startIndex >>= 1;
    }
  }
  /**
   * It updates a leaf in the tree. It's very similar to the {@link LeanIMT#insert} function.
   * @param index The index of the leaf to be updated.
   * @param newLeaf The new leaf to be inserted.
   */
  update(index, newLeaf) {
    requireDefined(index, "index");
    requireDefined(newLeaf, "newLeaf");
    requireNumber(index, "index");
    let node = newLeaf;
    for (let level = 0; level < this.depth; level += 1) {
      this._nodes[level][index] = node;
      if (index & 1) {
        const sibling = this._nodes[level][index - 1];
        node = this._hash(sibling, node);
      } else {
        const sibling = this._nodes[level][index + 1];
        if (sibling) {
          node = this._hash(node, sibling);
        }
      }
      index >>= 1;
    }
    this._nodes[this.depth] = [node];
  }
  /**
   * Updates m leaves all at once.
   * It is more efficient than using the {@link LeanIMT#update} method m times because it
   * prevents updating middle nodes several times. This would happen when updating leaves
   * with common ancestors. The naive approach of calling 'update' m times has complexity
   * O(m*log(n)) (where n is the number of leaves of the tree), which ends up in
   * O(n*log(n)) when m ~ n. With this new approach, this ends up being O(n) because every
   * node is updated at most once and there are around 2*n nodes in the tree.
   * @param indices The list of indices of the respective leaves.
   * @param leaves The list of leaves to be updated.
   */
  updateMany(indices, leaves) {
    requireDefined(leaves, "leaves");
    requireDefined(indices, "indices");
    requireArray(leaves, "leaves");
    requireArray(indices, "indices");
    if (leaves.length !== indices.length) {
      throw new Error("There is no correspondence between indices and leaves");
    }
    let modifiedIndices = /* @__PURE__ */ new Set();
    for (let i = 0; i < indices.length; i += 1) {
      requireNumber(indices[i], `index ${i}`);
      if (indices[i] < 0 || indices[i] >= this.size) {
        throw new Error(`Index ${i} is out of range`);
      }
      if (modifiedIndices.has(indices[i])) {
        throw new Error(`Leaf ${indices[i]} is repeated`);
      }
      modifiedIndices.add(indices[i]);
    }
    modifiedIndices.clear();
    for (let leaf = 0; leaf < indices.length; leaf += 1) {
      this._nodes[0][indices[leaf]] = leaves[leaf];
      modifiedIndices.add(indices[leaf] >> 1);
    }
    for (let level = 1; level <= this.depth; level += 1) {
      const newModifiedIndices = [];
      for (const index of modifiedIndices) {
        const leftChild = this._nodes[level - 1][2 * index];
        const rightChild = this._nodes[level - 1][2 * index + 1];
        this._nodes[level][index] = rightChild ? this._hash(leftChild, rightChild) : leftChild;
        newModifiedIndices.push(index >> 1);
      }
      modifiedIndices = new Set(newModifiedIndices);
    }
  }
  /**
   * It generates a {@link LeanIMTMerkleProof} for a leaf of the tree.
   * That proof can be verified by this tree using the same hash function.
   * @param index The index of the leaf for which a Merkle proof will be generated.
   * @returns The Merkle proof of the leaf.
   */
  generateProof(index) {
    requireDefined(index, "index");
    requireNumber(index, "index");
    if (index < 0 || index >= this.size) {
      throw new Error(`The leaf at index '${index}' does not exist in this tree`);
    }
    const leaf = this.leaves[index];
    const siblings = [];
    const path = [];
    for (let level = 0; level < this.depth; level += 1) {
      const isRightNode = index & 1;
      const siblingIndex = isRightNode ? index - 1 : index + 1;
      const sibling = this._nodes[level][siblingIndex];
      if (sibling !== void 0) {
        path.push(isRightNode);
        siblings.push(sibling);
      }
      index >>= 1;
    }
    return { root: this.root, leaf, index: Number.parseInt(path.reverse().join(""), 2), siblings };
  }
  /**
   * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed
   * belongs to a tree.  Does not verify that the node belongs to this
   * tree in particular.  Equivalent to
   * `LeanIMT.verifyProof(proof, this._hash)`.
   * @param proof The Merkle tree proof.
   * @returns True if the leaf is part of the tree, and false otherwise.
   */
  verifyProof(proof) {
    return _LeanIMT.verifyProof(proof, this._hash);
  }
  /**
   * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed
   * belongs to a tree.
   * @param proof The Merkle tree proof.
   * @returns True if the leaf is part of the tree, and false otherwise.
   */
  static verifyProof(proof, hash4) {
    requireDefined(proof, "proof");
    const { root, leaf, siblings, index } = proof;
    requireDefined(proof.root, "proof.root");
    requireDefined(proof.leaf, "proof.leaf");
    requireDefined(proof.siblings, "proof.siblings");
    requireDefined(proof.index, "proof.index");
    requireArray(proof.siblings, "proof.siblings");
    requireNumber(proof.index, "proof.index");
    let node = leaf;
    for (let i = 0; i < siblings.length; i += 1) {
      if (index >> i & 1) {
        node = hash4(siblings[i], node);
      } else {
        node = hash4(node, siblings[i]);
      }
    }
    return root === node;
  }
  /**
   * It enables the conversion of the full tree structure into a JSON string,
   * facilitating future imports of the tree. This approach is beneficial for
   * large trees, as it saves time by storing hashes instead of recomputing them
   * @returns The stringified JSON of the tree.
   */
  export() {
    return JSON.stringify(this._nodes, (_, v) => typeof v === "bigint" ? v.toString() : v);
  }
  /**
   * It imports an entire tree by initializing the nodes without calculating
   * any hashes. Note that it is crucial to ensure the integrity of the tree
   * before or after importing it. If the map function is not defined, node
   * values will be converted to bigints by default.
   * @param hash The hash function used to create nodes.
   * @param nodes The stringified JSON of the tree.
   * @param map A function to map each node of the tree and convert their types.
   * @returns A LeanIMT instance.
   */
  static import(hash4, nodes, map) {
    requireDefined(hash4, "hash");
    requireDefined(nodes, "nodes");
    requireFunction(hash4, "hash");
    requireString(nodes, "nodes");
    if (map) {
      requireDefined(map, "map");
      requireFunction(map, "map");
    }
    const tree = new _LeanIMT(hash4);
    tree._nodes = JSON.parse(nodes, (_, value) => {
      if (typeof value === "string") {
        return map ? map(value) : BigInt(value);
      }
      return value;
    });
    return tree;
  }
};

// ../../node_modules/.pnpm/@semaphore-protocol+group@4.7.0/node_modules/@semaphore-protocol/group/dist/index.js
var import_poseidon22 = __toESM(require_poseidon2(), 1);
var Group = class _Group {
  /**
   * Creates a new instance of the Group. Optionally, a list of identity commitments can
   * be passed as a parameter. Adding members in chunks is more efficient than adding
   * them one by one with the `addMember` function.
   * @param members A list of identity commitments.
   */
  constructor(members = []) {
    for (const member of members) {
      if (member === 0n || member === "0") {
        throw new Error("Failed to add member: value cannot be 0");
      }
    }
    this.leanIMT = new LeanIMT((a2, b3) => (0, import_poseidon22.poseidon2)([a2, b3]), members.map(BigInt));
  }
  /**
   * Returns the root hash of the tree.
   * @returns The root hash as a string.
   */
  get root() {
    return this.leanIMT.root ? this.leanIMT.root : 0n;
  }
  /**
   * Returns the depth of the tree.
   * @returns The tree depth as a number.
   */
  get depth() {
    return this.leanIMT.depth;
  }
  /**
   * Returns the size of the tree (i.e. number of leaves).
   * @returns The tree size as a number.
   */
  get size() {
    return this.leanIMT.size;
  }
  /**
   * Returns the members (i.e. identity commitments) of the group.
   * @returns The list of members of the group.
   */
  get members() {
    return this.leanIMT.leaves;
  }
  /**
   * Returns the index of a member. If the member does not exist it returns -1.
   * @param member A member of the group.
   * @returns The index of the member, or -1 if it does not exist.
   */
  indexOf(member) {
    return this.leanIMT.indexOf(BigInt(member));
  }
  /**
   * Adds a new member to the group.
   * @param member The new member to be added.
   */
  addMember(member) {
    if (member === 0n || member === "0") {
      throw new Error("Failed to add member: value cannot be 0");
    }
    this.leanIMT.insert(BigInt(member));
  }
  /**
   * Adds new members to the group.
   * @param members New members.
   */
  addMembers(members) {
    for (const member of members) {
      if (member === 0n || member === "0") {
        throw new Error("Failed to add member: value cannot be 0");
      }
    }
    this.leanIMT.insertMany(members.map(BigInt));
  }
  /**
   * Updates a member in the group.
   * @param index Index of the member to be updated.
   * @param member New member value.
   */
  updateMember(index, member) {
    if (this.members[index] === 0n) {
      throw new Error("Failed to update member: it has been removed");
    }
    this.leanIMT.update(index, BigInt(member));
  }
  /**
   * Removes a member from the group.
   * @param index The index of the member to be removed.
   */
  removeMember(index) {
    if (this.members[index] === 0n) {
      throw new Error("Failed to remove member: it has already been removed");
    }
    this.leanIMT.update(index, 0n);
  }
  /**
   * Creates a proof of membership for a member of the group.
   * @param index The index of the member.
   * @returns The {@link MerkleProof} object.
   */
  generateMerkleProof(index) {
    return this.leanIMT.generateProof(index);
  }
  /**
   * Enables the conversion of the group into a JSON string that
   * can be re-used for future imports. This approach is beneficial for
   * large groups, as it avoids re-calculating the tree hashes.
   * @returns The stringified JSON of the group.
   */
  export() {
    return this.leanIMT.export();
  }
  /**
   * Imports an entire group by initializing the tree without calculating
   * any hashes. Note that it is crucial to ensure the integrity of the
   * exported group.
   * @param nodes The stringified JSON of the group.
   * @returns The {@link Group} instance.
   */
  static import(nodes) {
    const group = new _Group();
    group.leanIMT = LeanIMT.import((a2, b3) => (0, import_poseidon22.poseidon2)([a2, b3]), nodes);
    return group;
  }
};

// ../../node_modules/.pnpm/@zk-kit+utils@1.2.1/node_modules/@zk-kit/utils/dist/lib.esm/proof-packing.js
function packGroth16Proof(proof) {
  return [
    proof.pi_a[0],
    proof.pi_a[1],
    proof.pi_b[0][1],
    proof.pi_b[0][0],
    proof.pi_b[1][1],
    proof.pi_b[1][0],
    proof.pi_c[0],
    proof.pi_c[1]
  ];
}

// ../../node_modules/.pnpm/@semaphore-protocol+utils@4.7.0/node_modules/@semaphore-protocol/utils/dist/lib.esm/semaphore-interface.json.js
var _format = "hh-sol-artifact-1";
var contractName = "Semaphore";
var sourceName = "contracts/Semaphore.sol";
var abi = [
  {
    inputs: [
      {
        internalType: "contract ISemaphoreVerifier",
        name: "_verifier",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "LeafAlreadyExists",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafCannotBeZero",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafDoesNotExist",
    type: "error"
  },
  {
    inputs: [],
    name: "LeafGreaterThanSnarkScalarField",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotTheGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__CallerIsNotThePendingGroupAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupDoesNotExist",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__GroupHasNoMembers",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__InvalidProof",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeDepthIsNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__MerkleTreeRootIsNotPartOfTheGroup",
    type: "error"
  },
  {
    inputs: [],
    name: "Semaphore__YouAreUsingTheSameNullifierTwice",
    type: "error"
  },
  {
    inputs: [],
    name: "WrongSiblingNodes",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminPending",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "GroupAdminUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "GroupCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMerkleTreeDuration",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "GroupMerkleTreeDurationUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MemberUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      }
    ],
    name: "MembersAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "merkleTreeDepth",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "merkleTreeRoot",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nullifier",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "message",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "scope",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[8]",
        name: "points",
        type: "uint256[8]"
      }
    ],
    name: "ProofValidated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "acceptGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "identityCommitments",
        type: "uint256[]"
      }
    ],
    name: "addMembers",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "merkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      }
    ],
    name: "createGroup",
    outputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getGroupAdmin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeDepth",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeRoot",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      }
    ],
    name: "getMerkleTreeSize",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "groupCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "groups",
    outputs: [
      {
        internalType: "uint256",
        name: "merkleTreeDuration",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "hasMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      }
    ],
    name: "indexOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "updateGroupAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newMerkleTreeDuration",
        type: "uint256"
      }
    ],
    name: "updateGroupMerkleTreeDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "identityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newIdentityCommitment",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "merkleProofSiblings",
        type: "uint256[]"
      }
    ],
    name: "updateMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "validateProof",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "verifier",
    outputs: [
      {
        internalType: "contract ISemaphoreVerifier",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "groupId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "merkleTreeDepth",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "merkleTreeRoot",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nullifier",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "message",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scope",
            type: "uint256"
          },
          {
            internalType: "uint256[8]",
            name: "points",
            type: "uint256[8]"
          }
        ],
        internalType: "struct ISemaphore.SemaphoreProof",
        name: "proof",
        type: "tuple"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var bytecode = "0x608060405234801561001057600080fd5b5060405161201538038061201583398101604081905261002f91610054565b600380546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b611f82806100936000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c80636389e107116100b8578063a9961c941161007c578063a9961c94146102b5578063d0d898dd146102de578063d24924fe146102f1578063da3cda52146102fa578063dabc4d511461030d578063fcf0b6ec1461032057600080fd5b80636389e1071461022c5780636cdd32fe1461024f5780637ee35a0c1461026257806390509d441461028257806396324bd41461029557600080fd5b80634178c4d5116100ff5780634178c4d5146101c8578063456f4188146101db578063568ee826146101fe578063575185ed146102115780635c3f3b601461021957600080fd5b8063042453711461013c57806306dd8485146101515780631783efc3146101775780632b7ac3f31461018a5780632c880363146101b5575b600080fd5b61014f61014a3660046119e2565b610333565b005b61016461015f366004611a2e565b610366565b6040519081526020015b60405180910390f35b61014f610185366004611a2e565b610387565b60035461019d906001600160a01b031681565b6040516001600160a01b03909116815260200161016e565b6101646101c3366004611a6c565b6103b8565b61014f6101d6366004611a96565b6103f0565b6101ee6101e9366004611af7565b610427565b604051901515815260200161016e565b61014f61020c366004611b31565b61068c565b61016461069a565b610164610227366004611b5d565b6106d1565b61016461023a366004611b78565b60009081526020819052604090206001015490565b61014f61025d366004611b91565b61070a565b610164610270366004611b78565b60009081526020819052604090205490565b6101ee610290366004611a2e565b61073f565b6101646102a3366004611b78565b60046020526000908152604090205481565b61019d6102c3366004611b78565b6000908152600160205260409020546001600160a01b031690565b61014f6102ec366004611af7565b610761565b61016460055481565b61014f610308366004611b78565b61084b565b61016461031b366004611b78565b610857565b61014f61032e366004611a2e565b61087b565b600061034084848461090b565b600094855260046020908152604080872092875260019092019052909320429055505050565b600082815260208190526040812061037e90836109a9565b90505b92915050565b600061039383836109f6565b6000938452600460209081526040808620928652600190920190529092204290555050565b60058054600091826103c983611bfa565b9190505590506103d98184610a98565b600081815260046020526040902091909155919050565b60006103ff8686868686610b22565b6000968752600460209081526040808920928952600190920190529095204290555050505050565b60008281526001602052604081205483906001600160a01b031661045e5760405163029f057960e01b815260040160405180910390fd5b60018335108061046f575060208335115b1561048d5760405163767b278960e11b815260040160405180910390fd5b600084815260208190526040812054908190036104bd5760405163c8b02e0160e01b815260040160405180910390fd5b60006104c886610857565b90508085602001351461054d576000868152600460208181526040808420898301358552600181018352908420548a855292909152549091829003610520576040516326994ac360e11b815260040160405180910390fd5b61052a8183611c13565b42111561054a576040516309581a9960e41b815260040160405180910390fd5b50505b60035460408051808201825260a0880135815260c088013560208083019190915282516080808201855260e08b01358286019081526101008c0135606080850191909152908352855180870187526101208d013581526101408d01358186015283850152855180870187526101608d013581526101808d01358186015286519283018752848d013583528c870135948301949094526001600160a01b039096169563a23f019995929392820190610606908d0135610be9565b81526020016106188c60800135610be9565b90526040516001600160e01b031960e087901b16815261064194939291908c3590600401611c88565b602060405180830381865afa15801561065e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106829190611d1b565b9695505050505050565b6106968282610c20565b5050565b60058054600091826106ab83611bfa565b9190505590506106bb8133610a98565b6000818152600460205260409020610e10905590565b60058054600091826106e283611bfa565b9190505590506106f28183610a98565b6000818152600460205260409020610e109055919050565b600061071885858585610cb4565b60009586526004602090815260408088209288526001909201905290942042905550505050565b600082815260208181526040808320848452600301909152812054151561037e565b600082815260046020908152604080832084820135845260020190915290205460ff16156107a25760405163041162bd60e31b815260040160405180910390fd5b6107ac8282610427565b6107c95760405163012a9af160e61b815260040160405180910390fd5b6000828152600460209081526040808320848201358085526002909101835292819020805460ff1916600117905551608084013592918401359185917f0c32e14cfe81a05d371c248d22de6b7ae849e981b76a1f8842e7b6da73fc405a9161083f918735919060608901359060a08a0190611d44565b60405180910390a45050565b61085481610d72565b50565b60008181526020818152604080832060018101548452600201909152812054610381565b60008281526001602052604090205482906001600160a01b031633146108b4576040516317737e4f60e31b815260040160405180910390fd5b60008381526004602090815260409182902080549085905582518181529182018590529185917f264b2a8f6763c084235fe832ba903482b2ef1a521336881fc75b987c2dfd29c5910160405180910390a250505050565b60008381526001602052604081205484906001600160a01b03163314610944576040516317737e4f60e31b815260040160405180910390fd5b6000858152602081905260409020805490610960908686610e17565b9250857f61e5e8054e3daf084a0c6c646c065e8bf5e7ca4d5567bda942309bd1652f349d828787876040516109989493929190611d6c565b60405180910390a250509392505050565b600081815260038301602052604081205481036109d957604051631c811d5b60e21b815260040160405180910390fd5b600082815260038401602052604090205461037e90600190611db2565b60008281526001602052604081205483906001600160a01b03163314610a2f576040516317737e4f60e31b815260040160405180910390fd5b6000848152602081905260409020805490610a4a9085611344565b604080518381526020810187905290810182905290935085907f19239b3f93cd10558aaf11423af70c77763bf54f52bcc75bfa74d4d13548cde99060600160405180910390a2505092915050565b60008281526001602052604080822080546001600160a01b0319166001600160a01b0385161790555183917ff0adfb94eab6daf835deb69c5738fe636150c3dfd08094a76f39b963dc8cb05a91a26040516001600160a01b0382169060009084907f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e3908390a45050565b60008581526001602052604081205486906001600160a01b03163314610b5b576040516317737e4f60e31b815260040160405180910390fd5b6000878152602081905260408120610b7390886109a9565b6000898152602081905260409020909150610b91908888888861150d565b60408051838152602081018a90529081018890526060810182905290935088907fea3588e4a2a0c93d6a0e69dfeaf7496f43ccccf02ad9ce0a5b7627cbca4b61b19060800160405180910390a2505095945050505050565b6000600882604051602001610c0091815260200190565b60408051601f198184030181529190528051602090910120901c92915050565b60008281526001602052604090205482906001600160a01b03163314610c59576040516317737e4f60e31b815260040160405180910390fd5b60008381526002602052604080822080546001600160a01b0319166001600160a01b03861690811790915590519091339186917f1018365553cce55d9cb02ef73e18cc9311894f3fe1d1eafd235ac2d26cd8ba5891a4505050565b60008481526001602052604081205485906001600160a01b03163314610ced576040516317737e4f60e31b815260040160405180910390fd5b6000868152602081905260408120610d0590876109a9565b6000888152602081905260409020909150610d229087878761197d565b604080518381526020810189905290810182905290935087907f3108849c053c77b8073a11256dffb5ffd5b55e93e105a355e1c9061db890d8719060600160405180910390a25050949350505050565b6000818152600260205260409020546001600160a01b03163314610da9576040516334c4245d60e01b815260040160405180910390fd5b60008181526001602090815260408083208054336001600160a01b031980831682179093556002909452828520805490921690915590516001600160a01b0390911692839185917f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e391a45050565b8254600090815b83811015610f4857600080516020611f2d833981519152858583818110610e4757610e47611c26565b9050602002013510610e6c576040516361c0541760e11b815260040160405180910390fd5b848482818110610e7e57610e7e611c26565b90506020020135600003610ea5576040516314b48df160e11b815260040160405180910390fd5b610eda86868684818110610ebb57610ebb611c26565b9050602002013560009081526003919091016020526040902054151590565b15610ef8576040516312c50cad60e11b815260040160405180910390fd5b80610f04836001611c13565b610f0e9190611c13565b866003016000878785818110610f2657610f26611c26565b6020908102929092013583525081019190915260400160002055600101610e1e565b50606084848080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050506001880154919250505b610f918584611c13565b610f9c826002611ea9565b1015610fb257610fab81611bfa565b9050610f87565b60018701819055826000610fc68783611c13565b9050600182811c90600090610fdb8185611db2565b610fe7911c6001611c13565b905060005b858110156112d85760006110008484611db2565b905060008167ffffffffffffffff81111561101d5761101d611eb5565b604051908082528060200260200182016040528015611046578160200160208202803683370190505b50905060005b82811015611203576000886110618884611c13565b61106c906002611ecb565b101561108f578f60020160008681526020019081526020016000205490506110cb565b8a8961109b8985611c13565b6110a6906002611ecb565b6110b09190611db2565b815181106110c0576110c0611c26565b602002602001015190505b6000886110d88985611c13565b6110e3906002611ecb565b6110ee906001611c13565b101561113b578b8a6111008a86611c13565b61110b906002611ecb565b611116906001611c13565b6111209190611db2565b8151811061113057611130611c26565b602002602001015190505b600081156111d357604080518082018252848152602081018490529051632b0aac7f60e11b815273__$75f79a42d9bcbdbb69ad79ebd80f556f39$__9163561558fe9161118b9190600401611ee2565b602060405180830381865af41580156111a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111cc9190611f13565b90506111d6565b50815b808585815181106111e9576111e9611c26565b60200260200101818152505083600101935050505061104c565b5085600116600103611254578860018a5161121e9190611db2565b8151811061122e5761122e611c26565b60200260200101518e60020160008581526020019081526020016000208190555061129f565b60018951111561129f578860028a5161126d9190611db2565b8151811061127d5761127d611c26565b60200260200101518e6002016000858152602001908152602001600020819055505b849650600185901c9450809850839550600180856112bd9190611db2565b6112c9911c6001611c13565b93508260010192505050610fec565b506112e38988611c13565b8b55855186906000906112f8576112f8611c26565b60200260200101518b6002016000878152602001908152602001600020819055508560008151811061132c5761132c611c26565b60200260200101519750505050505050509392505050565b6000600080516020611f2d8339815191528210611374576040516361c0541760e11b815260040160405180910390fd5b81600003611395576040516314b48df160e11b815260040160405180910390fd5b6000828152600384016020526040902054156113c4576040516312c50cad60e11b815260040160405180910390fd5b8254600180850154906113d8908390611c13565b6113e3826002611ea9565b10156113f5576113f281611bfa565b90505b600185018190558360005b828110156114d2578084901c6001166001036114b657604080518082018252600083815260028a0160209081529083902054825281018490529051632b0aac7f60e11b815273__$75f79a42d9bcbdbb69ad79ebd80f556f39$__9163561558fe9161146e9190600401611ee2565b602060405180830381865af415801561148b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114af9190611f13565b91506114ca565b600081815260028801602052604090208290555b600101611400565b506114dc83611bfa565b8087556000928352600287016020908152604080852084905596845260039097019096529390209390935550919050565b6000600080516020611f2d833981519152841061153d576040516361c0541760e11b815260040160405180910390fd5b600085815260038701602052604090205461156b57604051631c811d5b60e21b815260040160405180910390fd5b60008481526003870160205260409020541561159a576040516312c50cad60e11b815260040160405180910390fd5b60006115a687876109a9565b8754909150859087906000906115be90600190611db2565b60018b0154909150600090815b818110156118f4578087901c60011660010361177e57600080516020611f2d8339815191528a8a8581811061160257611602611c26565b9050602002013510611627576040516361c0541760e11b815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d8881811061165e5761165e611c26565b905060200201358152602001898152506040518263ffffffff1660e01b815260040161168a9190611ee2565b602060405180830381865af41580156116a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116cb9190611f13565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d8881811061170457611704611c26565b905060200201358152602001888152506040518263ffffffff1660e01b81526004016117309190611ee2565b602060405180830381865af415801561174d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117719190611f13565b94508260010192506118ec565b86811c84821c146118d857600080516020611f2d8339815191528a8a858181106117aa576117aa611c26565b90506020020135106117cf576040516361c0541760e11b815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808981526020018d8d8881811061180c5761180c611c26565b905060200201358152506040518263ffffffff1660e01b81526004016118329190611ee2565b602060405180830381865af415801561184f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118739190611f13565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808881526020018d8d888181106118b2576118b2611c26565b905060200201358152506040518263ffffffff1660e01b81526004016117309190611ee2565b600083815260028e01602052604090208690555b6001016115cb565b5060018c0154600090815260028d016020526040902054841461192a57604051631fd4986360e11b815260040160405180910390fd5b600081815260028d0160205260409020859055891561195c5760008b815260038d016020526040808220548c83529120555b505050600088815260038a0160205260408120555091505095945050505050565b600061198d85856000868661150d565b95945050505050565b60008083601f8401126119a857600080fd5b50813567ffffffffffffffff8111156119c057600080fd5b6020830191508360208260051b85010111156119db57600080fd5b9250929050565b6000806000604084860312156119f757600080fd5b83359250602084013567ffffffffffffffff811115611a1557600080fd5b611a2186828701611996565b9497909650939450505050565b60008060408385031215611a4157600080fd5b50508035926020909101359150565b80356001600160a01b0381168114611a6757600080fd5b919050565b60008060408385031215611a7f57600080fd5b611a8883611a50565b946020939093013593505050565b600080600080600060808688031215611aae57600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611ada57600080fd5b611ae688828901611996565b969995985093965092949392505050565b6000808284036101c0811215611b0c57600080fd5b833592506101a0601f1982011215611b2357600080fd5b506020830190509250929050565b60008060408385031215611b4457600080fd5b82359150611b5460208401611a50565b90509250929050565b600060208284031215611b6f57600080fd5b61037e82611a50565b600060208284031215611b8a57600080fd5b5035919050565b60008060008060608587031215611ba757600080fd5b8435935060208501359250604085013567ffffffffffffffff811115611bcc57600080fd5b611bd887828801611996565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611c0c57611c0c611be4565b5060010190565b8082018082111561038157610381611be4565b634e487b7160e01b600052603260045260246000fd5b8060005b6002811015611c5f578151845260209384019390910190600101611c40565b50505050565b8060005b6004811015611c5f578151845260209384019390910190600101611c69565b6101a08101611c978288611c3c565b6040808301876000805b6002808210611cb05750611cea565b835185845b83811015611cd3578251825260209283019290910190600101611cb5565b505050938501935060209290920191600101611ca1565b5050505050611cfc60c0830186611c3c565b611d0a610100830185611c65565b826101808301529695505050505050565b600060208284031215611d2d57600080fd5b81518015158114611d3d57600080fd5b9392505050565b8481526020810184905260408101839052610160810161010083606084013795945050505050565b848152606060208201819052810183905260006001600160fb1b03841115611d9357600080fd5b8360051b80866080850137604083019390935250016080019392505050565b8181038181111561038157610381611be4565b600181815b80851115611e00578160001904821115611de657611de6611be4565b80851615611df357918102915b93841c9390800290611dca565b509250929050565b600082611e1757506001610381565b81611e2457506000610381565b8160018114611e3a5760028114611e4457611e60565b6001915050610381565b60ff841115611e5557611e55611be4565b50506001821b610381565b5060208310610133831016604e8410600b8410161715611e83575081810a610381565b611e8d8383611dc5565b8060001904821115611ea157611ea1611be4565b029392505050565b600061037e8383611e08565b634e487b7160e01b600052604160045260246000fd5b808202811582820484141761038157610381611be4565b60408101818360005b6002811015611f0a578151835260209283019290910190600101611eeb565b50505092915050565b600060208284031215611f2557600080fd5b505191905056fe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a2646970667358221220164ddea4e67fb9956ad9d73065c0b85ecf9b8062f67bcc5be446364b9475660664736f6c63430008170033";
var deployedBytecode = "0x608060405234801561001057600080fd5b50600436106101375760003560e01c80636389e107116100b8578063a9961c941161007c578063a9961c94146102b5578063d0d898dd146102de578063d24924fe146102f1578063da3cda52146102fa578063dabc4d511461030d578063fcf0b6ec1461032057600080fd5b80636389e1071461022c5780636cdd32fe1461024f5780637ee35a0c1461026257806390509d441461028257806396324bd41461029557600080fd5b80634178c4d5116100ff5780634178c4d5146101c8578063456f4188146101db578063568ee826146101fe578063575185ed146102115780635c3f3b601461021957600080fd5b8063042453711461013c57806306dd8485146101515780631783efc3146101775780632b7ac3f31461018a5780632c880363146101b5575b600080fd5b61014f61014a3660046119e2565b610333565b005b61016461015f366004611a2e565b610366565b6040519081526020015b60405180910390f35b61014f610185366004611a2e565b610387565b60035461019d906001600160a01b031681565b6040516001600160a01b03909116815260200161016e565b6101646101c3366004611a6c565b6103b8565b61014f6101d6366004611a96565b6103f0565b6101ee6101e9366004611af7565b610427565b604051901515815260200161016e565b61014f61020c366004611b31565b61068c565b61016461069a565b610164610227366004611b5d565b6106d1565b61016461023a366004611b78565b60009081526020819052604090206001015490565b61014f61025d366004611b91565b61070a565b610164610270366004611b78565b60009081526020819052604090205490565b6101ee610290366004611a2e565b61073f565b6101646102a3366004611b78565b60046020526000908152604090205481565b61019d6102c3366004611b78565b6000908152600160205260409020546001600160a01b031690565b61014f6102ec366004611af7565b610761565b61016460055481565b61014f610308366004611b78565b61084b565b61016461031b366004611b78565b610857565b61014f61032e366004611a2e565b61087b565b600061034084848461090b565b600094855260046020908152604080872092875260019092019052909320429055505050565b600082815260208190526040812061037e90836109a9565b90505b92915050565b600061039383836109f6565b6000938452600460209081526040808620928652600190920190529092204290555050565b60058054600091826103c983611bfa565b9190505590506103d98184610a98565b600081815260046020526040902091909155919050565b60006103ff8686868686610b22565b6000968752600460209081526040808920928952600190920190529095204290555050505050565b60008281526001602052604081205483906001600160a01b031661045e5760405163029f057960e01b815260040160405180910390fd5b60018335108061046f575060208335115b1561048d5760405163767b278960e11b815260040160405180910390fd5b600084815260208190526040812054908190036104bd5760405163c8b02e0160e01b815260040160405180910390fd5b60006104c886610857565b90508085602001351461054d576000868152600460208181526040808420898301358552600181018352908420548a855292909152549091829003610520576040516326994ac360e11b815260040160405180910390fd5b61052a8183611c13565b42111561054a576040516309581a9960e41b815260040160405180910390fd5b50505b60035460408051808201825260a0880135815260c088013560208083019190915282516080808201855260e08b01358286019081526101008c0135606080850191909152908352855180870187526101208d013581526101408d01358186015283850152855180870187526101608d013581526101808d01358186015286519283018752848d013583528c870135948301949094526001600160a01b039096169563a23f019995929392820190610606908d0135610be9565b81526020016106188c60800135610be9565b90526040516001600160e01b031960e087901b16815261064194939291908c3590600401611c88565b602060405180830381865afa15801561065e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106829190611d1b565b9695505050505050565b6106968282610c20565b5050565b60058054600091826106ab83611bfa565b9190505590506106bb8133610a98565b6000818152600460205260409020610e10905590565b60058054600091826106e283611bfa565b9190505590506106f28183610a98565b6000818152600460205260409020610e109055919050565b600061071885858585610cb4565b60009586526004602090815260408088209288526001909201905290942042905550505050565b600082815260208181526040808320848452600301909152812054151561037e565b600082815260046020908152604080832084820135845260020190915290205460ff16156107a25760405163041162bd60e31b815260040160405180910390fd5b6107ac8282610427565b6107c95760405163012a9af160e61b815260040160405180910390fd5b6000828152600460209081526040808320848201358085526002909101835292819020805460ff1916600117905551608084013592918401359185917f0c32e14cfe81a05d371c248d22de6b7ae849e981b76a1f8842e7b6da73fc405a9161083f918735919060608901359060a08a0190611d44565b60405180910390a45050565b61085481610d72565b50565b60008181526020818152604080832060018101548452600201909152812054610381565b60008281526001602052604090205482906001600160a01b031633146108b4576040516317737e4f60e31b815260040160405180910390fd5b60008381526004602090815260409182902080549085905582518181529182018590529185917f264b2a8f6763c084235fe832ba903482b2ef1a521336881fc75b987c2dfd29c5910160405180910390a250505050565b60008381526001602052604081205484906001600160a01b03163314610944576040516317737e4f60e31b815260040160405180910390fd5b6000858152602081905260409020805490610960908686610e17565b9250857f61e5e8054e3daf084a0c6c646c065e8bf5e7ca4d5567bda942309bd1652f349d828787876040516109989493929190611d6c565b60405180910390a250509392505050565b600081815260038301602052604081205481036109d957604051631c811d5b60e21b815260040160405180910390fd5b600082815260038401602052604090205461037e90600190611db2565b60008281526001602052604081205483906001600160a01b03163314610a2f576040516317737e4f60e31b815260040160405180910390fd5b6000848152602081905260409020805490610a4a9085611344565b604080518381526020810187905290810182905290935085907f19239b3f93cd10558aaf11423af70c77763bf54f52bcc75bfa74d4d13548cde99060600160405180910390a2505092915050565b60008281526001602052604080822080546001600160a01b0319166001600160a01b0385161790555183917ff0adfb94eab6daf835deb69c5738fe636150c3dfd08094a76f39b963dc8cb05a91a26040516001600160a01b0382169060009084907f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e3908390a45050565b60008581526001602052604081205486906001600160a01b03163314610b5b576040516317737e4f60e31b815260040160405180910390fd5b6000878152602081905260408120610b7390886109a9565b6000898152602081905260409020909150610b91908888888861150d565b60408051838152602081018a90529081018890526060810182905290935088907fea3588e4a2a0c93d6a0e69dfeaf7496f43ccccf02ad9ce0a5b7627cbca4b61b19060800160405180910390a2505095945050505050565b6000600882604051602001610c0091815260200190565b60408051601f198184030181529190528051602090910120901c92915050565b60008281526001602052604090205482906001600160a01b03163314610c59576040516317737e4f60e31b815260040160405180910390fd5b60008381526002602052604080822080546001600160a01b0319166001600160a01b03861690811790915590519091339186917f1018365553cce55d9cb02ef73e18cc9311894f3fe1d1eafd235ac2d26cd8ba5891a4505050565b60008481526001602052604081205485906001600160a01b03163314610ced576040516317737e4f60e31b815260040160405180910390fd5b6000868152602081905260408120610d0590876109a9565b6000888152602081905260409020909150610d229087878761197d565b604080518381526020810189905290810182905290935087907f3108849c053c77b8073a11256dffb5ffd5b55e93e105a355e1c9061db890d8719060600160405180910390a25050949350505050565b6000818152600260205260409020546001600160a01b03163314610da9576040516334c4245d60e01b815260040160405180910390fd5b60008181526001602090815260408083208054336001600160a01b031980831682179093556002909452828520805490921690915590516001600160a01b0390911692839185917f0ba83579a0e79193ef649b9f5a8759d35af086ba62a3e207b52e4a8ae30d49e391a45050565b8254600090815b83811015610f4857600080516020611f2d833981519152858583818110610e4757610e47611c26565b9050602002013510610e6c576040516361c0541760e11b815260040160405180910390fd5b848482818110610e7e57610e7e611c26565b90506020020135600003610ea5576040516314b48df160e11b815260040160405180910390fd5b610eda86868684818110610ebb57610ebb611c26565b9050602002013560009081526003919091016020526040902054151590565b15610ef8576040516312c50cad60e11b815260040160405180910390fd5b80610f04836001611c13565b610f0e9190611c13565b866003016000878785818110610f2657610f26611c26565b6020908102929092013583525081019190915260400160002055600101610e1e565b50606084848080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050506001880154919250505b610f918584611c13565b610f9c826002611ea9565b1015610fb257610fab81611bfa565b9050610f87565b60018701819055826000610fc68783611c13565b9050600182811c90600090610fdb8185611db2565b610fe7911c6001611c13565b905060005b858110156112d85760006110008484611db2565b905060008167ffffffffffffffff81111561101d5761101d611eb5565b604051908082528060200260200182016040528015611046578160200160208202803683370190505b50905060005b82811015611203576000886110618884611c13565b61106c906002611ecb565b101561108f578f60020160008681526020019081526020016000205490506110cb565b8a8961109b8985611c13565b6110a6906002611ecb565b6110b09190611db2565b815181106110c0576110c0611c26565b602002602001015190505b6000886110d88985611c13565b6110e3906002611ecb565b6110ee906001611c13565b101561113b578b8a6111008a86611c13565b61110b906002611ecb565b611116906001611c13565b6111209190611db2565b8151811061113057611130611c26565b602002602001015190505b600081156111d357604080518082018252848152602081018490529051632b0aac7f60e11b815273__$75f79a42d9bcbdbb69ad79ebd80f556f39$__9163561558fe9161118b9190600401611ee2565b602060405180830381865af41580156111a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111cc9190611f13565b90506111d6565b50815b808585815181106111e9576111e9611c26565b60200260200101818152505083600101935050505061104c565b5085600116600103611254578860018a5161121e9190611db2565b8151811061122e5761122e611c26565b60200260200101518e60020160008581526020019081526020016000208190555061129f565b60018951111561129f578860028a5161126d9190611db2565b8151811061127d5761127d611c26565b60200260200101518e6002016000858152602001908152602001600020819055505b849650600185901c9450809850839550600180856112bd9190611db2565b6112c9911c6001611c13565b93508260010192505050610fec565b506112e38988611c13565b8b55855186906000906112f8576112f8611c26565b60200260200101518b6002016000878152602001908152602001600020819055508560008151811061132c5761132c611c26565b60200260200101519750505050505050509392505050565b6000600080516020611f2d8339815191528210611374576040516361c0541760e11b815260040160405180910390fd5b81600003611395576040516314b48df160e11b815260040160405180910390fd5b6000828152600384016020526040902054156113c4576040516312c50cad60e11b815260040160405180910390fd5b8254600180850154906113d8908390611c13565b6113e3826002611ea9565b10156113f5576113f281611bfa565b90505b600185018190558360005b828110156114d2578084901c6001166001036114b657604080518082018252600083815260028a0160209081529083902054825281018490529051632b0aac7f60e11b815273__$75f79a42d9bcbdbb69ad79ebd80f556f39$__9163561558fe9161146e9190600401611ee2565b602060405180830381865af415801561148b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114af9190611f13565b91506114ca565b600081815260028801602052604090208290555b600101611400565b506114dc83611bfa565b8087556000928352600287016020908152604080852084905596845260039097019096529390209390935550919050565b6000600080516020611f2d833981519152841061153d576040516361c0541760e11b815260040160405180910390fd5b600085815260038701602052604090205461156b57604051631c811d5b60e21b815260040160405180910390fd5b60008481526003870160205260409020541561159a576040516312c50cad60e11b815260040160405180910390fd5b60006115a687876109a9565b8754909150859087906000906115be90600190611db2565b60018b0154909150600090815b818110156118f4578087901c60011660010361177e57600080516020611f2d8339815191528a8a8581811061160257611602611c26565b9050602002013510611627576040516361c0541760e11b815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d8881811061165e5761165e611c26565b905060200201358152602001898152506040518263ffffffff1660e01b815260040161168a9190611ee2565b602060405180830381865af41580156116a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116cb9190611f13565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808d8d8881811061170457611704611c26565b905060200201358152602001888152506040518263ffffffff1660e01b81526004016117309190611ee2565b602060405180830381865af415801561174d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117719190611f13565b94508260010192506118ec565b86811c84821c146118d857600080516020611f2d8339815191528a8a858181106117aa576117aa611c26565b90506020020135106117cf576040516361c0541760e11b815260040160405180910390fd5b73__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808981526020018d8d8881811061180c5761180c611c26565b905060200201358152506040518263ffffffff1660e01b81526004016118329190611ee2565b602060405180830381865af415801561184f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118739190611f13565b955073__$75f79a42d9bcbdbb69ad79ebd80f556f39$__63561558fe60405180604001604052808881526020018d8d888181106118b2576118b2611c26565b905060200201358152506040518263ffffffff1660e01b81526004016117309190611ee2565b600083815260028e01602052604090208690555b6001016115cb565b5060018c0154600090815260028d016020526040902054841461192a57604051631fd4986360e11b815260040160405180910390fd5b600081815260028d0160205260409020859055891561195c5760008b815260038d016020526040808220548c83529120555b505050600088815260038a0160205260408120555091505095945050505050565b600061198d85856000868661150d565b95945050505050565b60008083601f8401126119a857600080fd5b50813567ffffffffffffffff8111156119c057600080fd5b6020830191508360208260051b85010111156119db57600080fd5b9250929050565b6000806000604084860312156119f757600080fd5b83359250602084013567ffffffffffffffff811115611a1557600080fd5b611a2186828701611996565b9497909650939450505050565b60008060408385031215611a4157600080fd5b50508035926020909101359150565b80356001600160a01b0381168114611a6757600080fd5b919050565b60008060408385031215611a7f57600080fd5b611a8883611a50565b946020939093013593505050565b600080600080600060808688031215611aae57600080fd5b853594506020860135935060408601359250606086013567ffffffffffffffff811115611ada57600080fd5b611ae688828901611996565b969995985093965092949392505050565b6000808284036101c0811215611b0c57600080fd5b833592506101a0601f1982011215611b2357600080fd5b506020830190509250929050565b60008060408385031215611b4457600080fd5b82359150611b5460208401611a50565b90509250929050565b600060208284031215611b6f57600080fd5b61037e82611a50565b600060208284031215611b8a57600080fd5b5035919050565b60008060008060608587031215611ba757600080fd5b8435935060208501359250604085013567ffffffffffffffff811115611bcc57600080fd5b611bd887828801611996565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611c0c57611c0c611be4565b5060010190565b8082018082111561038157610381611be4565b634e487b7160e01b600052603260045260246000fd5b8060005b6002811015611c5f578151845260209384019390910190600101611c40565b50505050565b8060005b6004811015611c5f578151845260209384019390910190600101611c69565b6101a08101611c978288611c3c565b6040808301876000805b6002808210611cb05750611cea565b835185845b83811015611cd3578251825260209283019290910190600101611cb5565b505050938501935060209290920191600101611ca1565b5050505050611cfc60c0830186611c3c565b611d0a610100830185611c65565b826101808301529695505050505050565b600060208284031215611d2d57600080fd5b81518015158114611d3d57600080fd5b9392505050565b8481526020810184905260408101839052610160810161010083606084013795945050505050565b848152606060208201819052810183905260006001600160fb1b03841115611d9357600080fd5b8360051b80866080850137604083019390935250016080019392505050565b8181038181111561038157610381611be4565b600181815b80851115611e00578160001904821115611de657611de6611be4565b80851615611df357918102915b93841c9390800290611dca565b509250929050565b600082611e1757506001610381565b81611e2457506000610381565b8160018114611e3a5760028114611e4457611e60565b6001915050610381565b60ff841115611e5557611e55611be4565b50506001821b610381565b5060208310610133831016604e8410600b8410161715611e83575081810a610381565b611e8d8383611dc5565b8060001904821115611ea157611ea1611be4565b029392505050565b600061037e8383611e08565b634e487b7160e01b600052604160045260246000fd5b808202811582820484141761038157610381611be4565b60408101818360005b6002811015611f0a578151835260209283019290910190600101611eeb565b50505092915050565b600060208284031215611f2557600080fd5b505191905056fe30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001a2646970667358221220164ddea4e67fb9956ad9d73065c0b85ecf9b8062f67bcc5be446364b9475660664736f6c63430008170033";
var linkReferences = {
  "poseidon-solidity/PoseidonT3.sol": {
    PoseidonT3: [
      {
        length: 20,
        start: 4599
      },
      {
        length: 20,
        start: 5338
      },
      {
        length: 20,
        start: 5820
      },
      {
        length: 20,
        start: 5986
      },
      {
        length: 20,
        start: 6244
      },
      {
        length: 20,
        start: 6410
      }
    ]
  }
};
var deployedLinkReferences = {
  "poseidon-solidity/PoseidonT3.sol": {
    PoseidonT3: [
      {
        length: 20,
        start: 4452
      },
      {
        length: 20,
        start: 5191
      },
      {
        length: 20,
        start: 5673
      },
      {
        length: 20,
        start: 5839
      },
      {
        length: 20,
        start: 6097
      },
      {
        length: 20,
        start: 6263
      }
    ]
  }
};
var _interface = {
  _format,
  contractName,
  sourceName,
  abi,
  bytecode,
  deployedBytecode,
  linkReferences,
  deployedLinkReferences
};

// ../../node_modules/.pnpm/@semaphore-protocol+utils@4.7.0/node_modules/@semaphore-protocol/utils/dist/lib.esm/constants.js
var MIN_DEPTH = 1;
var MAX_DEPTH = 32;
var SemaphoreABI = _interface.abi;
var SemaphoreBytecode = _interface.bytecode;

// ../../node_modules/.pnpm/@zk-kit+artifacts@1.8.0/node_modules/@zk-kit/artifacts/dist/index.node.js
var import_node_fs = require("node:fs");
var import_promises = require("node:fs/promises");
var import_node_path = require("node:path");
var import_node_os = require("node:os");
async function download(url, outputPath) {
  const { body, ok, statusText } = await fetch(url);
  if (!ok)
    throw new Error(`Failed to fetch ${url}: ${statusText}`);
  if (!body)
    throw new Error("Failed to get response body");
  const dir = (0, import_node_path.dirname)(outputPath);
  await (0, import_promises.mkdir)(dir, { recursive: true });
  const fileStream = (0, import_node_fs.createWriteStream)(outputPath);
  const reader = body.getReader();
  try {
    const pump = async () => {
      const { done, value } = await reader.read();
      if (done) {
        fileStream.end();
        return;
      }
      fileStream.write(Buffer.from(value));
      await pump();
    };
    await pump();
  } catch (error) {
    fileStream.close();
    throw error;
  }
}
async function maybeDownload(url, outputPath) {
  if (!(0, import_node_fs.existsSync)(outputPath))
    await download(url, outputPath);
  return outputPath;
}
var Project;
(function(Project2) {
  Project2["SEMAPHORE_IDENTITY"] = "semaphore-identity";
  Project2["POSEIDON"] = "poseidon";
  Project2["SEMAPHORE"] = "semaphore";
})(Project || (Project = {}));
var projects = Object.values(Project);
var BASE_URL = "https://snark-artifacts.pse.dev";
var getBaseUrl = (project, version4) => `${BASE_URL}/${project}/${version4}/${project}`;
async function maybeGetSnarkArtifacts$1(project, options = {}) {
  if (!projects.includes(project))
    throw new Error(`Project '${project}' is not supported`);
  options.version ??= "latest";
  const url = getBaseUrl(project, options.version);
  const parameters = options.parameters ? `-${options.parameters.join("-")}` : "";
  return {
    wasm: `${url}${parameters}.wasm`,
    zkey: `${url}${parameters}.zkey`
  };
}
var extractEndPath = (url) => url.split("pse.dev/")[1];
async function maybeGetSnarkArtifacts(...pars) {
  const urls = await maybeGetSnarkArtifacts$1(...pars);
  const outputPath = `${(0, import_node_os.tmpdir)()}/snark-artifacts/${extractEndPath(urls.wasm)}`;
  const [wasm, zkey] = await Promise.all([
    maybeDownload(urls.wasm, outputPath),
    maybeDownload(urls.zkey, outputPath.replace(/.wasm$/, ".zkey"))
  ]);
  return {
    wasm,
    zkey
  };
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/groth16.js
var groth16_exports = {};
__export(groth16_exports, {
  exportSolidityCallData: () => groth16ExportSolidityCallData,
  fullProve: () => groth16FullProve,
  prove: () => groth16Prove,
  verify: () => groth16Verify
});

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/scalar.js
var scalar_exports2 = {};
__export(scalar_exports2, {
  abs: () => abs,
  add: () => add,
  band: () => band,
  bitLength: () => bitLength,
  bits: () => bits2,
  bor: () => bor,
  bxor: () => bxor,
  div: () => div,
  e: () => e,
  eq: () => eq,
  exp: () => exp,
  fromArray: () => fromArray,
  fromRprBE: () => fromRprBE,
  fromRprLE: () => fromRprLE,
  fromString: () => fromString,
  geq: () => geq,
  gt: () => gt2,
  isNegative: () => isNegative,
  isOdd: () => isOdd2,
  isZero: () => isZero2,
  land: () => land,
  leq: () => leq,
  lnot: () => lnot,
  lor: () => lor,
  lt: () => lt,
  mod: () => mod2,
  mul: () => mul2,
  naf: () => naf,
  neg: () => neg,
  neq: () => neq,
  one: () => one,
  pow: () => pow3,
  shiftLeft: () => shiftLeft,
  shiftRight: () => shiftRight2,
  shl: () => shl,
  shr: () => shr,
  square: () => square,
  sub: () => sub,
  toArray: () => toArray,
  toLEBuff: () => toLEBuff,
  toNumber: () => toNumber2,
  toRprBE: () => toRprBE,
  toRprLE: () => toRprLE,
  toString: () => toString3,
  zero: () => zero
});
var hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
function fromString(s2, radix) {
  if (!radix || radix == 10) {
    return BigInt(s2);
  } else if (radix == 16) {
    if (s2.slice(0, 2) == "0x") {
      return BigInt(s2);
    } else {
      return BigInt("0x" + s2);
    }
  }
}
var e = fromString;
function fromArray(a2, radix) {
  let acc = BigInt(0);
  radix = BigInt(radix);
  for (let i = 0; i < a2.length; i++) {
    acc = acc * radix + BigInt(a2[i]);
  }
  return acc;
}
function bitLength(a2) {
  const aS = a2.toString(16);
  return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
}
function isNegative(a2) {
  return BigInt(a2) < BigInt(0);
}
function isZero2(a2) {
  return !a2;
}
function shiftLeft(a2, n3) {
  return BigInt(a2) << BigInt(n3);
}
function shiftRight2(a2, n3) {
  return BigInt(a2) >> BigInt(n3);
}
var shl = shiftLeft;
var shr = shiftRight2;
function isOdd2(a2) {
  return (BigInt(a2) & BigInt(1)) == BigInt(1);
}
function naf(n3) {
  let E = BigInt(n3);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      const z2 = 2 - Number(E % BigInt(4));
      res.push(z2);
      E = E - BigInt(z2);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function bits2(n3) {
  let E = BigInt(n3);
  const res = [];
  while (E) {
    if (E & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E = E >> BigInt(1);
  }
  return res;
}
function toNumber2(s2) {
  if (s2 > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("Number too big");
  }
  return Number(s2);
}
function toArray(s2, radix) {
  const res = [];
  let rem = BigInt(s2);
  radix = BigInt(radix);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  return res;
}
function add(a2, b3) {
  return BigInt(a2) + BigInt(b3);
}
function sub(a2, b3) {
  return BigInt(a2) - BigInt(b3);
}
function neg(a2) {
  return -BigInt(a2);
}
function mul2(a2, b3) {
  return BigInt(a2) * BigInt(b3);
}
function square(a2) {
  return BigInt(a2) * BigInt(a2);
}
function pow3(a2, b3) {
  return BigInt(a2) ** BigInt(b3);
}
function exp(a2, b3) {
  return BigInt(a2) ** BigInt(b3);
}
function abs(a2) {
  return BigInt(a2) >= 0 ? BigInt(a2) : -BigInt(a2);
}
function div(a2, b3) {
  return BigInt(a2) / BigInt(b3);
}
function mod2(a2, b3) {
  return BigInt(a2) % BigInt(b3);
}
function eq(a2, b3) {
  return BigInt(a2) == BigInt(b3);
}
function neq(a2, b3) {
  return BigInt(a2) != BigInt(b3);
}
function lt(a2, b3) {
  return BigInt(a2) < BigInt(b3);
}
function gt2(a2, b3) {
  return BigInt(a2) > BigInt(b3);
}
function leq(a2, b3) {
  return BigInt(a2) <= BigInt(b3);
}
function geq(a2, b3) {
  return BigInt(a2) >= BigInt(b3);
}
function band(a2, b3) {
  return BigInt(a2) & BigInt(b3);
}
function bor(a2, b3) {
  return BigInt(a2) | BigInt(b3);
}
function bxor(a2, b3) {
  return BigInt(a2) ^ BigInt(b3);
}
function land(a2, b3) {
  return BigInt(a2) && BigInt(b3);
}
function lor(a2, b3) {
  return BigInt(a2) || BigInt(b3);
}
function lnot(a2) {
  return !BigInt(a2);
}
function toRprLE(buff, o, e2, n8) {
  const s2 = "0000000" + e2.toString(16);
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const l = ((s2.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++) v[i] = parseInt(s2.substring(s2.length - 8 * i - 8, s2.length - 8 * i), 16);
  for (let i = l; i < v.length; i++) v[i] = 0;
  for (let i = v.length * 4; i < n8; i++) buff[i] = toNumber2(band(shiftRight2(e2, i * 8), 255));
}
function toRprBE(buff, o, e2, n8) {
  const s2 = "0000000" + e2.toString(16);
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const l = ((s2.length - 7) * 4 - 1 >> 5) + 1;
  for (let i = 0; i < l; i++) v.setUint32(n8 - i * 4 - 4, parseInt(s2.substring(s2.length - 8 * i - 8, s2.length - 8 * i), 16), false);
  for (let i = 0; i < n8 / 4 - l; i++) v[i] = 0;
}
function fromRprLE(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
  const a2 = new Array(n8 / 4);
  v.forEach((ch, i) => a2[a2.length - i - 1] = ch.toString(16).padStart(8, "0"));
  return fromString(a2.join(""), 16);
}
function fromRprBE(buff, o, n8) {
  n8 = n8 || buff.byteLength;
  o = o || 0;
  const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
  const a2 = new Array(n8 / 4);
  for (let i = 0; i < n8 / 4; i++) {
    a2[i] = v.getUint32(i * 4, false).toString(16).padStart(8, "0");
  }
  return fromString(a2.join(""), 16);
}
function toString3(a2, radix) {
  return a2.toString(radix);
}
function toLEBuff(a2) {
  const buff = new Uint8Array(Math.floor((bitLength(a2) - 1) / 8) + 1);
  toRprLE(buff, 0, a2, buff.byteLength);
  return buff;
}
var zero = e(0);
var one = e(1);

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/polfield.js
var _revTable = [];
for (let i = 0; i < 256; i++) {
  _revTable[i] = _revSlow(i, 8);
}
function _revSlow(idx, bits3) {
  let res = 0;
  let a2 = idx;
  for (let i = 0; i < bits3; i++) {
    res <<= 1;
    res = res | a2 & 1;
    a2 >>= 1;
  }
  return res;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/futils.js
function exp2(F, base, e2) {
  if (isZero2(e2)) return F.one;
  const n3 = bits2(e2);
  if (n3.length == 0) return F.one;
  let res = base;
  for (let i = n3.length - 2; i >= 0; i--) {
    res = F.square(res);
    if (n3[i]) {
      res = F.mul(res, base);
    }
  }
  return res;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/fsqrt.js
function buildSqrt(F) {
  if (F.m % 2 == 1) {
    if (eq(mod2(F.p, 4), 1)) {
      if (eq(mod2(F.p, 8), 1)) {
        if (eq(mod2(F.p, 16), 1)) {
          alg5_tonelliShanks(F);
        } else if (eq(mod2(F.p, 16), 9)) {
          alg4_kong(F);
        } else {
          throw new Error("Field withot sqrt");
        }
      } else if (eq(mod2(F.p, 8), 5)) {
        alg3_atkin(F);
      } else {
        throw new Error("Field withot sqrt");
      }
    } else if (eq(mod2(F.p, 4), 3)) {
      alg2_shanks(F);
    }
  } else {
    const pm2mod4 = mod2(pow3(F.p, F.m / 2), 4);
    if (pm2mod4 == 1) {
      alg10_adj(F);
    } else if (pm2mod4 == 3) {
      alg9_adj(F);
    } else {
      alg8_complex(F);
    }
  }
}
function alg5_tonelliShanks(F) {
  F.sqrt_q = pow3(F.p, F.m);
  F.sqrt_s = 0;
  F.sqrt_t = sub(F.sqrt_q, 1);
  while (!isOdd2(F.sqrt_t)) {
    F.sqrt_s = F.sqrt_s + 1;
    F.sqrt_t = div(F.sqrt_t, 2);
  }
  let c0 = F.one;
  while (F.eq(c0, F.one)) {
    const c2 = F.random();
    F.sqrt_z = F.pow(c2, F.sqrt_t);
    c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s - 1));
  }
  F.sqrt_tm1d2 = div(sub(F.sqrt_t, 1), 2);
  F.sqrt = function(a2) {
    const F2 = this;
    if (F2.isZero(a2)) return F2.zero;
    let w = F2.pow(a2, F2.sqrt_tm1d2);
    const a0 = F2.pow(F2.mul(F2.square(w), a2), 2 ** (F2.sqrt_s - 1));
    if (F2.eq(a0, F2.negone)) return null;
    let v = F2.sqrt_s;
    let x = F2.mul(a2, w);
    let b3 = F2.mul(x, w);
    let z2 = F2.sqrt_z;
    while (!F2.eq(b3, F2.one)) {
      let b2k = F2.square(b3);
      let k = 1;
      while (!F2.eq(b2k, F2.one)) {
        b2k = F2.square(b2k);
        k++;
      }
      w = z2;
      for (let i = 0; i < v - k - 1; i++) {
        w = F2.square(w);
      }
      z2 = F2.square(w);
      b3 = F2.mul(b3, z2);
      x = F2.mul(x, w);
      v = k;
    }
    return F2.geq(x, F2.zero) ? x : F2.neg(x);
  };
}
function alg4_kong(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 4 not implemented");
  };
}
function alg3_atkin(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 3 not implemented");
  };
}
function alg2_shanks(F) {
  F.sqrt_q = pow3(F.p, F.m);
  F.sqrt_e1 = div(sub(F.sqrt_q, 3), 4);
  F.sqrt = function(a2) {
    if (this.isZero(a2)) return this.zero;
    const a1 = this.pow(a2, this.sqrt_e1);
    const a0 = this.mul(this.square(a1), a2);
    if (this.eq(a0, this.negone)) return null;
    const x = this.mul(a1, a2);
    return F.geq(x, F.zero) ? x : F.neg(x);
  };
}
function alg10_adj(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 10 not implemented");
  };
}
function alg9_adj(F) {
  F.sqrt_q = pow3(F.p, F.m / 2);
  F.sqrt_e34 = div(sub(F.sqrt_q, 3), 4);
  F.sqrt_e12 = div(sub(F.sqrt_q, 1), 2);
  F.frobenius = function(n3, x) {
    if (n3 % 2 == 1) {
      return F.conjugate(x);
    } else {
      return x;
    }
  };
  F.sqrt = function(a2) {
    const F2 = this;
    const a1 = F2.pow(a2, F2.sqrt_e34);
    const alfa = F2.mul(F2.square(a1), a2);
    const a0 = F2.mul(F2.frobenius(1, alfa), alfa);
    if (F2.eq(a0, F2.negone)) return null;
    const x0 = F2.mul(a1, a2);
    let x;
    if (F2.eq(alfa, F2.negone)) {
      x = F2.mul(x0, [F2.F.zero, F2.F.one]);
    } else {
      const b3 = F2.pow(F2.add(F2.one, alfa), F2.sqrt_e12);
      x = F2.mul(b3, x0);
    }
    return F2.geq(x, F2.zero) ? x : F2.neg(x);
  };
}
function alg8_complex(F) {
  F.sqrt = function() {
    throw new Error("Sqrt alg 8 not implemented");
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/chacha.js
function quarterRound(st, a2, b3, c2, d2) {
  st[a2] = st[a2] + st[b3] >>> 0;
  st[d2] = (st[d2] ^ st[a2]) >>> 0;
  st[d2] = (st[d2] << 16 | st[d2] >>> 16 & 65535) >>> 0;
  st[c2] = st[c2] + st[d2] >>> 0;
  st[b3] = (st[b3] ^ st[c2]) >>> 0;
  st[b3] = (st[b3] << 12 | st[b3] >>> 20 & 4095) >>> 0;
  st[a2] = st[a2] + st[b3] >>> 0;
  st[d2] = (st[d2] ^ st[a2]) >>> 0;
  st[d2] = (st[d2] << 8 | st[d2] >>> 24 & 255) >>> 0;
  st[c2] = st[c2] + st[d2] >>> 0;
  st[b3] = (st[b3] ^ st[c2]) >>> 0;
  st[b3] = (st[b3] << 7 | st[b3] >>> 25 & 127) >>> 0;
}
function doubleRound(st) {
  quarterRound(st, 0, 4, 8, 12);
  quarterRound(st, 1, 5, 9, 13);
  quarterRound(st, 2, 6, 10, 14);
  quarterRound(st, 3, 7, 11, 15);
  quarterRound(st, 0, 5, 10, 15);
  quarterRound(st, 1, 6, 11, 12);
  quarterRound(st, 2, 7, 8, 13);
  quarterRound(st, 3, 4, 9, 14);
}
var ChaCha = class {
  constructor(seed) {
    seed = seed || [0, 0, 0, 0, 0, 0, 0, 0];
    this.state = [
      1634760805,
      857760878,
      2036477234,
      1797285236,
      seed[0],
      seed[1],
      seed[2],
      seed[3],
      seed[4],
      seed[5],
      seed[6],
      seed[7],
      0,
      0,
      0,
      0
    ];
    this.idx = 16;
    this.buff = new Array(16);
  }
  nextU32() {
    if (this.idx == 16) this.update();
    return this.buff[this.idx++];
  }
  nextU64() {
    return add(mul2(this.nextU32(), 4294967296), this.nextU32());
  }
  nextBool() {
    return (this.nextU32() & 1) == 1;
  }
  update() {
    for (let i = 0; i < 16; i++) this.buff[i] = this.state[i];
    for (let i = 0; i < 10; i++) doubleRound(this.buff);
    for (let i = 0; i < 16; i++) this.buff[i] = this.buff[i] + this.state[i] >>> 0;
    this.idx = 0;
    this.state[12] = this.state[12] + 1 >>> 0;
    if (this.state[12] != 0) return;
    this.state[13] = this.state[13] + 1 >>> 0;
    if (this.state[13] != 0) return;
    this.state[14] = this.state[14] + 1 >>> 0;
    if (this.state[14] != 0) return;
    this.state[15] = this.state[15] + 1 >>> 0;
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/random.js
var import_crypto25 = __toESM(require("crypto"), 1);
function getRandomBytes(n3) {
  let array = new Uint8Array(n3);
  if (process.browser) {
    if (typeof globalThis.crypto !== "undefined") {
      globalThis.crypto.getRandomValues(array);
    } else {
      for (let i = 0; i < n3; i++) {
        array[i] = Math.random() * 4294967296 >>> 0;
      }
    }
  } else {
    import_crypto25.default.randomFillSync(array);
  }
  return array;
}
function getRandomSeed() {
  const arr = getRandomBytes(32);
  const arrV = new Uint32Array(arr.buffer);
  const seed = [];
  for (let i = 0; i < 8; i++) {
    seed.push(arrV[i]);
  }
  return seed;
}
var threadRng = null;
function getThreadRng() {
  if (threadRng) return threadRng;
  threadRng = new ChaCha(getRandomSeed());
  return threadRng;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/fft.js
var FFT = class {
  constructor(G, F, opMulGF) {
    this.F = F;
    this.G = G;
    this.opMulGF = opMulGF;
    let rem = F.sqrt_t || F.t;
    let s2 = F.sqrt_s || F.s;
    let nqr = F.one;
    while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);
    this.w = new Array(s2 + 1);
    this.wi = new Array(s2 + 1);
    this.w[s2] = this.F.pow(nqr, rem);
    this.wi[s2] = this.F.inv(this.w[s2]);
    let n3 = s2 - 1;
    while (n3 >= 0) {
      this.w[n3] = this.F.square(this.w[n3 + 1]);
      this.wi[n3] = this.F.square(this.wi[n3 + 1]);
      n3--;
    }
    this.roots = [];
    this._setRoots(Math.min(s2, 15));
  }
  _setRoots(n3) {
    for (let i = n3; i >= 0 && !this.roots[i]; i--) {
      let r2 = this.F.one;
      const nroots = 1 << i;
      const rootsi = new Array(nroots);
      for (let j = 0; j < nroots; j++) {
        rootsi[j] = r2;
        r2 = this.F.mul(r2, this.w[i]);
      }
      this.roots[i] = rootsi;
    }
  }
  fft(p) {
    if (p.length <= 1) return p;
    const bits3 = log2(p.length - 1) + 1;
    this._setRoots(bits3);
    const m = 1 << bits3;
    if (p.length != m) {
      throw new Error("Size must be multiple of 2");
    }
    const res = __fft(this, p, bits3, 0, 1);
    return res;
  }
  ifft(p) {
    if (p.length <= 1) return p;
    const bits3 = log2(p.length - 1) + 1;
    this._setRoots(bits3);
    const m = 1 << bits3;
    if (p.length != m) {
      throw new Error("Size must be multiple of 2");
    }
    const res = __fft(this, p, bits3, 0, 1);
    const twoinvm = this.F.inv(this.F.mulScalar(this.F.one, m));
    const resn = new Array(m);
    for (let i = 0; i < m; i++) {
      resn[i] = this.opMulGF(res[(m - i) % m], twoinvm);
    }
    return resn;
  }
};
function log2(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}
function __fft(PF, pall, bits3, offset, step) {
  const n3 = 1 << bits3;
  if (n3 == 1) {
    return [pall[offset]];
  } else if (n3 == 2) {
    return [
      PF.G.add(pall[offset], pall[offset + step]),
      PF.G.sub(pall[offset], pall[offset + step])
    ];
  }
  const ndiv2 = n3 >> 1;
  const p1 = __fft(PF, pall, bits3 - 1, offset, step * 2);
  const p2 = __fft(PF, pall, bits3 - 1, offset + step, step * 2);
  const out = new Array(n3);
  for (let i = 0; i < ndiv2; i++) {
    out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits3][i]));
    out[i + ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits3][i]));
  }
  return out;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/f1field.js
var ZqField = class {
  constructor(p) {
    this.type = "F1";
    this.one = BigInt(1);
    this.zero = BigInt(0);
    this.p = BigInt(p);
    this.m = 1;
    this.negone = this.p - this.one;
    this.two = BigInt(2);
    this.half = this.p >> this.one;
    this.bitLength = bitLength(this.p);
    this.mask = (this.one << BigInt(this.bitLength)) - this.one;
    this.n64 = Math.floor((this.bitLength - 1) / 64) + 1;
    this.n32 = this.n64 * 2;
    this.n8 = this.n64 * 8;
    this.R = this.e(this.one << BigInt(this.n64 * 64));
    this.Ri = this.inv(this.R);
    const e2 = this.negone >> this.one;
    this.nqr = this.two;
    let r2 = this.pow(this.nqr, e2);
    while (!this.eq(r2, this.negone)) {
      this.nqr = this.nqr + this.one;
      r2 = this.pow(this.nqr, e2);
    }
    this.s = 0;
    this.t = this.negone;
    while ((this.t & this.one) == this.zero) {
      this.s = this.s + 1;
      this.t = this.t >> this.one;
    }
    this.nqr_to_t = this.pow(this.nqr, this.t);
    buildSqrt(this);
    this.FFT = new FFT(this, this, this.mul.bind(this));
    this.fft = this.FFT.fft.bind(this.FFT);
    this.ifft = this.FFT.ifft.bind(this.FFT);
    this.w = this.FFT.w;
    this.wi = this.FFT.wi;
    this.shift = this.square(this.nqr);
    this.k = this.exp(this.nqr, 2 ** this.s);
  }
  e(a2, b3) {
    let res;
    if (!b3) {
      res = BigInt(a2);
    } else if (b3 == 16) {
      res = BigInt("0x" + a2);
    }
    if (res < 0) {
      let nres = -res;
      if (nres >= this.p) nres = nres % this.p;
      return this.p - nres;
    } else {
      return res >= this.p ? res % this.p : res;
    }
  }
  add(a2, b3) {
    const res = a2 + b3;
    return res >= this.p ? res - this.p : res;
  }
  sub(a2, b3) {
    return a2 >= b3 ? a2 - b3 : this.p - b3 + a2;
  }
  neg(a2) {
    return a2 ? this.p - a2 : a2;
  }
  mul(a2, b3) {
    return a2 * b3 % this.p;
  }
  mulScalar(base, s2) {
    return base * this.e(s2) % this.p;
  }
  square(a2) {
    return a2 * a2 % this.p;
  }
  eq(a2, b3) {
    return a2 == b3;
  }
  neq(a2, b3) {
    return a2 != b3;
  }
  lt(a2, b3) {
    const aa = a2 > this.half ? a2 - this.p : a2;
    const bb = b3 > this.half ? b3 - this.p : b3;
    return aa < bb;
  }
  gt(a2, b3) {
    const aa = a2 > this.half ? a2 - this.p : a2;
    const bb = b3 > this.half ? b3 - this.p : b3;
    return aa > bb;
  }
  leq(a2, b3) {
    const aa = a2 > this.half ? a2 - this.p : a2;
    const bb = b3 > this.half ? b3 - this.p : b3;
    return aa <= bb;
  }
  geq(a2, b3) {
    const aa = a2 > this.half ? a2 - this.p : a2;
    const bb = b3 > this.half ? b3 - this.p : b3;
    return aa >= bb;
  }
  div(a2, b3) {
    return this.mul(a2, this.inv(b3));
  }
  idiv(a2, b3) {
    if (!b3) throw new Error("Division by zero");
    return a2 / b3;
  }
  inv(a2) {
    if (!a2) throw new Error("Division by zero");
    let t = this.zero;
    let r2 = this.p;
    let newt = this.one;
    let newr = a2 % this.p;
    while (newr) {
      let q = r2 / newr;
      [t, newt] = [newt, t - q * newt];
      [r2, newr] = [newr, r2 - q * newr];
    }
    if (t < this.zero) t += this.p;
    return t;
  }
  mod(a2, b3) {
    return a2 % b3;
  }
  pow(b3, e2) {
    return exp2(this, b3, e2);
  }
  exp(b3, e2) {
    return exp2(this, b3, e2);
  }
  band(a2, b3) {
    const res = a2 & b3 & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bor(a2, b3) {
    const res = (a2 | b3) & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bxor(a2, b3) {
    const res = (a2 ^ b3) & this.mask;
    return res >= this.p ? res - this.p : res;
  }
  bnot(a2) {
    const res = a2 ^ this.mask;
    return res >= this.p ? res - this.p : res;
  }
  shl(a2, b3) {
    if (Number(b3) < this.bitLength) {
      const res = a2 << b3 & this.mask;
      return res >= this.p ? res - this.p : res;
    } else {
      const nb = this.p - b3;
      if (Number(nb) < this.bitLength) {
        return a2 >> nb;
      } else {
        return this.zero;
      }
    }
  }
  shr(a2, b3) {
    if (Number(b3) < this.bitLength) {
      return a2 >> b3;
    } else {
      const nb = this.p - b3;
      if (Number(nb) < this.bitLength) {
        const res = a2 << nb & this.mask;
        return res >= this.p ? res - this.p : res;
      } else {
        return 0;
      }
    }
  }
  land(a2, b3) {
    return a2 && b3 ? this.one : this.zero;
  }
  lor(a2, b3) {
    return a2 || b3 ? this.one : this.zero;
  }
  lnot(a2) {
    return a2 ? this.zero : this.one;
  }
  sqrt_old(n3) {
    if (n3 == this.zero) return this.zero;
    const res = this.pow(n3, this.negone >> this.one);
    if (res != this.one) return null;
    let m = this.s;
    let c2 = this.nqr_to_t;
    let t = this.pow(n3, this.t);
    let r2 = this.pow(n3, this.add(this.t, this.one) >> this.one);
    while (t != this.one) {
      let sq = this.square(t);
      let i = 1;
      while (sq != this.one) {
        i++;
        sq = this.square(sq);
      }
      let b3 = c2;
      for (let j = 0; j < m - i - 1; j++) b3 = this.square(b3);
      m = i;
      c2 = this.square(b3);
      t = this.mul(t, c2);
      r2 = this.mul(r2, b3);
    }
    if (r2 > this.p >> this.one) {
      r2 = this.neg(r2);
    }
    return r2;
  }
  normalize(a2, b3) {
    a2 = BigInt(a2, b3);
    if (a2 < 0) {
      let na = -a2;
      if (na >= this.p) na = na % this.p;
      return this.p - na;
    } else {
      return a2 >= this.p ? a2 % this.p : a2;
    }
  }
  random() {
    const nBytes = this.bitLength * 2 / 8;
    let res = this.zero;
    for (let i = 0; i < nBytes; i++) {
      res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);
    }
    return res % this.p;
  }
  toString(a2, base) {
    base = base || 10;
    let vs;
    if (a2 > this.half && base == 10) {
      const v = this.p - a2;
      vs = "-" + v.toString(base);
    } else {
      vs = a2.toString(base);
    }
    return vs;
  }
  isZero(a2) {
    return a2 == this.zero;
  }
  fromRng(rng) {
    let v;
    do {
      v = this.zero;
      for (let i = 0; i < this.n64; i++) {
        v += rng.nextU64() << BigInt(64 * i);
      }
      v &= this.mask;
    } while (v >= this.p);
    v = v * this.Ri % this.p;
    return v;
  }
  fft(a2) {
    return this.FFT.fft(a2);
  }
  ifft(a2) {
    return this.FFT.ifft(a2);
  }
  // Returns a buffer with Little Endian Representation
  toRprLE(buff, o, e2) {
    toRprLE(buff, o, e2, this.n64 * 8);
  }
  // Returns a buffer with Big Endian Representation
  toRprBE(buff, o, e2) {
    toRprBE(buff, o, e2, this.n64 * 8);
  }
  // Returns a buffer with Big Endian Montgomery Representation
  toRprBEM(buff, o, e2) {
    return this.toRprBE(buff, o, this.mul(this.R, e2));
  }
  toRprLEM(buff, o, e2) {
    return this.toRprLE(buff, o, this.mul(this.R, e2));
  }
  // Pases a buffer with Little Endian Representation
  fromRprLE(buff, o) {
    return fromRprLE(buff, o, this.n8);
  }
  // Pases a buffer with Big Endian Representation
  fromRprBE(buff, o) {
    return fromRprBE(buff, o, this.n8);
  }
  fromRprLEM(buff, o) {
    return this.mul(this.fromRprLE(buff, o), this.Ri);
  }
  fromRprBEM(buff, o) {
    return this.mul(this.fromRprBE(buff, o), this.Ri);
  }
  toObject(a2) {
    return a2;
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/bn128.js
var import_wasmcurves = __toESM(require_wasmcurves(), 1);

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  array2buffer: () => array2buffer,
  beBuff2int: () => beBuff2int,
  beInt2Buff: () => beInt2Buff,
  bitReverse: () => bitReverse,
  buffReverseBits: () => buffReverseBits,
  buffer2array: () => buffer2array,
  leBuff2int: () => leBuff2int,
  leInt2Buff: () => leInt2Buff,
  log2: () => log22,
  stringifyBigInts: () => stringifyBigInts,
  stringifyFElements: () => stringifyFElements,
  unstringifyBigInts: () => unstringifyBigInts,
  unstringifyFElements: () => unstringifyFElements
});
function stringifyBigInts(o) {
  if (typeof o == "bigint" || o.eq !== void 0) {
    return o.toString(10);
  } else if (o instanceof Uint8Array) {
    return fromRprLE(o, 0);
  } else if (Array.isArray(o)) {
    return o.map(stringifyBigInts);
  } else if (typeof o == "object") {
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = stringifyBigInts(o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function unstringifyBigInts(o) {
  if (typeof o == "string" && /^[0-9]+$/.test(o)) {
    return BigInt(o);
  } else if (typeof o == "string" && /^0x[0-9a-fA-F]+$/.test(o)) {
    return BigInt(o);
  } else if (Array.isArray(o)) {
    return o.map(unstringifyBigInts);
  } else if (typeof o == "object") {
    if (o === null) return null;
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = unstringifyBigInts(o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function beBuff2int(buff) {
  let res = BigInt(0);
  let i = buff.length;
  let offset = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i > 0) {
    if (i >= 4) {
      i -= 4;
      res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);
      offset += 4;
    } else if (i >= 2) {
      i -= 2;
      res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);
      offset += 2;
    } else {
      i -= 1;
      res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);
      offset += 1;
    }
  }
  return res;
}
function beInt2Buff(n3, len) {
  let r2 = n3;
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o = len;
  while (o > 0) {
    if (o - 4 >= 0) {
      o -= 4;
      buffV.setUint32(o, Number(r2 & BigInt(4294967295)));
      r2 = r2 >> BigInt(32);
    } else if (o - 2 >= 0) {
      o -= 2;
      buffV.setUint16(o, Number(r2 & BigInt(65535)));
      r2 = r2 >> BigInt(16);
    } else {
      o -= 1;
      buffV.setUint8(o, Number(r2 & BigInt(255)));
      r2 = r2 >> BigInt(8);
    }
  }
  if (r2) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function leBuff2int(buff) {
  let res = BigInt(0);
  let i = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i < buff.length) {
    if (i + 4 <= buff.length) {
      res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);
      i += 4;
    } else if (i + 2 <= buff.length) {
      res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);
      i += 2;
    } else {
      res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);
      i += 1;
    }
  }
  return res;
}
function leInt2Buff(n3, len) {
  let r2 = n3;
  if (typeof len === "undefined") {
    len = Math.floor((bitLength(n3) - 1) / 8) + 1;
    if (len == 0) len = 1;
  }
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o = 0;
  while (o < len) {
    if (o + 4 <= len) {
      buffV.setUint32(o, Number(r2 & BigInt(4294967295)), true);
      o += 4;
      r2 = r2 >> BigInt(32);
    } else if (o + 2 <= len) {
      buffV.setUint16(o, Number(r2 & BigInt(65535)), true);
      o += 2;
      r2 = r2 >> BigInt(16);
    } else {
      buffV.setUint8(o, Number(r2 & BigInt(255)), true);
      o += 1;
      r2 = r2 >> BigInt(8);
    }
  }
  if (r2) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function stringifyFElements(F, o) {
  if (typeof o == "bigint" || o.eq !== void 0) {
    return o.toString(10);
  } else if (o instanceof Uint8Array) {
    return F.toString(F.e(o));
  } else if (Array.isArray(o)) {
    return o.map(stringifyFElements.bind(this, F));
  } else if (typeof o == "object") {
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = stringifyFElements(F, o[k]);
    });
    return res;
  } else {
    return o;
  }
}
function unstringifyFElements(F, o) {
  if (typeof o == "string" && /^[0-9]+$/.test(o)) {
    return F.e(o);
  } else if (typeof o == "string" && /^0x[0-9a-fA-F]+$/.test(o)) {
    return F.e(o);
  } else if (Array.isArray(o)) {
    return o.map(unstringifyFElements.bind(this, F));
  } else if (typeof o == "object") {
    if (o === null) return null;
    const res = {};
    const keys = Object.keys(o);
    keys.forEach((k) => {
      res[k] = unstringifyFElements(F, o[k]);
    });
    return res;
  } else {
    return o;
  }
}
var _revTable2 = [];
for (let i = 0; i < 256; i++) {
  _revTable2[i] = _revSlow2(i, 8);
}
function _revSlow2(idx, bits3) {
  let res = 0;
  let a2 = idx;
  for (let i = 0; i < bits3; i++) {
    res <<= 1;
    res = res | a2 & 1;
    a2 >>= 1;
  }
  return res;
}
function bitReverse(idx, bits3) {
  return (_revTable2[idx >>> 24] | _revTable2[idx >>> 16 & 255] << 8 | _revTable2[idx >>> 8 & 255] << 16 | _revTable2[idx & 255] << 24) >>> 32 - bits3;
}
function log22(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}
function buffReverseBits(buff, eSize) {
  const n3 = buff.byteLength / eSize;
  const bits3 = log22(n3);
  if (n3 != 1 << bits3) {
    throw new Error("Invalid number of pointers");
  }
  for (let i = 0; i < n3; i++) {
    const r2 = bitReverse(i, bits3);
    if (i > r2) {
      const tmp = buff.slice(i * eSize, (i + 1) * eSize);
      buff.set(buff.slice(r2 * eSize, (r2 + 1) * eSize), i * eSize);
      buff.set(tmp, r2 * eSize);
    }
  }
}
function array2buffer(arr, sG) {
  const buff = new Uint8Array(sG * arr.length);
  for (let i = 0; i < arr.length; i++) {
    buff.set(arr[i], i * sG);
  }
  return buff;
}
function buffer2array(buff, sG) {
  const n3 = buff.byteLength / sG;
  const arr = new Array(n3);
  for (let i = 0; i < n3; i++) {
    arr[i] = buff.slice(i * sG, i * sG + sG);
  }
  return arr;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/bigbuffer.js
var PAGE_SIZE = 1 << 30;
var BigBuffer = class _BigBuffer {
  constructor(size) {
    this.buffers = [];
    this.byteLength = size;
    for (let i = 0; i < size; i += PAGE_SIZE) {
      const n3 = Math.min(size - i, PAGE_SIZE);
      this.buffers.push(new Uint8Array(n3));
    }
  }
  slice(fr, to) {
    if (to === void 0) to = this.byteLength;
    if (fr === void 0) fr = 0;
    const len = to - fr;
    const firstPage = Math.floor(fr / PAGE_SIZE);
    const lastPage = Math.floor((fr + len - 1) / PAGE_SIZE);
    if (firstPage == lastPage || len == 0)
      return this.buffers[firstPage].slice(fr % PAGE_SIZE, fr % PAGE_SIZE + len);
    let buff;
    let p = firstPage;
    let o = fr % PAGE_SIZE;
    let r2 = len;
    while (r2 > 0) {
      const l = o + r2 > PAGE_SIZE ? PAGE_SIZE - o : r2;
      const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      if (l == len) return srcView.slice();
      if (!buff) {
        if (len <= PAGE_SIZE) {
          buff = new Uint8Array(len);
        } else {
          buff = new _BigBuffer(len);
        }
      }
      buff.set(srcView, len - r2);
      r2 = r2 - l;
      p++;
      o = 0;
    }
    return buff;
  }
  set(buff, offset) {
    if (offset === void 0) offset = 0;
    const len = buff.byteLength;
    if (len == 0) return;
    const firstPage = Math.floor(offset / PAGE_SIZE);
    const lastPage = Math.floor((offset + len - 1) / PAGE_SIZE);
    if (firstPage == lastPage) {
      if (buff instanceof _BigBuffer && buff.buffers.length == 1) {
        return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);
      } else {
        return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);
      }
    }
    let p = firstPage;
    let o = offset % PAGE_SIZE;
    let r2 = len;
    while (r2 > 0) {
      const l = o + r2 > PAGE_SIZE ? PAGE_SIZE - o : r2;
      const srcView = buff.slice(len - r2, len - r2 + l);
      const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);
      dstView.set(srcView);
      r2 = r2 - l;
      p++;
      o = 0;
    }
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine_batchconvert.js
function buildBatchConvert(tm, fnName, sIn, sOut) {
  return async function batchConvert(buffIn) {
    const nPoints = Math.floor(buffIn.byteLength / sIn);
    if (nPoints * sIn !== buffIn.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < tm.concurrency; i++) {
      let n3;
      if (i < tm.concurrency - 1) {
        n3 = pointsPerChunk;
      } else {
        n3 = nPoints - i * pointsPerChunk;
      }
      if (n3 == 0) continue;
      const buffChunk = buffIn.slice(i * pointsPerChunk * sIn, i * pointsPerChunk * sIn + n3 * sIn);
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffChunk },
        { cmd: "ALLOC", var: 1, len: sOut * n3 },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: n3 },
          { var: 1 }
        ] },
        { cmd: "GET", out: 0, var: 1, len: sOut * n3 }
      ];
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buffIn instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sOut);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return fullBuffOut;
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/wasm_field1.js
var WasmField1 = class {
  constructor(tm, prefix, n8, p) {
    this.tm = tm;
    this.prefix = prefix;
    this.p = p;
    this.n8 = n8;
    this.type = "F1";
    this.m = 1;
    this.half = shiftRight2(p, one);
    this.bitLength = bitLength(p);
    this.mask = sub(shiftLeft(one, this.bitLength), one);
    this.pOp1 = tm.alloc(n8);
    this.pOp2 = tm.alloc(n8);
    this.pOp3 = tm.alloc(n8);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = this.tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = this.tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
    this.n64 = Math.floor(n8 / 8);
    this.n32 = Math.floor(n8 / 4);
    if (this.n64 * 8 != this.n8) {
      throw new Error("n8 must be a multiple of 8");
    }
    this.half = shiftRight2(this.p, one);
    this.nqr = this.two;
    let r2 = this.exp(this.nqr, this.half);
    while (!this.eq(r2, this.negone)) {
      this.nqr = this.add(this.nqr, this.one);
      r2 = this.exp(this.nqr, this.half);
    }
    this.shift = this.mul(this.nqr, this.nqr);
    this.shiftInv = this.inv(this.shift);
    this.s = 0;
    let t = sub(this.p, one);
    while (!isOdd2(t)) {
      this.s = this.s + 1;
      t = shiftRight2(t, one);
    }
    this.w = [];
    this.w[this.s] = this.exp(this.nqr, t);
    for (let i = this.s - 1; i >= 0; i--) {
      this.w[i] = this.square(this.w[i + 1]);
    }
    if (!this.eq(this.w[0], this.one)) {
      throw new Error("Error calculating roots of unity");
    }
    this.batchToMontgomery = buildBatchConvert(tm, prefix + "_batchToMontgomery", this.n8, this.n8);
    this.batchFromMontgomery = buildBatchConvert(tm, prefix + "_batchFromMontgomery", this.n8, this.n8);
  }
  op2(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a2, b3) {
    return this.op2("_add", a2, b3);
  }
  eq(a2, b3) {
    return this.op2Bool("_eq", a2, b3);
  }
  isZero(a2) {
    return this.op1Bool("_isZero", a2);
  }
  sub(a2, b3) {
    return this.op2("_sub", a2, b3);
  }
  neg(a2) {
    return this.op1("_neg", a2);
  }
  inv(a2) {
    return this.op1("_inverse", a2);
  }
  toMontgomery(a2) {
    return this.op1("_toMontgomery", a2);
  }
  fromMontgomery(a2) {
    return this.op1("_fromMontgomery", a2);
  }
  mul(a2, b3) {
    return this.op2("_mul", a2, b3);
  }
  div(a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a2) {
    return this.op1("_square", a2);
  }
  isSquare(a2) {
    return this.op1Bool("_isSquare", a2);
  }
  sqrt(a2) {
    return this.op1("_sqrt", a2);
  }
  exp(a2, b3) {
    if (!(b3 instanceof Uint8Array)) {
      b3 = toLEBuff(e(b3));
    }
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b3.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  isNegative(a2) {
    return this.op1Bool("_isNegative", a2);
  }
  e(a2, b3) {
    if (a2 instanceof Uint8Array) return a2;
    let ra = e(a2, b3);
    if (isNegative(ra)) {
      ra = neg(ra);
      if (gt2(ra, this.p)) {
        ra = mod2(ra, this.p);
      }
      ra = sub(this.p, ra);
    } else {
      if (gt2(ra, this.p)) {
        ra = mod2(ra, this.p);
      }
    }
    const buff = leInt2Buff(ra, this.n8);
    return this.toMontgomery(buff);
  }
  toString(a2, radix) {
    const an = this.fromMontgomery(a2);
    const s2 = fromRprLE(an, 0);
    return toString3(s2, radix);
  }
  fromRng(rng) {
    let v;
    const buff = new Uint8Array(this.n8);
    do {
      v = zero;
      for (let i = 0; i < this.n64; i++) {
        v = add(v, shiftLeft(rng.nextU64(), 64 * i));
      }
      v = band(v, this.mask);
    } while (geq(v, this.p));
    toRprLE(buff, 0, v, this.n8);
    return buff;
  }
  random() {
    return this.fromRng(getThreadRng());
  }
  toObject(a2) {
    const an = this.fromMontgomery(a2);
    return fromRprLE(an, 0);
  }
  fromObject(a2) {
    const buff = new Uint8Array(this.n8);
    toRprLE(buff, 0, a2, this.n8);
    return this.toMontgomery(buff);
  }
  toRprLE(buff, offset, a2) {
    buff.set(this.fromMontgomery(a2), offset);
  }
  toRprBE(buff, offset, a2) {
    const buff2 = this.fromMontgomery(a2);
    for (let i = 0; i < this.n8 / 2; i++) {
      const aux = buff2[i];
      buff2[i] = buff2[this.n8 - 1 - i];
      buff2[this.n8 - 1 - i] = aux;
    }
    buff.set(buff2, offset);
  }
  fromRprLE(buff, offset) {
    offset = offset || 0;
    const res = buff.slice(offset, offset + this.n8);
    return this.toMontgomery(res);
  }
  async batchInverse(buffIn) {
    let returnArray = false;
    const sIn = this.n8;
    const sOut = this.n8;
    if (Array.isArray(buffIn)) {
      buffIn = array2buffer(buffIn, sIn);
      returnArray = true;
    } else {
      buffIn = buffIn.slice(0, buffIn.byteLength);
    }
    const nPoints = Math.floor(buffIn.byteLength / sIn);
    if (nPoints * sIn !== buffIn.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const pointsPerChunk = Math.floor(nPoints / this.tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < this.tm.concurrency; i++) {
      let n3;
      if (i < this.tm.concurrency - 1) {
        n3 = pointsPerChunk;
      } else {
        n3 = nPoints - i * pointsPerChunk;
      }
      if (n3 == 0) continue;
      const buffChunk = buffIn.slice(i * pointsPerChunk * sIn, i * pointsPerChunk * sIn + n3 * sIn);
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffChunk },
        { cmd: "ALLOC", var: 1, len: sOut * n3 },
        { cmd: "CALL", fnName: this.prefix + "_batchInverse", params: [
          { var: 0 },
          { val: sIn },
          { val: n3 },
          { var: 1 },
          { val: sOut }
        ] },
        { cmd: "GET", out: 0, var: 1, len: sOut * n3 }
      ];
      opPromises.push(
        this.tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buffIn instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sOut);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    if (returnArray) {
      return buffer2array(fullBuffOut, sOut);
    } else {
      return fullBuffOut;
    }
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/wasm_field2.js
var WasmField2 = class {
  constructor(tm, prefix, F) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.type = "F2";
    this.m = F.m * 2;
    this.n8 = this.F.n8 * 2;
    this.n32 = this.F.n32 * 2;
    this.n64 = this.F.n64 * 2;
    this.pOp1 = tm.alloc(F.n8 * 2);
    this.pOp2 = tm.alloc(F.n8 * 2);
    this.pOp3 = tm.alloc(F.n8 * 2);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
  }
  op2(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a2, b3) {
    return this.op2("_add", a2, b3);
  }
  eq(a2, b3) {
    return this.op2Bool("_eq", a2, b3);
  }
  isZero(a2) {
    return this.op1Bool("_isZero", a2);
  }
  sub(a2, b3) {
    return this.op2("_sub", a2, b3);
  }
  neg(a2) {
    return this.op1("_neg", a2);
  }
  inv(a2) {
    return this.op1("_inverse", a2);
  }
  isNegative(a2) {
    return this.op1Bool("_isNegative", a2);
  }
  toMontgomery(a2) {
    return this.op1("_toMontgomery", a2);
  }
  fromMontgomery(a2) {
    return this.op1("_fromMontgomery", a2);
  }
  mul(a2, b3) {
    return this.op2("_mul", a2, b3);
  }
  mul1(a2, b3) {
    return this.op2("_mul1", a2, b3);
  }
  div(a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a2) {
    return this.op1("_square", a2);
  }
  isSquare(a2) {
    return this.op1Bool("_isSquare", a2);
  }
  sqrt(a2) {
    return this.op1("_sqrt", a2);
  }
  exp(a2, b3) {
    if (!(b3 instanceof Uint8Array)) {
      b3 = toLEBuff(e(b3));
    }
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b3.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  e(a2, b3) {
    if (a2 instanceof Uint8Array) return a2;
    if (Array.isArray(a2) && a2.length == 2) {
      const c1 = this.F.e(a2[0], b3);
      const c2 = this.F.e(a2[1], b3);
      const res = new Uint8Array(this.F.n8 * 2);
      res.set(c1);
      res.set(c2, this.F.n8 * 2);
      return res;
    } else {
      throw new Error("invalid F2");
    }
  }
  toString(a2, radix) {
    const s1 = this.F.toString(a2.slice(0, this.F.n8), radix);
    const s2 = this.F.toString(a2.slice(this.F.n8), radix);
    return `[${s1}, ${s2}]`;
  }
  fromRng(rng) {
    const c1 = this.F.fromRng(rng);
    const c2 = this.F.fromRng(rng);
    const res = new Uint8Array(this.F.n8 * 2);
    res.set(c1);
    res.set(c2, this.F.n8);
    return res;
  }
  random() {
    return this.fromRng(getThreadRng());
  }
  toObject(a2) {
    const c1 = this.F.toObject(a2.slice(0, this.F.n8));
    const c2 = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
    return [c1, c2];
  }
  fromObject(a2) {
    const buff = new Uint8Array(this.F.n8 * 2);
    const b1 = this.F.fromObject(a2[0]);
    const b22 = this.F.fromObject(a2[1]);
    buff.set(b1);
    buff.set(b22, this.F.n8);
    return buff;
  }
  c1(a2) {
    return a2.slice(0, this.F.n8);
  }
  c2(a2) {
    return a2.slice(this.F.n8);
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/wasm_field3.js
var WasmField3 = class {
  constructor(tm, prefix, F) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.type = "F3";
    this.m = F.m * 3;
    this.n8 = this.F.n8 * 3;
    this.n32 = this.F.n32 * 3;
    this.n64 = this.F.n64 * 3;
    this.pOp1 = tm.alloc(F.n8 * 3);
    this.pOp2 = tm.alloc(F.n8 * 3);
    this.pOp3 = tm.alloc(F.n8 * 3);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = tm.getBuff(this.pOp1, this.n8);
    this.tm.instance.exports[prefix + "_one"](this.pOp1);
    this.one = tm.getBuff(this.pOp1, this.n8);
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
  }
  op2(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op2Bool(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
  }
  op1(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  op1Bool(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  eq(a2, b3) {
    return this.op2Bool("_eq", a2, b3);
  }
  isZero(a2) {
    return this.op1Bool("_isZero", a2);
  }
  add(a2, b3) {
    return this.op2("_add", a2, b3);
  }
  sub(a2, b3) {
    return this.op2("_sub", a2, b3);
  }
  neg(a2) {
    return this.op1("_neg", a2);
  }
  inv(a2) {
    return this.op1("_inverse", a2);
  }
  isNegative(a2) {
    return this.op1Bool("_isNegative", a2);
  }
  toMontgomery(a2) {
    return this.op1("_toMontgomery", a2);
  }
  fromMontgomery(a2) {
    return this.op1("_fromMontgomery", a2);
  }
  mul(a2, b3) {
    return this.op2("_mul", a2, b3);
  }
  div(a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
    this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.n8);
  }
  square(a2) {
    return this.op1("_square", a2);
  }
  isSquare(a2) {
    return this.op1Bool("_isSquare", a2);
  }
  sqrt(a2) {
    return this.op1("_sqrt", a2);
  }
  exp(a2, b3) {
    if (!(b3 instanceof Uint8Array)) {
      b3 = toLEBuff(e(b3));
    }
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b3.byteLength, this.pOp3);
    return this.getBuff(this.pOp3, this.n8);
  }
  e(a2, b3) {
    if (a2 instanceof Uint8Array) return a2;
    if (Array.isArray(a2) && a2.length == 3) {
      const c1 = this.F.e(a2[0], b3);
      const c2 = this.F.e(a2[1], b3);
      const c3 = this.F.e(a2[2], b3);
      const res = new Uint8Array(this.F.n8 * 3);
      res.set(c1);
      res.set(c2, this.F.n8);
      res.set(c3, this.F.n8 * 2);
      return res;
    } else {
      throw new Error("invalid F3");
    }
  }
  toString(a2, radix) {
    const s1 = this.F.toString(a2.slice(0, this.F.n8), radix);
    const s2 = this.F.toString(a2.slice(this.F.n8, this.F.n8 * 2), radix);
    const s3 = this.F.toString(a2.slice(this.F.n8 * 2), radix);
    return `[${s1}, ${s2}, ${s3}]`;
  }
  fromRng(rng) {
    const c1 = this.F.fromRng(rng);
    const c2 = this.F.fromRng(rng);
    const c3 = this.F.fromRng(rng);
    const res = new Uint8Array(this.F.n8 * 3);
    res.set(c1);
    res.set(c2, this.F.n8);
    res.set(c3, this.F.n8 * 2);
    return res;
  }
  random() {
    return this.fromRng(getThreadRng());
  }
  toObject(a2) {
    const c1 = this.F.toObject(a2.slice(0, this.F.n8));
    const c2 = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
    const c3 = this.F.toObject(a2.slice(this.F.n8 * 2, this.F.n8 * 3));
    return [c1, c2, c3];
  }
  fromObject(a2) {
    const buff = new Uint8Array(this.F.n8 * 3);
    const b1 = this.F.fromObject(a2[0]);
    const b22 = this.F.fromObject(a2[1]);
    const b3 = this.F.fromObject(a2[2]);
    buff.set(b1);
    buff.set(b22, this.F.n8);
    buff.set(b3, this.F.n8 * 2);
    return buff;
  }
  c1(a2) {
    return a2.slice(0, this.F.n8);
  }
  c2(a2) {
    return a2.slice(this.F.n8, this.F.n8 * 2);
  }
  c3(a2) {
    return a2.slice(this.F.n8 * 2);
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/wasm_curve.js
var WasmCurve = class {
  constructor(tm, prefix, F, pGen, pGb, cofactor) {
    this.tm = tm;
    this.prefix = prefix;
    this.F = F;
    this.pOp1 = tm.alloc(F.n8 * 3);
    this.pOp2 = tm.alloc(F.n8 * 3);
    this.pOp3 = tm.alloc(F.n8 * 3);
    this.tm.instance.exports[prefix + "_zero"](this.pOp1);
    this.zero = this.tm.getBuff(this.pOp1, F.n8 * 3);
    this.tm.instance.exports[prefix + "_zeroAffine"](this.pOp1);
    this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8 * 2);
    this.one = this.tm.getBuff(pGen, F.n8 * 3);
    this.g = this.one;
    this.oneAffine = this.tm.getBuff(pGen, F.n8 * 2);
    this.gAffine = this.oneAffine;
    this.b = this.tm.getBuff(pGb, F.n8);
    if (cofactor) {
      this.cofactor = toLEBuff(cofactor);
    }
    this.negone = this.neg(this.one);
    this.two = this.add(this.one, this.one);
    this.batchLEMtoC = buildBatchConvert(tm, prefix + "_batchLEMtoC", F.n8 * 2, F.n8);
    this.batchLEMtoU = buildBatchConvert(tm, prefix + "_batchLEMtoU", F.n8 * 2, F.n8 * 2);
    this.batchCtoLEM = buildBatchConvert(tm, prefix + "_batchCtoLEM", F.n8, F.n8 * 2);
    this.batchUtoLEM = buildBatchConvert(tm, prefix + "_batchUtoLEM", F.n8 * 2, F.n8 * 2);
    this.batchToJacobian = buildBatchConvert(tm, prefix + "_batchToJacobian", F.n8 * 2, F.n8 * 3);
    this.batchToAffine = buildBatchConvert(tm, prefix + "_batchToAffine", F.n8 * 3, F.n8 * 2);
  }
  op2(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  op2bool(opName, a2, b3) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, b3);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
  }
  op1(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  op1Affine(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 2);
  }
  op1Bool(opName, a2) {
    this.tm.setBuff(this.pOp1, a2);
    return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
  }
  add(a2, b3) {
    if (a2.byteLength == this.F.n8 * 3) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2("_add", a2, b3);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2("_addMixed", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a2.byteLength == this.F.n8 * 2) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2("_addMixed", b3, a2);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2("_addAffine", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  sub(a2, b3) {
    if (a2.byteLength == this.F.n8 * 3) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2("_sub", a2, b3);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2("_subMixed", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a2.byteLength == this.F.n8 * 2) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2("_subMixed", b3, a2);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2("_subAffine", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  neg(a2) {
    if (a2.byteLength == this.F.n8 * 3) {
      return this.op1("_neg", a2);
    } else if (a2.byteLength == this.F.n8 * 2) {
      return this.op1Affine("_negAffine", a2);
    } else {
      throw new Error("invalid point size");
    }
  }
  double(a2) {
    if (a2.byteLength == this.F.n8 * 3) {
      return this.op1("_double", a2);
    } else if (a2.byteLength == this.F.n8 * 2) {
      return this.op1("_doubleAffine", a2);
    } else {
      throw new Error("invalid point size");
    }
  }
  isZero(a2) {
    if (a2.byteLength == this.F.n8 * 3) {
      return this.op1Bool("_isZero", a2);
    } else if (a2.byteLength == this.F.n8 * 2) {
      return this.op1Bool("_isZeroAffine", a2);
    } else {
      throw new Error("invalid point size");
    }
  }
  timesScalar(a2, s2) {
    if (!(s2 instanceof Uint8Array)) {
      s2 = toLEBuff(e(s2));
    }
    let fnName;
    if (a2.byteLength == this.F.n8 * 3) {
      fnName = this.prefix + "_timesScalar";
    } else if (a2.byteLength == this.F.n8 * 2) {
      fnName = this.prefix + "_timesScalarAffine";
    } else {
      throw new Error("invalid point size");
    }
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, s2);
    this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s2.byteLength, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  timesFr(a2, s2) {
    let fnName;
    if (a2.byteLength == this.F.n8 * 3) {
      fnName = this.prefix + "_timesFr";
    } else if (a2.byteLength == this.F.n8 * 2) {
      fnName = this.prefix + "_timesFrAffine";
    } else {
      throw new Error("invalid point size");
    }
    this.tm.setBuff(this.pOp1, a2);
    this.tm.setBuff(this.pOp2, s2);
    this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);
    return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
  }
  eq(a2, b3) {
    if (a2.byteLength == this.F.n8 * 3) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2bool("_eq", a2, b3);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2bool("_eqMixed", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else if (a2.byteLength == this.F.n8 * 2) {
      if (b3.byteLength == this.F.n8 * 3) {
        return this.op2bool("_eqMixed", b3, a2);
      } else if (b3.byteLength == this.F.n8 * 2) {
        return this.op2bool("_eqAffine", a2, b3);
      } else {
        throw new Error("invalid point size");
      }
    } else {
      throw new Error("invalid point size");
    }
  }
  toAffine(a2) {
    if (a2.byteLength == this.F.n8 * 3) {
      return this.op1Affine("_toAffine", a2);
    } else if (a2.byteLength == this.F.n8 * 2) {
      return a2;
    } else {
      throw new Error("invalid point size");
    }
  }
  toJacobian(a2) {
    if (a2.byteLength == this.F.n8 * 3) {
      return a2;
    } else if (a2.byteLength == this.F.n8 * 2) {
      return this.op1("_toJacobian", a2);
    } else {
      throw new Error("invalid point size");
    }
  }
  toRprUncompressed(arr, offset, a2) {
    this.tm.setBuff(this.pOp1, a2);
    if (a2.byteLength == this.F.n8 * 3) {
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
    } else if (a2.byteLength != this.F.n8 * 2) {
      throw new Error("invalid point size");
    }
    this.tm.instance.exports[this.prefix + "_LEMtoU"](this.pOp1, this.pOp1);
    const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
    arr.set(res, offset);
  }
  fromRprUncompressed(arr, offset) {
    const buff = arr.slice(offset, offset + this.F.n8 * 2);
    this.tm.setBuff(this.pOp1, buff);
    this.tm.instance.exports[this.prefix + "_UtoLEM"](this.pOp1, this.pOp1);
    return this.tm.getBuff(this.pOp1, this.F.n8 * 2);
  }
  toRprCompressed(arr, offset, a2) {
    this.tm.setBuff(this.pOp1, a2);
    if (a2.byteLength == this.F.n8 * 3) {
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
    } else if (a2.byteLength != this.F.n8 * 2) {
      throw new Error("invalid point size");
    }
    this.tm.instance.exports[this.prefix + "_LEMtoC"](this.pOp1, this.pOp1);
    const res = this.tm.getBuff(this.pOp1, this.F.n8);
    arr.set(res, offset);
  }
  fromRprCompressed(arr, offset) {
    const buff = arr.slice(offset, offset + this.F.n8);
    this.tm.setBuff(this.pOp1, buff);
    this.tm.instance.exports[this.prefix + "_CtoLEM"](this.pOp1, this.pOp2);
    return this.tm.getBuff(this.pOp2, this.F.n8 * 2);
  }
  toUncompressed(a2) {
    const buff = new Uint8Array(this.F.n8 * 2);
    this.toRprUncompressed(buff, 0, a2);
    return buff;
  }
  toRprLEM(arr, offset, a2) {
    if (a2.byteLength == this.F.n8 * 2) {
      arr.set(a2, offset);
      return;
    } else if (a2.byteLength == this.F.n8 * 3) {
      this.tm.setBuff(this.pOp1, a2);
      this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
      const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
      arr.set(res, offset);
    } else {
      throw new Error("invalid point size");
    }
  }
  fromRprLEM(arr, offset) {
    offset = offset || 0;
    return arr.slice(offset, offset + this.F.n8 * 2);
  }
  toString(a2, radix) {
    if (a2.byteLength == this.F.n8 * 3) {
      const x = this.F.toString(a2.slice(0, this.F.n8), radix);
      const y = this.F.toString(a2.slice(this.F.n8, this.F.n8 * 2), radix);
      const z2 = this.F.toString(a2.slice(this.F.n8 * 2), radix);
      return `[ ${x}, ${y}, ${z2} ]`;
    } else if (a2.byteLength == this.F.n8 * 2) {
      const x = this.F.toString(a2.slice(0, this.F.n8), radix);
      const y = this.F.toString(a2.slice(this.F.n8), radix);
      return `[ ${x}, ${y} ]`;
    } else {
      throw new Error("invalid point size");
    }
  }
  isValid(a2) {
    if (this.isZero(a2)) return true;
    const F = this.F;
    const aa = this.toAffine(a2);
    const x = aa.slice(0, this.F.n8);
    const y = aa.slice(this.F.n8, this.F.n8 * 2);
    const x3b = F.add(F.mul(F.square(x), x), this.b);
    const y2 = F.square(y);
    return F.eq(x3b, y2);
  }
  fromRng(rng) {
    const F = this.F;
    let P = [];
    let greatest;
    let x3b;
    do {
      P[0] = F.fromRng(rng);
      greatest = rng.nextBool();
      x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);
    } while (!F.isSquare(x3b));
    P[1] = F.sqrt(x3b);
    const s2 = F.isNegative(P[1]);
    if (greatest ^ s2) P[1] = F.neg(P[1]);
    let Pbuff = new Uint8Array(this.F.n8 * 2);
    Pbuff.set(P[0]);
    Pbuff.set(P[1], this.F.n8);
    if (this.cofactor) {
      Pbuff = this.timesScalar(Pbuff, this.cofactor);
    }
    return Pbuff;
  }
  toObject(a2) {
    if (this.isZero(a2)) {
      return [
        this.F.toObject(this.F.zero),
        this.F.toObject(this.F.one),
        this.F.toObject(this.F.zero)
      ];
    }
    const x = this.F.toObject(a2.slice(0, this.F.n8));
    const y = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
    let z2;
    if (a2.byteLength == this.F.n8 * 3) {
      z2 = this.F.toObject(a2.slice(this.F.n8 * 2, this.F.n8 * 3));
    } else {
      z2 = this.F.toObject(this.F.one);
    }
    return [x, y, z2];
  }
  fromObject(a2) {
    const x = this.F.fromObject(a2[0]);
    const y = this.F.fromObject(a2[1]);
    let z2;
    if (a2.length == 3) {
      z2 = this.F.fromObject(a2[2]);
    } else {
      z2 = this.F.one;
    }
    if (this.F.isZero(z2, this.F.one)) {
      return this.zeroAffine;
    } else if (this.F.eq(z2, this.F.one)) {
      const buff = new Uint8Array(this.F.n8 * 2);
      buff.set(x);
      buff.set(y, this.F.n8);
      return buff;
    } else {
      const buff = new Uint8Array(this.F.n8 * 3);
      buff.set(x);
      buff.set(y, this.F.n8);
      buff.set(z2, this.F.n8 * 2);
      return buff;
    }
  }
  e(a2) {
    if (a2 instanceof Uint8Array) return a2;
    return this.fromObject(a2);
  }
  x(a2) {
    const tmp = this.toAffine(a2);
    return tmp.slice(0, this.F.n8);
  }
  y(a2) {
    const tmp = this.toAffine(a2);
    return tmp.slice(this.F.n8);
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/threadman_thread.js
function thread(self2) {
  const MAXMEM = 32767;
  let instance;
  let memory;
  if (self2) {
    self2.onmessage = function(e2) {
      let data4;
      if (e2.data) {
        data4 = e2.data;
      } else {
        data4 = e2;
      }
      if (data4[0].cmd == "INIT") {
        init2(data4[0]).then(function() {
          self2.postMessage(data4.result);
        });
      } else if (data4[0].cmd == "TERMINATE") {
        self2.close();
      } else {
        const res = runTask(data4);
        self2.postMessage(res);
      }
    };
  }
  async function init2(data4) {
    const code = new Uint8Array(data4.code);
    const wasmModule = await WebAssembly.compile(code);
    memory = new WebAssembly.Memory({ initial: data4.init, maximum: MAXMEM });
    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      }
    });
  }
  function alloc(length) {
    const u323 = new Uint32Array(memory.buffer, 0, 1);
    while (u323[0] & 3) u323[0]++;
    const res = u323[0];
    u323[0] += length;
    if (u323[0] + length > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 65536;
      let requiredPages = Math.floor((u323[0] + length) / 65536) + 1;
      if (requiredPages > MAXMEM) requiredPages = MAXMEM;
      memory.grow(requiredPages - currentPages);
    }
    return res;
  }
  function allocBuffer(buffer) {
    const p = alloc(buffer.byteLength);
    setBuffer(p, buffer);
    return p;
  }
  function getBuffer(pointer, length) {
    const u8 = new Uint8Array(memory.buffer);
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
  }
  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer);
    u8.set(new Uint8Array(buffer), pointer);
  }
  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init2(task[0]);
    }
    const ctx = {
      vars: [],
      out: []
    };
    const u32a = new Uint32Array(memory.buffer, 0, 1);
    const oldAlloc = u32a[0];
    for (let i = 0; i < task.length; i++) {
      switch (task[i].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i].var] = allocBuffer(task[i].buff);
          break;
        case "ALLOC":
          ctx.vars[task[i].var] = alloc(task[i].len);
          break;
        case "SET":
          setBuffer(ctx.vars[task[i].var], task[i].buff);
          break;
        case "CALL": {
          const params = [];
          for (let j = 0; j < task[i].params.length; j++) {
            const p = task[i].params[j];
            if (typeof p.var !== "undefined") {
              params.push(ctx.vars[p.var] + (p.offset || 0));
            } else if (typeof p.val != "undefined") {
              params.push(p.val);
            }
          }
          instance.exports[task[i].fnName](...params);
          break;
        }
        case "GET":
          ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
          break;
        default:
          throw new Error("Invalid cmd");
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1);
    u32b[0] = oldAlloc;
    return ctx.out;
  }
  return runTask;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/threadman.js
var import_os = __toESM(require("os"), 1);
var import_web_worker = __toESM(require_node2(), 1);
var MEM_SIZE = 25;
var Deferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
};
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var workerSource;
var threadStr = `(${thread.toString()})(self)`;
if (process.browser) {
  if (globalThis?.Blob) {
    const threadBytes = new TextEncoder().encode(threadStr);
    const workerBlob = new Blob([threadBytes], { type: "application/javascript" });
    workerSource = URL.createObjectURL(workerBlob);
  } else {
    workerSource = "data:application/javascript;base64," + globalThis.btoa(threadStr);
  }
} else {
  workerSource = "data:application/javascript;base64," + Buffer.from(threadStr).toString("base64");
}
async function buildThreadManager(wasm, singleThread) {
  const tm = new ThreadManager();
  tm.memory = new WebAssembly.Memory({ initial: MEM_SIZE });
  tm.u8 = new Uint8Array(tm.memory.buffer);
  tm.u32 = new Uint32Array(tm.memory.buffer);
  const wasmModule = await WebAssembly.compile(wasm.code);
  tm.instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": tm.memory
    }
  });
  if (process.browser && !globalThis?.Worker) {
    singleThread = true;
  }
  tm.singleThread = singleThread;
  tm.initalPFree = tm.u32[0];
  tm.pq = wasm.pq;
  tm.pr = wasm.pr;
  tm.pG1gen = wasm.pG1gen;
  tm.pG1zero = wasm.pG1zero;
  tm.pG2gen = wasm.pG2gen;
  tm.pG2zero = wasm.pG2zero;
  tm.pOneT = wasm.pOneT;
  if (singleThread) {
    tm.code = wasm.code;
    tm.taskManager = thread();
    await tm.taskManager([{
      cmd: "INIT",
      init: MEM_SIZE,
      code: tm.code.slice()
    }]);
    tm.concurrency = 1;
  } else {
    tm.workers = [];
    tm.pendingDeferreds = [];
    tm.working = [];
    let concurrency = 2;
    if (process.browser) {
      if (typeof navigator === "object" && navigator.hardwareConcurrency) {
        concurrency = navigator.hardwareConcurrency;
      }
    } else {
      concurrency = import_os.default.cpus().length;
    }
    if (concurrency == 0) {
      concurrency = 2;
    }
    if (concurrency > 64) concurrency = 64;
    tm.concurrency = concurrency;
    for (let i = 0; i < concurrency; i++) {
      tm.workers[i] = new import_web_worker.default(workerSource);
      tm.workers[i].addEventListener("message", getOnMsg(i));
      tm.working[i] = false;
    }
    const initPromises = [];
    for (let i = 0; i < tm.workers.length; i++) {
      const copyCode = wasm.code.slice();
      initPromises.push(tm.postAction(i, [{
        cmd: "INIT",
        init: MEM_SIZE,
        code: copyCode
      }], [copyCode.buffer]));
    }
    await Promise.all(initPromises);
  }
  return tm;
  function getOnMsg(i) {
    return function(e2) {
      let data4;
      if (e2 && e2.data) {
        data4 = e2.data;
      } else {
        data4 = e2;
      }
      tm.working[i] = false;
      tm.pendingDeferreds[i].resolve(data4);
      tm.processWorks();
    };
  }
}
var ThreadManager = class {
  constructor() {
    this.actionQueue = [];
    this.oldPFree = 0;
  }
  startSyncOp() {
    if (this.oldPFree != 0) throw new Error("Sync operation in progress");
    this.oldPFree = this.u32[0];
  }
  endSyncOp() {
    if (this.oldPFree == 0) throw new Error("No sync operation in progress");
    this.u32[0] = this.oldPFree;
    this.oldPFree = 0;
  }
  postAction(workerId, e2, transfers, _deferred) {
    if (this.working[workerId]) {
      throw new Error("Posting a job t a working worker");
    }
    this.working[workerId] = true;
    this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();
    this.workers[workerId].postMessage(e2, transfers);
    return this.pendingDeferreds[workerId].promise;
  }
  processWorks() {
    for (let i = 0; i < this.workers.length && this.actionQueue.length > 0; i++) {
      if (this.working[i] == false) {
        const work = this.actionQueue.shift();
        this.postAction(i, work.data, work.transfers, work.deferred);
      }
    }
  }
  queueAction(actionData, transfers) {
    const d2 = new Deferred();
    if (this.singleThread) {
      const res = this.taskManager(actionData);
      d2.resolve(res);
    } else {
      this.actionQueue.push({
        data: actionData,
        transfers,
        deferred: d2
      });
      this.processWorks();
    }
    return d2.promise;
  }
  resetMemory() {
    this.u32[0] = this.initalPFree;
  }
  allocBuff(buff) {
    const pointer = this.alloc(buff.byteLength);
    this.setBuff(pointer, buff);
    return pointer;
  }
  getBuff(pointer, length) {
    return this.u8.slice(pointer, pointer + length);
  }
  setBuff(pointer, buffer) {
    this.u8.set(new Uint8Array(buffer), pointer);
  }
  alloc(length) {
    while (this.u32[0] & 3) this.u32[0]++;
    const res = this.u32[0];
    this.u32[0] += length;
    return res;
  }
  async terminate() {
    for (let i = 0; i < this.workers.length; i++) {
      this.workers[i].postMessage([{ cmd: "TERMINATE" }]);
    }
    await sleep(200);
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine_applykey.js
function buildBatchApplyKey(curve2, groupName) {
  const G = curve2[groupName];
  const Fr2 = curve2.Fr;
  const tm = curve2.tm;
  curve2[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {
    inType = inType || "affine";
    outType = outType || "affine";
    let fnName, fnAffine;
    let sGin, sGmid, sGout;
    if (groupName == "G1") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3;
        fnName = "g1m_batchApplyKey";
      } else {
        sGin = G.F.n8 * 2;
        fnName = "g1m_batchApplyKeyMixed";
      }
      sGmid = G.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3;
      } else {
        fnAffine = "g1m_batchToAffine";
        sGout = G.F.n8 * 2;
      }
    } else if (groupName == "G2") {
      if (inType == "jacobian") {
        sGin = G.F.n8 * 3;
        fnName = "g2m_batchApplyKey";
      } else {
        sGin = G.F.n8 * 2;
        fnName = "g2m_batchApplyKeyMixed";
      }
      sGmid = G.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G.F.n8 * 3;
      } else {
        fnAffine = "g2m_batchToAffine";
        sGout = G.F.n8 * 2;
      }
    } else if (groupName == "Fr") {
      fnName = "frm_batchApplyKey";
      sGin = G.n8;
      sGmid = G.n8;
      sGout = G.n8;
    } else {
      throw new Error("Invalid group: " + groupName);
    }
    const nPoints = Math.floor(buff.byteLength / sGin);
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    inc = Fr2.e(inc);
    let t = Fr2.e(first);
    for (let i = 0; i < tm.concurrency; i++) {
      let n3;
      if (i < tm.concurrency - 1) {
        n3 = pointsPerChunk;
      } else {
        n3 = nPoints - i * pointsPerChunk;
      }
      if (n3 == 0) continue;
      const task = [];
      task.push({
        cmd: "ALLOCSET",
        var: 0,
        buff: buff.slice(i * pointsPerChunk * sGin, i * pointsPerChunk * sGin + n3 * sGin)
      });
      task.push({ cmd: "ALLOCSET", var: 1, buff: t });
      task.push({ cmd: "ALLOCSET", var: 2, buff: inc });
      task.push({ cmd: "ALLOC", var: 3, len: n3 * Math.max(sGmid, sGout) });
      task.push({
        cmd: "CALL",
        fnName,
        params: [
          { var: 0 },
          { val: n3 },
          { var: 1 },
          { var: 2 },
          { var: 3 }
        ]
      });
      if (fnAffine) {
        task.push({
          cmd: "CALL",
          fnName: fnAffine,
          params: [
            { var: 3 },
            { val: n3 },
            { var: 3 }
          ]
        });
      }
      task.push({ cmd: "GET", out: 0, var: 3, len: n3 * sGout });
      opPromises.push(tm.queueAction(task));
      t = Fr2.mul(t, Fr2.exp(inc, n3));
    }
    const result = await Promise.all(opPromises);
    let outBuff;
    if (buff instanceof BigBuffer) {
      outBuff = new BigBuffer(nPoints * sGout);
    } else {
      outBuff = new Uint8Array(nPoints * sGout);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      outBuff.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return outBuff;
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine_pairing.js
function buildPairing(curve2) {
  const tm = curve2.tm;
  curve2.pairing = function pairing(a2, b3) {
    tm.startSyncOp();
    const pA = tm.allocBuff(curve2.G1.toJacobian(a2));
    const pB = tm.allocBuff(curve2.G2.toJacobian(b3));
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports[curve2.name + "_pairing"](pA, pB, pRes);
    const res = tm.getBuff(pRes, curve2.Gt.n8);
    tm.endSyncOp();
    return res;
  };
  curve2.pairingEq = async function pairingEq() {
    let buffCt;
    let nEqs;
    if (arguments.length % 2 == 1) {
      buffCt = arguments[arguments.length - 1];
      nEqs = (arguments.length - 1) / 2;
    } else {
      buffCt = curve2.Gt.one;
      nEqs = arguments.length / 2;
    }
    const opPromises = [];
    for (let i = 0; i < nEqs; i++) {
      const task = [];
      const g1Buff = curve2.G1.toJacobian(arguments[i * 2]);
      task.push({ cmd: "ALLOCSET", var: 0, buff: g1Buff });
      task.push({ cmd: "ALLOC", var: 1, len: curve2.prePSize });
      const g2Buff = curve2.G2.toJacobian(arguments[i * 2 + 1]);
      task.push({ cmd: "ALLOCSET", var: 2, buff: g2Buff });
      task.push({ cmd: "ALLOC", var: 3, len: curve2.preQSize });
      task.push({ cmd: "ALLOC", var: 4, len: curve2.Gt.n8 });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG1", params: [
        { var: 0 },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG2", params: [
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_millerLoop", params: [
        { var: 1 },
        { var: 3 },
        { var: 4 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 4, len: curve2.Gt.n8 });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    tm.startSyncOp();
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports.ftm_one(pRes);
    for (let i = 0; i < result.length; i++) {
      const pMR = tm.allocBuff(result[i][0]);
      tm.instance.exports.ftm_mul(pRes, pMR, pRes);
    }
    tm.instance.exports[curve2.name + "_finalExponentiation"](pRes, pRes);
    const pCt = tm.allocBuff(buffCt);
    const r2 = !!tm.instance.exports.ftm_eq(pRes, pCt);
    tm.endSyncOp();
    return r2;
  };
  curve2.prepareG1 = function(p) {
    this.tm.startSyncOp();
    const pP = this.tm.allocBuff(p);
    const pPrepP = this.tm.alloc(this.prePSize);
    this.tm.instance.exports[this.name + "_prepareG1"](pP, pPrepP);
    const res = this.tm.getBuff(pPrepP, this.prePSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.prepareG2 = function(q) {
    this.tm.startSyncOp();
    const pQ = this.tm.allocBuff(q);
    const pPrepQ = this.tm.alloc(this.preQSize);
    this.tm.instance.exports[this.name + "_prepareG2"](pQ, pPrepQ);
    const res = this.tm.getBuff(pPrepQ, this.preQSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.millerLoop = function(preP, preQ) {
    this.tm.startSyncOp();
    const pPreP = this.tm.allocBuff(preP);
    const pPreQ = this.tm.allocBuff(preQ);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_millerLoop"](pPreP, pPreQ, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
  curve2.finalExponentiation = function(a2) {
    this.tm.startSyncOp();
    const pA = this.tm.allocBuff(a2);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_finalExponentiation"](pA, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine_multiexp.js
var pTSizes = [
  1,
  1,
  1,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  13,
  14,
  15,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17
];
function buildMultiexp(curve2, groupName) {
  const G = curve2[groupName];
  const tm = G.tm;
  async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {
    if (!(buffBases instanceof Uint8Array)) {
      if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
    }
    if (!(buffScalars instanceof Uint8Array)) {
      if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
    }
    inType = inType || "affine";
    let sGIn;
    let fnName;
    if (groupName == "G1") {
      if (inType == "affine") {
        fnName = "g1m_multiexpAffine_chunk";
        sGIn = G.F.n8 * 2;
      } else {
        fnName = "g1m_multiexp_chunk";
        sGIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        fnName = "g2m_multiexpAffine_chunk";
        sGIn = G.F.n8 * 2;
      } else {
        fnName = "g2m_multiexp_chunk";
        sGIn = G.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    if (nPoints == 0) return G.zero;
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log22(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffBases },
        { cmd: "ALLOCSET", var: 1, buff: buffScalars },
        { cmd: "ALLOC", var: 2, len: G.F.n8 * 3 },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { var: 1 },
          { val: sScalar },
          { val: nPoints },
          { val: i * bitChunkSize },
          { val: Math.min(sScalar * 8 - i * bitChunkSize, bitChunkSize) },
          { var: 2 }
        ] },
        { cmd: "GET", out: 0, var: 2, len: G.F.n8 * 3 }
      ];
      opPromises.push(
        G.tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let res = G.zero;
    for (let i = result.length - 1; i >= 0; i--) {
      if (!G.isZero(res)) {
        for (let j = 0; j < bitChunkSize; j++) res = G.double(res);
      }
      res = G.add(res, result[i][0]);
    }
    return res;
  }
  async function _multiExp(buffBases, buffScalars, inType, logger, logText) {
    const MAX_CHUNK_SIZE = 1 << 22;
    const MIN_CHUNK_SIZE = 1 << 10;
    let sGIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sGIn = G.F.n8 * 2;
      } else {
        sGIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sGIn = G.F.n8 * 2;
      } else {
        sGIn = G.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log22(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    let chunkSize;
    chunkSize = Math.floor(nPoints / (tm.concurrency / nChunks));
    if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;
    if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;
    const opPromises = [];
    for (let i = 0; i < nPoints; i += chunkSize) {
      if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);
      const n3 = Math.min(nPoints - i, chunkSize);
      const buffBasesChunk = buffBases.slice(i * sGIn, (i + n3) * sGIn);
      const buffScalarsChunk = buffScalars.slice(i * sScalar, (i + n3) * sScalar);
      opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then((r2) => {
        if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);
        return r2;
      }));
    }
    const result = await Promise.all(opPromises);
    let res = G.zero;
    for (let i = result.length - 1; i >= 0; i--) {
      res = G.add(res, result[i]);
    }
    return res;
  }
  G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "jacobian", logger, logText);
  };
  G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "affine", logger, logText);
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine_fft.js
function buildFFT(curve2, groupName) {
  const G = curve2[groupName];
  const Fr2 = curve2.Fr;
  const tm = G.tm;
  async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    const MAX_BITS_THREAD = 14;
    let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g1m_fftFinal";
      }
      fnFFTJoin = "g1m_fftJoin";
      fnFFTMix = "g1m_fftMix";
      if (outType == "affine") {
        sOut = G.F.n8 * 2;
        fnMid2Out = "g1m_batchToAffine";
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g2m_fftFinal";
      }
      fnFFTJoin = "g2m_fftJoin";
      fnFFTMix = "g2m_fftMix";
      if (outType == "affine") {
        sOut = G.F.n8 * 2;
        fnMid2Out = "g2m_batchToAffine";
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = G.n8;
      sMid = G.n8;
      sOut = G.n8;
      if (inverse) {
        fnFFTFinal = "frm_fftFinal";
      }
      fnFFTMix = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    }
    let returnArray = false;
    if (Array.isArray(buff)) {
      buff = array2buffer(buff, sIn);
      returnArray = true;
    } else {
      buff = buff.slice(0, buff.byteLength);
    }
    const nPoints = buff.byteLength / sIn;
    const bits3 = log22(nPoints);
    if (1 << bits3 != nPoints) {
      throw new Error("fft must be multiple of 2");
    }
    if (bits3 == Fr2.s + 1) {
      let buffOut2;
      if (inverse) {
        buffOut2 = await _fftExtInv(buff, inType, outType, logger, loggerTxt);
      } else {
        buffOut2 = await _fftExt(buff, inType, outType, logger, loggerTxt);
      }
      if (returnArray) {
        return buffer2array(buffOut2, sOut);
      } else {
        return buffOut2;
      }
    }
    let inv;
    if (inverse) {
      inv = Fr2.inv(Fr2.e(nPoints));
    }
    let buffOut;
    buffReverseBits(buff, sIn);
    let chunks;
    let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);
    let nChunks = nPoints / pointsInChunk;
    while (nChunks < tm.concurrency && pointsInChunk >= 16) {
      nChunks *= 2;
      pointsInChunk /= 2;
    }
    const l2Chunk = log22(pointsInChunk);
    const promises = [];
    for (let i = 0; i < nChunks; i++) {
      if (logger) logger.debug(`${loggerTxt}: fft ${bits3} mix start: ${i}/${nChunks}`);
      const task = [];
      task.push({ cmd: "ALLOC", var: 0, len: sMid * pointsInChunk });
      const buffChunk = buff.slice(pointsInChunk * i * sIn, pointsInChunk * (i + 1) * sIn);
      task.push({ cmd: "SET", var: 0, buff: buffChunk });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
      }
      for (let j = 1; j <= l2Chunk; j++) {
        task.push({ cmd: "CALL", fnName: fnFFTMix, params: [{ var: 0 }, { val: pointsInChunk }, { val: j }] });
      }
      if (l2Chunk == bits3) {
        if (fnFFTFinal) {
          task.push({ cmd: "ALLOCSET", var: 1, buff: inv });
          task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
            { var: 0 },
            { val: pointsInChunk },
            { var: 1 }
          ] });
        }
        if (fnMid2Out) {
          task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
        }
        task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
      } else {
        task.push({ cmd: "GET", out: 0, var: 0, len: sMid * pointsInChunk });
      }
      promises.push(tm.queueAction(task).then((r2) => {
        if (logger) logger.debug(`${loggerTxt}: fft ${bits3} mix end: ${i}/${nChunks}`);
        return r2;
      }));
    }
    chunks = await Promise.all(promises);
    for (let i = 0; i < nChunks; i++) chunks[i] = chunks[i][0];
    for (let i = l2Chunk + 1; i <= bits3; i++) {
      if (logger) logger.debug(`${loggerTxt}: fft  ${bits3}  join: ${i}/${bits3}`);
      const nGroups = 1 << bits3 - i;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises = [];
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const first = Fr2.exp(Fr2.w[i], k * pointsInChunk);
          const inc = Fr2.w[i];
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsInChunk },
            { var: 2 },
            { var: 3 }
          ] });
          if (i == bits3) {
            if (fnFFTFinal) {
              task.push({ cmd: "ALLOCSET", var: 4, buff: inv });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 0 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 1 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
            }
            if (fnMid2Out) {
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: pointsInChunk }, { var: 1 }] });
            }
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sOut });
          } else {
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sMid });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sMid });
          }
          opPromises.push(tm.queueAction(task).then((r2) => {
            if (logger) logger.debug(`${loggerTxt}: fft ${bits3} join  ${i}/${bits3}  ${j + 1}/${nGroups} ${k}/${nChunksPerGroup / 2}`);
            return r2;
          }));
        }
      }
      const res = await Promise.all(opPromises);
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    if (buff instanceof BigBuffer) {
      buffOut = new BigBuffer(nPoints * sOut);
    } else {
      buffOut = new Uint8Array(nPoints * sOut);
    }
    if (inverse) {
      buffOut.set(chunks[0].slice((pointsInChunk - 1) * sOut));
      let p = sOut;
      for (let i = nChunks - 1; i > 0; i--) {
        buffOut.set(chunks[i], p);
        p += pointsInChunk * sOut;
        delete chunks[i];
      }
      buffOut.set(chunks[0].slice(0, (pointsInChunk - 1) * sOut), p);
      delete chunks[0];
    } else {
      for (let i = 0; i < nChunks; i++) {
        buffOut.set(chunks[i], pointsInChunk * sOut * i);
        delete chunks[i];
      }
    }
    if (returnArray) {
      return buffer2array(buffOut, sOut);
    } else {
      return buffOut;
    }
  }
  async function _fftExt(buff, inType, outType, logger, loggerTxt) {
    let b1, b22;
    b1 = buff.slice(0, buff.byteLength / 2);
    b22 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    [b1, b22] = await _fftJoinExt(b1, b22, "fftJoinExt", Fr2.one, Fr2.shift, inType, "jacobian", logger, loggerTxt);
    promises.push(_fft(b1, false, "jacobian", outType, logger, loggerTxt));
    promises.push(_fft(b22, false, "jacobian", outType, logger, loggerTxt));
    const res1 = await Promise.all(promises);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {
    let b1, b22;
    b1 = buff.slice(0, buff.byteLength / 2);
    b22 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    promises.push(_fft(b1, true, inType, "jacobian", logger, loggerTxt));
    promises.push(_fft(b22, true, inType, "jacobian", logger, loggerTxt));
    [b1, b22] = await Promise.all(promises);
    const res1 = await _fftJoinExt(b1, b22, "fftJoinExtInv", Fr2.one, Fr2.shiftInv, "jacobian", outType, logger, loggerTxt);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {
    const MAX_CHUNK_SIZE = 1 << 16;
    const MIN_CHUNK_SIZE = 1 << 4;
    let fnName;
    let fnIn2Mid, fnMid2Out;
    let sOut, sIn, sMid;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      sMid = G.F.n8 * 3;
      fnName = "g1m_" + fn;
      if (outType == "affine") {
        fnMid2Out = "g1m_batchToAffine";
        sOut = G.F.n8 * 2;
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G.F.n8 * 3;
      }
      fnName = "g2m_" + fn;
      sMid = G.F.n8 * 3;
      if (outType == "affine") {
        fnMid2Out = "g2m_batchToAffine";
        sOut = G.F.n8 * 2;
      } else {
        sOut = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr2.n8;
      sOut = Fr2.n8;
      sMid = Fr2.n8;
      fnName = "frm_" + fn;
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sIn);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let chunkSize = Math.floor(nPoints / tm.concurrency);
    if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;
    if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;
    const opPromises = [];
    for (let i = 0; i < nPoints; i += chunkSize) {
      if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);
      const n3 = Math.min(nPoints - i, chunkSize);
      const firstChunk = Fr2.mul(first, Fr2.exp(inc, i));
      const task = [];
      const b1 = buff1.slice(i * sIn, (i + n3) * sIn);
      const b22 = buff2.slice(i * sIn, (i + n3) * sIn);
      task.push({ cmd: "ALLOC", var: 0, len: sMid * n3 });
      task.push({ cmd: "SET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOC", var: 1, len: sMid * n3 });
      task.push({ cmd: "SET", var: 1, buff: b22 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: n3 }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 1 }, { val: n3 }, { var: 1 }] });
      }
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: n3 },
        { var: 2 },
        { var: 3 },
        { val: Fr2.s }
      ] });
      if (fnMid2Out) {
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: n3 }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: n3 }, { var: 1 }] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: n3 * sOut });
      task.push({ cmd: "GET", out: 1, var: 1, len: n3 * sOut });
      opPromises.push(
        tm.queueAction(task).then((r2) => {
          if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);
          return r2;
        })
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (nPoints * sOut > 1 << 28) {
      fullBuffOut1 = new BigBuffer(nPoints * sOut);
      fullBuffOut2 = new BigBuffer(nPoints * sOut);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sOut);
      fullBuffOut2 = new Uint8Array(nPoints * sOut);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut1.set(result[i][0], p);
      fullBuffOut2.set(result[i][1], p);
      p += result[i][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  }
  G.fft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, false, inType, outType, logger, loggerTxt);
  };
  G.ifft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, true, inType, outType, logger, loggerTxt);
  };
  G.lagrangeEvaluations = async function(buff, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    let sIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
      } else {
        sIn = G.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G.F.n8 * 2;
      } else {
        sIn = G.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr2.n8;
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = buff.byteLength / sIn;
    const bits3 = log22(nPoints);
    if (2 ** bits3 * sIn != buff.byteLength) {
      if (logger) logger.error("lagrangeEvaluations iinvalid input size");
      throw new Error("lagrangeEvaluations invalid Input size");
    }
    if (bits3 <= Fr2.s) {
      return await G.ifft(buff, inType, outType, logger, loggerTxt);
    }
    if (bits3 > Fr2.s + 1) {
      if (logger) logger.error("lagrangeEvaluations input too big");
      throw new Error("lagrangeEvaluations input too big");
    }
    let t0 = buff.slice(0, buff.byteLength / 2);
    let t1 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const shiftToSmallM = Fr2.exp(Fr2.shift, nPoints / 2);
    const sConst = Fr2.inv(Fr2.sub(Fr2.one, shiftToSmallM));
    [t0, t1] = await _fftJoinExt(t0, t1, "prepareLagrangeEvaluation", sConst, Fr2.shiftInv, inType, "jacobian", logger, loggerTxt + " prep");
    const promises = [];
    promises.push(_fft(t0, true, "jacobian", outType, logger, loggerTxt + " t0"));
    promises.push(_fft(t1, true, "jacobian", outType, logger, loggerTxt + " t1"));
    [t0, t1] = await Promise.all(promises);
    let buffOut;
    if (t0.byteLength > 1 << 28) {
      buffOut = new BigBuffer(t0.byteLength * 2);
    } else {
      buffOut = new Uint8Array(t0.byteLength * 2);
    }
    buffOut.set(t0);
    buffOut.set(t1, t0.byteLength);
    return buffOut;
  };
  G.fftMix = async function fftMix(buff) {
    const sG = G.F.n8 * 3;
    let fnName, fnFFTJoin;
    if (groupName == "G1") {
      fnName = "g1m_fftMix";
      fnFFTJoin = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftMix";
      fnFFTJoin = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    const power = log22(nPoints);
    let nChunks = 1 << log22(tm.concurrency);
    if (nPoints <= nChunks * 2) nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const powerChunk = log22(pointsPerChunk);
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [];
      const b3 = buff.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b3 });
      for (let j = 1; j <= powerChunk; j++) {
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: pointsPerChunk },
          { val: j }
        ] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    const chunks = [];
    for (let i = 0; i < result.length; i++) chunks[i] = result[i][0];
    for (let i = powerChunk + 1; i <= power; i++) {
      const nGroups = 1 << power - i;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises2 = [];
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const first = Fr2.exp(Fr2.w[i], k * pointsPerChunk);
          const inc = Fr2.w[i];
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsPerChunk },
            { var: 2 },
            { var: 3 }
          ] });
          task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
          task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
          opPromises2.push(tm.queueAction(task));
        }
      }
      const res = await Promise.all(opPromises2);
      for (let j = 0; j < nGroups; j++) {
        for (let k = 0; k < nChunksPerGroup / 2; k++) {
          const o1 = j * nChunksPerGroup + k;
          const o2 = j * nChunksPerGroup + k + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    let fullBuffOut;
    if (buff instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sG);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sG);
    }
    let p = 0;
    for (let i = 0; i < nChunks; i++) {
      fullBuffOut.set(chunks[i], p);
      p += chunks[i].byteLength;
    }
    return fullBuffOut;
  };
  G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {
    const sG = G.F.n8 * 3;
    let fnName;
    if (groupName == "G1") {
      fnName = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sG);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let nChunks = 1 << log22(tm.concurrency);
    if (nPoints <= nChunks * 2) nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const opPromises = [];
    for (let i = 0; i < nChunks; i++) {
      const task = [];
      const firstChunk = Fr2.mul(first, Fr2.exp(inc, i * pointsPerChunk));
      const b1 = buff1.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      const b22 = buff2.slice(i * pointsPerChunk * sG, (i + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOCSET", var: 1, buff: b22 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: pointsPerChunk },
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (buff1 instanceof BigBuffer) {
      fullBuffOut1 = new BigBuffer(nPoints * sG);
      fullBuffOut2 = new BigBuffer(nPoints * sG);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sG);
      fullBuffOut2 = new Uint8Array(nPoints * sG);
    }
    let p = 0;
    for (let i = 0; i < result.length; i++) {
      fullBuffOut1.set(result[i][0], p);
      fullBuffOut2.set(result[i][1], p);
      p += result[i][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  };
  G.fftFinal = async function fftFinal(buff, factor) {
    const sG = G.F.n8 * 3;
    const sGout = G.F.n8 * 2;
    let fnName, fnToAffine;
    if (groupName == "G1") {
      fnName = "g1m_fftFinal";
      fnToAffine = "g1m_batchToAffine";
    } else if (groupName == "G2") {
      fnName = "g2m_fftFinal";
      fnToAffine = "g2m_batchToAffine";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    if (nPoints != 1 << log22(nPoints)) {
      throw new Error("Invalid number of points");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i = 0; i < tm.concurrency; i++) {
      let n3;
      if (i < tm.concurrency - 1) {
        n3 = pointsPerChunk;
      } else {
        n3 = nPoints - i * pointsPerChunk;
      }
      if (n3 == 0) continue;
      const task = [];
      const b3 = buff.slice(i * pointsPerChunk * sG, (i * pointsPerChunk + n3) * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b3 });
      task.push({ cmd: "ALLOCSET", var: 1, buff: factor });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { val: n3 },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: fnToAffine, params: [
        { var: 0 },
        { val: n3 },
        { var: 0 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: n3 * sGout });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buff instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sGout);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sGout);
    }
    let p = 0;
    for (let i = result.length - 1; i >= 0; i--) {
      fullBuffOut.set(result[i][0], p);
      p += result[i][0].byteLength;
    }
    return fullBuffOut;
  };
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/engine.js
async function buildEngine(params) {
  const tm = await buildThreadManager(params.wasm, params.singleThread);
  const curve2 = {};
  curve2.q = e(params.wasm.q.toString());
  curve2.r = e(params.wasm.r.toString());
  curve2.name = params.name;
  curve2.tm = tm;
  curve2.prePSize = params.wasm.prePSize;
  curve2.preQSize = params.wasm.preQSize;
  curve2.Fr = new WasmField1(tm, "frm", params.n8r, params.r);
  curve2.F1 = new WasmField1(tm, "f1m", params.n8q, params.q);
  curve2.F2 = new WasmField2(tm, "f2m", curve2.F1);
  curve2.G1 = new WasmCurve(tm, "g1m", curve2.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);
  curve2.G2 = new WasmCurve(tm, "g2m", curve2.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);
  curve2.F6 = new WasmField3(tm, "f6m", curve2.F2);
  curve2.F12 = new WasmField2(tm, "ftm", curve2.F6);
  curve2.Gt = curve2.F12;
  buildBatchApplyKey(curve2, "G1");
  buildBatchApplyKey(curve2, "G2");
  buildBatchApplyKey(curve2, "Fr");
  buildMultiexp(curve2, "G1");
  buildMultiexp(curve2, "G2");
  buildFFT(curve2, "G1");
  buildFFT(curve2, "G2");
  buildFFT(curve2, "Fr");
  buildPairing(curve2);
  curve2.array2buffer = function(arr, sG) {
    const buff = new Uint8Array(sG * arr.length);
    for (let i = 0; i < arr.length; i++) {
      buff.set(arr[i], i * sG);
    }
    return buff;
  };
  curve2.buffer2array = function(buff, sG) {
    const n3 = buff.byteLength / sG;
    const arr = new Array(n3);
    for (let i = 0; i < n3; i++) {
      arr[i] = buff.slice(i * sG, i * sG + sG);
    }
    return arr;
  };
  return curve2;
}

// ../../node_modules/.pnpm/wasmbuilder@0.0.16/node_modules/wasmbuilder/src/utils.js
function toNumber3(n3) {
  return BigInt(n3);
}
function isNegative2(n3) {
  return n3 < 0n;
}
function isZero3(n3) {
  return n3 === 0n;
}
function bitLength2(n3) {
  if (isNegative2(n3)) {
    return n3.toString(2).length - 1;
  } else {
    return n3.toString(2).length;
  }
}
function u322(n3) {
  const b3 = [];
  const v = toNumber3(n3);
  b3.push(Number(v & 0xFFn));
  b3.push(Number(v >> 8n & 0xFFn));
  b3.push(Number(v >> 16n & 0xFFn));
  b3.push(Number(v >> 24n & 0xFFn));
  return b3;
}
function toUTF8Array(str) {
  var utf8 = [];
  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);
    if (charcode < 128) utf8.push(charcode);
    else if (charcode < 2048) {
      utf8.push(
        192 | charcode >> 6,
        128 | charcode & 63
      );
    } else if (charcode < 55296 || charcode >= 57344) {
      utf8.push(
        224 | charcode >> 12,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    } else {
      i++;
      charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
      utf8.push(
        240 | charcode >> 18,
        128 | charcode >> 12 & 63,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    }
  }
  return utf8;
}
function string(str) {
  const bytes2 = toUTF8Array(str);
  return [...varuint32(bytes2.length), ...bytes2];
}
function varuint(n3) {
  const code = [];
  let v = toNumber3(n3);
  if (isNegative2(v)) throw new Error("Number cannot be negative");
  while (!isZero3(v)) {
    code.push(Number(v & 0x7Fn));
    v = v >> 7n;
  }
  if (code.length == 0) code.push(0);
  for (let i = 0; i < code.length - 1; i++) {
    code[i] = code[i] | 128;
  }
  return code;
}
function varint(_n) {
  let n3, sign;
  const bits3 = bitLength2(_n);
  if (_n < 0) {
    sign = true;
    n3 = (1n << BigInt(bits3)) + _n;
  } else {
    sign = false;
    n3 = toNumber3(_n);
  }
  const paddingBits = 7 - bits3 % 7;
  const padding4 = (1n << BigInt(paddingBits)) - 1n << BigInt(bits3);
  const paddingMask = (1 << 7 - paddingBits) - 1 | 128;
  const code = varuint(n3 + padding4);
  if (!sign) {
    code[code.length - 1] = code[code.length - 1] & paddingMask;
  }
  return code;
}
function varint32(n3) {
  let v = toNumber3(n3);
  if (v > 0xFFFFFFFFn) throw new Error("Number too big");
  if (v > 0x7FFFFFFFn) v = v - 0x100000000n;
  if (v < -2147483648n) throw new Error("Number too small");
  return varint(v);
}
function varint64(n3) {
  let v = toNumber3(n3);
  if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error("Number too big");
  if (v > 0x7FFFFFFFFFFFFFFFn) v = v - 0x10000000000000000n;
  if (v < -9223372036854775808n) throw new Error("Number too small");
  return varint(v);
}
function varuint32(n3) {
  let v = toNumber3(n3);
  if (v > 0xFFFFFFFFn) throw new Error("Number too big");
  return varuint(v);
}
function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}

// ../../node_modules/.pnpm/wasmbuilder@0.0.16/node_modules/wasmbuilder/src/codebuilder.js
var CodeBuilder = class {
  constructor(func) {
    this.func = func;
    this.functionName = func.functionName;
    this.module = func.module;
  }
  setLocal(localName, valCode) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [...valCode, 33, ...varuint32(idx)];
  }
  teeLocal(localName, valCode) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [...valCode, 34, ...varuint32(idx)];
  }
  getLocal(localName) {
    const idx = this.func.localIdxByName[localName];
    if (idx === void 0)
      throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
    return [32, ...varuint32(idx)];
  }
  i64_load8_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 48, align, ...varuint32(offset)];
  }
  i64_load8_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 49, align, ...varuint32(offset)];
  }
  i64_load16_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 50, align, ...varuint32(offset)];
  }
  i64_load16_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 51, align, ...varuint32(offset)];
  }
  i64_load32_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 52, align, ...varuint32(offset)];
  }
  i64_load32_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 53, align, ...varuint32(offset)];
  }
  i64_load(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 3 : _align;
    return [...idxCode, 41, align, ...varuint32(offset)];
  }
  i64_store(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 3;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 3;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 55, align, ...varuint32(offset)];
  }
  i64_store32(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 2;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 2;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 62, align, ...varuint32(offset)];
  }
  i64_store16(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 1;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 1;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 61, align, ...varuint32(offset)];
  }
  i64_store8(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 0;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 0;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 60, align, ...varuint32(offset)];
  }
  i32_load8_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 44, align, ...varuint32(offset)];
  }
  i32_load8_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 0 : _align;
    return [...idxCode, 45, align, ...varuint32(offset)];
  }
  i32_load16_s(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 46, align, ...varuint32(offset)];
  }
  i32_load16_u(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 1 : _align;
    return [...idxCode, 47, align, ...varuint32(offset)];
  }
  i32_load(idxCode, _offset, _align) {
    const offset = _offset || 0;
    const align = _align === void 0 ? 2 : _align;
    return [...idxCode, 40, align, ...varuint32(offset)];
  }
  i32_store(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 2;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 2;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 54, align, ...varuint32(offset)];
  }
  i32_store16(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 1;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 1;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 59, align, ...varuint32(offset)];
  }
  i32_store8(idxCode, _offset, _align, _codeVal) {
    let offset, align, codeVal;
    if (Array.isArray(_offset)) {
      offset = 0;
      align = 0;
      codeVal = _offset;
    } else if (Array.isArray(_align)) {
      offset = _offset;
      align = 0;
      codeVal = _align;
    } else if (Array.isArray(_codeVal)) {
      offset = _offset;
      align = _align;
      codeVal = _codeVal;
    }
    return [...idxCode, ...codeVal, 58, align, ...varuint32(offset)];
  }
  call(fnName, ...args) {
    const idx = this.module.functionIdxByName[fnName];
    if (idx === void 0)
      throw new Error(`Function not defined: Function: ${fnName}`);
    return [...[].concat(...args), 16, ...varuint32(idx)];
  }
  call_indirect(fnIdx, ...args) {
    return [...[].concat(...args), ...fnIdx, 17, 0, 0];
  }
  if(condCode, thenCode, elseCode) {
    if (elseCode) {
      return [...condCode, 4, 64, ...thenCode, 5, ...elseCode, 11];
    } else {
      return [...condCode, 4, 64, ...thenCode, 11];
    }
  }
  block(bCode) {
    return [2, 64, ...bCode, 11];
  }
  loop(...args) {
    return [3, 64, ...[].concat(...[...args]), 11];
  }
  br_if(relPath, condCode) {
    return [...condCode, 13, ...varuint32(relPath)];
  }
  br(relPath) {
    return [12, ...varuint32(relPath)];
  }
  ret(rCode) {
    return [...rCode, 15];
  }
  drop(dCode) {
    return [...dCode, 26];
  }
  i64_const(num) {
    return [66, ...varint64(num)];
  }
  i32_const(num) {
    return [65, ...varint32(num)];
  }
  i64_eqz(opcode) {
    return [...opcode, 80];
  }
  i64_eq(op1code, op2code) {
    return [...op1code, ...op2code, 81];
  }
  i64_ne(op1code, op2code) {
    return [...op1code, ...op2code, 82];
  }
  i64_lt_s(op1code, op2code) {
    return [...op1code, ...op2code, 83];
  }
  i64_lt_u(op1code, op2code) {
    return [...op1code, ...op2code, 84];
  }
  i64_gt_s(op1code, op2code) {
    return [...op1code, ...op2code, 85];
  }
  i64_gt_u(op1code, op2code) {
    return [...op1code, ...op2code, 86];
  }
  i64_le_s(op1code, op2code) {
    return [...op1code, ...op2code, 87];
  }
  i64_le_u(op1code, op2code) {
    return [...op1code, ...op2code, 88];
  }
  i64_ge_s(op1code, op2code) {
    return [...op1code, ...op2code, 89];
  }
  i64_ge_u(op1code, op2code) {
    return [...op1code, ...op2code, 90];
  }
  i64_add(op1code, op2code) {
    return [...op1code, ...op2code, 124];
  }
  i64_sub(op1code, op2code) {
    return [...op1code, ...op2code, 125];
  }
  i64_mul(op1code, op2code) {
    return [...op1code, ...op2code, 126];
  }
  i64_div_s(op1code, op2code) {
    return [...op1code, ...op2code, 127];
  }
  i64_div_u(op1code, op2code) {
    return [...op1code, ...op2code, 128];
  }
  i64_rem_s(op1code, op2code) {
    return [...op1code, ...op2code, 129];
  }
  i64_rem_u(op1code, op2code) {
    return [...op1code, ...op2code, 130];
  }
  i64_and(op1code, op2code) {
    return [...op1code, ...op2code, 131];
  }
  i64_or(op1code, op2code) {
    return [...op1code, ...op2code, 132];
  }
  i64_xor(op1code, op2code) {
    return [...op1code, ...op2code, 133];
  }
  i64_shl(op1code, op2code) {
    return [...op1code, ...op2code, 134];
  }
  i64_shr_s(op1code, op2code) {
    return [...op1code, ...op2code, 135];
  }
  i64_shr_u(op1code, op2code) {
    return [...op1code, ...op2code, 136];
  }
  i64_extend_i32_s(op1code) {
    return [...op1code, 172];
  }
  i64_extend_i32_u(op1code) {
    return [...op1code, 173];
  }
  i64_clz(op1code) {
    return [...op1code, 121];
  }
  i64_ctz(op1code) {
    return [...op1code, 122];
  }
  i32_eqz(op1code) {
    return [...op1code, 69];
  }
  i32_eq(op1code, op2code) {
    return [...op1code, ...op2code, 70];
  }
  i32_ne(op1code, op2code) {
    return [...op1code, ...op2code, 71];
  }
  i32_lt_s(op1code, op2code) {
    return [...op1code, ...op2code, 72];
  }
  i32_lt_u(op1code, op2code) {
    return [...op1code, ...op2code, 73];
  }
  i32_gt_s(op1code, op2code) {
    return [...op1code, ...op2code, 74];
  }
  i32_gt_u(op1code, op2code) {
    return [...op1code, ...op2code, 75];
  }
  i32_le_s(op1code, op2code) {
    return [...op1code, ...op2code, 76];
  }
  i32_le_u(op1code, op2code) {
    return [...op1code, ...op2code, 77];
  }
  i32_ge_s(op1code, op2code) {
    return [...op1code, ...op2code, 78];
  }
  i32_ge_u(op1code, op2code) {
    return [...op1code, ...op2code, 79];
  }
  i32_add(op1code, op2code) {
    return [...op1code, ...op2code, 106];
  }
  i32_sub(op1code, op2code) {
    return [...op1code, ...op2code, 107];
  }
  i32_mul(op1code, op2code) {
    return [...op1code, ...op2code, 108];
  }
  i32_div_s(op1code, op2code) {
    return [...op1code, ...op2code, 109];
  }
  i32_div_u(op1code, op2code) {
    return [...op1code, ...op2code, 110];
  }
  i32_rem_s(op1code, op2code) {
    return [...op1code, ...op2code, 111];
  }
  i32_rem_u(op1code, op2code) {
    return [...op1code, ...op2code, 112];
  }
  i32_and(op1code, op2code) {
    return [...op1code, ...op2code, 113];
  }
  i32_or(op1code, op2code) {
    return [...op1code, ...op2code, 114];
  }
  i32_xor(op1code, op2code) {
    return [...op1code, ...op2code, 115];
  }
  i32_shl(op1code, op2code) {
    return [...op1code, ...op2code, 116];
  }
  i32_shr_s(op1code, op2code) {
    return [...op1code, ...op2code, 117];
  }
  i32_shr_u(op1code, op2code) {
    return [...op1code, ...op2code, 118];
  }
  i32_rotl(op1code, op2code) {
    return [...op1code, ...op2code, 119];
  }
  i32_rotr(op1code, op2code) {
    return [...op1code, ...op2code, 120];
  }
  i32_wrap_i64(op1code) {
    return [...op1code, 167];
  }
  i32_clz(op1code) {
    return [...op1code, 103];
  }
  i32_ctz(op1code) {
    return [...op1code, 104];
  }
  unreachable() {
    return [0];
  }
  current_memory() {
    return [63, 0];
  }
  comment() {
    return [];
  }
};

// ../../node_modules/.pnpm/wasmbuilder@0.0.16/node_modules/wasmbuilder/src/functionbuilder.js
var typeCodes = {
  "i32": 127,
  "i64": 126,
  "f32": 125,
  "f64": 124,
  "anyfunc": 112,
  "func": 96,
  "emptyblock": 64
};
var FunctionBuilder = class {
  constructor(module2, fnName, fnType, moduleName, fieldName) {
    if (fnType == "import") {
      this.fnType = "import";
      this.moduleName = moduleName;
      this.fieldName = fieldName;
    } else if (fnType == "internal") {
      this.fnType = "internal";
    } else {
      throw new Error("Invalid function fnType: " + fnType);
    }
    this.module = module2;
    this.fnName = fnName;
    this.params = [];
    this.locals = [];
    this.localIdxByName = {};
    this.code = [];
    this.returnType = null;
    this.nextLocal = 0;
  }
  addParam(paramName, paramType) {
    if (this.localIdxByName[paramName])
      throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);
    const idx = this.nextLocal++;
    this.localIdxByName[paramName] = idx;
    this.params.push({
      type: paramType
    });
  }
  addLocal(localName, localType, _length) {
    const length = _length || 1;
    if (this.localIdxByName[localName])
      throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);
    const idx = this.nextLocal++;
    this.localIdxByName[localName] = idx;
    this.locals.push({
      type: localType,
      length
    });
  }
  setReturnType(returnType) {
    if (this.returnType)
      throw new Error(`returnType already defined. Function: ${this.fnName}`);
    this.returnType = returnType;
  }
  getSignature() {
    const params = [...varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];
    const returns = this.returnType ? [1, typeCodes[this.returnType]] : [0];
    return [96, ...params, ...returns];
  }
  getBody() {
    const locals = this.locals.map((l) => [
      ...varuint32(l.length),
      typeCodes[l.type]
    ]);
    const body = [
      ...varuint32(this.locals.length),
      ...[].concat(...locals),
      ...this.code,
      11
    ];
    return [
      ...varuint32(body.length),
      ...body
    ];
  }
  addCode(...code) {
    this.code.push(...[].concat(...[...code]));
  }
  getCodeBuilder() {
    return new CodeBuilder(this);
  }
};

// ../../node_modules/.pnpm/wasmbuilder@0.0.16/node_modules/wasmbuilder/src/modulebuilder.js
var ModuleBuilder = class {
  constructor() {
    this.functions = [];
    this.functionIdxByName = {};
    this.nImportFunctions = 0;
    this.nInternalFunctions = 0;
    this.memory = {
      pagesSize: 1,
      moduleName: "env",
      fieldName: "memory"
    };
    this.free = 8;
    this.datas = [];
    this.modules = {};
    this.exports = [];
    this.functionsTable = [];
  }
  build() {
    this._setSignatures();
    return new Uint8Array([
      ...u322(1836278016),
      ...u322(1),
      ...this._buildType(),
      ...this._buildImport(),
      ...this._buildFunctionDeclarations(),
      ...this._buildFunctionsTable(),
      ...this._buildExports(),
      ...this._buildElements(),
      ...this._buildCode(),
      ...this._buildData()
    ]);
  }
  addFunction(fnName) {
    if (typeof this.functionIdxByName[fnName] !== "undefined")
      throw new Error(`Function already defined: ${fnName}`);
    const idx = this.functions.length;
    this.functionIdxByName[fnName] = idx;
    this.functions.push(new FunctionBuilder(this, fnName, "internal"));
    this.nInternalFunctions++;
    return this.functions[idx];
  }
  addIimportFunction(fnName, moduleName, _fieldName) {
    if (typeof this.functionIdxByName[fnName] !== "undefined")
      throw new Error(`Function already defined: ${fnName}`);
    if (this.functions.length > 0 && this.functions[this.functions.length - 1].type == "internal")
      throw new Error(`Import functions must be declared before internal: ${fnName}`);
    let fieldName = _fieldName || fnName;
    const idx = this.functions.length;
    this.functionIdxByName[fnName] = idx;
    this.functions.push(new FunctionBuilder(this, fnName, "import", moduleName, fieldName));
    this.nImportFunctions++;
    return this.functions[idx];
  }
  setMemory(pagesSize, moduleName, fieldName) {
    this.memory = {
      pagesSize,
      moduleName: moduleName || "env",
      fieldName: fieldName || "memory"
    };
  }
  exportFunction(fnName, _exportName) {
    const exportName = _exportName || fnName;
    if (typeof this.functionIdxByName[fnName] === "undefined")
      throw new Error(`Function not defined: ${fnName}`);
    const idx = this.functionIdxByName[fnName];
    if (exportName != fnName) {
      this.functionIdxByName[exportName] = idx;
    }
    this.exports.push({
      exportName,
      idx
    });
  }
  addFunctionToTable(fnName) {
    const idx = this.functionIdxByName[fnName];
    this.functionsTable.push(idx);
  }
  addData(offset, bytes2) {
    this.datas.push({
      offset,
      bytes: bytes2
    });
  }
  alloc(a2, b3) {
    let size;
    let bytes2;
    if ((Array.isArray(a2) || ArrayBuffer.isView(a2)) && typeof b3 === "undefined") {
      size = a2.length;
      bytes2 = a2;
    } else {
      size = a2;
      bytes2 = b3;
    }
    size = (size - 1 >> 3) + 1 << 3;
    const p = this.free;
    this.free += size;
    if (bytes2) {
      this.addData(p, bytes2);
    }
    return p;
  }
  allocString(s2) {
    const encoder = new globalThis.TextEncoder();
    const uint8array = encoder.encode(s2);
    return this.alloc([...uint8array, 0]);
  }
  _setSignatures() {
    this.signatures = [];
    const signatureIdxByName = {};
    if (this.functionsTable.length > 0) {
      const signature = this.functions[this.functionsTable[0]].getSignature();
      const signatureName = "s_" + toHexString(signature);
      signatureIdxByName[signatureName] = 0;
      this.signatures.push(signature);
    }
    for (let i = 0; i < this.functions.length; i++) {
      const signature = this.functions[i].getSignature();
      const signatureName = "s_" + toHexString(signature);
      if (typeof signatureIdxByName[signatureName] === "undefined") {
        signatureIdxByName[signatureName] = this.signatures.length;
        this.signatures.push(signature);
      }
      this.functions[i].signatureIdx = signatureIdxByName[signatureName];
    }
  }
  _buildSection(sectionType, section) {
    return [sectionType, ...varuint32(section.length), ...section];
  }
  _buildType() {
    return this._buildSection(
      1,
      [
        ...varuint32(this.signatures.length),
        ...[].concat(...this.signatures)
      ]
    );
  }
  _buildImport() {
    const entries = [];
    entries.push([
      ...string(this.memory.moduleName),
      ...string(this.memory.fieldName),
      2,
      0,
      //Flags no init valua
      ...varuint32(this.memory.pagesSize)
    ]);
    for (let i = 0; i < this.nImportFunctions; i++) {
      entries.push([
        ...string(this.functions[i].moduleName),
        ...string(this.functions[i].fieldName),
        0,
        ...varuint32(this.functions[i].signatureIdx)
      ]);
    }
    return this._buildSection(
      2,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildFunctionDeclarations() {
    const entries = [];
    for (let i = this.nImportFunctions; i < this.nImportFunctions + this.nInternalFunctions; i++) {
      entries.push(...varuint32(this.functions[i].signatureIdx));
    }
    return this._buildSection(
      3,
      [
        ...varuint32(entries.length),
        ...[...entries]
      ]
    );
  }
  _buildFunctionsTable() {
    if (this.functionsTable.length == 0) return [];
    return this._buildSection(
      4,
      [
        ...varuint32(1),
        112,
        0,
        ...varuint32(this.functionsTable.length)
      ]
    );
  }
  _buildElements() {
    if (this.functionsTable.length == 0) return [];
    const entries = [];
    for (let i = 0; i < this.functionsTable.length; i++) {
      entries.push(...varuint32(this.functionsTable[i]));
    }
    return this._buildSection(
      9,
      [
        ...varuint32(1),
        // 1 entry
        ...varuint32(0),
        // Table (0 in MVP)
        65,
        // offset 0
        ...varint32(0),
        11,
        ...varuint32(this.functionsTable.length),
        // Number of elements
        ...[...entries]
      ]
    );
  }
  _buildExports() {
    const entries = [];
    for (let i = 0; i < this.exports.length; i++) {
      entries.push([
        ...string(this.exports[i].exportName),
        0,
        ...varuint32(this.exports[i].idx)
      ]);
    }
    return this._buildSection(
      7,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildCode() {
    const entries = [];
    for (let i = this.nImportFunctions; i < this.nImportFunctions + this.nInternalFunctions; i++) {
      entries.push(this.functions[i].getBody());
    }
    return this._buildSection(
      10,
      varuint32(entries.length).concat(...entries)
    );
  }
  _buildData() {
    const entries = [];
    entries.push([
      0,
      65,
      0,
      11,
      4,
      ...u322(this.free)
    ]);
    for (let i = 0; i < this.datas.length; i++) {
      entries.push([
        0,
        65,
        ...varint32(this.datas[i].offset),
        11,
        ...varuint32(this.datas[i].bytes.length),
        ...this.datas[i].bytes
      ]);
    }
    return this._buildSection(
      11,
      varuint32(entries.length).concat(...entries)
    );
  }
};

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/bn128.js
globalThis.curve_bn128 = null;
async function buildBn128(singleThread, plugins) {
  if (!singleThread && globalThis.curve_bn128) return globalThis.curve_bn128;
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  (0, import_wasmcurves.buildBn128)(moduleBuilder);
  if (plugins) plugins(moduleBuilder);
  const bn128wasm = {};
  bn128wasm.code = moduleBuilder.build();
  bn128wasm.pq = moduleBuilder.modules.f1m.pq;
  bn128wasm.pr = moduleBuilder.modules.frm.pq;
  bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;
  bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;
  bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;
  bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;
  bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;
  bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;
  bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;
  bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;
  bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;
  bn128wasm.n8q = 32;
  bn128wasm.n8r = 32;
  bn128wasm.q = moduleBuilder.modules.bn128.q;
  bn128wasm.r = moduleBuilder.modules.bn128.r;
  const params = {
    name: "bn128",
    wasm: bn128wasm,
    q: e("21888242871839275222246405745257275088696311157297823662689037894645226208583"),
    r: e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
    n8q: 32,
    n8r: 32,
    cofactorG2: e("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bn128 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bn128 = curve2;
  }
  return curve2;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/bls12381.js
var import_wasmcurves2 = __toESM(require_wasmcurves(), 1);
globalThis.curve_bls12381 = null;
async function buildBls12381(singleThread, plugins) {
  if (!singleThread && globalThis.curve_bls12381) return globalThis.curve_bls12381;
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  (0, import_wasmcurves2.buildBls12381)(moduleBuilder);
  if (plugins) plugins(moduleBuilder);
  const bls12381wasm = {};
  bls12381wasm.code = moduleBuilder.build();
  bls12381wasm.pq = moduleBuilder.modules.f1m.pq;
  bls12381wasm.pr = moduleBuilder.modules.frm.pq;
  bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;
  bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;
  bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;
  bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;
  bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;
  bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;
  bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;
  bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;
  bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;
  bls12381wasm.n8q = 48;
  bls12381wasm.n8r = 32;
  bls12381wasm.q = moduleBuilder.modules.bls12381.q;
  bls12381wasm.r = moduleBuilder.modules.bls12381.r;
  const params = {
    name: "bls12381",
    wasm: bls12381wasm,
    q: e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16),
    r: e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16),
    n8q: 48,
    n8r: 32,
    cofactorG1: e("0x396c8c005555e1568c00aaab0000aaab", 16),
    cofactorG2: e("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bls12381 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bls12381 = curve2;
  }
  return curve2;
}

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/src/curves.js
var bls12381r = e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r = e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q = e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q = e("21888242871839275222246405745257275088696311157297823662689037894645226208583");

// ../../node_modules/.pnpm/ffjavascript@0.3.0/node_modules/ffjavascript/main.js
var Scalar = scalar_exports2;
var utils = utils_exports2;

// ../../node_modules/.pnpm/fastfile@0.0.20/node_modules/fastfile/src/osfile.js
var import_fs = __toESM(require("fs"), 1);
async function open(fileName, openFlags, cacheSize, pageSize) {
  cacheSize = cacheSize || 4096 * 64;
  if (typeof openFlags !== "number" && ["w+", "wx+", "r", "ax+", "a+"].indexOf(openFlags) < 0)
    throw new Error("Invalid open option");
  const fd = await import_fs.default.promises.open(fileName, openFlags);
  const stats = await fd.stat();
  return new FastFile(fd, stats, cacheSize, pageSize, fileName);
}
var FastFile = class {
  constructor(fd, stats, cacheSize, pageSize, fileName) {
    this.fileName = fileName;
    this.fd = fd;
    this.pos = 0;
    this.pageSize = pageSize || 1 << 8;
    while (this.pageSize < stats.blksize) {
      this.pageSize *= 2;
    }
    this.totalSize = stats.size;
    this.totalPages = Math.floor((stats.size - 1) / this.pageSize) + 1;
    this.maxPagesLoaded = Math.floor(cacheSize / this.pageSize) + 1;
    this.pages = {};
    this.pendingLoads = [];
    this.writing = false;
    this.reading = false;
    this.avBuffs = [];
    this.history = {};
  }
  _loadPage(p) {
    const self2 = this;
    const P = new Promise((resolve, reject) => {
      self2.pendingLoads.push({
        page: p,
        resolve,
        reject
      });
    });
    self2.__statusPage("After Load request: ", p);
    return P;
  }
  __statusPage(s2, p) {
    const logEntry = [];
    const self2 = this;
    if (!self2.logHistory) return;
    logEntry.push("==" + s2 + " " + p);
    let S2 = "";
    for (let i = 0; i < self2.pendingLoads.length; i++) {
      if (self2.pendingLoads[i].page == p) S2 = S2 + " " + i;
    }
    if (S2) logEntry.push("Pending loads:" + S2);
    if (typeof self2.pages[p] != "undefined") {
      const page = self2.pages[p];
      logEntry.push("Loaded");
      logEntry.push("pendingOps: " + page.pendingOps);
      if (page.loading) logEntry.push("loading: " + page.loading);
      if (page.writing) logEntry.push("writing");
      if (page.dirty) logEntry.push("dirty");
    }
    logEntry.push("==");
    if (!self2.history[p]) self2.history[p] = [];
    self2.history[p].push(logEntry);
  }
  __printHistory(p) {
    const self2 = this;
    if (!self2.history[p]) console.log("Empty History ", p);
    console.log("History " + p);
    for (let i = 0; i < self2.history[p].length; i++) {
      for (let j = 0; j < self2.history[p][i].length; j++) {
        console.log("-> " + self2.history[p][i][j]);
      }
    }
  }
  _triggerLoad() {
    const self2 = this;
    if (self2.reading) return;
    if (self2.pendingLoads.length == 0) return;
    const pageIdxs = Object.keys(self2.pages);
    const deletablePages = [];
    for (let i = 0; i < pageIdxs.length; i++) {
      const page = self2.pages[parseInt(pageIdxs[i])];
      if (page.dirty == false && page.pendingOps == 0 && !page.writing && !page.loading) deletablePages.push(parseInt(pageIdxs[i]));
    }
    let freePages = self2.maxPagesLoaded - pageIdxs.length;
    const ops = [];
    while (self2.pendingLoads.length > 0 && (typeof self2.pages[self2.pendingLoads[0].page] != "undefined" || (freePages > 0 || deletablePages.length > 0))) {
      const load = self2.pendingLoads.shift();
      if (typeof self2.pages[load.page] != "undefined") {
        self2.pages[load.page].pendingOps++;
        const idx = deletablePages.indexOf(load.page);
        if (idx >= 0) deletablePages.splice(idx, 1);
        if (self2.pages[load.page].loading) {
          self2.pages[load.page].loading.push(load);
        } else {
          load.resolve();
        }
        self2.__statusPage("After Load (cached): ", load.page);
      } else {
        if (freePages) {
          freePages--;
        } else {
          const fp = deletablePages.shift();
          self2.__statusPage("Before Unload: ", fp);
          self2.avBuffs.unshift(self2.pages[fp]);
          delete self2.pages[fp];
          self2.__statusPage("After Unload: ", fp);
        }
        if (load.page >= self2.totalPages) {
          self2.pages[load.page] = getNewPage();
          load.resolve();
          self2.__statusPage("After Load (new): ", load.page);
        } else {
          self2.reading = true;
          self2.pages[load.page] = getNewPage();
          self2.pages[load.page].loading = [load];
          ops.push(self2.fd.read(self2.pages[load.page].buff, 0, self2.pageSize, load.page * self2.pageSize).then((res) => {
            self2.pages[load.page].size = res.bytesRead;
            const loading = self2.pages[load.page].loading;
            delete self2.pages[load.page].loading;
            for (let i = 0; i < loading.length; i++) {
              loading[i].resolve();
            }
            self2.__statusPage("After Load (loaded): ", load.page);
            return res;
          }, (err) => {
            load.reject(err);
          }));
          self2.__statusPage("After Load (loading): ", load.page);
        }
      }
    }
    Promise.all(ops).then(() => {
      self2.reading = false;
      if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
      self2._tryClose();
    });
    function getNewPage() {
      if (self2.avBuffs.length > 0) {
        const p = self2.avBuffs.shift();
        p.dirty = false;
        p.pendingOps = 1;
        p.size = 0;
        return p;
      } else {
        return {
          dirty: false,
          buff: new Uint8Array(self2.pageSize),
          pendingOps: 1,
          size: 0
        };
      }
    }
  }
  _triggerWrite() {
    const self2 = this;
    if (self2.writing) return;
    const pageIdxs = Object.keys(self2.pages);
    const ops = [];
    for (let i = 0; i < pageIdxs.length; i++) {
      const page = self2.pages[parseInt(pageIdxs[i])];
      if (page.dirty) {
        page.dirty = false;
        page.writing = true;
        self2.writing = true;
        ops.push(self2.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i]) * self2.pageSize).then(() => {
          page.writing = false;
          return;
        }, (err) => {
          console.log("ERROR Writing: " + err);
          self2.error = err;
          self2._tryClose();
        }));
      }
    }
    if (self2.writing) {
      Promise.all(ops).then(() => {
        self2.writing = false;
        setImmediate(self2._triggerWrite.bind(self2));
        self2._tryClose();
        if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
      });
    }
  }
  _getDirtyPage() {
    for (let p in this.pages) {
      if (this.pages[p].dirty) return p;
    }
    return -1;
  }
  async write(buff, pos) {
    if (buff.byteLength == 0) return;
    const self2 = this;
    if (typeof pos == "undefined") pos = self2.pos;
    self2.pos = pos + buff.byteLength;
    if (self2.totalSize < pos + buff.byteLength) self2.totalSize = pos + buff.byteLength;
    if (self2.pendingClose)
      throw new Error("Writing a closing file");
    const firstPage = Math.floor(pos / self2.pageSize);
    const lastPage = Math.floor((pos + buff.byteLength - 1) / self2.pageSize);
    const pagePromises = [];
    for (let i = firstPage; i <= lastPage; i++) pagePromises.push(self2._loadPage(i));
    self2._triggerLoad();
    let p = firstPage;
    let o = pos % self2.pageSize;
    let r2 = buff.byteLength;
    while (r2 > 0) {
      await pagePromises[p - firstPage];
      const l = o + r2 > self2.pageSize ? self2.pageSize - o : r2;
      const srcView = buff.slice(buff.byteLength - r2, buff.byteLength - r2 + l);
      const dstView = new Uint8Array(self2.pages[p].buff.buffer, o, l);
      dstView.set(srcView);
      self2.pages[p].dirty = true;
      self2.pages[p].pendingOps--;
      self2.pages[p].size = Math.max(o + l, self2.pages[p].size);
      if (p >= self2.totalPages) {
        self2.totalPages = p + 1;
      }
      r2 = r2 - l;
      p++;
      o = 0;
      if (!self2.writing) setImmediate(self2._triggerWrite.bind(self2));
    }
  }
  async read(len, pos) {
    const self2 = this;
    let buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  async readToBuffer(buffDst, offset, len, pos) {
    if (len == 0) {
      return;
    }
    const self2 = this;
    if (len > self2.pageSize * self2.maxPagesLoaded * 0.8) {
      const cacheSize = Math.floor(len * 1.1);
      this.maxPagesLoaded = Math.floor(cacheSize / self2.pageSize) + 1;
    }
    if (typeof pos == "undefined") pos = self2.pos;
    self2.pos = pos + len;
    if (self2.pendingClose)
      throw new Error("Reading a closing file");
    const firstPage = Math.floor(pos / self2.pageSize);
    const lastPage = Math.floor((pos + len - 1) / self2.pageSize);
    const pagePromises = [];
    for (let i = firstPage; i <= lastPage; i++) pagePromises.push(self2._loadPage(i));
    self2._triggerLoad();
    let p = firstPage;
    let o = pos % self2.pageSize;
    let r2 = pos + len > self2.totalSize ? len - (pos + len - self2.totalSize) : len;
    while (r2 > 0) {
      await pagePromises[p - firstPage];
      self2.__statusPage("After Await (read): ", p);
      const l = o + r2 > self2.pageSize ? self2.pageSize - o : r2;
      const srcView = new Uint8Array(self2.pages[p].buff.buffer, self2.pages[p].buff.byteOffset + o, l);
      buffDst.set(srcView, offset + len - r2);
      self2.pages[p].pendingOps--;
      self2.__statusPage("After Op done: ", p);
      r2 = r2 - l;
      p++;
      o = 0;
      if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
    }
    this.pos = pos + len;
  }
  _tryClose() {
    const self2 = this;
    if (!self2.pendingClose) return;
    if (self2.error) {
      self2.pendingCloseReject(self2.error);
    }
    const p = self2._getDirtyPage();
    if (p >= 0 || self2.writing || self2.reading || self2.pendingLoads.length > 0) return;
    self2.pendingClose();
  }
  close() {
    const self2 = this;
    if (self2.pendingClose)
      throw new Error("Closing the file twice");
    return new Promise((resolve, reject) => {
      self2.pendingClose = resolve;
      self2.pendingCloseReject = reject;
      self2._tryClose();
    }).then(() => {
      self2.fd.close();
    }, (err) => {
      self2.fd.close();
      throw err;
    });
  }
  async discard() {
    const self2 = this;
    await self2.close();
    await import_fs.default.promises.unlink(this.fileName);
  }
  async writeULE32(v, pos) {
    const self2 = this;
    const tmpBuff323 = new Uint8Array(4);
    const tmpBuff32v3 = new DataView(tmpBuff323.buffer);
    tmpBuff32v3.setUint32(0, v, true);
    await self2.write(tmpBuff323, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    const tmpBuff323 = new Uint8Array(4);
    const tmpBuff32v3 = new DataView(tmpBuff323.buffer);
    tmpBuff32v3.setUint32(0, v, false);
    await self2.write(tmpBuff323, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    const tmpBuff643 = new Uint8Array(8);
    const tmpBuff64v3 = new DataView(tmpBuff643.buffer);
    tmpBuff64v3.setUint32(0, v & 4294967295, true);
    tmpBuff64v3.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff643, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new Uint32Array(b3.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new DataView(b3.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b3 = await self2.read(8, pos);
    const view = new Uint32Array(b3.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    if (self2.pendingClose) {
      throw new Error("Reading a closing file");
    }
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    let currentPage = Math.floor(currentPosition / self2.pageSize);
    let endOfStringFound = false;
    let str = "";
    while (!endOfStringFound) {
      let pagePromise = self2._loadPage(currentPage);
      self2._triggerLoad();
      await pagePromise;
      self2.__statusPage("After Await (read): ", currentPage);
      let offsetOnPage = currentPosition % self2.pageSize;
      const dataArray = new Uint8Array(
        self2.pages[currentPage].buff.buffer,
        self2.pages[currentPage].buff.byteOffset + offsetOnPage,
        self2.pageSize - offsetOnPage
      );
      let indexEndOfString = dataArray.findIndex((element) => element === 0);
      endOfStringFound = indexEndOfString !== -1;
      if (endOfStringFound) {
        str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
        self2.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;
      } else {
        str += new TextDecoder().decode(dataArray);
        self2.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;
      }
      self2.pages[currentPage].pendingOps--;
      self2.__statusPage("After Op done: ", currentPage);
      currentPosition = self2.pos;
      currentPage++;
      if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
    }
    return str;
  }
};

// ../../node_modules/.pnpm/fastfile@0.0.20/node_modules/fastfile/src/memfile.js
function createNew(o) {
  const initialSize = o.initialSize || 1 << 20;
  const fd = new MemFile();
  fd.o = o;
  fd.o.data = new Uint8Array(initialSize);
  fd.allocSize = initialSize;
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting(o) {
  const fd = new MemFile();
  fd.o = o;
  fd.allocSize = o.data.byteLength;
  fd.totalSize = o.data.byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
var tmpBuff32 = new Uint8Array(4);
var tmpBuff32v = new DataView(tmpBuff32.buffer);
var tmpBuff64 = new Uint8Array(8);
var tmpBuff64v = new DataView(tmpBuff64.buffer);
var MemFile = class {
  constructor() {
    this.pageSize = 1 << 14;
  }
  _resizeIfNeeded(newLen) {
    if (newLen > this.allocSize) {
      const newAllocSize = Math.max(
        this.allocSize + (1 << 20),
        Math.floor(this.allocSize * 1.1),
        newLen
      );
      const newData = new Uint8Array(newAllocSize);
      newData.set(this.o.data);
      this.o.data = newData;
      this.allocSize = newAllocSize;
    }
  }
  async write(buff, pos) {
    const self2 = this;
    if (typeof pos == "undefined") pos = self2.pos;
    if (this.readOnly) throw new Error("Writing a read only file");
    this._resizeIfNeeded(pos + buff.byteLength);
    this.o.data.set(buff.slice(), pos);
    if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;
    this.pos = pos + buff.byteLength;
  }
  async readToBuffer(buffDest, offset, len, pos) {
    const self2 = this;
    if (typeof pos == "undefined") pos = self2.pos;
    if (this.readOnly) {
      if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
    }
    this._resizeIfNeeded(pos + len);
    const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);
    buffDest.set(buffSrc, offset);
    this.pos = pos + len;
  }
  async read(len, pos) {
    const self2 = this;
    const buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  close() {
    if (this.o.data.byteLength != this.totalSize) {
      this.o.data = this.o.data.slice(0, this.totalSize);
    }
  }
  async discard() {
  }
  async writeULE32(v, pos) {
    const self2 = this;
    tmpBuff32v.setUint32(0, v, true);
    await self2.write(tmpBuff32, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    tmpBuff32v.setUint32(0, v, false);
    await self2.write(tmpBuff32, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    tmpBuff64v.setUint32(0, v & 4294967295, true);
    tmpBuff64v.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff64, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new Uint32Array(b3.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new DataView(b3.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b3 = await self2.read(8, pos);
    const view = new Uint32Array(b3.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    if (currentPosition > this.totalSize) {
      if (this.readOnly) {
        throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos);
    }
    const dataArray = new Uint8Array(
      self2.o.data.buffer,
      currentPosition,
      this.totalSize - currentPosition
    );
    let indexEndOfString = dataArray.findIndex((element) => element === 0);
    let endOfStringFound = indexEndOfString !== -1;
    let str = "";
    if (endOfStringFound) {
      str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
      self2.pos = currentPosition + indexEndOfString + 1;
    } else {
      self2.pos = currentPosition;
    }
    return str;
  }
};

// ../../node_modules/.pnpm/fastfile@0.0.20/node_modules/fastfile/src/bigmemfile.js
var PAGE_SIZE2 = 1 << 22;
function createNew2(o) {
  const initialSize = o.initialSize || 0;
  const fd = new BigMemFile();
  fd.o = o;
  const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE2) + 1 : 0;
  fd.o.data = [];
  for (let i = 0; i < nPages - 1; i++) {
    fd.o.data.push(new Uint8Array(PAGE_SIZE2));
  }
  if (nPages) fd.o.data.push(new Uint8Array(initialSize - PAGE_SIZE2 * (nPages - 1)));
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting2(o) {
  const fd = new BigMemFile();
  fd.o = o;
  fd.totalSize = (o.data.length - 1) * PAGE_SIZE2 + o.data[o.data.length - 1].byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
var tmpBuff322 = new Uint8Array(4);
var tmpBuff32v2 = new DataView(tmpBuff322.buffer);
var tmpBuff642 = new Uint8Array(8);
var tmpBuff64v2 = new DataView(tmpBuff642.buffer);
var BigMemFile = class {
  constructor() {
    this.pageSize = 1 << 14;
  }
  _resizeIfNeeded(newLen) {
    if (newLen <= this.totalSize) return;
    if (this.readOnly) throw new Error("Reading out of file bounds");
    const nPages = Math.floor((newLen - 1) / PAGE_SIZE2) + 1;
    for (let i = Math.max(this.o.data.length - 1, 0); i < nPages; i++) {
      const newSize = i < nPages - 1 ? PAGE_SIZE2 : newLen - (nPages - 1) * PAGE_SIZE2;
      const p = new Uint8Array(newSize);
      if (i == this.o.data.length - 1) p.set(this.o.data[i]);
      this.o.data[i] = p;
    }
    this.totalSize = newLen;
  }
  async write(buff, pos) {
    const self2 = this;
    if (typeof pos == "undefined") pos = self2.pos;
    if (this.readOnly) throw new Error("Writing a read only file");
    this._resizeIfNeeded(pos + buff.byteLength);
    const firstPage = Math.floor(pos / PAGE_SIZE2);
    let p = firstPage;
    let o = pos % PAGE_SIZE2;
    let r2 = buff.byteLength;
    while (r2 > 0) {
      const l = o + r2 > PAGE_SIZE2 ? PAGE_SIZE2 - o : r2;
      const srcView = buff.slice(buff.byteLength - r2, buff.byteLength - r2 + l);
      const dstView = new Uint8Array(self2.o.data[p].buffer, o, l);
      dstView.set(srcView);
      r2 = r2 - l;
      p++;
      o = 0;
    }
    this.pos = pos + buff.byteLength;
  }
  async readToBuffer(buffDst, offset, len, pos) {
    const self2 = this;
    if (typeof pos == "undefined") pos = self2.pos;
    if (this.readOnly) {
      if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
    }
    this._resizeIfNeeded(pos + len);
    const firstPage = Math.floor(pos / PAGE_SIZE2);
    let p = firstPage;
    let o = pos % PAGE_SIZE2;
    let r2 = len;
    while (r2 > 0) {
      const l = o + r2 > PAGE_SIZE2 ? PAGE_SIZE2 - o : r2;
      const srcView = new Uint8Array(self2.o.data[p].buffer, o, l);
      buffDst.set(srcView, offset + len - r2);
      r2 = r2 - l;
      p++;
      o = 0;
    }
    this.pos = pos + len;
  }
  async read(len, pos) {
    const self2 = this;
    const buff = new Uint8Array(len);
    await self2.readToBuffer(buff, 0, len, pos);
    return buff;
  }
  close() {
  }
  async discard() {
  }
  async writeULE32(v, pos) {
    const self2 = this;
    tmpBuff32v2.setUint32(0, v, true);
    await self2.write(tmpBuff322, pos);
  }
  async writeUBE32(v, pos) {
    const self2 = this;
    tmpBuff32v2.setUint32(0, v, false);
    await self2.write(tmpBuff322, pos);
  }
  async writeULE64(v, pos) {
    const self2 = this;
    tmpBuff64v2.setUint32(0, v & 4294967295, true);
    tmpBuff64v2.setUint32(4, Math.floor(v / 4294967296), true);
    await self2.write(tmpBuff642, pos);
  }
  async readULE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new Uint32Array(b3.buffer);
    return view[0];
  }
  async readUBE32(pos) {
    const self2 = this;
    const b3 = await self2.read(4, pos);
    const view = new DataView(b3.buffer);
    return view.getUint32(0, false);
  }
  async readULE64(pos) {
    const self2 = this;
    const b3 = await self2.read(8, pos);
    const view = new Uint32Array(b3.buffer);
    return view[1] * 4294967296 + view[0];
  }
  async readString(pos) {
    const self2 = this;
    const fixedSize = 2048;
    let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
    if (currentPosition > this.totalSize) {
      if (this.readOnly) {
        throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos);
    }
    let endOfStringFound = false;
    let str = "";
    while (!endOfStringFound) {
      let currentPage = Math.floor(currentPosition / PAGE_SIZE2);
      let offsetOnPage = currentPosition % PAGE_SIZE2;
      if (self2.o.data[currentPage] === void 0) {
        throw new Error("ERROR");
      }
      let readLength = Math.min(fixedSize, self2.o.data[currentPage].length - offsetOnPage);
      const dataArray = new Uint8Array(self2.o.data[currentPage].buffer, offsetOnPage, readLength);
      let indexEndOfString = dataArray.findIndex((element) => element === 0);
      endOfStringFound = indexEndOfString !== -1;
      if (endOfStringFound) {
        str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
        self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + indexEndOfString + 1;
      } else {
        str += new TextDecoder().decode(dataArray);
        self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + dataArray.length;
      }
      currentPosition = self2.pos;
    }
    return str;
  }
};

// ../../node_modules/.pnpm/fastfile@0.0.20/node_modules/fastfile/src/fastfile.js
var import_constants6 = require("constants");
var DEFAULT_CACHE_SIZE = 1 << 16;
var DEFAULT_PAGE_SIZE = 1 << 13;
async function createOverride(o, b3, c2) {
  if (typeof o === "string") {
    o = {
      type: "file",
      fileName: o,
      cacheSize: b3 || DEFAULT_CACHE_SIZE,
      pageSize: c2 || DEFAULT_PAGE_SIZE
    };
  }
  if (o.type == "file") {
    return await open(o.fileName, import_constants6.O_TRUNC | import_constants6.O_CREAT | import_constants6.O_RDWR, o.cacheSize, o.pageSize);
  } else if (o.type == "mem") {
    return createNew(o);
  } else if (o.type == "bigMem") {
    return createNew2(o);
  } else {
    throw new Error("Invalid FastFile type: " + o.type);
  }
}
async function readExisting3(o, b3, c2) {
  if (o instanceof Uint8Array) {
    o = {
      type: "mem",
      data: o
    };
  }
  if (process.browser) {
    if (typeof o === "string") {
      const buff = await fetch(o).then(function(res) {
        return res.arrayBuffer();
      }).then(function(ab) {
        return new Uint8Array(ab);
      });
      o = {
        type: "mem",
        data: buff
      };
    }
  } else {
    if (typeof o === "string") {
      o = {
        type: "file",
        fileName: o,
        cacheSize: b3 || DEFAULT_CACHE_SIZE,
        pageSize: c2 || DEFAULT_PAGE_SIZE
      };
    }
  }
  if (o.type == "file") {
    return await open(o.fileName, import_constants6.O_RDONLY, o.cacheSize, o.pageSize);
  } else if (o.type == "mem") {
    return await readExisting(o);
  } else if (o.type == "bigMem") {
    return await readExisting2(o);
  } else {
    throw new Error("Invalid FastFile type: " + o.type);
  }
}

// ../../node_modules/.pnpm/@iden3+binfileutils@0.0.12/node_modules/@iden3/binfileutils/src/binfileutils.js
async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {
  const fd = await readExisting3(fileName, cacheSize, pageSize);
  const b3 = await fd.read(4);
  let readedType = "";
  for (let i = 0; i < 4; i++) readedType += String.fromCharCode(b3[i]);
  if (readedType != type) throw new Error(fileName + ": Invalid File format");
  let v = await fd.readULE32();
  if (v > maxVersion) throw new Error("Version not supported");
  const nSections = await fd.readULE32();
  let sections = [];
  for (let i = 0; i < nSections; i++) {
    let ht = await fd.readULE32();
    let hl = await fd.readULE64();
    if (typeof sections[ht] == "undefined") sections[ht] = [];
    sections[ht].push({
      p: fd.pos,
      size: hl
    });
    fd.pos += hl;
  }
  return { fd, sections };
}
async function createBinFile(fileName, type, version4, nSections, cacheSize, pageSize) {
  const fd = await createOverride(fileName, cacheSize, pageSize);
  const buff = new Uint8Array(4);
  for (let i = 0; i < 4; i++) buff[i] = type.charCodeAt(i);
  await fd.write(buff, 0);
  await fd.writeULE32(version4);
  await fd.writeULE32(nSections);
  return fd;
}
async function startWriteSection(fd, idSection) {
  if (typeof fd.writingSection !== "undefined") throw new Error("Already writing a section");
  await fd.writeULE32(idSection);
  fd.writingSection = {
    pSectionSize: fd.pos
  };
  await fd.writeULE64(0);
}
async function endWriteSection(fd) {
  if (typeof fd.writingSection === "undefined") throw new Error("Not writing a section");
  const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;
  const oldPos = fd.pos;
  fd.pos = fd.writingSection.pSectionSize;
  await fd.writeULE64(sectionSize);
  fd.pos = oldPos;
  delete fd.writingSection;
}
async function startReadUniqueSection(fd, sections, idSection) {
  if (typeof fd.readingSection !== "undefined") throw new Error("Already reading a section");
  if (!sections[idSection]) throw new Error(fd.fileName + ": Missing section " + idSection);
  if (sections[idSection].length > 1) throw new Error(fd.fileName + ": Section Duplicated " + idSection);
  fd.pos = sections[idSection][0].p;
  fd.readingSection = sections[idSection][0];
}
async function endReadSection(fd, noCheck) {
  if (typeof fd.readingSection === "undefined") throw new Error("Not reading a section");
  if (!noCheck) {
    if (fd.pos - fd.readingSection.p != fd.readingSection.size) throw new Error("Invalid section size reading");
  }
  delete fd.readingSection;
}
async function writeBigInt(fd, n3, n8, pos) {
  const buff = new Uint8Array(n8);
  Scalar.toRprLE(buff, 0, n3, n8);
  await fd.write(buff, pos);
}
async function readBigInt(fd, n8, pos) {
  const buff = await fd.read(n8, pos);
  return Scalar.fromRprLE(buff, 0, n8);
}
async function readSection(fd, sections, idSection, offset, length) {
  offset = typeof offset === "undefined" ? 0 : offset;
  length = typeof length === "undefined" ? sections[idSection][0].size - offset : length;
  if (offset + length > sections[idSection][0].size) {
    throw new Error("Reading out of the range of the section");
  }
  let buff;
  if (length < 1 << 30) {
    buff = new Uint8Array(length);
  } else {
    buff = new BigBuffer(length);
  }
  await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);
  return buff;
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/curves.js
var bls12381r2 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r2 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var bls12381q2 = Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
var bn128q2 = Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");
async function getCurveFromQ2(q) {
  let curve2;
  if (Scalar.eq(q, bn128q2)) {
    curve2 = await buildBn128();
  } else if (Scalar.eq(q, bls12381q2)) {
    curve2 = await buildBls12381();
  } else {
    throw new Error(`Curve not supported: ${Scalar.toString(q)}`);
  }
  return curve2;
}
async function getCurveFromName2(name) {
  let curve2;
  const normName = normalizeName(name);
  if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
    curve2 = await buildBn128();
  } else if (["BLS12381"].indexOf(normName) >= 0) {
    curve2 = await buildBls12381();
  } else {
    throw new Error(`Curve not supported: ${name}`);
  }
  return curve2;
  function normalizeName(n3) {
    return n3.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
  }
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/misc.js
var import_blake2b_wasm = __toESM(require_blake2b_wasm(), 1);
var _revTable3 = [];
for (let i = 0; i < 256; i++) {
  _revTable3[i] = _revSlow3(i, 8);
}
function _revSlow3(idx, bits3) {
  let res = 0;
  let a2 = idx;
  for (let i = 0; i < bits3; i++) {
    res <<= 1;
    res = res | a2 & 1;
    a2 >>= 1;
  }
  return res;
}
function log23(V) {
  return ((V & 4294901760) !== 0 ? (V &= 4294901760, 16) : 0) | ((V & 4278255360) !== 0 ? (V &= 4278255360, 8) : 0) | ((V & 4042322160) !== 0 ? (V &= 4042322160, 4) : 0) | ((V & 3435973836) !== 0 ? (V &= 3435973836, 2) : 0) | (V & 2863311530) !== 0;
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_constants.js
var GROTH16_PROTOCOL_ID = 1;
var PLONK_PROTOCOL_ID = 2;
var FFLONK_PROTOCOL_ID = 10;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_constants.js
var ZKEY_FF_HEADER_SECTION = 2;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_utils.js
async function readG1(fd, curve2, toObject2) {
  const buff = await fd.read(curve2.G1.F.n8 * 2);
  const res = curve2.G1.fromRprLEM(buff, 0);
  return toObject2 ? curve2.G1.toObject(res) : res;
}
async function readG2(fd, curve2, toObject2) {
  const buff = await fd.read(curve2.G2.F.n8 * 2);
  const res = curve2.G2.fromRprLEM(buff, 0);
  return toObject2 ? curve2.G2.toObject(res) : res;
}
async function readHeader(fd, sections, toObject2) {
  await startReadUniqueSection(fd, sections, 1);
  const protocolId = await fd.readULE32();
  await endReadSection(fd);
  if (protocolId === GROTH16_PROTOCOL_ID) {
    return await readHeaderGroth16(fd, sections, toObject2);
  } else if (protocolId === PLONK_PROTOCOL_ID) {
    return await readHeaderPlonk(fd, sections, toObject2);
  } else if (protocolId === FFLONK_PROTOCOL_ID) {
    return await readHeaderFFlonk(fd, sections, toObject2);
  } else {
    throw new Error("Protocol not supported: ");
  }
}
async function readHeaderGroth16(fd, sections, toObject2) {
  const zkey = {};
  zkey.protocol = "groth16";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.curve = await getCurveFromQ2(zkey.q);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject2);
  zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject2);
  zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject2);
  zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject2);
  zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject2);
  zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject2);
  await endReadSection(fd);
  return zkey;
}
async function readHeaderPlonk(fd, sections, toObject2) {
  const zkey = {};
  zkey.protocol = "plonk";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.curve = await getCurveFromQ2(zkey.q);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.nAdditions = await fd.readULE32();
  zkey.nConstraints = await fd.readULE32();
  zkey.k1 = await fd.read(n8r);
  zkey.k2 = await fd.read(n8r);
  zkey.Qm = await readG1(fd, zkey.curve, toObject2);
  zkey.Ql = await readG1(fd, zkey.curve, toObject2);
  zkey.Qr = await readG1(fd, zkey.curve, toObject2);
  zkey.Qo = await readG1(fd, zkey.curve, toObject2);
  zkey.Qc = await readG1(fd, zkey.curve, toObject2);
  zkey.S1 = await readG1(fd, zkey.curve, toObject2);
  zkey.S2 = await readG1(fd, zkey.curve, toObject2);
  zkey.S3 = await readG1(fd, zkey.curve, toObject2);
  zkey.X_2 = await readG2(fd, zkey.curve, toObject2);
  await endReadSection(fd);
  return zkey;
}
async function readHeaderFFlonk(fd, sections, toObject2) {
  const zkey = {};
  zkey.protocol = "fflonk";
  zkey.protocolId = FFLONK_PROTOCOL_ID;
  await startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);
  const n8q = await fd.readULE32();
  zkey.n8q = n8q;
  zkey.q = await readBigInt(fd, n8q);
  zkey.curve = await getCurveFromQ2(zkey.q);
  const n8r = await fd.readULE32();
  zkey.n8r = n8r;
  zkey.r = await readBigInt(fd, n8r);
  zkey.nVars = await fd.readULE32();
  zkey.nPublic = await fd.readULE32();
  zkey.domainSize = await fd.readULE32();
  zkey.power = log23(zkey.domainSize);
  zkey.nAdditions = await fd.readULE32();
  zkey.nConstraints = await fd.readULE32();
  zkey.k1 = await fd.read(n8r);
  zkey.k2 = await fd.read(n8r);
  zkey.w3 = await fd.read(n8r);
  zkey.w4 = await fd.read(n8r);
  zkey.w8 = await fd.read(n8r);
  zkey.wr = await fd.read(n8r);
  zkey.X_2 = await readG2(fd, zkey.curve, toObject2);
  zkey.C0 = await readG1(fd, zkey.curve, toObject2);
  await endReadSection(fd);
  return zkey;
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/wtns_utils.js
async function writeBin(fd, witnessBin, prime) {
  await startWriteSection(fd, 1);
  const n8 = (Math.floor((Scalar.bitLength(prime) - 1) / 64) + 1) * 8;
  await fd.writeULE32(n8);
  await writeBigInt(fd, prime, n8);
  if (witnessBin.byteLength % n8 != 0) {
    throw new Error("Invalid witness length");
  }
  await fd.writeULE32(witnessBin.byteLength / n8);
  await endWriteSection(fd);
  await startWriteSection(fd, 2);
  await fd.write(witnessBin);
  await endWriteSection(fd);
}
async function readHeader2(fd, sections) {
  await startReadUniqueSection(fd, sections, 1);
  const n8 = await fd.readULE32();
  const q = await readBigInt(fd, n8);
  const nWitness = await fd.readULE32();
  await endReadSection(fd);
  return { n8, q, nWitness };
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/groth16_prove.js
var { stringifyBigInts: stringifyBigInts2 } = utils;
async function groth16Prove(zkeyFileName, witnessFileName, logger) {
  const { fd: fdWtns, sections: sectionsWtns } = await readBinFile(witnessFileName, "wtns", 2, 1 << 25, 1 << 23);
  const wtns = await readHeader2(fdWtns, sectionsWtns);
  const { fd: fdZKey, sections: sectionsZKey } = await readBinFile(zkeyFileName, "zkey", 2, 1 << 25, 1 << 23);
  const zkey = await readHeader(fdZKey, sectionsZKey);
  if (zkey.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  if (!Scalar.eq(zkey.r, wtns.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  if (wtns.nWitness != zkey.nVars) {
    throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);
  }
  const curve2 = zkey.curve;
  const Fr2 = curve2.Fr;
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  const power = log23(zkey.domainSize);
  if (logger) logger.debug("Reading Wtns");
  const buffWitness = await readSection(fdWtns, sectionsWtns, 2);
  if (logger) logger.debug("Reading Coeffs");
  const buffCoeffs = await readSection(fdZKey, sectionsZKey, 4);
  if (logger) logger.debug("Building ABC");
  const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve2, zkey, buffWitness, buffCoeffs, logger);
  const inc = power == Fr2.s ? curve2.Fr.shift : curve2.Fr.w[power + 1];
  const buffA = await Fr2.ifft(buffA_T, "", "", logger, "IFFT_A");
  const buffAodd = await Fr2.batchApplyKey(buffA, Fr2.e(1), inc);
  const buffAodd_T = await Fr2.fft(buffAodd, "", "", logger, "FFT_A");
  const buffB = await Fr2.ifft(buffB_T, "", "", logger, "IFFT_B");
  const buffBodd = await Fr2.batchApplyKey(buffB, Fr2.e(1), inc);
  const buffBodd_T = await Fr2.fft(buffBodd, "", "", logger, "FFT_B");
  const buffC = await Fr2.ifft(buffC_T, "", "", logger, "IFFT_C");
  const buffCodd = await Fr2.batchApplyKey(buffC, Fr2.e(1), inc);
  const buffCodd_T = await Fr2.fft(buffCodd, "", "", logger, "FFT_C");
  if (logger) logger.debug("Join ABC");
  const buffPodd_T = await joinABC(curve2, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);
  let proof = {};
  if (logger) logger.debug("Reading A Points");
  const buffBasesA = await readSection(fdZKey, sectionsZKey, 5);
  proof.pi_a = await curve2.G1.multiExpAffine(buffBasesA, buffWitness, logger, "multiexp A");
  if (logger) logger.debug("Reading B1 Points");
  const buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);
  let pib1 = await curve2.G1.multiExpAffine(buffBasesB1, buffWitness, logger, "multiexp B1");
  if (logger) logger.debug("Reading B2 Points");
  const buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);
  proof.pi_b = await curve2.G2.multiExpAffine(buffBasesB2, buffWitness, logger, "multiexp B2");
  if (logger) logger.debug("Reading C Points");
  const buffBasesC = await readSection(fdZKey, sectionsZKey, 8);
  proof.pi_c = await curve2.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic + 1) * curve2.Fr.n8), logger, "multiexp C");
  if (logger) logger.debug("Reading H Points");
  const buffBasesH = await readSection(fdZKey, sectionsZKey, 9);
  const resH = await curve2.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, "multiexp H");
  const r2 = curve2.Fr.random();
  const s2 = curve2.Fr.random();
  proof.pi_a = G1.add(proof.pi_a, zkey.vk_alpha_1);
  proof.pi_a = G1.add(proof.pi_a, G1.timesFr(zkey.vk_delta_1, r2));
  proof.pi_b = G2.add(proof.pi_b, zkey.vk_beta_2);
  proof.pi_b = G2.add(proof.pi_b, G2.timesFr(zkey.vk_delta_2, s2));
  pib1 = G1.add(pib1, zkey.vk_beta_1);
  pib1 = G1.add(pib1, G1.timesFr(zkey.vk_delta_1, s2));
  proof.pi_c = G1.add(proof.pi_c, resH);
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(proof.pi_a, s2));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(pib1, r2));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(zkey.vk_delta_1, Fr2.neg(Fr2.mul(r2, s2))));
  let publicSignals = [];
  for (let i = 1; i <= zkey.nPublic; i++) {
    const b3 = buffWitness.slice(i * Fr2.n8, i * Fr2.n8 + Fr2.n8);
    publicSignals.push(Scalar.fromRprLE(b3));
  }
  proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
  proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));
  proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));
  proof.protocol = "groth16";
  proof.curve = curve2.name;
  await fdZKey.close();
  await fdWtns.close();
  proof = stringifyBigInts2(proof);
  publicSignals = stringifyBigInts2(publicSignals);
  return { proof, publicSignals };
}
async function buildABC1(curve2, zkey, witness, coeffs, logger) {
  const n8 = curve2.Fr.n8;
  const sCoef = 4 * 3 + zkey.n8r;
  const nCoef = (coeffs.byteLength - 4) / sCoef;
  const outBuffA = new BigBuffer(zkey.domainSize * n8);
  const outBuffB = new BigBuffer(zkey.domainSize * n8);
  const outBuffC = new BigBuffer(zkey.domainSize * n8);
  const outBuf = [outBuffA, outBuffB];
  for (let i = 0; i < nCoef; i++) {
    if (logger && i % 1e6 == 0) logger.debug(`QAP AB: ${i}/${nCoef}`);
    const buffCoef = coeffs.slice(4 + i * sCoef, 4 + i * sCoef + sCoef);
    const buffCoefV = new DataView(buffCoef.buffer);
    const m = buffCoefV.getUint32(0, true);
    const c2 = buffCoefV.getUint32(4, true);
    const s2 = buffCoefV.getUint32(8, true);
    const coef = buffCoef.slice(12, 12 + n8);
    outBuf[m].set(
      curve2.Fr.add(
        outBuf[m].slice(c2 * n8, c2 * n8 + n8),
        curve2.Fr.mul(coef, witness.slice(s2 * n8, s2 * n8 + n8))
      ),
      c2 * n8
    );
  }
  for (let i = 0; i < zkey.domainSize; i++) {
    if (logger && i % 1e6 == 0) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);
    outBuffC.set(
      curve2.Fr.mul(
        outBuffA.slice(i * n8, i * n8 + n8),
        outBuffB.slice(i * n8, i * n8 + n8)
      ),
      i * n8
    );
  }
  return [outBuffA, outBuffB, outBuffC];
}
async function joinABC(curve2, zkey, a2, b3, c2, logger) {
  const MAX_CHUNK_SIZE = 1 << 22;
  const n8 = curve2.Fr.n8;
  const nElements = Math.floor(a2.byteLength / curve2.Fr.n8);
  const promises = [];
  for (let i = 0; i < nElements; i += MAX_CHUNK_SIZE) {
    if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);
    const n3 = Math.min(nElements - i, MAX_CHUNK_SIZE);
    const task = [];
    const aChunk = a2.slice(i * n8, (i + n3) * n8);
    const bChunk = b3.slice(i * n8, (i + n3) * n8);
    const cChunk = c2.slice(i * n8, (i + n3) * n8);
    task.push({ cmd: "ALLOCSET", var: 0, buff: aChunk });
    task.push({ cmd: "ALLOCSET", var: 1, buff: bChunk });
    task.push({ cmd: "ALLOCSET", var: 2, buff: cChunk });
    task.push({ cmd: "ALLOC", var: 3, len: n3 * n8 });
    task.push({ cmd: "CALL", fnName: "qap_joinABC", params: [
      { var: 0 },
      { var: 1 },
      { var: 2 },
      { val: n3 },
      { var: 3 }
    ] });
    task.push({ cmd: "CALL", fnName: "frm_batchFromMontgomery", params: [
      { var: 3 },
      { val: n3 },
      { var: 3 }
    ] });
    task.push({ cmd: "GET", out: 0, var: 3, len: n3 * n8 });
    promises.push(curve2.tm.queueAction(task));
  }
  const result = await Promise.all(promises);
  let outBuff;
  if (a2 instanceof BigBuffer) {
    outBuff = new BigBuffer(a2.byteLength);
  } else {
    outBuff = new Uint8Array(a2.byteLength);
  }
  let p = 0;
  for (let i = 0; i < result.length; i++) {
    outBuff.set(result[i][0], p);
    p += result[i][0].byteLength;
  }
  return outBuff;
}

// ../../node_modules/.pnpm/circom_runtime@0.1.25/node_modules/circom_runtime/js/utils.js
function flatArray(a2) {
  var res = [];
  fillArray(res, a2);
  return res;
  function fillArray(res2, a3) {
    if (Array.isArray(a3)) {
      for (let i = 0; i < a3.length; i++) {
        fillArray(res2, a3[i]);
      }
    } else {
      res2.push(a3);
    }
  }
}
function normalize(n3, prime) {
  let res = BigInt(n3) % prime;
  if (res < 0) res += prime;
  return res;
}
function fnvHash(str) {
  const uint64_max = BigInt(2) ** BigInt(64);
  let hash4 = BigInt("0xCBF29CE484222325");
  for (var i = 0; i < str.length; i++) {
    hash4 ^= BigInt(str[i].charCodeAt());
    hash4 *= BigInt(1099511628211);
    hash4 %= uint64_max;
  }
  let shash = hash4.toString(16);
  let n3 = 16 - shash.length;
  shash = "0".repeat(n3).concat(shash);
  return shash;
}
function toArray32(s2, size) {
  const res = [];
  let rem = BigInt(s2);
  const radix = BigInt(4294967296);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  if (size) {
    var i = size - res.length;
    while (i > 0) {
      res.unshift(0);
      i--;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/circom_runtime@0.1.25/node_modules/circom_runtime/js/witness_calculator.js
async function builder(code, options) {
  options = options || {};
  let memorySize = 32767;
  let memory;
  let memoryAllocated = false;
  while (!memoryAllocated) {
    try {
      memory = new WebAssembly.Memory({ initial: memorySize });
      memoryAllocated = true;
    } catch (err) {
      if (memorySize === 1) {
        throw err;
      }
      console.warn("Could not allocate " + memorySize * 1024 * 64 + " bytes. This may cause severe instability. Trying with " + memorySize * 1024 * 64 / 2 + " bytes");
      memorySize = Math.floor(memorySize / 2);
    }
  }
  const wasmModule = await WebAssembly.compile(code);
  let wc;
  let errStr = "";
  let msgStr = "";
  let majorVersion = 1;
  let minorVersion = 0;
  let patchVersion = 0;
  const instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": memory
    },
    runtime: {
      exceptionHandler: function(code2) {
        let err;
        if (code2 == 1) {
          err = "Signal not found. ";
        } else if (code2 == 2) {
          err = "Too many signals set. ";
        } else if (code2 == 3) {
          err = "Signal already set. ";
        } else if (code2 == 4) {
          err = "Assert Failed. ";
        } else if (code2 == 5) {
          err = "Not enough memory. ";
        } else if (code2 == 6) {
          err = "Input signal array access exceeds the size. ";
        } else {
          err = "Unknown error. ";
        }
        console.error("ERROR: ", code2, errStr);
        throw new Error(err + errStr);
      },
      // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports
      // `printErrorMessage` and `writeBufferMessage`.
      printErrorMessage: function() {
        errStr += getMessage() + "\n";
      },
      writeBufferMessage: function() {
        const msg = getMessage();
        if (msg === "\n") {
          console.log(msgStr);
          msgStr = "";
        } else {
          if (msgStr !== "") {
            msgStr += " ";
          }
          msgStr += msg;
        }
      },
      showSharedRWMemory: function() {
        const shared_rw_memory_size = instance.exports.getFieldNumLen32();
        const arr = new Uint32Array(shared_rw_memory_size);
        for (let j = 0; j < shared_rw_memory_size; j++) {
          arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);
        }
        if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {
          if (msgStr !== "") {
            msgStr += " ";
          }
          const msg = Scalar.fromArray(arr, 4294967296).toString();
          msgStr += msg;
        } else {
          console.log(Scalar.fromArray(arr, 4294967296));
        }
      },
      error: function(code2, pstr, a2, b3, c2, d2) {
        let errStr2;
        if (code2 == 7) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b3).toString() + " != " + wc.getFr(c2).toString() + " " + p2str(d2);
        } else if (code2 == 9) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b3).toString() + " " + p2str(c2);
        } else if (code2 == 5 && options.sym) {
          errStr2 = p2str(pstr) + " " + options.sym.labelIdx2Name[c2];
        } else {
          errStr2 = p2str(pstr) + " " + a2 + " " + b3 + " " + c2 + " " + d2;
        }
        console.log("ERROR: ", code2, errStr2);
        throw new Error(errStr2);
      },
      log: function(a2) {
        console.log(wc.getFr(a2).toString());
      },
      logGetSignal: function(signal, pVal) {
        if (options.logGetSignal) {
          options.logGetSignal(signal, wc.getFr(pVal));
        }
      },
      logSetSignal: function(signal, pVal) {
        if (options.logSetSignal) {
          options.logSetSignal(signal, wc.getFr(pVal));
        }
      },
      logStartComponent: function(cIdx) {
        if (options.logStartComponent) {
          options.logStartComponent(cIdx);
        }
      },
      logFinishComponent: function(cIdx) {
        if (options.logFinishComponent) {
          options.logFinishComponent(cIdx);
        }
      }
    }
  });
  if (typeof instance.exports.getVersion == "function") {
    majorVersion = instance.exports.getVersion();
  }
  if (typeof instance.exports.getMinorVersion == "function") {
    minorVersion = instance.exports.getMinorVersion();
  }
  if (typeof instance.exports.getPatchVersion == "function") {
    patchVersion = instance.exports.getPatchVersion();
  }
  const sanityCheck = options && (options.sanityCheck || options.logGetSignal || options.logSetSignal || options.logStartComponent || options.logFinishComponent);
  if (majorVersion === 2) {
    wc = new WitnessCalculatorCircom2(instance, sanityCheck);
  } else {
    wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);
  }
  return wc;
  function getMessage() {
    var message = "";
    var c2 = instance.exports.getMessageChar();
    while (c2 != 0) {
      message += String.fromCharCode(c2);
      c2 = instance.exports.getMessageChar();
    }
    return message;
  }
  function p2str(p) {
    const i8 = new Uint8Array(memory.buffer);
    const bytes2 = [];
    for (let i = 0; i8[p + i] > 0; i++) bytes2.push(i8[p + i]);
    return String.fromCharCode.apply(null, bytes2);
  }
}
var WitnessCalculatorCircom1 = class {
  constructor(memory, instance, sanityCheck) {
    this.memory = memory;
    this.i32 = new Uint32Array(memory.buffer);
    this.instance = instance;
    this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;
    const pRawPrime = this.instance.exports.getPRawPrime();
    const arr = new Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.i32[(pRawPrime >> 2) + i];
    }
    this.prime = Scalar.fromArray(arr, 4294967296);
    this.Fr = new ZqField(this.prime);
    this.mask32 = Scalar.fromString("FFFFFFFF", 16);
    this.NVars = this.instance.exports.getNVars();
    this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;
    this.R = this.Fr.e(Scalar.shiftLeft(1, this.n64 * 64));
    this.RInv = this.Fr.inv(this.R);
    this.sanityCheck = sanityCheck;
  }
  circom_version() {
    return 1;
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const pSigOffset = this.allocInt();
    const pFr = this.allocFr();
    const keys = Object.keys(input);
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      try {
        this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);
      } catch (err) {
        throw new Error(`Signal ${k} is not an input of the circuit.`);
      }
      const sigOffset = this.getInt(pSigOffset);
      const fArr = flatArray(input[k]);
      for (let i = 0; i < fArr.length; i++) {
        this.setFr(pFr, fArr[i]);
        this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);
      }
    });
  }
  async calculateWitness(input, sanityCheck) {
    const self2 = this;
    const old0 = self2.i32[0];
    const w = [];
    await self2._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < self2.NVars; i++) {
      const pWitness = self2.instance.exports.getPWitness(i);
      w.push(self2.getFr(pWitness));
    }
    self2.i32[0] = old0;
    return w;
  }
  async calculateBinWitness(input, sanityCheck) {
    const self2 = this;
    const old0 = self2.i32[0];
    await self2._doCalculateWitness(input, sanityCheck);
    const pWitnessBuffer = self2.instance.exports.getWitnessBuffer();
    self2.i32[0] = old0;
    const buff = self2.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + self2.NVars * self2.n64 * 8);
    return new Uint8Array(buff);
  }
  allocInt() {
    const p = this.i32[0];
    this.i32[0] = p + 8;
    return p;
  }
  allocFr() {
    const p = this.i32[0];
    this.i32[0] = p + this.n32 * 4 + 8;
    return p;
  }
  getInt(p) {
    return this.i32[p >> 2];
  }
  setInt(p, v) {
    this.i32[p >> 2] = v;
  }
  getFr(p) {
    const self2 = this;
    const idx = p >> 2;
    if (self2.i32[idx + 1] & 2147483648) {
      const arr = new Array(self2.n32);
      for (let i = 0; i < self2.n32; i++) {
        arr[self2.n32 - 1 - i] = self2.i32[idx + 2 + i];
      }
      const res = self2.Fr.e(Scalar.fromArray(arr, 4294967296));
      if (self2.i32[idx + 1] & 1073741824) {
        return fromMontgomery(res);
      } else {
        return res;
      }
    } else {
      if (self2.i32[idx] & 2147483648) {
        return self2.Fr.e(self2.i32[idx] - 4294967296);
      } else {
        return self2.Fr.e(self2.i32[idx]);
      }
    }
    function fromMontgomery(n3) {
      return self2.Fr.mul(self2.RInv, n3);
    }
  }
  setFr(p, v) {
    const self2 = this;
    v = self2.Fr.e(v);
    const minShort = self2.Fr.neg(self2.Fr.e("80000000", 16));
    const maxShort = self2.Fr.e("7FFFFFFF", 16);
    if (self2.Fr.geq(v, minShort) && self2.Fr.leq(v, maxShort)) {
      let a2;
      if (self2.Fr.geq(v, self2.Fr.zero)) {
        a2 = Scalar.toNumber(v);
      } else {
        a2 = Scalar.toNumber(self2.Fr.sub(v, minShort));
        a2 = a2 - 2147483648;
        a2 = 4294967296 + a2;
      }
      self2.i32[p >> 2] = a2;
      self2.i32[(p >> 2) + 1] = 0;
      return;
    }
    self2.i32[p >> 2] = 0;
    self2.i32[(p >> 2) + 1] = 2147483648;
    const arr = Scalar.toArray(v, 4294967296);
    for (let i = 0; i < self2.n32; i++) {
      const idx = arr.length - 1 - i;
      if (idx >= 0) {
        self2.i32[(p >> 2) + 2 + i] = arr[idx];
      } else {
        self2.i32[(p >> 2) + 2 + i] = 0;
      }
    }
  }
};
var WitnessCalculatorCircom2 = class {
  constructor(instance, sanityCheck) {
    this.instance = instance;
    this.version = this.instance.exports.getVersion();
    this.n32 = this.instance.exports.getFieldNumLen32();
    this.instance.exports.getRawPrime();
    const arr = new Uint32Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);
    }
    this.prime = Scalar.fromArray(arr, 4294967296);
    this.witnessSize = this.instance.exports.getWitnessSize();
    this.sanityCheck = sanityCheck;
  }
  circom_version() {
    return this.instance.exports.getVersion();
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const keys = Object.keys(input);
    var input_counter = 0;
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      const fArr = flatArray(input[k]);
      if (typeof this.instance.exports.getInputSignalSize === "function") {
        let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);
        if (signalSize < 0) {
          throw new Error(`Signal ${k} not found
`);
        }
        if (fArr.length < signalSize) {
          throw new Error(`Not enough values for input signal ${k}
`);
        }
        if (fArr.length > signalSize) {
          throw new Error(`Too many values for input signal ${k}
`);
        }
      }
      for (let i = 0; i < fArr.length; i++) {
        const arrFr = toArray32(normalize(fArr[i], this.prime), this.n32);
        for (let j = 0; j < this.n32; j++) {
          this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);
        }
        try {
          this.instance.exports.setInputSignal(hMSB, hLSB, i);
          input_counter++;
        } catch (err) {
          throw new Error(err);
        }
      }
    });
    if (input_counter < this.instance.exports.getInputSize()) {
      throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
    }
  }
  async calculateWitness(input, sanityCheck) {
    const w = [];
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const arr = new Uint32Array(this.n32);
      for (let j = 0; j < this.n32; j++) {
        arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);
      }
      w.push(Scalar.fromArray(arr, 4294967296));
    }
    return w;
  }
  async calculateWTNSBin(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    buff[0] = "w".charCodeAt(0);
    buff[1] = "t".charCodeAt(0);
    buff[2] = "n".charCodeAt(0);
    buff[3] = "s".charCodeAt(0);
    buff32[1] = 2;
    buff32[2] = 2;
    buff32[3] = 1;
    const n8 = this.n32 * 4;
    const idSection1length = 8 + n8;
    const idSection1lengthHex = idSection1length.toString(16);
    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
    buff32[6] = n8;
    this.instance.exports.getRawPrime();
    var pos = 7;
    for (let j = 0; j < this.n32; j++) {
      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
    }
    pos += this.n32;
    buff32[pos] = this.witnessSize;
    pos++;
    buff32[pos] = 2;
    pos++;
    const idSection2length = n8 * this.witnessSize;
    const idSection2lengthHex = idSection2length.toString(16);
    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
    pos += 2;
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
      pos += this.n32;
    }
    return buff;
  }
};

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/wtns_calculate.js
var { unstringifyBigInts: unstringifyBigInts2 } = utils;
async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {
  const input = unstringifyBigInts2(_input);
  const fdWasm = await readExisting3(wasmFileName);
  const wasm = await fdWasm.read(fdWasm.totalSize);
  await fdWasm.close();
  const wc = await builder(wasm);
  if (wc.circom_version() == 1) {
    const w = await wc.calculateBinWitness(input);
    const fdWtns = await createBinFile(wtnsFileName, "wtns", 2, 2);
    await writeBin(fdWtns, w, wc.prime);
    await fdWtns.close();
  } else {
    const fdWtns = await createOverride(wtnsFileName);
    const w = await wc.calculateWTNSBin(input);
    await fdWtns.write(w);
    await fdWtns.close();
  }
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/groth16_fullprove.js
var { unstringifyBigInts: unstringifyBigInts3 } = utils;
async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {
  const input = unstringifyBigInts3(_input);
  const wtns = {
    type: "mem"
  };
  await wtnsCalculate(input, wasmFile, wtns);
  return await groth16Prove(zkeyFileName, wtns, logger);
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/groth16_verify.js
var { unstringifyBigInts: unstringifyBigInts4 } = utils;
async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {
  const vk_verifier = unstringifyBigInts4(_vk_verifier);
  const proof = unstringifyBigInts4(_proof);
  const publicSignals = unstringifyBigInts4(_publicSignals);
  const curve2 = await getCurveFromName2(vk_verifier.curve);
  const IC0 = curve2.G1.fromObject(vk_verifier.IC[0]);
  const IC = new Uint8Array(curve2.G1.F.n8 * 2 * publicSignals.length);
  const w = new Uint8Array(curve2.Fr.n8 * publicSignals.length);
  if (!publicInputsAreValid(curve2, publicSignals)) {
    if (logger) logger.error("Public inputs are not valid.");
    return false;
  }
  for (let i = 0; i < publicSignals.length; i++) {
    const buffP = curve2.G1.fromObject(vk_verifier.IC[i + 1]);
    IC.set(buffP, i * curve2.G1.F.n8 * 2);
    Scalar.toRprLE(w, curve2.Fr.n8 * i, publicSignals[i], curve2.Fr.n8);
  }
  let cpub = await curve2.G1.multiExpAffine(IC, w);
  cpub = curve2.G1.add(cpub, IC0);
  const pi_a = curve2.G1.fromObject(proof.pi_a);
  const pi_b = curve2.G2.fromObject(proof.pi_b);
  const pi_c = curve2.G1.fromObject(proof.pi_c);
  if (!isWellConstructed(curve2, { pi_a, pi_b, pi_c })) {
    if (logger) logger.error("Proof commitments are not valid.");
    return false;
  }
  const vk_gamma_2 = curve2.G2.fromObject(vk_verifier.vk_gamma_2);
  const vk_delta_2 = curve2.G2.fromObject(vk_verifier.vk_delta_2);
  const vk_alpha_1 = curve2.G1.fromObject(vk_verifier.vk_alpha_1);
  const vk_beta_2 = curve2.G2.fromObject(vk_verifier.vk_beta_2);
  const res = await curve2.pairingEq(
    curve2.G1.neg(pi_a),
    pi_b,
    cpub,
    vk_gamma_2,
    pi_c,
    vk_delta_2,
    vk_alpha_1,
    vk_beta_2
  );
  if (!res) {
    if (logger) logger.error("Invalid proof");
    return false;
  }
  if (logger) logger.info("OK!");
  return true;
}
function isWellConstructed(curve2, proof) {
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  return G1.isValid(proof.pi_a) && G2.isValid(proof.pi_b) && G1.isValid(proof.pi_c);
}
function publicInputsAreValid(curve2, publicInputs) {
  for (let i = 0; i < publicInputs.length; i++) {
    if (!Scalar.lt(publicInputs[i], curve2.r)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js
var { unstringifyBigInts: unstringifyBigInts5 } = utils;
function p256(n3) {
  let nstr = n3.toString(16);
  while (nstr.length < 64) nstr = "0" + nstr;
  nstr = `"0x${nstr}"`;
  return nstr;
}
async function groth16ExportSolidityCallData(_proof, _pub) {
  const proof = unstringifyBigInts5(_proof);
  const pub = unstringifyBigInts5(_pub);
  let inputs = "";
  for (let i = 0; i < pub.length; i++) {
    if (inputs != "") inputs = inputs + ",";
    inputs = inputs + p256(pub[i]);
  }
  let S2;
  S2 = `[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],[${inputs}]`;
  return S2;
}

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_utils.js
var import_blake2b_wasm3 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/keypair.js
var import_blake2b_wasm2 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_new.js
var import_blake2b_wasm4 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_export_challenge.js
var import_blake2b_wasm5 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_import.js
var import_blake2b_wasm6 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_verify.js
var import_blake2b_wasm7 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_challenge_contribute.js
var import_blake2b_wasm8 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_beacon.js
var import_blake2b_wasm9 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/powersoftau_contribute.js
var import_blake2b_wasm10 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/r1cs_info.js
var bls12381r3 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
var bn128r3 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/wtns_debug.js
var { unstringifyBigInts: unstringifyBigInts6 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_new.js
var import_blake2b_wasm11 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_verify_frominit.js
var import_blake2b_wasm12 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_contribute.js
var import_blake2b_wasm13 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_beacon.js
var import_blake2b_wasm14 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_bellman_contribute.js
var import_blake2b_wasm15 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_export_verificationkey.js
var { stringifyBigInts: stringifyBigInts3 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/zkey_export_solidityverifier.js
var import_ejs2 = __toESM(require_ejs(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js
var import_ejs = __toESM(require_ejs(), 1);
var { unstringifyBigInts: unstringifyBigInts7, stringifyBigInts: stringifyBigInts4 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/plonk_setup.js
var import_blake2b_wasm16 = __toESM(require_blake2b_wasm(), 1);

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/Keccak256Transcript.js
var import_js_sha3 = __toESM(require_sha3(), 1);
var { keccak256: keccak2562 } = import_js_sha3.default;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/plonk_prove.js
var { stringifyBigInts: stringifyBigInts5 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/plonk_fullprove.js
var { unstringifyBigInts: unstringifyBigInts8 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/plonk_verify.js
var { unstringifyBigInts: unstringifyBigInts9 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js
var { unstringifyBigInts: unstringifyBigInts10 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_prove.js
var { stringifyBigInts: stringifyBigInts6 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_full_prove.js
var { unstringifyBigInts: unstringifyBigInts11 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_verify.js
var { unstringifyBigInts: unstringifyBigInts12 } = utils;

// ../../node_modules/.pnpm/snarkjs@0.7.4/node_modules/snarkjs/src/fflonk_export_calldata.js
var { unstringifyBigInts: unstringifyBigInts13 } = utils;

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/_version.js
var version2 = "6.10.0";

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/utils/properties.js
function checkType2(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
function defineProperties2(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType2(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/utils/errors.js
function stringify3(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify3).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify3(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify3(k)}: ${stringify3(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function makeError2(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify3(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify3(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version2}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties2(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties2(error, { shortMessage });
  }
  return error;
}
function assert2(check, message, code, info) {
  if (!check) {
    throw makeError2(message, code, info);
  }
}
function assertArgument2(check, message, name, value) {
  assert2(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
var _normalizeForms2 = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize2(form) {
  assert2(_normalizeForms2.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/utils/data.js
function _getBytes2(value, name, copy7) {
  if (value instanceof Uint8Array) {
    if (copy7) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument2(false, "invalid BytesLike value", name || "value", value);
}
function getBytes2(value, name) {
  return _getBytes2(value, name, false);
}
var HexCharacters2 = "0123456789abcdef";
function hexlify2(data4) {
  const bytes2 = getBytes2(data4);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
  }
  return result;
}
function zeroPad2(data4, length, left) {
  const bytes2 = getBytes2(data4);
  assert2(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify2(result);
}
function zeroPadBytes2(data4, length) {
  return zeroPad2(data4, length, false);
}

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/utils/maths.js
var BN_012 = BigInt(0);
var BN_17 = BigInt(1);
var maxValue2 = 9007199254740991;
function getBigInt2(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument2(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument2(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument2(false, "invalid BigNumberish value", name || "value", value);
}
function getUint2(value, name) {
  const result = getBigInt2(value, name);
  assert2(result >= BN_012, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
var Nibbles3 = "0123456789abcdef";
function toBigInt2(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles3[v >> 4];
      result += Nibbles3[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt2(value);
}
function getNumber2(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument2(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument2(value >= -maxValue2 && value <= maxValue2, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber2(BigInt(value), name);
      } catch (e2) {
        assertArgument2(false, `invalid numeric string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument2(false, "invalid numeric value", name || "value", value);
}
function toBeHex2(_value, _width) {
  const value = getUint2(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber2(_width, "width");
    assert2(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc2(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument2(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc2(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc2(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument2(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc2(reason, offset, bytes2, output2, badCodepoint);
}
var Utf8ErrorFuncs2 = Object.freeze({
  error: errorFunc2,
  ignore: ignoreFunc2,
  replace: replaceFunc2
});
function toUtf8Bytes2(str, form) {
  if (form != null) {
    assertNormalize2(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument2(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/crypto/keccak.js
var locked7 = false;
var _keccak2562 = function(data4) {
  return keccak_256(data4);
};
var __keccak2562 = _keccak2562;
function keccak2563(_data) {
  const data4 = getBytes2(_data, "data");
  return hexlify2(__keccak2562(data4));
}
keccak2563._ = _keccak2562;
keccak2563.lock = function() {
  locked7 = true;
};
keccak2563.register = function(func) {
  if (locked7) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak2562 = func;
};
Object.freeze(keccak2563);

// ../../node_modules/.pnpm/ethers@6.10.0/node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String2(text) {
  const bytes2 = toUtf8Bytes2(text);
  if (bytes2.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes2(bytes2, 32);
}

// ../../node_modules/.pnpm/@semaphore-protocol+proof@4.7.0_@semaphore-protocol+group@4.7.0_@semaphore-protocol+identity@4.7.0/node_modules/@semaphore-protocol/proof/dist/index.node.js
function hash3(message) {
  return (BigInt(keccak2563(toBeHex2(message, 32))) >> BigInt(8)).toString();
}
function toBigInt3(value) {
  try {
    return toBigInt2(value);
  } catch (error) {
    if (typeof value === "string") {
      return toBigInt2(encodeBytes32String2(value));
    }
    throw TypeError(error.message);
  }
}
async function generateProof(identity, groupOrMerkleProof, message, scope, merkleTreeDepth, snarkArtifacts) {
  requireDefined(identity, "identity");
  requireDefined(groupOrMerkleProof, "groupOrMerkleProof");
  requireDefined(message, "message");
  requireDefined(scope, "scope");
  requireObject(identity, "identity");
  requireObject(groupOrMerkleProof, "groupOrMerkleProof");
  requireTypes(message, "message", ["string", "bigint", "number", "Uint8Array"]);
  requireTypes(scope, "scope", ["string", "bigint", "number", "Uint8Array"]);
  if (merkleTreeDepth) {
    requireNumber(merkleTreeDepth, "merkleTreeDepth");
  }
  if (snarkArtifacts) {
    requireObject(snarkArtifacts, "snarkArtifacts");
  }
  message = toBigInt3(message);
  scope = toBigInt3(scope);
  let merkleProof;
  if ("siblings" in groupOrMerkleProof) {
    merkleProof = groupOrMerkleProof;
  } else {
    const leafIndex = groupOrMerkleProof.indexOf(identity.commitment);
    merkleProof = groupOrMerkleProof.generateMerkleProof(leafIndex);
  }
  const merkleProofLength = merkleProof.siblings.length;
  if (merkleTreeDepth !== void 0) {
    if (merkleTreeDepth < MIN_DEPTH || merkleTreeDepth > MAX_DEPTH) {
      throw new TypeError(`The tree depth must be a number between ${MIN_DEPTH} and ${MAX_DEPTH}`);
    }
  } else {
    merkleTreeDepth = merkleProofLength !== 0 ? merkleProofLength : 1;
  }
  snarkArtifacts ?? (snarkArtifacts = await maybeGetSnarkArtifacts(Project.SEMAPHORE, {
    parameters: [merkleTreeDepth],
    version: "4.0.0"
  }));
  const { wasm, zkey } = snarkArtifacts;
  const merkleProofIndices = [];
  const merkleProofSiblings = merkleProof.siblings;
  for (let i = 0; i < merkleTreeDepth; i += 1) {
    merkleProofIndices.push(merkleProof.index >> i & 1);
    if (merkleProofSiblings[i] === void 0) {
      merkleProofSiblings[i] = 0n;
    }
  }
  const { proof, publicSignals } = await groth16_exports.fullProve({
    secret: identity.secretScalar,
    merkleProofLength,
    merkleProofIndices,
    merkleProofSiblings,
    scope: hash3(scope),
    message: hash3(message)
  }, wasm, zkey);
  return {
    merkleTreeDepth,
    merkleTreeRoot: merkleProof.root.toString(),
    nullifier: publicSignals[1],
    message: message.toString(),
    scope: scope.toString(),
    points: packGroth16Proof(proof)
  };
}

// ../../node_modules/.pnpm/@semaphore-protocol+utils@4.7.0/node_modules/@semaphore-protocol/utils/dist/lib.esm/networks/deployed-contracts.json.js
var deployedContracts = [
  {
    network: "sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 6983614
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 6983614
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 6983614
      }
    ]
  },
  {
    network: "arbitrum-sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 93258221
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 93258221
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 93258221
      }
    ]
  },
  {
    network: "optimism-sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 19289434
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 19289434
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 19289434
      }
    ]
  },
  {
    network: "matic-amoy",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 13850778
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 13850778
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 13850778
      }
    ]
  },
  {
    network: "arbitrum",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 269586534
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 269586534
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 269586534
      }
    ]
  },
  {
    network: "matic",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 63715311
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 63715311
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 63715311
      }
    ]
  },
  {
    network: "optimism",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 127391657
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 127391657
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 127391657
      }
    ]
  },
  {
    network: "base-sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 17307202
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 17307202
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 17307202
      }
    ]
  },
  {
    network: "linea-sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 5225214
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 5225214
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 5225214
      }
    ]
  },
  {
    network: "base",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 21796660
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 21796660
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 21796660
      }
    ]
  },
  {
    network: "linea",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 11459722
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 11459722
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 11459722
      }
    ]
  },
  {
    network: "scroll-sepolia",
    contracts: [
      {
        name: "SemaphoreVerifier",
        address: "0x6C42599435B82121794D835263C846384869502d",
        startBlock: 7397758
      },
      {
        name: "PoseidonT3",
        address: "0xB43122Ecb241DD50062641f089876679fd06599a",
        startBlock: 7397758
      },
      {
        name: "Semaphore",
        address: "0x06d1530c829366A7fff0069e77c5af6A6FA7db2E",
        startBlock: 7397758
      }
    ]
  }
];

// ../../node_modules/.pnpm/@semaphore-protocol+utils@4.7.0/node_modules/@semaphore-protocol/utils/dist/lib.esm/networks/supported-networks.js
var supportedNetworks = {
  sepolia: {
    name: "Sepolia",
    url: "https://rpc2.sepolia.org",
    chainId: 11155111,
    explorer: "https://sepolia.etherscan.io"
  },
  "arbitrum-sepolia": {
    name: "Arbitrum Sepolia",
    url: "https://sepolia-rollup.arbitrum.io/rpc",
    chainId: 421614,
    explorer: "https://sepolia.arbiscan.io"
  },
  arbitrum: {
    name: "Arbitrum",
    url: "https://arb1.arbitrum.io/rpc",
    chainId: 42161,
    explorer: "https://arbiscan.io"
  },
  "optimism-sepolia": {
    name: "Optimism Sepolia",
    url: "https://sepolia.optimism.io",
    chainId: 11155420,
    explorer: "https://sepolia-optimism.etherscan.io"
  },
  optimism: {
    name: "Optimism",
    url: "https://mainnet.optimism.io ",
    chainId: 10,
    explorer: "https://optimistic.etherscan.io"
  },
  "matic-amoy": {
    name: "Matic Amoy",
    url: "https://rpc-amoy.polygon.technology",
    chainId: 80002,
    explorer: "https://amoy.polygonscan.com"
  },
  matic: {
    name: "Matic",
    url: "https://polygon-rpc.com",
    chainId: 137,
    explorer: "https://polygonscan.com"
  },
  "base-sepolia": {
    name: "Base Sepolia",
    url: "https://sepolia.base.org",
    chainId: 84532,
    explorer: "https://sepolia.basescan.org"
  },
  base: {
    name: "Base",
    url: "https://mainnet.base.org",
    chainId: 8453,
    explorer: "https://basescan.org"
  },
  "linea-sepolia": {
    name: "Linea Sepolia",
    url: "https://rpc.sepolia.linea.build",
    chainId: 59141,
    explorer: "https://sepolia.lineascan.build"
  },
  linea: {
    name: "Linea",
    url: "https://rpc.linea.build",
    chainId: 59144,
    explorer: "https://lineascan.build"
  },
  "scroll-sepolia": {
    name: "Scroll Sepolia",
    url: "https://sepolia-rpc.scroll.io",
    chainId: 534351,
    explorer: "https://sepolia.scrollscan.com"
  }
};

// ../../node_modules/.pnpm/@semaphore-protocol+utils@4.7.0/node_modules/@semaphore-protocol/utils/dist/lib.esm/networks/index.js
var defaultNetwork = "sepolia";
function isSupportedNetwork(supportedNetwork) {
  return Object.keys(supportedNetworks).includes(supportedNetwork);
}
function getDeployedContract(supportedNetwork) {
  if (!isSupportedNetwork(supportedNetwork)) {
    throw new Error(`Semaphore has not been deployed on '${supportedNetwork}' yet`);
  }
  const deployedContract = deployedContracts.find(({ network }) => network === supportedNetwork);
  return deployedContract.contracts.find(({ name }) => name === "Semaphore");
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress2 = "0x0000000000000000000000000000000000000000";

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash2 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/_version.js
var version3 = "6.11.0";

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/properties.js
function checkType3(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties2(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties3(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType3(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/errors.js
function stringify4(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify4).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify4(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify4(k)}: ${stringify4(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError2(error, code) {
  return error && error.code === code;
}
function isCallException2(error) {
  return isError2(error, "CALL_EXCEPTION");
}
function makeError3(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify4(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify4(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version3}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties3(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties3(error, { shortMessage });
  }
  return error;
}
function assert3(check, message, code, info) {
  if (!check) {
    throw makeError3(message, code, info);
  }
}
function assertArgument3(check, message, name, value) {
  assert3(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount2(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert3(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert3(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms3 = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize3(form) {
  assert3(_normalizeForms3.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate2(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert3(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/data.js
function _getBytes3(value, name, copy7) {
  if (value instanceof Uint8Array) {
    if (copy7) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument3(false, "invalid BytesLike value", name || "value", value);
}
function getBytes3(value, name) {
  return _getBytes3(value, name, false);
}
function getBytesCopy3(value, name) {
  return _getBytes3(value, name, true);
}
function isHexString3(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike3(value) {
  return isHexString3(value, true) || value instanceof Uint8Array;
}
var HexCharacters3 = "0123456789abcdef";
function hexlify3(data4) {
  const bytes2 = getBytes3(data4);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters3[(v & 240) >> 4] + HexCharacters3[v & 15];
  }
  return result;
}
function concat3(datas) {
  return "0x" + datas.map((d2) => hexlify3(d2).substring(2)).join("");
}
function dataLength3(data4) {
  if (isHexString3(data4, true)) {
    return (data4.length - 2) / 2;
  }
  return getBytes3(data4).length;
}
function dataSlice3(data4, start2, end) {
  const bytes2 = getBytes3(data4);
  if (end != null && end > bytes2.length) {
    assert3(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify3(bytes2.slice(start2 == null ? 0 : start2, end == null ? bytes2.length : end));
}
function zeroPad3(data4, length, left) {
  const bytes2 = getBytes3(data4);
  assert3(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify3(result);
}
function zeroPadValue3(data4, length) {
  return zeroPad3(data4, length, true);
}
function zeroPadBytes3(data4, length) {
  return zeroPad3(data4, length, false);
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/maths.js
var BN_013 = BigInt(0);
var BN_18 = BigInt(1);
var maxValue3 = 9007199254740991;
function fromTwos3(_value, _width) {
  const value = getUint3(_value, "value");
  const width = BigInt(getNumber3(_width, "width"));
  assert3(value >> width === BN_013, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_18) {
    const mask4 = (BN_18 << width) - BN_18;
    return -((~value & mask4) + BN_18);
  }
  return value;
}
function toTwos3(_value, _width) {
  let value = getBigInt3(_value, "value");
  const width = BigInt(getNumber3(_width, "width"));
  const limit = BN_18 << width - BN_18;
  if (value < BN_013) {
    value = -value;
    assert3(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask4 = (BN_18 << width) - BN_18;
    return (~value & mask4) + BN_18;
  } else {
    assert3(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask3(_value, _bits) {
  const value = getUint3(_value, "value");
  const bits3 = BigInt(getNumber3(_bits, "bits"));
  return value & (BN_18 << bits3) - BN_18;
}
function getBigInt3(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument3(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument3(value >= -maxValue3 && value <= maxValue3, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument3(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument3(false, "invalid BigNumberish value", name || "value", value);
}
function getUint3(value, name) {
  const result = getBigInt3(value, name);
  assert3(result >= BN_013, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
var Nibbles4 = "0123456789abcdef";
function toBigInt4(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles4[v >> 4];
      result += Nibbles4[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt3(value);
}
function getNumber3(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument3(value >= -maxValue3 && value <= maxValue3, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument3(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument3(value >= -maxValue3 && value <= maxValue3, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber3(BigInt(value), name);
      } catch (e2) {
        assertArgument3(false, `invalid numeric string: ${e2.message}`, name || "value", value);
      }
  }
  assertArgument3(false, "invalid numeric value", name || "value", value);
}
function toNumber5(value) {
  return getNumber3(toBigInt4(value));
}
function toBeHex3(_value, _width) {
  const value = getUint3(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber3(_width, "width");
    assert3(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray3(_value) {
  const value = getUint3(_value, "value");
  if (value === BN_013) {
    return new Uint8Array([]);
  }
  let hex2 = value.toString(16);
  if (hex2.length % 2) {
    hex2 = "0" + hex2;
  }
  const result = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex2.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity3(value) {
  let result = hexlify3(isBytesLike3(value) ? value : toBeArray3(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/base58.js
var Alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var BN_014 = BigInt(0);
var BN_582 = BigInt(58);
function encodeBase582(_value) {
  const bytes2 = getBytes3(_value);
  let value = toBigInt4(bytes2);
  let result = "";
  while (value) {
    result = Alphabet2[Number(value % BN_582)] + result;
    value /= BN_582;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet2[0] + result;
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/base64.js
function decodeBase642(value) {
  return getBytesCopy3(Buffer.from(value, "base64"));
}
function encodeBase642(data4) {
  return Buffer.from(getBytes3(data4)).toString("base64");
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/events.js
var EventPayload2 = class {
  /**
   *  The event filter.
   */
  filter;
  /**
   *  The **EventEmitterable**.
   */
  emitter;
  #listener;
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties3(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc3(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument3(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc3(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc3(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument3(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc3(reason, offset, bytes2, output2, badCodepoint);
}
var Utf8ErrorFuncs3 = Object.freeze({
  error: errorFunc3,
  ignore: ignoreFunc3,
  replace: replaceFunc3
});
function getUtf8CodePoints2(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs3.error;
  }
  const bytes2 = getBytes3(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c2 = bytes2[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes3(str, form) {
  if (form != null) {
    assertNormalize3(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument3(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String2(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String3(bytes2, onError) {
  return _toUtf8String2(getUtf8CodePoints2(bytes2, onError));
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/geturl.js
var import_http2 = __toESM(require("http"), 1);
var import_https2 = __toESM(require("https"), 1);
var import_zlib2 = require("zlib");
function createGetUrl2(options) {
  async function getUrl(req, signal) {
    const protocol = req.url.split(":")[0].toLowerCase();
    assert3(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert3(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options) {
      if (options.agent) {
        reqOptions.agent = options.agent;
      }
    }
    const request = (protocol === "http" ? import_http2.default : import_https2.default).request(req.url, reqOptions);
    request.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request.write(Buffer.from(body));
    }
    request.end();
    return new Promise((resolve, reject) => {
      request.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
          let value = resp.headers[name] || "";
          if (Array.isArray(value)) {
            value = value.join(", ");
          }
          accum[name] = value;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error) {
              return reject(error);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          if (headers2["content-encoding"] === "gzip" && body2) {
            body2 = getBytes3((0, import_zlib2.gunzipSync)(body2));
          }
          resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
        });
        resp.on("error", (error) => {
          error.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject(error);
        });
      });
      request.on("error", (error) => {
        reject(error);
      });
    });
  }
  return getUrl;
}
var defaultGetUrl2 = createGetUrl2({});

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS2 = 12;
var SLOT_INTERVAL2 = 250;
var defaultGetUrlFunc2 = createGetUrl2();
var reData2 = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs2 = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked8 = false;
async function dataGatewayFunc2(url, signal) {
  try {
    const match = url.match(reData2);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse2(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase642(match[3]) : unpercent2(match[3]));
  } catch (error) {
    return new FetchResponse2(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest2(url));
  }
}
function getIpfsGatewayFunc2(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs2);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest2(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse2(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest2(url));
    }
  }
  return gatewayIpfs;
}
var Gateways2 = {
  "data": dataGatewayFunc2,
  "ipfs": getIpfsGatewayFunc2("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals2 = /* @__PURE__ */ new WeakMap();
var FetchCancelSignal2 = class {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals2.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert3(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert3(!this.cancelled, "cancelled", "CANCELLED", {});
  }
};
function checkSignal2(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
var FetchRequest2 = class _FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  // Hooks
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  /**
   *  The fetch URL to request.
   */
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = void 0;
      this.#bodyType = void 0;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes3(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes3(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase642(toUtf8Bytes3(this.#creds))}`;
    }
    ;
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return this.#creds || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument3(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument3(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process2) {
    this.#process = process2;
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc2;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 3e5;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL2,
      maxAttempts: MAX_ATTEMPTS2
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify3(this.#body) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async #send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert3(getTime4() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait2(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways2) {
      const result = await Gateways2[scheme](req.url, checkSignal2(_request.#signal));
      if (result instanceof FetchResponse2) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal2(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal2(_request.#signal));
    let response = new FetchResponse2(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal2(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        ;
        if (error.stall >= 0) {
          delay2 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert3(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal2(this);
    return this.#send(0, getTime4() + this.timeout, 0, this, new FetchResponse2(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert3(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals2.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert3(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    clone.#getUrlFunc = this.#getUrlFunc;
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked8 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways2[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked8) {
      throw new Error("gateways locked");
    }
    Gateways2[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked8) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc2 = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl2(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc2;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc2(baseUrl);
  }
};
var FetchResponse2 = class _FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify3(this.#body) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return this.#statusCode;
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return this.#statusMessage;
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, this.#headers);
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String3(this.#body);
    } catch (error) {
      assert3(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert3(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
    response.#error = { message, error };
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall6) {
    if (stall6 == null) {
      stall6 = -1;
    } else {
      assertArgument3(Number.isInteger(stall6) && stall6 >= 0, "invalid stall timeout", "stall", stall6);
    }
    const error = new Error(message || "throttling requests");
    defineProperties3(error, { stall: stall6, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return this.#body != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return this.#request;
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String3(this.#body);
      }
    } catch (e2) {
    }
    assert3(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
function getTime4() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent2(value) {
  return toUtf8Bytes3(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait2(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte2(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger2(data4, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data4[offset + i];
  }
  return result;
}
function _decodeChildren2(data4, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode2(data4, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert3(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data4,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode2(data4, offset) {
  assert3(data4.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data4,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert3(offset2 <= data4.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data4,
      length: data4.length,
      offset: offset2
    });
  };
  if (data4[offset] >= 248) {
    const lengthLength = data4[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data4, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren2(data4, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data4[offset] >= 192) {
    const length = data4[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren2(data4, offset, offset + 1, length);
  } else if (data4[offset] >= 184) {
    const lengthLength = data4[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data4, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify3(data4.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data4[offset] >= 128) {
    const length = data4[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify3(data4.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte2(data4[offset]) };
}
function decodeRlp2(_data) {
  const data4 = getBytes3(_data, "data");
  const decoded = _decode2(data4, 0);
  assertArgument3(decoded.consumed === data4.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger2(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode2(object3) {
  if (Array.isArray(object3)) {
    let payload = [];
    object3.forEach(function(child) {
      payload = payload.concat(_encode2(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger2(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data4 = Array.prototype.slice.call(getBytes3(object3, "object"));
  if (data4.length === 1 && data4[0] <= 127) {
    return data4;
  } else if (data4.length <= 55) {
    data4.unshift(128 + data4.length);
    return data4;
  }
  const length = arrayifyInteger2(data4.length);
  length.unshift(183 + length.length);
  return length.concat(data4);
}
var nibbles2 = "0123456789abcdef";
function encodeRlp2(object3) {
  let result = "0x";
  for (const v of _encode2(object3)) {
    result += nibbles2[v >> 4];
    result += nibbles2[v & 15];
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize2 = 32;
var Padding2 = new Uint8Array(WordSize2);
var passProperties3 = ["then"];
var _guard7 = {};
function throwError2(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
var Result2 = class _Result extends Array {
  #names;
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard7) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    this.#names = Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    }));
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber3(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError2(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties3.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  /**
   *  Returns the Result as a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray() {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError2(`index ${index}`, item);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject() {
    return this.#names.reduce((accum, name, index) => {
      assert3(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      if (!(name in accum)) {
        accum[name] = this.getValue(name);
      }
      return accum;
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start2, end) {
    if (start2 == null) {
      start2 = 0;
    }
    if (start2 < 0) {
      start2 += this.length;
      if (start2 < 0) {
        start2 = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const result = [], names2 = [];
    for (let i = start2; i < end; i++) {
      result.push(this[i]);
      names2.push(this.#names[i]);
    }
    return new _Result(_guard7, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError2(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(this.#names[i]);
      }
    }
    return new _Result(_guard7, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError2(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = this.#names.indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError2(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard7, items, keys);
  }
};
function getValue3(value) {
  let bytes2 = toBeArray3(value);
  assert3(bytes2.length <= WordSize2, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize2, offset: bytes2.length });
  if (bytes2.length !== WordSize2) {
    bytes2 = getBytesCopy3(concat3([Padding2.slice(bytes2.length % WordSize2), bytes2]));
  }
  return bytes2;
}
var Coder2 = class {
  // The coder name:
  //   - address, uint256, tuple, array, etc.
  name;
  // The fully expanded type, including composite types:
  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
  type;
  // The localName bound in the signature, in this example it is "baz":
  //   - tuple(address foo, uint bar) baz
  localName;
  // Whether this type is dynamic:
  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties3(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument3(false, message, this.localName, value);
  }
};
var Writer2 = class {
  // An array of WordSize lengthed objects to concatenation
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat3(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data4) {
    this.#data.push(data4);
    this.#dataLength += data4.length;
    return data4.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy3(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy3(value);
    const paddingOffset = bytes2.length % WordSize2;
    if (paddingOffset) {
      bytes2 = getBytesCopy3(concat3([bytes2, Padding2.slice(paddingOffset)]));
    }
    return this.#writeData(bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return this.#writeData(getValue3(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding2);
    this.#dataLength += WordSize2;
    return (value) => {
      this.#data[offset] = getValue3(value);
    };
  }
};
var Reader2 = class _Reader {
  // Allows incomplete unpadded data to be read; otherwise an error
  // is raised if attempting to overrun the buffer. This is required
  // to deal with an old Solidity bug, in which event data for
  // external (not public thoguh) was tightly packed.
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data4, allowLoose, maxInflation) {
    defineProperties3(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy3(data4);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify3(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert3(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy3(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize2) * WordSize2;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert3(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy3(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt4(this.readBytes(WordSize2));
  }
  readIndex() {
    return toNumber5(this.readBytes(WordSize2));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/crypto/keccak.js
var locked9 = false;
var _keccak2563 = function(data4) {
  return keccak_256(data4);
};
var __keccak2563 = _keccak2563;
function keccak2564(_data) {
  const data4 = getBytes3(_data, "data");
  return hexlify3(__keccak2563(data4));
}
keccak2564._ = _keccak2563;
keccak2564.lock = function() {
  locked9 = true;
};
keccak2564.register = function(func) {
  if (locked9) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak2563 = func;
};
Object.freeze(keccak2564);

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/crypto/signature.js
var BN_015 = BigInt(0);
var BN_19 = BigInt(1);
var BN_25 = BigInt(2);
var BN_273 = BigInt(27);
var BN_283 = BigInt(28);
var BN_353 = BigInt(35);
var _guard8 = {};
function toUint2562(value) {
  return zeroPadValue3(toBeArray3(value), 32);
}
var Signature2 = class _Signature {
  #r;
  #s;
  #v;
  #networkV;
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument3(dataLength3(value) === 32, "invalid r", "value", value);
    this.#r = hexlify3(value);
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return this.#s;
  }
  set s(_value) {
    assertArgument3(dataLength3(_value) === 32, "invalid s", "value", _value);
    const value = hexlify3(_value);
    assertArgument3(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    this.#s = value;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber3(value, "value");
    assertArgument3(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return this.#networkV;
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return _Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes3(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify3(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat3([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat3([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  @private
   */
  constructor(guard, r2, s2, v) {
    assertPrivate2(guard, _guard8, "Signature");
    this.#r = r2;
    this.#s = s2;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard8, this.r, this.s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt3(v, "v");
    if (bv == BN_273 || bv == BN_283) {
      return BN_015;
    }
    assertArgument3(bv >= BN_353, "invalid EIP-155 v", "v", v);
    return (bv - BN_353) / BN_25;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt3(chainId) * BN_25 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt3(v);
    if (bv === BN_015 || bv === BN_273) {
      return 27;
    }
    if (bv === BN_19 || bv === BN_283) {
      return 28;
    }
    assertArgument3(bv >= BN_353, "invalid v", "v", v);
    return bv & BN_19 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument3(check, message, "signature", sig);
    }
    ;
    if (sig == null) {
      return new _Signature(_guard8, ZeroHash2, ZeroHash2, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes3(sig, "signature");
      if (bytes2.length === 64) {
        const r3 = hexlify3(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        const v2 = s3[0] & 128 ? 28 : 27;
        s3[0] &= 127;
        return new _Signature(_guard8, r3, hexlify3(s3), v2);
      }
      if (bytes2.length === 65) {
        const r3 = hexlify3(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        assertError((s3[0] & 128) === 0, "non-canonical s");
        const v2 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard8, r3, hexlify3(s3), v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r2 = toUint2562(_r);
    const s2 = function(s3, yParityAndS) {
      if (s3 != null) {
        return toUint2562(s3);
      }
      if (yParityAndS != null) {
        assertError(isHexString3(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes3(yParityAndS);
        bytes2[0] &= 127;
        return hexlify3(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes3(s2)[0] & 128) == 0, "non-canonical s");
    const { networkV, v } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt3(_v);
        return {
          networkV: v2 >= BN_353 ? v2 : void 0,
          v: _Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString3(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes3(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber3(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard8, r2, s2, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber3(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/crypto/signing-key.js
var SigningKey2 = class _SigningKey {
  #privateKey;
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    assertArgument3(dataLength3(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify3(privateKey);
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return this.#privateKey;
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(this.#privateKey);
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(this.#privateKey, true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument3(dataLength3(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy3(digest), getBytesCopy3(this.#privateKey), {
      lowS: true
    });
    return Signature2.from({
      r: toBeHex3(sig.r, 32),
      s: toBeHex3(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify3(secp256k1.getSharedSecret(getBytesCopy3(this.#privateKey), getBytes3(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes3(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify3(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify3(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument3(dataLength3(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature2.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy3(concat3([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy3(digest));
    assertArgument3(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/address/address.js
var BN_016 = BigInt(0);
var BN_362 = BigInt(36);
function getChecksumAddress2(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes3(keccak2564(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup2 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup2[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup2[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits2 = 15;
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup2[c2];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum7 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum7.length < 2) {
    checksum7 = "0" + checksum7;
  }
  return checksum7;
}
var Base362 = function() {
  ;
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase362(value) {
  value = value.toLowerCase();
  let result = BN_016;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_362 + Base362[value[i]];
  }
  return result;
}
function getAddress2(address) {
  assertArgument3(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress2(address);
    assertArgument3(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument3(address.substring(2, 4) === ibanChecksum2(address), "bad icap checksum", "address", address);
    let result = fromBase362(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress2("0x" + result);
  }
  assertArgument3(false, "invalid address", "address", address);
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress2(tx) {
  const from = getAddress2(tx.from);
  const nonce = getBigInt3(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress2(dataSlice3(keccak2564(encodeRlp2([from, nonceHex])), 12));
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/address/checks.js
function isAddressable2(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress2(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert3(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument3(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress2(result);
}
function resolveAddress2(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress2(target);
    }
    assert3(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress2(target, resolver.resolveName(target));
  } else if (isAddressable2(target)) {
    return checkAddress2(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress2(target, target);
  }
  assertArgument3(false, "unsupported addressable value", "target", target);
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/typed.js
var _gaurd2 = {};
function n2(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed2(_gaurd2, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b2(value, size) {
  return new Typed2(_gaurd2, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol2 = Symbol.for("_ethers_typed");
var Typed2 = class _Typed {
  /**
   *  The type, as a Solidity-compatible type.
   */
  type;
  /**
   *  The actual value.
   */
  value;
  #options;
  /**
   *  @_ignore:
   */
  _typedSymbol;
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate2(_gaurd2, gaurd, "Typed");
    defineProperties3(this, { _typedSymbol: _typedSymbol2, type, value });
    this.#options = options;
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd2, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n2(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n2(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n2(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n2(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n2(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n2(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n2(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n2(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n2(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n2(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n2(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n2(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n2(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n2(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n2(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n2(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n2(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n2(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n2(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n2(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n2(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n2(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n2(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n2(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n2(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n2(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n2(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n2(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n2(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n2(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n2(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n2(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n2(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n2(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n2(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n2(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n2(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n2(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n2(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n2(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n2(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n2(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n2(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n2(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n2(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n2(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n2(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n2(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n2(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n2(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n2(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n2(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n2(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n2(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n2(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n2(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n2(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n2(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n2(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n2(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n2(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n2(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n2(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n2(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n2(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n2(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b2(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b2(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b2(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b2(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b2(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b2(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b2(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b2(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b2(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b2(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b2(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b2(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b2(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b2(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b2(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b2(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b2(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b2(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b2(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b2(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b2(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b2(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b2(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b2(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b2(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b2(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b2(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b2(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b2(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b2(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b2(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b2(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new _Typed(_gaurd2, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new _Typed(_gaurd2, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new _Typed(_gaurd2, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new _Typed(_gaurd2, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd2, "array", v, dynamic);
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd2, "tuple", v, name);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new _Typed(_gaurd2, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol2;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder2 = class extends Coder2 {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed2.dereference(_value, "string");
    try {
      value = getAddress2(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress2(toBeHex3(reader.readValue(), 20));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder2 = class extends Coder2 {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/array.js
function pack2(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert3(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert3(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument3(false, "invalid tuple value", "tuple", values);
  }
  assertArgument3(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer2();
  let dynamicWriter = new Writer2();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack2(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError2(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError2(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result2.fromItems(values, keys);
}
var ArrayCoder2 = class extends Coder2 {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties3(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount2(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack2(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert3(count * WordSize2 <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize2, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder2(this.coder));
    }
    return unpack2(reader, coders);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder2 = class extends Coder2 {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder2 = class extends Coder2 {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy3(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
};
var BytesCoder2 = class extends DynamicBytesCoder2 {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify3(super.decode(reader));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder2 = class extends Coder2 {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties3(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data4 = getBytesCopy3(Typed2.dereference(_value, this.type));
    if (data4.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data4);
  }
  decode(reader) {
    return hexlify3(reader.readBytes(this.size));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/null.js
var Empty2 = new Uint8Array([]);
var NullCoder2 = class extends Coder2 {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty2);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/number.js
var BN_017 = BigInt(0);
var BN_110 = BigInt(1);
var BN_MAX_UINT2563 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var NumberCoder2 = class extends Coder2 {
  size;
  signed;
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties3(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt3(Typed2.dereference(_value, this.type));
    let maxUintValue = mask3(BN_MAX_UINT2563, WordSize2 * 8);
    if (this.signed) {
      let bounds = mask3(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_110)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos3(value, 8 * WordSize2);
    } else if (value < BN_017 || value > mask3(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask3(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos3(value, this.size * 8);
    }
    return value;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder2 = class extends DynamicBytesCoder2 {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes3(Typed2.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String3(super.decode(reader));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder2 = class extends Coder2 {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties3(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed2.dereference(_value, "tuple");
    return pack2(writer, this.coders, value);
  }
  decode(reader) {
    return unpack2(reader, this.coders);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/hash/id.js
function id2(value) {
  return keccak2564(toUtf8Bytes3(value));
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/hash/namehash.js
var Zeros3 = new Uint8Array(32);
Zeros3.fill(0);
function checkComponent2(comp) {
  assertArgument3(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit2(name) {
  const bytes2 = toUtf8Bytes3(ensNormalize2(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d2 = bytes2[i];
    if (d2 === 46) {
      comps.push(checkComponent2(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument3(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent2(bytes2.slice(last)));
  return comps;
}
function ensNormalize2(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument3(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function namehash2(name) {
  assertArgument3(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument3(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros3;
  const comps = ensNameSplit2(name);
  while (comps.length) {
    result = keccak2564(concat3([result, keccak2564(comps.pop())]));
  }
  return hexlify3(result);
}
function dnsEncode2(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument3(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify3(concat3(ensNameSplit2(name).map((comp) => {
    assertArgument3(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify2(addr, storageKeys) {
  return {
    address: getAddress2(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument3(isHexString3(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify2(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument3(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify2(set[0], set[1]);
      }
      assertArgument3(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify2(set.address, set.storageKeys);
    });
  }
  assertArgument3(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify2(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b3) => a2.address.localeCompare(b3.address));
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/transaction/address.js
function computeAddress2(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey2.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress2(keccak2564("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress2(digest, signature) {
  return computeAddress2(SigningKey2.recoverPublicKey(digest, signature));
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/transaction/transaction.js
var BN_018 = BigInt(0);
var BN_26 = BigInt(2);
var BN_274 = BigInt(27);
var BN_284 = BigInt(28);
var BN_354 = BigInt(35);
var BN_MAX_UINT2 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function handleAddress2(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress2(value);
}
function handleAccessList2(value, param) {
  try {
    return accessListify2(value);
  } catch (error) {
    assertArgument3(false, error.message, param, value);
  }
}
function handleNumber2(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber3(_value, param);
}
function handleUint2(_value, param) {
  if (_value === "0x") {
    return BN_018;
  }
  const value = getBigInt3(_value, param);
  assertArgument3(value <= BN_MAX_UINT2, "value exceeds uint size", param, value);
  return value;
}
function formatNumber2(_value, name) {
  const value = getBigInt3(_value, "value");
  const result = toBeArray3(value);
  assertArgument3(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList2(value) {
  return accessListify2(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes2(value, param) {
  assertArgument3(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument3(isHexString3(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy2(data4) {
  const fields = decodeRlp2(data4);
  assertArgument3(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data4);
  const tx = {
    type: 0,
    nonce: handleNumber2(fields[0], "nonce"),
    gasPrice: handleUint2(fields[1], "gasPrice"),
    gasLimit: handleUint2(fields[2], "gasLimit"),
    to: handleAddress2(fields[3]),
    value: handleUint2(fields[4], "value"),
    data: hexlify3(fields[5]),
    chainId: BN_018
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint2(fields[6], "v");
  const r2 = handleUint2(fields[7], "r");
  const s2 = handleUint2(fields[8], "s");
  if (r2 === BN_018 && s2 === BN_018) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_354) / BN_26;
    if (chainId < BN_018) {
      chainId = BN_018;
    }
    tx.chainId = chainId;
    assertArgument3(chainId !== BN_018 || (v === BN_274 || v === BN_284), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature2.from({
      r: zeroPadValue3(fields[7], 32),
      s: zeroPadValue3(fields[8], 32),
      v
    });
    tx.hash = keccak2564(data4);
  }
  return tx;
}
function _serializeLegacy2(tx, sig) {
  const fields = [
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_018;
  if (tx.chainId != BN_018) {
    chainId = getBigInt3(tx.chainId, "tx.chainId");
    assertArgument3(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_018) {
      fields.push(toBeArray3(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp2(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_018) {
    v = Signature2.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument3(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray3(v));
  fields.push(toBeArray3(sig.r));
  fields.push(toBeArray3(sig.s));
  return encodeRlp2(fields);
}
function _parseEipSignature2(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber2(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument3(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue3(fields[1], 32);
  const s2 = zeroPadValue3(fields[2], 32);
  const signature = Signature2.from({ r: r2, s: s2, yParity });
  tx.signature = signature;
}
function _parseEip15592(data4) {
  const fields = decodeRlp2(getBytes3(data4).slice(1));
  assertArgument3(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify3(data4));
  const tx = {
    type: 2,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint2(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint2(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint2(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint2(fields[6], "value"),
    data: hexlify3(fields[7]),
    accessList: handleAccessList2(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  tx.hash = keccak2564(data4);
  _parseEipSignature2(tx, fields.slice(9));
  return tx;
}
function _serializeEip15592(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "yParity"));
    fields.push(toBeArray3(sig.r));
    fields.push(toBeArray3(sig.s));
  }
  return concat3(["0x02", encodeRlp2(fields)]);
}
function _parseEip29302(data4) {
  const fields = decodeRlp2(getBytes3(data4).slice(1));
  assertArgument3(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify3(data4));
  const tx = {
    type: 1,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    gasPrice: handleUint2(fields[2], "gasPrice"),
    gasLimit: handleUint2(fields[3], "gasLimit"),
    to: handleAddress2(fields[4]),
    value: handleUint2(fields[5], "value"),
    data: hexlify3(fields[6]),
    accessList: handleAccessList2(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  tx.hash = keccak2564(data4);
  _parseEipSignature2(tx, fields.slice(8));
  return tx;
}
function _serializeEip29302(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "recoveryParam"));
    fields.push(toBeArray3(sig.r));
    fields.push(toBeArray3(sig.s));
  }
  return concat3(["0x01", encodeRlp2(fields)]);
}
function _parseEip48442(data4) {
  const fields = decodeRlp2(getBytes3(data4).slice(1));
  assertArgument3(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), "invalid field count for transaction type: 3", "data", hexlify3(data4));
  const tx = {
    type: 3,
    chainId: handleUint2(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint2(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint2(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint2(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint2(fields[6], "value"),
    data: hexlify3(fields[7]),
    accessList: handleAccessList2(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint2(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  assertArgument3(tx.to != null, "invalid address for transaction type: 3", "data", data4);
  assertArgument3(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data4);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument3(isHexString3(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data4);
  }
  if (fields.length === 11) {
    return tx;
  }
  tx.hash = keccak2564(data4);
  _parseEipSignature2(tx, fields.slice(11));
  return tx;
}
function _serializeEip48442(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId, "chainId"),
    formatNumber2(tx.nonce, "nonce"),
    formatNumber2(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress2,
    formatNumber2(tx.value, "value"),
    tx.data,
    formatAccessList2(tx.accessList || []),
    formatNumber2(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes2(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "yParity"));
    fields.push(toBeArray3(sig.r));
    fields.push(toBeArray3(sig.s));
  }
  return concat3(["0x03", encodeRlp2(fields)]);
}
var Transaction2 = class _Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      default:
        assertArgument3(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress2;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress2(value);
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber3(value, "value");
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt3(value);
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_018;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt3(value, "gasPrice");
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_018;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt3(value, "maxPriorityFeePerGas");
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_018;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt3(value, "maxFeePerGas");
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify3(value);
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt3(value, "value");
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt3(value);
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature2.from(value);
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify2(value);
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_018;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt3(value, "maxFeePerBlobGas");
  }
  /**
   *  The BLOB versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument3(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument3(isHexString3(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_018;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_018;
    this.#chainId = BN_018;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak2564(this.serialized);
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak2564(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress2(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey2.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    assert3(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy2(this, this.signature);
      case 1:
        return _serializeEip29302(this, this.signature);
      case 2:
        return _serializeEip15592(this, this.signature);
      case 3:
        return _serializeEip48442(this, this.signature);
    }
    assert3(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy2(this);
      case 1:
        return _serializeEip29302(this);
      case 2:
        return _serializeEip15592(this);
      case 3:
        return _serializeEip48442(this);
    }
    assert3(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert3(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert3(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert3(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s2 = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s2(this.gasLimit),
      gasPrice: s2(this.gasPrice),
      maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
      maxFeePerGas: s2(this.maxFeePerGas),
      value: s2(this.value),
      chainId: s2(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes3(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy2(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip29302(payload));
        case 2:
          return _Transaction.from(_parseEip15592(payload));
        case 3:
          return _Transaction.from(_parseEip48442(payload));
      }
      assert3(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature2.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.hash != null) {
      assertArgument3(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx);
      assertArgument3(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument3(result.isSigned(), "unsigned transaction cannot define from", "tx", tx);
      assertArgument3(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/hash/typed-data.js
var padding3 = new Uint8Array(32);
padding3.fill(0);
var BN__12 = BigInt(-1);
var BN_019 = BigInt(0);
var BN_111 = BigInt(1);
var BN_MAX_UINT2564 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight2(value) {
  const bytes2 = getBytes3(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat3([bytes2, padding3.slice(padOffset)]);
  }
  return hexlify3(bytes2);
}
var hexTrue2 = toBeHex3(BN_111, 32);
var hexFalse2 = toBeHex3(BN_019, 32);
var domainFieldTypes2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames2 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString2(key) {
  return function(value) {
    assertArgument3(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks2 = {
  name: checkString2("name"),
  version: checkString2("version"),
  chainId: function(_value) {
    const value = getBigInt3(_value, "domain.chainId");
    assertArgument3(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity3(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress2(value).toLowerCase();
    } catch (error) {
    }
    assertArgument3(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes3(value, "domain.salt");
    assertArgument3(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify3(bytes2);
  }
};
function getBaseEncoder2(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument3(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask3(BN_MAX_UINT2564, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_111) * BN__12 : BN_019;
      return function(_value) {
        const value = getBigInt3(_value, "value");
        assertArgument3(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex3(signed2 ? toTwos3(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument3(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes3(value);
        assertArgument3(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue3(getAddress2(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse2 : hexTrue2;
      };
    case "bytes":
      return function(value) {
        return keccak2564(value);
      };
    case "string":
      return function(value) {
        return id2(value);
      };
  }
  return null;
}
function encodeType2(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray2(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
var TypedDataEncoder2 = class _TypedDataEncoder {
  /**
   *  The primary type for the structured [[types]].
   *
   *  This is derived automatically from the [[types]], since no
   *  recursion is possible, once the DAG for the types is consturcted
   *  internally, the primary type must be the only remaining type with
   *  no parent nodes.
   */
  primaryType;
  #types;
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types) {
    this.#fullTypes = /* @__PURE__ */ new Map();
    this.#encoderCache = /* @__PURE__ */ new Map();
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types).forEach((type) => {
      types[type] = _types[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray2(type2);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument3(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray2(field.type).base;
        assertArgument3(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder2(baseType);
        if (encoder) {
          continue;
        }
        assertArgument3(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n3) => parents.get(n3).length === 0);
    assertArgument3(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument3(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
    defineProperties3(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument3(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType2(name, types[name]) + st.map((t) => encodeType2(t, types[t])).join(""));
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray2(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument3(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak2564);
        }
        return keccak2564(concat3(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id2(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak2564(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat3(values);
      };
    }
    assertArgument3(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument3(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak2564(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray2(type).array;
    if (array) {
      assertArgument3(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument3(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes2[name];
      assertArgument3(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b3) => {
      return domainFieldNames2.indexOf(a2.name) - domainFieldNames2.indexOf(b3.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat3([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak2564(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString3(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString3(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames2.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks2[name](value2);
      domainTypes.push({ name, type: domainFieldTypes2[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument3(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify3(getBytes3(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt3(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument3(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument3(false, "unsupported type", "type", type);
      })
    };
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/fragments.js
function setify2(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
var _kwVisibDeploy2 = "external public payable override";
var KwVisibDeploy2 = setify2(_kwVisibDeploy2.split(" "));
var _kwVisib2 = "constant external internal payable private public pure view override";
var KwVisib2 = setify2(_kwVisib2.split(" "));
var _kwTypes2 = "constructor error event fallback function receive struct";
var KwTypes2 = setify2(_kwTypes2.split(" "));
var _kwModifiers2 = "calldata memory storage payable indexed";
var KwModifiers2 = setify2(_kwModifiers2.split(" "));
var _kwOther2 = "tuple returns";
var _keywords2 = [_kwTypes2, _kwModifiers2, _kwOther2, _kwVisib2].join(" ");
var Keywords2 = setify2(_keywords2.split(" "));
var SimpleTokens2 = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix2 = new RegExp("^(\\s*)");
var regexNumberPrefix2 = new RegExp("^([0-9]+)");
var regexIdPrefix2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType2 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var TokenString2 = class _TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new _TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new _TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset; i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
function lex2(text) {
  const tokens = [];
  const throwError3 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix2);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens2[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError3("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber3(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix2);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords2.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType2)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix2);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString2(tokens.map((t) => Object.freeze(t)));
}
function allowSingle2(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName2(type, tokens) {
  if (tokens.peekKeyword(KwTypes2)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords2(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability2(tokens) {
  let modifiers = consumeKeywords2(tokens, KwVisib2);
  allowSingle2(modifiers, setify2("constant payable nonpayable".split(" ")));
  allowSingle2(modifiers, setify2("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams2(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType2.from(t, allowIndexed));
}
function consumeGas2(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt3(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi2(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType2 = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType2(type) {
  const match = type.match(regexType2);
  assertArgument3(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument3(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument3(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard9 = {};
var internal3 = Symbol.for("_ethers_internal");
var ParamTypeInternal2 = "_ParamTypeInternal";
var ErrorFragmentInternal2 = "_ErrorInternal";
var EventFragmentInternal2 = "_EventInternal";
var ConstructorFragmentInternal2 = "_ConstructorInternal";
var FallbackFragmentInternal2 = "_FallbackInternal";
var FunctionFragmentInternal2 = "_FunctionInternal";
var StructFragmentInternal2 = "_StructInternal";
var ParamType2 = class _ParamType {
  /**
   *  The local name of the parameter (or ``""`` if unbound)
   */
  name;
  /**
   *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
   *  ``"uint256[3][]"``)
   */
  type;
  /**
   *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
   */
  baseType;
  /**
   *  True if the parameters is indexed.
   *
   *  For non-indexable types this is ``null``.
   */
  indexed;
  /**
   *  The components for the tuple.
   *
   *  For non-tuple types this is ``null``.
   */
  components;
  /**
   *  The array length, or ``-1`` for dynamic-lengthed arrays.
   *
   *  For non-array types this is ``null``.
   */
  arrayLength;
  /**
   *  The type of each child in the array.
   *
   *  For non-array types this is ``null``.
   */
  arrayChildren;
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate2(guard, _guard9, "ParamType");
    Object.defineProperty(this, internal3, { value: ParamTypeInternal2 });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties3(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process2));
    }
    return process2(this.type, value);
  }
  #walkAsync(promises, value, process2, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process2(this.type, value);
    if (result.then) {
      promises.push(async function() {
        setValue(await result);
      }());
    } else {
      setValue(result);
    }
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex2(obj), allowIndexed);
      } catch (error) {
        assertArgument3(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords2(obj, setify2(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType2(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard9, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords2(obj, KwModifiers2);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard9, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument3(!name || typeof name === "string" && name.match(regexId2), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument3(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType2);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard9, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard9, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType2(obj.type);
    return new _ParamType(_guard9, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal3] === ParamTypeInternal2;
  }
};
var Fragment2 = class _Fragment {
  /**
   *  The type of the fragment.
   */
  type;
  /**
   *  The inputs for the fragment.
   */
  inputs;
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    assertPrivate2(guard, _guard9, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties3(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e2) {
      }
      return _Fragment.from(lex2(obj));
    }
    if (obj instanceof TokenString2) {
      const type = obj.peekKeyword(KwTypes2);
      switch (type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
      assert3(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument3(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment2.isFragment(value);
  }
};
var NamedFragment2 = class extends Fragment2 {
  /**
   *  The name of the fragment.
   */
  name;
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument3(typeof name === "string" && name.match(regexId2), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties3(this, { name });
  }
};
function joinParams2(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var ErrorFragment2 = class _ErrorFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal3, { value: ErrorFragmentInternal2 });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id2(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("error", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _ErrorFragment(_guard9, name, inputs);
    }
    return new _ErrorFragment(_guard9, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ErrorFragmentInternal2;
  }
};
var EventFragment2 = class _EventFragment extends NamedFragment2 {
  /**
   *  Whether this event is anonymous.
   */
  anonymous;
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal3, { value: EventFragmentInternal2 });
    defineProperties3(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id2(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType2.from(p));
    const fragment = new _EventFragment(_guard9, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _EventFragment.from(lex2(obj));
      } catch (error) {
        assertArgument3(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("event", obj);
      const inputs = consumeParams2(obj, true);
      const anonymous = !!consumeKeywords2(obj, setify2(["anonymous"])).has("anonymous");
      consumeEoi2(obj);
      return new _EventFragment(_guard9, name, inputs, anonymous);
    }
    return new _EventFragment(_guard9, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType2.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === EventFragmentInternal2;
  }
};
var ConstructorFragment2 = class _ConstructorFragment extends Fragment2 {
  /**
   *  Whether the constructor can receive an endowment.
   */
  payable;
  /**
   *  The recommended gas limit for deployment or ``null``.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal3, { value: ConstructorFragmentInternal2 });
    defineProperties3(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert3(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams2(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ConstructorFragment.from(lex2(obj));
      } catch (error) {
        assertArgument3(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      consumeKeywords2(obj, setify2(["constructor"]));
      const inputs = consumeParams2(obj);
      const payable = !!consumeKeywords2(obj, KwVisibDeploy2).has("payable");
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _ConstructorFragment(_guard9, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard9, "constructor", obj.inputs ? obj.inputs.map(ParamType2.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ConstructorFragmentInternal2;
  }
};
var FallbackFragment2 = class _FallbackFragment extends Fragment2 {
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal3, { value: FallbackFragmentInternal2 });
    defineProperties3(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FallbackFragment.from(lex2(obj));
      } catch (error) {
        assertArgument3(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify2(["fallback", "receive"]));
      assertArgument3(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify2(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams2(obj);
        assertArgument3(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords2(obj, setify2(["payable"]));
        consumeEoi2(obj);
        return new _FallbackFragment(_guard9, [], true);
      }
      let inputs = consumeParams2(obj);
      if (inputs.length) {
        assertArgument3(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType2.from("bytes")];
      }
      const mutability = consumeMutability2(obj);
      assertArgument3(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        const outputs = consumeParams2(obj);
        assertArgument3(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi2(obj);
      return new _FallbackFragment(_guard9, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard9, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType2.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard9, inputs, payable);
    }
    assertArgument3(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FallbackFragmentInternal2;
  }
};
var FunctionFragment2 = class _FunctionFragment extends NamedFragment2 {
  /**
   *  If the function is constant (e.g. ``pure`` or ``view`` functions).
   */
  constant;
  /**
   *  The returned types for the result of calling this function.
   */
  outputs;
  /**
   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
   *  or ``pure``)
   */
  stateMutability;
  /**
   *  If the function can be sent value during invocation.
   */
  payable;
  /**
   *  The recommended gas limit to send when calling this function.
   */
  gas;
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal3, { value: FunctionFragmentInternal2 });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties3(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id2(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams2(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType2.from(p));
    const fragment = new _FunctionFragment(_guard9, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FunctionFragment.from(lex2(obj));
      } catch (error) {
        assertArgument3(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("function", obj);
      const inputs = consumeParams2(obj);
      const mutability = consumeMutability2(obj);
      let outputs = [];
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        outputs = consumeParams2(obj);
      }
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _FunctionFragment(_guard9, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard9, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType2.from) : [], obj.outputs ? obj.outputs.map(ParamType2.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FunctionFragmentInternal2;
  }
};
var StructFragment2 = class _StructFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal3, { value: StructFragmentInternal2 });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return _StructFragment.from(lex2(obj));
      } catch (error) {
        assertArgument3(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("struct", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _StructFragment(_guard9, name, inputs);
    }
    return new _StructFragment(_guard9, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === StructFragmentInternal2;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons3 = /* @__PURE__ */ new Map();
PanicReasons3.set(0, "GENERIC_PANIC");
PanicReasons3.set(1, "ASSERT_FALSE");
PanicReasons3.set(17, "OVERFLOW");
PanicReasons3.set(18, "DIVIDE_BY_ZERO");
PanicReasons3.set(33, "ENUM_RANGE_ERROR");
PanicReasons3.set(34, "BAD_STORAGE_DATA");
PanicReasons3.set(49, "STACK_UNDERFLOW");
PanicReasons3.set(50, "ARRAY_RANGE_ERROR");
PanicReasons3.set(65, "OUT_OF_MEMORY");
PanicReasons3.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes2 = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber2 = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder2 = null;
var defaultMaxInflation2 = 1024;
function getBuiltinCallException2(action, tx, data4, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data4) {
    message = "execution reverted";
    const bytes2 = getBytes3(data4);
    data4 = hexlify3(data4);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify3(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify3(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons3.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress2(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress2(tx.from);
  }
  return makeError3(message, "CALL_EXCEPTION", {
    action,
    data: data4,
    reason,
    transaction,
    invocation,
    revert
  });
}
var AbiCoder2 = class _AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder2(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder2(param.components.map((c2) => this.#getCoder(c2)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder2(param.name);
      case "bool":
        return new BooleanCoder2(param.name);
      case "string":
        return new StringCoder2(param.name);
      case "bytes":
        return new BytesCoder2(param.name);
      case "":
        return new NullCoder2(param.name);
    }
    let match = param.type.match(paramTypeNumber2);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument3(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder2(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes2);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument3(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder2(size, param.name);
    }
    assertArgument3(false, "invalid type", "type", param.type);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount2(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    const writer = new Writer2();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data4, loose) {
    const coders = types.map((type) => this.#getCoder(ParamType2.from(type)));
    const coder = new TupleCoder2(coders, "_");
    return coder.decode(new Reader2(data4, loose, defaultMaxInflation2));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument3(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation2 = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder2 == null) {
      defaultCoder2 = new _AbiCoder();
    }
    return defaultCoder2;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data4) {
    return getBuiltinCallException2(action, tx, data4, _AbiCoder.defaultAbiCoder());
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/abi/interface.js
var LogDescription2 = class {
  /**
   *  The matching fragment for the ``topic0``.
   */
  fragment;
  /**
   *  The name of the Event.
   */
  name;
  /**
   *  The full Event signature.
   */
  signature;
  /**
   *  The topic hash for the Event.
   */
  topic;
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  args;
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties3(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
};
var TransactionDescription2 = class {
  /**
   *  The matching fragment from the transaction ``data``.
   */
  fragment;
  /**
   *  The name of the Function from the transaction ``data``.
   */
  name;
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  args;
  /**
   *  The full Function signature from the transaction ``data``.
   */
  signature;
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  selector;
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  value;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties3(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription2 = class {
  /**
   *  The matching fragment.
   */
  fragment;
  /**
   *  The name of the Error.
   */
  name;
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  args;
  /**
   *  The full Error signature.
   */
  signature;
  /**
   *  The selector for the Error.
   */
  selector;
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties3(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
};
var Indexed2 = class {
  /**
   *  The ``keccak256`` of the value logged.
   */
  hash;
  /**
   *  @_ignore:
   */
  _isIndexed;
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  /**
   *  @_ignore:
   */
  constructor(hash4) {
    defineProperties3(this, { hash: hash4, _isIndexed: true });
  }
};
var PanicReasons4 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors2 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons4[code.toString()]) {
        reason = PanicReasons4[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var Interface2 = class _Interface {
  /**
   *  All the Contract ABI members (i.e. methods, events, errors, etc).
   */
  fragments;
  /**
   *  The Contract constructor.
   */
  deploy;
  /**
   *  The Fallback method, if any.
   */
  fallback;
  /**
   *  If receiving ether is supported.
   */
  receive;
  #errors;
  #events;
  #functions;
  //    #structs: Map<string, StructFragment>;
  #abiCoder;
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    this.#functions = /* @__PURE__ */ new Map();
    this.#errors = /* @__PURE__ */ new Map();
    this.#events = /* @__PURE__ */ new Map();
    const frags = [];
    for (const a2 of abi2) {
      try {
        frags.push(Fragment2.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties3(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties3(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument3(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties3(this, {
        deploy: ConstructorFragment2.from("constructor()")
      });
    }
    defineProperties3(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi2 = this.fragments.map((f2) => f2.format(format));
    return abi2;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi2 = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi2.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder2.defaultAbiCoder();
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  #getFunction(key, values, forceUnique) {
    if (isHexString3(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed2.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed2.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument3(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment2.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument3(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#functions.get(name), i);
    }
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  #getEvent(key, values, forceUnique) {
    if (isHexString3(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1; i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1; i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0; j < values.length; j++) {
            if (!Typed2.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument3(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment2.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument3(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#events.get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString3(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors2[selector]) {
        return ErrorFragment2.from(BuiltinErrors2[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment2.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment2.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument3(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment2.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment2.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment2.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a2, b3) => a2.localeCompare(b3));
    for (let i = 0; i < names2.length; i++) {
      const name = names2[i];
      callback(this.#errors.get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data4) {
    return this.#abiCoder.decode(params, data4);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument3(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument3(dataSlice3(data4, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data4);
    return this._decodeParams(fragment.inputs, dataSlice3(data4, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument3(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat3([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument3(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument3(dataSlice3(data4, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data4);
    return this._decodeParams(fragment.inputs, dataSlice3(data4, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument3(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat3([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data4) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument3(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy3(data4);
    if (bytes2.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert3(false, message, "BAD_DATA", {
      value: hexlify3(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data4 = getBytes3(_data, "data");
    const error = AbiCoder2.getBuiltinCallException("call", tx, data4);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify3(data4.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data4.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e2) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument3(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify3(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument3(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert3(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id2(value);
      } else if (param.type === "bytes") {
        return keccak2564(hexlify3(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex3(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes3(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue3(hexlify3(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument3(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument3(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument3(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument3(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id2(value));
        } else if (param.type === "bytes") {
          topics.push(keccak2564(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data4, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument3(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument3(isHexString3(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType2.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat3(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data4, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed2(null);
        } else if (dynamic[index]) {
          value = new Indexed2(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result2.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data4 = getBytes3(tx.data, "tx.data");
    const value = getBigInt3(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify3(data4.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data4.slice(4));
    return new TransactionDescription2(fragment, fragment.selector, args, value);
  }
  parseCallResult(data4) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription2(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data4) {
    const hexData = hexlify3(data4);
    const fragment = this.getError(dataSlice3(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice3(hexData, 4));
    return new ErrorDescription2(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider.js
var BN_020 = BigInt(0);
function getValue4(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson2(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
var FeeData2 = class {
  /**
   *  The gas price for legacy networks.
   */
  gasPrice;
  /**
   *  The maximum fee to pay per gas.
   *
   *  The base fee per gas is defined by the network and based on
   *  congestion, increasing the cost during times of heavy load
   *  and lowering when less busy.
   *
   *  The actual fee per gas will be the base fee for the block
   *  and the priority fee, up to the max fee per gas.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxFeePerGas;
  /**
   *  The additional amout to pay per gas to encourage a validator
   *  to include the transaction.
   *
   *  The purpose of this is to compensate the validator for the
   *  adjusted risk for including a given transaction.
   *
   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
   */
  maxPriorityFeePerGas;
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties3(this, {
      gasPrice: getValue4(gasPrice),
      maxFeePerGas: getValue4(maxFeePerGas),
      maxPriorityFeePerGas: getValue4(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson2(gasPrice),
      maxFeePerGas: toJson2(maxFeePerGas),
      maxPriorityFeePerGas: toJson2(maxPriorityFeePerGas)
    };
  }
};
function copyRequest2(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify3(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt3(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber3(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify2(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  return result;
}
var Block2 = class {
  /**
   *  The provider connected to the block used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The block number, sometimes called the block height. This is a
   *  sequential number that is one higher than the parent block.
   */
  number;
  /**
   *  The block hash.
   *
   *  This hash includes all properties, so can be safely used to identify
   *  an exact set of block properties.
   */
  hash;
  /**
   *  The timestamp for this block, which is the number of seconds since
   *  epoch that this block was included.
   */
  timestamp;
  /**
   *  The block hash of the parent block.
   */
  parentHash;
  /**
   *  The hash tree root of the parent beacon block for the given
   *  execution block. See [[link-eip-4788]].
   */
  parentBeaconBlockRoot;
  /**
   *  The nonce.
   *
   *  On legacy networks, this is the random number inserted which
   *  permitted the difficulty target to be reached.
   */
  nonce;
  /**
   *  The difficulty target.
   *
   *  On legacy networks, this is the proof-of-work target required
   *  for a block to meet the protocol rules to be included.
   *
   *  On modern networks, this is a random number arrived at using
   *  randao.  @TODO: Find links?
   */
  difficulty;
  /**
   *  The total gas limit for this block.
   */
  gasLimit;
  /**
   *  The total gas used in this block.
   */
  gasUsed;
  /**
   *  The root hash for the global state after applying changes
   *  in this block.
   */
  stateRoot;
  /**
   *  The hash of the transaction receipts trie.
   */
  receiptsRoot;
  /**
   *  The total amount of blob gas consumed by the transactions
   *  within the block. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The running total of blob gas consumed in excess of the
   *  target, prior to the block. See [[link-eip-4844]].
   */
  excessBlobGas;
  /**
   *  The miner coinbase address, wihch receives any subsidies for
   *  including this block.
   */
  miner;
  /**
   *  Any extra data the validator wished to include.
   */
  extraData;
  /**
   *  The base fee per gas that all transactions in this block were
   *  charged.
   *
   *  This adjusts after each block, depending on how congested the network
   *  is.
   */
  baseFeePerGas;
  #transactions;
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse2(tx, provider);
      }
      return tx;
    });
    defineProperties3(this, {
      provider,
      hash: getValue4(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      extraData: block.extraData,
      baseFeePerGas: getValue4(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert3(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash4, miner, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson2(baseFeePerGas),
      difficulty: toJson2(difficulty),
      extraData,
      gasLimit: toJson2(gasLimit),
      gasUsed: toJson2(gasUsed),
      blobGasUsed: toJson2(this.blobGasUsed),
      excessBlobGas: toJson2(this.excessBlobGas),
      hash: hash4,
      miner,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return this.#transactions.length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash4 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash4) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash === hash4) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument3(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter2(this);
  }
};
var Log2 = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The transaction hash of the transaction this log occurred in. Use the
   *  [[Log-getTransaction]] to get the [[TransactionResponse]].
   */
  transactionHash;
  /**
   *  The block hash of the block this log occurred in. Use the
   *  [[Log-getBlock]] to get the [[Block]].
   */
  blockHash;
  /**
   *  The block number of the block this log occurred in. It is preferred
   *  to use the [[Block-hash]] when fetching the related [[Block]],
   *  since in the case of an orphaned block, the block at that height may
   *  have changed.
   */
  blockNumber;
  /**
   *  If the **Log** represents a block that was removed due to an orphaned
   *  block, this will be true.
   *
   *  This can only happen within an orphan event listener.
   */
  removed;
  /**
   *  The address of the contract that emitted this log.
   */
  address;
  /**
   *  The data included in this log when it was emitted.
   */
  data;
  /**
   *  The indexed topics included in this log when it was emitted.
   *
   *  All topics are included in the bloom filters, so they can be
   *  efficiently filtered using the [[Provider-getLogs]] method.
   */
  topics;
  /**
   *  The index within the block this log occurred at. This is generally
   *  not useful to developers, but can be used with the various roots
   *  to proof inclusion within a block.
   */
  index;
  /**
   *  The index within the transaction of this log.
   */
  transactionIndex;
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties3(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data: data4, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data: data4,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert3(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert3(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert3(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter2(this);
  }
};
var TransactionReceipt2 = class {
  /**
   *  The provider connected to the log used to fetch additional details
   *  if necessary.
   */
  provider;
  /**
   *  The address the transaction was sent to.
   */
  to;
  /**
   *  The sender of the transaction.
   */
  from;
  /**
   *  The address of the contract if the transaction was directly
   *  responsible for deploying one.
   *
   *  This is non-null **only** if the ``to`` is empty and the ``data``
   *  was successfully executed as initcode.
   */
  contractAddress;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The index of this transaction within the block transactions.
   */
  index;
  /**
   *  The block hash of the [[Block]] this transaction was included in.
   */
  blockHash;
  /**
   *  The block number of the [[Block]] this transaction was included in.
   */
  blockNumber;
  /**
   *  The bloom filter bytes that represent all logs that occurred within
   *  this transaction. This is generally not useful for most developers,
   *  but can be used to validate the included logs.
   */
  logsBloom;
  /**
   *  The actual amount of gas used by this transaction.
   *
   *  When creating a transaction, the amount of gas that will be used can
   *  only be approximated, but the sender must pay the gas fee for the
   *  entire gas limit. After the transaction, the difference is refunded.
   */
  gasUsed;
  /**
   *  The gas used for BLObs. See [[link-eip-4844]].
   */
  blobGasUsed;
  /**
   *  The amount of gas used by all transactions within the block for this
   *  and all transactions with a lower ``index``.
   *
   *  This is generally not useful for developers but can be used to
   *  validate certain aspects of execution.
   */
  cumulativeGasUsed;
  /**
   *  The actual gas price used during execution.
   *
   *  Due to the complexity of [[link-eip-1559]] this value can only
   *  be caluclated after the transaction has been mined, snce the base
   *  fee is protocol-enforced.
   */
  gasPrice;
  /**
   *  The price paid per BLOB in gas. See [[link-eip-4844]].
   */
  blobGasPrice;
  /**
   *  The [[link-eip-2718]] transaction type.
   */
  type;
  //readonly byzantium!: boolean;
  /**
   *  The status of this transaction, indicating success (i.e. ``1``) or
   *  a revert (i.e. ``0``).
   *
   *  This is available in post-byzantium blocks, but some backends may
   *  backfill this value.
   */
  status;
  /**
   *  The root hash of this transaction.
   *
   *  This is no present and was only included in pre-byzantium blocks, but
   *  could be used to validate certain parts of the receipt.
   */
  root;
  #logs;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log) => {
      return new Log2(log, provider);
    }));
    let gasPrice = BN_020;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties3(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return this.#logs;
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash4,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson2(this.cumulativeGasUsed),
      from,
      gasPrice: toJson2(this.gasPrice),
      blobGasUsed: toJson2(this.blobGasUsed),
      blobGasPrice: toJson2(this.blobGasPrice),
      gasUsed: toJson2(this.gasUsed),
      hash: hash4,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter2(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert3(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter2(this, other);
  }
};
var TransactionResponse2 = class _TransactionResponse {
  /**
   *  The provider this is connected to, which will influence how its
   *  methods will resolve its async inspection methods.
   */
  provider;
  /**
   *  The block number of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockNumber;
  /**
   *  The blockHash of the block that this transaction was included in.
   *
   *  This is ``null`` for pending transactions.
   */
  blockHash;
  /**
   *  The index within the block that this transaction resides at.
   */
  index;
  /**
   *  The transaction hash.
   */
  hash;
  /**
   *  The [[link-eip-2718]] transaction envelope type. This is
   *  ``0`` for legacy transactions types.
   */
  type;
  /**
   *  The receiver of this transaction.
   *
   *  If ``null``, then the transaction is an initcode transaction.
   *  This means the result of executing the [[data]] will be deployed
   *  as a new contract on chain (assuming it does not revert) and the
   *  address may be computed using [[getCreateAddress]].
   */
  to;
  /**
   *  The sender of this transaction. It is implicitly computed
   *  from the transaction pre-image hash (as the digest) and the
   *  [[signature]] using ecrecover.
   */
  from;
  /**
   *  The nonce, which is used to prevent replay attacks and offer
   *  a method to ensure transactions from a given sender are explicitly
   *  ordered.
   *
   *  When sending a transaction, this must be equal to the number of
   *  transactions ever sent by [[from]].
   */
  nonce;
  /**
   *  The maximum units of gas this transaction can consume. If execution
   *  exceeds this, the entries transaction is reverted and the sender
   *  is charged for the full amount, despite not state changes being made.
   */
  gasLimit;
  /**
   *  The gas price can have various values, depending on the network.
   *
   *  In modern networks, for transactions that are included this is
   *  the //effective gas price// (the fee per gas that was actually
   *  charged), while for transactions that have not been included yet
   *  is the [[maxFeePerGas]].
   *
   *  For legacy transactions, or transactions on legacy networks, this
   *  is the fee that will be charged per unit of gas the transaction
   *  consumes.
   */
  gasPrice;
  /**
   *  The maximum priority fee (per unit of gas) to allow a
   *  validator to charge the sender. This is inclusive of the
   *  [[maxFeeFeePerGas]].
   */
  maxPriorityFeePerGas;
  /**
   *  The maximum fee (per unit of gas) to allow this transaction
   *  to charge the sender.
   */
  maxFeePerGas;
  /**
   *  The [[link-eip-4844]] max fee per BLOb gas.
   */
  maxFeePerBlobGas;
  /**
   *  The data.
   */
  data;
  /**
   *  The value, in wei. Use [[formatEther]] to format this value
   *  as ether.
   */
  value;
  /**
   *  The chain ID.
   */
  chainId;
  /**
   *  The signature.
   */
  signature;
  /**
   *  The [[link-eip-2930]] access list for transaction types that
   *  support it, otherwise ``null``.
   */
  accessList;
  /**
   *  The [[link-eip-4844]] BLOb versioned hashes.
   */
  blobVersionedHashes;
  #startBlock;
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.#startBlock = -1;
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash4, type, to, from, nonce, data: data4, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson2(this.chainId),
      data: data4,
      from,
      gasLimit: toJson2(this.gasLimit),
      gasPrice: toJson2(this.gasPrice),
      hash: hash4,
      maxFeePerGas: toJson2(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson2(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson2(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson2(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties2({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties2({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash4 of block) {
          if (hash4 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_020) {
              reason = "cancelled";
            }
            assert3(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert3(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError3("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError2(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert3(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter2(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert3(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert3(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter2(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument3(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
};
function createOrphanedBlockFilter2(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter2(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter2(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter2(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog2 = class extends Log2 {
  /**
   *  The Contract Interface.
   */
  interface;
  /**
   *  The matching event.
   */
  fragment;
  /**
   *  The parsed arguments passed to the event by ``emit``.
   */
  args;
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties3(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};
var UndecodedEventLog2 = class extends Log2 {
  /**
   *  The error encounted when trying to decode the log.
   */
  error;
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    defineProperties3(this, { error });
  }
};
var ContractTransactionReceipt2 = class extends TransactionReceipt2 {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog2(log, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog2(log, error);
        }
      }
      return log;
    });
  }
};
var ContractTransactionResponse8 = class extends TransactionResponse2 {
  #iface;
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt2(this.#iface, this.provider, receipt);
  }
};
var ContractUnknownEventPayload2 = class extends EventPayload2 {
  /**
   *  The log with no matching events.
   */
  log;
  /**
   *  @_event:
   */
  constructor(contract2, listener, filter, log) {
    super(contract2, listener, filter);
    defineProperties3(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
};
var ContractEventPayload2 = class extends ContractUnknownEventPayload2 {
  /**
   *  @_ignore:
   */
  constructor(contract2, listener, filter, fragment, _log) {
    super(contract2, listener, filter, new EventLog2(_log, contract2.interface, fragment));
    const args = contract2.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties3(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/contract/contract.js
var BN_021 = BigInt(0);
function canCall2(value) {
  return value && typeof value.call === "function";
}
function canEstimate2(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve2(value) {
  return value && typeof value.resolveName === "function";
}
function canSend2(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver2(value) {
  if (value != null) {
    if (canResolve2(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
var PreparedTopicFilter2 = class {
  #filter;
  fragment;
  constructor(contract2, fragment, args) {
    defineProperties3(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner2(contract2.runner, "resolveName");
    const resolver = canResolve2(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress2(v, resolver)));
            }
            return resolveAddress2(value, resolver);
          }
          return value;
        });
      }));
      return contract2.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
};
function getRunner2(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider2(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides2(arg, allowed) {
  const _overrides = Typed2.dereference(arg, "overrides");
  assertArgument3(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest2(_overrides);
  assertArgument3(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument3(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs2(_runner, inputs, args) {
  const runner = getRunner2(_runner, "resolveName");
  const resolver = canResolve2(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed2.dereference(value, type);
      if (type === "address") {
        return resolveAddress2(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback2(contract2) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides2(overrides, ["data"]);
    tx.to = await contract2.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress2(tx.from, getResolver2(contract2.runner));
    }
    const iface = contract2.interface;
    const noValue = getBigInt3(tx.value || BN_021, "overrides.value") === BN_021;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument3(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument3(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument3(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument3(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner2(contract2.runner, "call");
    assert3(canCall2(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException2(error) && error.data) {
        throw contract2.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract2.runner;
    assert3(canSend2(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider2(contract2.runner);
    return new ContractTransactionResponse8(contract2.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner2(contract2.runner, "estimateGas");
    assert3(canEstimate2(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties3(method, {
    _contract: contract2,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod2(contract2, key) {
  const getFragment = function(...args) {
    const fragment = contract2.interface.getFunction(key, args);
    assert3(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides2(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress2(overrides.from, getResolver2(contract2.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs2(contract2.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties2({
      to: contract2.getAddress(),
      data: contract2.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract2.runner;
    assert3(canSend2(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider2(contract2.runner);
    return new ContractTransactionResponse8(contract2.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner2(contract2.runner, "estimateGas");
    assert3(canEstimate2(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner2(contract2.runner, "call");
    assert3(canCall2(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException2(error) && error.data) {
        throw contract2.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract2.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties3(method, {
    name: contract2.interface.getFunctionName(key),
    _contract: contract2,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract2.interface.getFunction(key);
      assert3(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent2(contract2, key) {
  const getFragment = function(...args) {
    const fragment = contract2.interface.getEvent(key, args);
    assert3(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter2(contract2, getFragment(...args), args);
  };
  defineProperties3(method, {
    name: contract2.interface.getEventName(key),
    _contract: contract2,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract2.interface.getEvent(key);
      assert3(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal4 = Symbol.for("_ethersInternal_contract");
var internalValues2 = /* @__PURE__ */ new WeakMap();
function setInternal2(contract2, values) {
  internalValues2.set(contract2[internal4], values);
}
function getInternal2(contract2) {
  return internalValues2.get(contract2[internal4]);
}
function isDeferred2(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo2(contract2, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString3(name, 32)) {
        return name;
      }
      const fragment2 = contract2.interface.getEvent(name);
      assertArgument3(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e2) => {
      if (e2 == null) {
        return null;
      }
      if (Array.isArray(e2)) {
        return e2.map(topicHashify);
      }
      return topicHashify(e2);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString3(event, 32)) {
      topics = [event];
    } else {
      fragment = contract2.interface.getEvent(event);
      assertArgument3(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred2(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument3(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub2(contract2, event) {
  const { subs } = getInternal2(contract2);
  return subs.get((await getSubInfo2(contract2, event)).tag) || null;
}
async function getSub2(contract2, operation, event) {
  const provider = getProvider2(contract2.runner);
  assert3(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo2(contract2, event);
  const { addr, subs } = getInternal2(contract2);
  let sub2 = subs.get(tag);
  if (!sub2) {
    const address = addr ? addr : contract2;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract2.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract2.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit2(contract2, event, args, (listener2) => {
          return new ContractEventPayload2(contract2, listener2, event, _foundFragment, log);
        });
      } else {
        emit2(contract2, event, [], (listener2) => {
          return new ContractUnknownEventPayload2(contract2, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start2 = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub2 = { tag, listeners: [], start: start2, stop };
    subs.set(tag, sub2);
  }
  return sub2;
}
var lastEmit2 = Promise.resolve();
async function _emit2(contract2, event, args, payloadFunc) {
  await lastEmit2;
  const sub2 = await hasSub2(contract2, event);
  if (!sub2) {
    return false;
  }
  const count = sub2.listeners.length;
  sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract2, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub2.listeners.length === 0) {
    sub2.stop();
    getInternal2(contract2).subs.delete(sub2.tag);
  }
  return count > 0;
}
async function emit2(contract2, event, args, payloadFunc) {
  try {
    await lastEmit2;
  } catch (error) {
  }
  const resultPromise = _emit2(contract2, event, args, payloadFunc);
  lastEmit2 = resultPromise;
  return await resultPromise;
}
var passProperties4 = ["then"];
var BaseContract2 = class _BaseContract {
  /**
   *  The target to connect to.
   *
   *  This can be an address, ENS name or any [[Addressable]], such as
   *  another contract. To get the resovled address, use the ``getAddress``
   *  method.
   */
  target;
  /**
   *  The contract Interface.
   */
  interface;
  /**
   *  The connected runner. This is generally a [[Provider]] or a
   *  [[Signer]], which dictates what operations are supported.
   *
   *  For example, a **Contract** connected to a [[Provider]] may
   *  only execute read-only operations.
   */
  runner;
  /**
   *  All the Events available on this contract.
   */
  filters;
  /**
   *  @_ignore:
   */
  [internal4];
  /**
   *  The fallback or receive function if any.
   */
  fallback;
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi2, runner, _deployTx) {
    assertArgument3(typeof target === "string" || isAddressable2(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface2.from(abi2);
    defineProperties3(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal4, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider2(runner);
      deployTx = new ContractTransactionResponse8(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString3(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner2(runner, "resolveName");
        if (!canResolve2(resolver)) {
          throw makeError3("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError3("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal2(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal2(this).addr = addr2;
        return addr2;
      });
    }
    setInternal2(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties4.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError2(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties4.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties3(this, { filters });
    defineProperties3(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback2(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties4.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError2(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties4.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal2(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider2(this.runner);
    assert3(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider2(this.runner);
    assert3(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal2(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod2(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent2(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash4) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal2(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo2(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider2(this.runner);
    assert3(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog2(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog2(log, error);
        }
      }
      return new Log2(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub2 = await getSub2(this, "on", event);
    sub2.listeners.push({ listener, once: false });
    sub2.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub2 = await getSub2(this, "once", event);
    sub2.listeners.push({ listener, once: true });
    sub2.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit2(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub2 = await hasSub2(this, event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    const { subs } = getInternal2(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub2 = await hasSub2(this, event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal2(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub2 = await hasSub2(this, event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub2.listeners.length === 0) {
      sub2.stop();
      getInternal2(this).subs.delete(sub2.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub2 = await hasSub2(this, event);
      if (!sub2) {
        return this;
      }
      sub2.stop();
      getInternal2(this).subs.delete(sub2.tag);
    } else {
      const { subs } = getInternal2(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi2) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi2, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi2, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract2 = new this(target, abi2, runner);
    return contract2;
  }
};
function _ContractBase2() {
  return BaseContract2;
}
var Contract2 = class extends _ContractBase2() {
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink2(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument3(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
var MulticoinProviderPlugin2 = class {
  /**
   *  The name.
   */
  name;
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    defineProperties3(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resovles to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resovles to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data4) {
    throw new Error("unsupported coin");
  }
};
var matcherIpfs2 = new RegExp("^(ipfs)://(.*)$", "i");
var matchers2 = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs2,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var EnsResolver2 = class _EnsResolver {
  /**
   *  The connected provider.
   */
  provider;
  /**
   *  The address of the resolver.
   */
  address;
  /**
   *  The name this resolver was resolved against.
   */
  name;
  // For EIP-2544 names, the ancestor that provided the resolver
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties3(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract2(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError2(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async #fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash2(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert3(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode2(this.name),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError2(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress2) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError2(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data5 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString3(data5, 20)) {
        return getAddress2(data5);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin2)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data4 = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data4 == null || data4 === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data4);
    if (address != null) {
      return address;
    }
    assert3(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data4 }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data4 = await this.#fetch("text(bytes32,string)", [key]);
    if (data4 == null || data4 === "0x") {
      return null;
    }
    return data4;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data4 = await this.#fetch("contenthash(bytes32)");
    if (data4 == null || data4 === "0x") {
      return null;
    }
    const ipfs = data4.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase582("0x" + ipfs[2])}`;
      }
    }
    const swarm = data4.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert3(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data4 }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers2.length; i++) {
        const match = avatar.match(matchers2[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink2(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract2 = new Contract2(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract2.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract2.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract2[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex3(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink2(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest2(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify3(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs2);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink2(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert3(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async #getResolver(provider, name) {
    const ensAddr = await _EnsResolver.getEnsAddress(provider);
    try {
      const contract2 = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract2.resolver(namehash2(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress2) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await _EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/format.js
var BN_022 = BigInt(0);
function allowNull2(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf2(format, allowNull3) {
  return (array) => {
    if (allowNull3 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object2(format, altNames) {
  return (value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert3(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean2(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument3(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData2(value) {
  assertArgument3(isHexString3(value, true), "invalid data", "value", value);
  return value;
}
function formatHash3(value) {
  assertArgument3(isHexString3(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog2 = object2({
  address: getAddress2,
  blockHash: formatHash3,
  blockNumber: getNumber3,
  data: formatData2,
  index: getNumber3,
  removed: allowNull2(formatBoolean2, false),
  topics: arrayOf2(formatHash3),
  transactionHash: formatHash3,
  transactionIndex: getNumber3
}, {
  index: ["logIndex"]
});
function formatLog2(value) {
  return _formatLog2(value);
}
var _formatBlock2 = object2({
  hash: allowNull2(formatHash3),
  parentHash: formatHash3,
  parentBeaconBlockRoot: allowNull2(formatHash3, null),
  number: getNumber3,
  timestamp: getNumber3,
  nonce: allowNull2(formatData2),
  difficulty: getBigInt3,
  gasLimit: getBigInt3,
  gasUsed: getBigInt3,
  stateRoot: allowNull2(formatHash3, null),
  receiptsRoot: allowNull2(formatHash3, null),
  blobGasUsed: allowNull2(getBigInt3, null),
  excessBlobGas: allowNull2(getBigInt3, null),
  miner: allowNull2(getAddress2),
  extraData: formatData2,
  baseFeePerGas: allowNull2(getBigInt3)
});
function formatBlock2(value) {
  const result = _formatBlock2(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse2(tx);
  });
  return result;
}
var _formatReceiptLog2 = object2({
  transactionIndex: getNumber3,
  blockNumber: getNumber3,
  transactionHash: formatHash3,
  address: getAddress2,
  topics: arrayOf2(formatHash3),
  data: formatData2,
  index: getNumber3,
  blockHash: formatHash3
}, {
  index: ["logIndex"]
});
function formatReceiptLog2(value) {
  return _formatReceiptLog2(value);
}
var _formatTransactionReceipt2 = object2({
  to: allowNull2(getAddress2, null),
  from: allowNull2(getAddress2, null),
  contractAddress: allowNull2(getAddress2, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber3,
  root: allowNull2(hexlify3),
  gasUsed: getBigInt3,
  blobGasUsed: allowNull2(getBigInt3, null),
  logsBloom: allowNull2(formatData2),
  blockHash: formatHash3,
  hash: formatHash3,
  logs: arrayOf2(formatReceiptLog2),
  blockNumber: getNumber3,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt3,
  effectiveGasPrice: allowNull2(getBigInt3),
  blobGasPrice: allowNull2(getBigInt3, null),
  status: allowNull2(getNumber3),
  type: allowNull2(getNumber3, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt2(value) {
  return _formatTransactionReceipt2(value);
}
function formatTransactionResponse2(value) {
  if (value.to && getBigInt3(value.to) === BN_022) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object2({
    hash: formatHash3,
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber3(value2);
    },
    accessList: allowNull2(accessListify2, null),
    blobVersionedHashes: allowNull2(arrayOf2(formatHash3, true), null),
    blockHash: allowNull2(formatHash3, null),
    blockNumber: allowNull2(getNumber3, null),
    transactionIndex: allowNull2(getNumber3, null),
    //confirmations: allowNull(getNumber, null),
    from: getAddress2,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull2(getBigInt3),
    maxPriorityFeePerGas: allowNull2(getBigInt3),
    maxFeePerGas: allowNull2(getBigInt3),
    maxFeePerBlobGas: allowNull2(getBigInt3, null),
    gasLimit: getBigInt3,
    to: allowNull2(getAddress2, null),
    value: getBigInt3,
    nonce: getNumber3,
    data: formatData2,
    creates: allowNull2(getAddress2, null),
    chainId: allowNull2(getBigInt3, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress2(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature2.from(value.signature);
  } else {
    result.signature = Signature2.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt3(result.blockHash) === BN_022) {
    result.blockHash = null;
  }
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress2 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
var NetworkPlugin2 = class _NetworkPlugin {
  /**
   *  The name of the plugin.
   *
   *  It is recommended to use reverse-domain-notation, which permits
   *  unique names with a known authority as well as hierarchal entries.
   */
  name;
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    defineProperties3(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new _NetworkPlugin(this.name);
  }
};
var GasCostPlugin2 = class _GasCostPlugin extends NetworkPlugin2 {
  /**
   *  The block number to treat these values as valid from.
   *
   *  This allows a hardfork to have updated values included as well as
   *  mulutiple hardforks to be supported.
   */
  effectiveBlock;
  /**
   *  The transactions base fee.
   */
  txBase;
  /**
   *  The fee for creating a new account.
   */
  txCreate;
  /**
   *  The fee per zero-byte in the data.
   */
  txDataZero;
  /**
   *  The fee per non-zero-byte in the data.
   */
  txDataNonzero;
  /**
   *  The fee per storage key in the [[link-eip-2930]] access list.
   */
  txAccessListStorageKey;
  /**
   *  The fee per address in the [[link-eip-2930]] access list.
   */
  txAccessListAddress;
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument3(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties3(this, props);
  }
  clone() {
    return new _GasCostPlugin(this.effectiveBlock, this);
  }
};
var EnsPlugin2 = class _EnsPlugin extends NetworkPlugin2 {
  /**
   *  The ENS Registrty Contract address.
   */
  address;
  /**
   *  The chain ID that the ENS contract lives on.
   */
  targetNetwork;
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties3(this, {
      address: address || EnsAddress2,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new _EnsPlugin(this.address, this.targetNetwork);
  }
};
var FetchUrlFeeDataNetworkPlugin2 = class extends NetworkPlugin2 {
  #url;
  #processFunc;
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return this.#url;
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return this.#processFunc;
  }
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/network.js
var Networks2 = /* @__PURE__ */ new Map();
var Network2 = class _Network {
  #name;
  #chainId;
  #plugins;
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt3(chainId);
    this.#plugins = /* @__PURE__ */ new Map();
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt3(value, "chainId");
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt3(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt3(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt3(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin2();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify2(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks2();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks2.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument3(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument3(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom2 = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin2(network.ensAddress, network.ensNetwork));
      }
      return custom2;
    }
    assertArgument3(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks2.get(nameOrChainId);
    if (existing) {
      assertArgument3(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks2.set(nameOrChainId, networkFunc);
  }
};
function parseUnits3(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin2(url) {
  return new FetchUrlFeeDataNetworkPlugin2(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits3(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits3(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert3(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
var injected2 = false;
function injectCommonNetworks2() {
  if (injected2) {
    return;
  }
  injected2 = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network2(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin2(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin2());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network2.register(name, func);
    Network2.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network2.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin2("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin2("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy4(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var PollingBlockSubscriber2 = class {
  #provider;
  #poller;
  #interval;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4e3;
    this.#blockNumber = -2;
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async #poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b3 = this.#blockNumber + 1; b3 <= blockNumber; b3++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b3);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};
var OnBlockSubscriber2 = class {
  #provider;
  #poll;
  #running;
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
};
var PollingBlockTagSubscriber2 = class extends OnBlockSubscriber2 {
  #tag;
  #lastBlock;
  constructor(provider, tag) {
    super(provider);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
};
var PollingOrphanSubscriber2 = class extends OnBlockSubscriber2 {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy4(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
};
var PollingTransactionSubscriber2 = class extends OnBlockSubscriber2 {
  #hash;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash4) {
    super(provider);
    this.#hash = hash4;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
};
var PollingEventSubscriber2 = class {
  #provider;
  #filter;
  #poller;
  #running;
  // The most recent block we have scanned for events. The value -2
  // indicates we still need to fetch an initial block number
  #blockNumber;
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy4(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async #poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy4(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log of logs) {
      this.#provider.emit(this.#filter, log);
      this.#blockNumber = log.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_29 = BigInt(2);
var MAX_CCIP_REDIRECTS2 = 10;
function isPromise3(value) {
  return value && typeof value.then === "function";
}
function getTag2(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
var UnmanagedSubscriber2 = class {
  /**
   *  The name fof the event.
   */
  name;
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    defineProperties3(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
};
function copy5(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify2(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription2(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString3(_event, 32)) {
    const hash4 = _event.toLowerCase();
    return { type: "transaction", tag: getTag2("tx", { hash: hash4 }), hash: hash4 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag2("orphan", event), filter: copy5(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify2(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString3(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress2(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify2(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag2("event", filter), type: "event" };
  }
  assertArgument3(false, "unknown ProviderEvent", "event", _event);
}
function getTime5() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var defaultOptions3 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var AbstractProvider2 = class {
  #subs;
  #plugins;
  // null=unpaused, true=paused+dropWhilePaused, false=paused
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  // The most recent block number if running an event or -1 if no "block" event
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions3, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network2.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#plugins = /* @__PURE__ */ new Map();
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = /* @__PURE__ */ new Map();
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  // Shares multiple identical requests made during the same 250ms
  async #perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag2(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data4 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data4);
      const request = new FetchRequest2(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data: data4, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      const resp = await request.send();
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert3(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert3(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block2(formatBlock2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log2(formatLog2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt2(formatTransactionReceipt2(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse2(formatTransactionResponse2(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert3(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert3(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber3(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress2(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString3(blockTag)) {
      if (isHexString3(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity3(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber3(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity3(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity3(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b3) => toQuantity3(b3 + blockTag));
    }
    assertArgument3(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify2(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resovles to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request) {
    const request = copyRequest2(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress2(request[key], this);
      if (isPromise3(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise3(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert3(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties2({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt3(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt3(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_29 + maxPriorityFeePerGas;
      }
      return new FeeData2(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest2(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData2(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise3(tx)) {
      tx = await tx;
    }
    return getBigInt3(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async #call(tx, blockTag, attempt) {
    assert3(attempt < MAX_CCIP_REDIRECTS2, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest2(tx);
    try {
      return hexlify3(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException2(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice3(error.data, 0, 4) === "0x556f1830") {
        const data4 = error.data;
        const txSender = await resolveAddress2(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup2(dataSlice3(error.data, 4));
        } catch (error2) {
          assert3(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data: data4 }
          });
        }
        assert3(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data: data4,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert3(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat3([ccipArgs.selector, encodeBytes2([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async #checkNetwork(promise) {
    const { value } = await resolveProperties2({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties2({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  // Account
  async #getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt3(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber3(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify3(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt3(_position, "position");
    return hexlify3(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash4, network } = await resolveProperties2({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction2.from(signedTx);
    if (tx.hash !== hash4) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async #getBlock(block, includeTransactions) {
    if (isHexString3(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash4) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash4 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash4) {
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash4 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash4 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash4) {
    const { result } = await resolveProperties2({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash4 })
    });
    if (result == null) {
      return null;
    }
    return hexlify3(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise3(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties2({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert3(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver2.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress2(address);
    const node = namehash2(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver2.getEnsAddress(this);
      const ensContract = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress2) {
        return null;
      }
      const resolverContract = new Contract2(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError2(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError2(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash4, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash4);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash4);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError3("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert3(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime5() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub2 of this.#subs.values()) {
      func(sub2.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber2(sub2.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber2(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber2(this, sub2.type);
      case "event":
        return new PollingEventSubscriber2(this, sub2.filter);
      case "transaction":
        return new PollingTransactionSubscriber2(this, sub2.hash);
      case "orphan":
        return new PollingOrphanSubscriber2(this, sub2.filter);
    }
    throw new Error(`unsupported event: ${sub2.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub2 of this.#subs.values()) {
      if (sub2.subscriber === oldSub) {
        if (sub2.started) {
          sub2.subscriber.stop();
        }
        sub2.subscriber = newSub;
        if (sub2.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async #hasSub(event, emitArgs) {
    let sub2 = await getSubscription2(event, this);
    if (sub2.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub2 = await getSubscription2({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub2.tag) || null;
  }
  async #getSub(event) {
    const subscription = await getSubscription2(event, this);
    const tag = subscription.tag;
    let sub2 = this.#subs.get(tag);
    if (!sub2) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = /* @__PURE__ */ new WeakMap();
      const nameMap = /* @__PURE__ */ new Map();
      sub2 = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub2);
    }
    return sub2;
  }
  async on(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: false });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: true });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub2 = await this.#hasSub(event, args);
    if (!sub2 || sub2.listeners.length === 0) {
      return false;
    }
    ;
    const count = sub2.listeners.length;
    sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload2(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub2 = await this.#hasSub(event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (!listener || sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return this.#destroyed;
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert3(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime5() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s2) => s2.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime5();
      setTimeout(timer.func, timeout);
    }
  }
};
function _parseString2(result, start2) {
  try {
    const bytes2 = _parseBytes2(result, start2);
    if (bytes2) {
      return toUtf8String3(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes2(result, start2) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber3(dataSlice3(result, start2, start2 + 32));
    const length = getNumber3(dataSlice3(result, offset, offset + 32));
    return dataSlice3(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad2(value) {
  const result = toBeArray3(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad2(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
var empty2 = new Uint8Array([]);
function encodeBytes2(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty2);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data4 = getBytes3(datas[i]);
    result[i] = numPad2(byteCount);
    result.push(numPad2(data4.length));
    result.push(bytesPad2(data4));
    byteCount += 32 + Math.ceil(data4.length / 32) * 32;
  }
  return concat3(result);
}
var zeros2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup2(data4) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert3(dataLength3(data4) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice3(data4, 0, 32);
  assert3(dataSlice3(sender, 0, 12) === dataSlice3(zeros2, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice3(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber3(dataSlice3(data4, 32, 64));
    const urlsLength = getNumber3(dataSlice3(data4, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice3(data4, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString2(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert3(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes2(data4, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert3(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert3(dataSlice3(data4, 100, 128) === dataSlice3(zeros2, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice3(data4, 96, 100);
  try {
    const extraData = _parseBytes2(data4, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert3(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider2(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert3(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate2(signer, tx) {
  let pop = copyRequest2(tx);
  if (pop.to != null) {
    pop.to = resolveAddress2(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress2(from, signer)
    ]).then(([address, from2]) => {
      assertArgument3(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties2(pop);
}
var AbstractSigner2 = class {
  /**
   *  The provider this signer is connected to.
   */
  provider;
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    defineProperties3(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider2(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate2(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider2(this, "populateTransaction");
    const pop = await populate2(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt3(pop.chainId);
      assertArgument3(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument3(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument3(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert3(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert3(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert3(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties2(pop);
  }
  async estimateGas(tx) {
    return checkProvider2(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider2(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider2(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider2(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction2.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/community.js
var shown2 = /* @__PURE__ */ new Set();
function showThrottleMessage2(service) {
  if (shown2.has(service)) {
    return;
  }
  shown2.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy6(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var FilterIdSubscriber2 = class {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async #poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError2(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
};
var FilterIdEventSubscriber2 = class extends FilterIdSubscriber2 {
  #event;
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    this.#event = copy6(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber2(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(this.#event, provider._wrapLog(result, provider._network));
    }
  }
};
var FilterIdPendingSubscriber2 = class extends FilterIdSubscriber2 {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive2 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy2(value) {
  if (value == null || Primitive2.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy2);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall5(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase2(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable2(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions4 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var JsonRpcSigner2 = class extends AbstractSigner2 {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress2(address);
    defineProperties3(this, { address });
  }
  connect(provider) {
    assert3(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy2(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress2(_from, this.provider);
        assertArgument3(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress2(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash4 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash4);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError2(error, "CANCELLED") || isError2(error, "BAD_DATA") || isError2(error, "NETWORK_ERROR")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash4;
            reject(error);
            return;
          }
          if (isError2(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash4;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError3("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy2(_tx);
    if (tx.from) {
      const from = await resolveAddress2(tx.from, this.provider);
      assertArgument3(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes3(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify3(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value) {
    const value = deepCopy2(_value);
    const populated = await TypedDataEncoder2.resolveNames(domain, types, value, async (value2) => {
      const address = await resolveAddress2(value2);
      assertArgument3(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder2.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes3(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify3(message)
    ]);
  }
};
var JsonRpcApiProvider2 = class extends AbstractProvider2 {
  #options;
  // The next ID to use for the JSON-RPC ID field
  #nextId;
  // Payloads are queued and triggered in batches using the drainTimer
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes2 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes2.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError3("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r2) => r2.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError3("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions4, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument3(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network2.from(network);
      }
    } else if (staticNetwork) {
      assertArgument3(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return this.#options[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert3(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt3(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network2.from(getBigInt3(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error) {
          this.#pendingDetectNetwork = null;
          throw error;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network2.from(getBigInt3(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError3("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall5(1e3);
        }
      }
      this.#scheduleDrain();
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub2) {
    if (sub2.type === "pending") {
      return new FilterIdPendingSubscriber2(this);
    }
    if (sub2.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber2(this, sub2.filter);
      }
      return new FilterIdEventSubscriber2(this, sub2.filter);
    }
    if (sub2.type === "orphan" && sub2.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber2("orphan");
    }
    return super._getSubscriber(sub2);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return this.#notReady == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity3(getBigInt3(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify3(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify2(tx.accessList);
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase2(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase2(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase2);
          } else {
            req.filter.address = getLowerCase2(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError3("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData2(error);
      const e2 = AbiCoder2.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e2.info = { error, payload };
      return e2;
    }
    const message = JSON.stringify(spelunkMessage2(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError3(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError3("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError3("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError3("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError3("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError3("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError3("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError3("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner2(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties2({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress2(address);
    for (const account of accounts) {
      if (getAddress2(account) === address) {
        return new JsonRpcSigner2(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner2(this, a2));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError3("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
};
var JsonRpcApiPollingProvider2 = class extends JsonRpcApiProvider2 {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    this.#pollingInterval = 4e3;
  }
  _getSubscriber(sub2) {
    const subscriber = super._getSubscriber(sub2);
    if (isPollable2(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub2) => {
      if (isPollable2(sub2)) {
        sub2.pollingInterval = this.#pollingInterval;
      }
    });
  }
};
var JsonRpcProvider2 = class extends JsonRpcApiPollingProvider2 {
  #connect;
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest2(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
};
function spelunkData2(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString3(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData2(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData2(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage2(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage2(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage2(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage2(value) {
  const result = [];
  _spelunkMessage2(value, result);
  return result;
}

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-ankr.js
var defaultApiKey3 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost7(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument3(false, "unsupported network", "network", name);
}
var AnkrProvider2 = class _AnkrProvider extends JsonRpcProvider2 {
  /**
   *  The API key for the Ankr connection.
   */
  apiKey;
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey3;
    }
    const options = { polling: true, staticNetwork: network };
    const request = _AnkrProvider.getRequest(network, apiKey);
    super(request, network, options);
    defineProperties3(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AnkrProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%apiKey%%.
   */
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey3;
    }
    const request = new FetchRequest2(`https://${getHost7(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey3) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey3;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-alchemy.js
var defaultApiKey4 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost8(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument3(false, "unsupported network", "network", name);
}
var AlchemyProvider2 = class _AlchemyProvider extends JsonRpcProvider2 {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey4;
    }
    const request = _AlchemyProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties3(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new _AlchemyProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties2({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data4;
      let error = false;
      try {
        data4 = trace[0].result.output;
        error = trace[0].error === "Reverted";
      } catch (error2) {
      }
      if (data4) {
        assert3(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data: data4,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
          // @TODO
        });
        return data4;
      }
      assert3(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey4;
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey4;
    }
    const request = new FetchRequest2(`https://${getHost8(network.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey4) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("alchemy");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-cloudflare.js
var CloudflareProvider2 = class extends JsonRpcProvider2 {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    assertArgument3(network.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network, { staticNetwork: network });
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-etherscan.js
var THROTTLE2 = 2e3;
function isPromise4(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId2 = "org.ethers.plugins.provider.Etherscan";
var skipKeys2 = ["enableCcipRead"];
var nextId2 = 1;
var EtherscanProvider2 = class extends AbstractProvider2 {
  /**
   *  The connected network.
   */
  network;
  /**
   *  The API key or null if using the community provided bandwidth.
   */
  apiKey;
  #plugin;
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network = Network2.from(_network);
    this.#plugin = network.getPlugin(EtherscanPluginId2);
    defineProperties3(this, { apiKey, network });
    this.getBaseUrl();
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument3(false, "unsupported network", "network", this.network);
  }
  /**
   *  Returns the URL for the %%module%% and %%params%%.
   */
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module2}${query}${apiKey}`;
  }
  /**
   *  Returns the URL for using POST requests.
   */
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  /**
   *  Returns the parameters for using POST requests.
   */
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the result of calling %%module%% with %%params%%.
   *
   *  If %%post%%, the request is made as a POST request.
   */
  async fetch(module2, params, post) {
    const id3 = nextId2++;
    const url = post ? this.getPostUrl() : this.getUrl(module2, params);
    const payload = post ? this.getPostData(module2, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url, payload });
    const request = new FetchRequest2(url);
    request.setThrottleParams({ slotInterval: 1e3 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage2("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result2 = response2.hasBody() ? JSON.parse(toUtf8String3(response2.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module2 === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result2 });
          response2.throwThrottleError(result2.result, THROTTLE2);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result2.result });
          response2.throwThrottleError(result2.result, THROTTLE2);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error) {
      this.emit("debug", { action: "receiveError", id: id3, error, reason: "assertOk" });
      assert3(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert3(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result = JSON.parse(toUtf8String3(response.body));
    if (module2 === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "invalid JSON-RPC" });
        assert3(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "JSON-RPC error" });
        assert3(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result });
        assert3(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    }
  }
  /**
   *  Returns %%transaction%% normalized for the Etherscan API.
   */
  _getTransactionPostData(transaction) {
    const result = {};
    for (let key in transaction) {
      if (skipKeys2.indexOf(key) >= 0) {
        continue;
      }
      if (transaction[key] == null) {
        continue;
      }
      let value = transaction[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity3(value);
      } else if (key === "accessList") {
        value = "[" + accessListify2(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else {
        value = hexlify3(value);
      }
      result[key] = value;
    }
    return result;
  }
  /**
   *  Throws the normalized Etherscan error.
   */
  _checkError(req, error, transaction) {
    let message = "";
    if (isError2(error, "SERVER_ERROR")) {
      try {
        message = error.info.result.error.message;
      } catch (e2) {
      }
      if (!message) {
        try {
          message = error.info.message;
        } catch (e2) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert3(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data4 = "";
        try {
          data4 = error.info.result.error.data;
        } catch (error2) {
        }
        const e2 = AbiCoder2.getBuiltinCallException(req.method, req.transaction, data4);
        e2.info = { request: req, error };
        throw e2;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction2 = Transaction2.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert3(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction2
          });
        }
        if (message.match(/insufficient funds/)) {
          assert3(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction2
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert3(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction2
          });
        }
      }
    }
    throw error;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      /* Working with Etherscan to get this added:
      try {
          const test = await this.fetch("proxy", {
              action: "eth_maxPriorityFeePerGas"
          });
          console.log(test);
          return test;
      } catch (e) {
          console.log("DEBUG", e);
          throw e;
      }
      */
      /* This might be safe; but due to rounding neither myself
         or Etherscan are necessarily comfortable with this. :)
      try {
          const result = await this.fetch("gastracker", { action: "gasoracle" });
          console.log(result);
          const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
          const baseFee = parseUnits(result.suggestBaseFee, "gwei");
          const priorityFee = gasPrice - baseFee;
          if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
          return priorityFee;
      } catch (error) {
          console.log("DEBUG", error);
          throw error;
      }
      */
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error) => {
          return this._checkError(req, error, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert3(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      /*
                  case "getLogs": {
                      // Needs to complain if more than one address is passed in
                      const args: Record<string, any> = { action: "getLogs" }
      
                      if (params.filter.fromBlock) {
                          args.fromBlock = checkLogTag(params.filter.fromBlock);
                      }
      
                      if (params.filter.toBlock) {
                          args.toBlock = checkLogTag(params.filter.toBlock);
                      }
      
                      if (params.filter.address) {
                          args.address = params.filter.address;
                      }
      
                      // @TODO: We can handle slightly more complicated logs using the logs API
                      if (params.filter.topics && params.filter.topics.length > 0) {
                          if (params.filter.topics.length > 1) {
                              logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                          }
                          if (params.filter.topics.length === 1) {
                              const topic0 = params.filter.topics[0];
                              if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                  logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                              }
                              args.topic0 = topic0;
                          }
                      }
      
                      const logs: Array<any> = await this.fetch("logs", args);
      
                      // Cache txHash => blockHash
                      let blocks: { [tag: string]: string } = {};
      
                      // Add any missing blockHash to the logs
                      for (let i = 0; i < logs.length; i++) {
                          const log = logs[i];
                          if (log.blockHash != null) { continue; }
                          if (blocks[log.blockNumber] == null) {
                              const block = await this.getBlock(log.blockNumber);
                              if (block) {
                                  blocks[log.blockNumber] = block.hash;
                              }
                          }
      
                          log.blockHash = blocks[log.blockNumber];
                      }
      
                      return logs;
                  }
      */
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the current price of ether.
   *
   *  This returns ``0`` on any network other than ``mainnet``.
   */
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  /**
   *  Resolves to a [Contract]] for %%address%%, using the
   *  Etherscan API to retreive the Contract ABI.
   */
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise4(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi2 = JSON.parse(resp);
      return new Contract2(address, abi2, this);
    } catch (error) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// ../../node_modules/.pnpm/ws@8.5.0/node_modules/ws/wrapper.mjs
var import_stream2 = __toESM(require_stream2(), 1);
var import_receiver2 = __toESM(require_receiver2(), 1);
var import_sender2 = __toESM(require_sender2(), 1);
var import_websocket2 = __toESM(require_websocket2(), 1);
var import_websocket_server2 = __toESM(require_websocket_server2(), 1);

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-socket.js
var SocketSubscriber2 = class {
  #provider;
  #filter;
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = JSON.stringify(filter);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      ;
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert3(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
};
var SocketBlockSubscriber2 = class extends SocketSubscriber2 {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
};
var SocketPendingSubscriber2 = class extends SocketSubscriber2 {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
};
var SocketEventSubscriber2 = class extends SocketSubscriber2 {
  #logFilter;
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  /**
   *  @_ignore:
   */
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    this.#logFilter = JSON.stringify(filter);
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
};
var SocketProvider2 = class extends JsonRpcApiProvider2 {
  #callbacks;
  // Maps each filterId to its subscriber
  #subs;
  // If any events come in before a subscriber has finished
  // registering, queue them
  #pending;
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument3(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    this.#callbacks = /* @__PURE__ */ new Map();
    this.#subs = /* @__PURE__ */ new Map();
    this.#pending = /* @__PURE__ */ new Map();
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "close":
        return new UnmanagedSubscriber2("close");
      case "block":
        return new SocketBlockSubscriber2(this);
      case "pending":
        return new SocketPendingSubscriber2(this);
      case "event":
        return new SocketEventSubscriber2(this, sub2.filter);
      case "orphan":
        if (sub2.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber2("drop-log");
        }
    }
    return super._getSubscriber(sub2);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument3(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = this.#callbacks.get(result.id);
      if (callback == null) {
        this.emit("error", makeError3("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      this.#callbacks.delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError3("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-websocket.js
var WebSocketProvider2 = class extends SocketProvider2 {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url, network, options) {
    super(network, options);
    if (typeof url === "string") {
      this.#connect = () => {
        return new import_websocket2.default(url);
      };
      this.#websocket = this.#connect();
    } else if (typeof url === "function") {
      this.#connect = url;
      this.#websocket = url();
    } else {
      this.#connect = null;
      this.#websocket = url;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-infura.js
var defaultProjectId2 = "84842078b09946638c03157f83405213";
function getHost9(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument3(false, "unsupported network", "network", name);
}
var InfuraWebSocketProvider2 = class extends WebSocketProvider2 {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network, projectId) {
    const provider = new InfuraProvider2(network, projectId);
    const req = provider._getConnection();
    assert3(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineProperties3(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId2;
  }
};
var InfuraProvider2 = class _InfuraProvider extends JsonRpcProvider2 {
  /**
   *  The Project ID for the INFURA connection.
   */
  projectId;
  /**
   *  The Project Secret.
   *
   *  If null, no authenticated requests are made. This should not
   *  be used outside of private contexts.
   */
  projectSecret;
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId2;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    defineProperties3(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId2;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider2(network, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId2;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest2(`https://${getHost9(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("InfuraProvider");
        return true;
      };
    }
    return request;
  }
};

// ../../node_modules/.pnpm/ethers@6.11.0/node_modules/ethers/lib.esm/providers/provider-pocket.js
var defaultApplicationId2 = "62e1ad51b37b8e00394bda3b";
function getHost10(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument3(false, "unsupported network", "network", name);
}
var PocketProvider2 = class _PocketProvider extends JsonRpcProvider2 {
  /**
   *  The Application ID for the Pocket connection.
   */
  applicationId;
  /**
   *  The Application Secret for making authenticated requests
   *  to the Pocket connection.
   */
  applicationSecret;
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network2.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId2;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network };
    const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
    super(request, network, options);
    defineProperties3(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%applicationId%%.
   */
  static getRequest(network, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId2;
    }
    const request = new FetchRequest2(`https://${getHost10(network.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage2("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId2;
  }
};

// ../../node_modules/.pnpm/@semaphore-protocol+data@4.7.0/node_modules/@semaphore-protocol/data/dist/index.js
function checkParameter(value, name, type) {
  if (typeof value !== type) {
    throw new TypeError(`Parameter '${name}' is not ${type === "object" ? "an" : "a"} ${type}`);
  }
}
async function getEvents(contract2, eventName, filterArgs = [], startBlock = 0) {
  const filter = contract2.filters[eventName](...filterArgs);
  const events = await contract2.queryFilter(filter, startBlock);
  return events.map(({ args, blockNumber }) => [...args, blockNumber]);
}
var SemaphoreEthers = class {
  /**
   * Constructs a new SemaphoreEthers instance, initializing it with a network or a custom Ethereum node URL,
   * and optional configuration settings for the ethers provider and contract.
   * @param networkOrEthereumURL The Ethereum network name or a custom JSON-RPC URL to connect to.
   * @param options Configuration options for the ethers provider and the Semaphore contract.
   */
  constructor(networkOrEthereumURL = defaultNetwork, options = {}) {
    checkParameter(networkOrEthereumURL, "networkOrEthereumURL", "string");
    if (options.provider) {
      checkParameter(options.provider, "provider", "string");
    } else if (!networkOrEthereumURL.startsWith("http")) {
      options.provider = "infura";
    }
    if (options.apiKey) {
      checkParameter(options.apiKey, "apiKey", "string");
    }
    if (isSupportedNetwork(networkOrEthereumURL)) {
      const { address, startBlock } = getDeployedContract(networkOrEthereumURL);
      options.address ?? (options.address = address);
      options.startBlock ?? (options.startBlock = startBlock);
    } else {
      if (options.address === void 0) {
        throw new Error(`Network '${networkOrEthereumURL}' needs a Semaphore contract address`);
      }
      options.startBlock ?? (options.startBlock = 0);
    }
    let provider;
    switch (options.provider) {
      case "infura":
        provider = new InfuraProvider2(networkOrEthereumURL, options.projectId, options.projectSecret);
        break;
      case "alchemy":
        provider = new AlchemyProvider2(networkOrEthereumURL, options.apiKey);
        break;
      case "cloudflare":
        provider = new CloudflareProvider2(networkOrEthereumURL);
        break;
      case "etherscan":
        provider = new EtherscanProvider2(networkOrEthereumURL, options.apiKey);
        break;
      case "pocket":
        provider = new PocketProvider2(networkOrEthereumURL, options.applicationId, options.applicationSecret);
        break;
      case "ankr":
        provider = new AnkrProvider2(networkOrEthereumURL, options.apiKey);
        break;
      default:
        if (!networkOrEthereumURL.startsWith("http")) {
          throw new Error(`Provider '${options.provider}' is not supported`);
        }
        provider = new JsonRpcProvider2(networkOrEthereumURL);
    }
    this._network = networkOrEthereumURL;
    this._options = options;
    this._contract = new Contract2(options.address, SemaphoreABI, provider);
  }
  /**
   * Retrieves the Ethereum network or custom URL currently used by this instance.
   * @returns The network or URL as a string.
   */
  get network() {
    return this._network;
  }
  /**
   * Retrieves the options used for configuring the ethers provider and the Semaphore contract.
   * @returns The configuration options.
   */
  get options() {
    return this._options;
  }
  /**
   * Retrieves the ethers Contract instance used to interact with the Semaphore contract.
   * @returns The Contract instance.
   */
  get contract() {
    return this._contract;
  }
  /**
   * Fetches the list of group IDs from the Semaphore contract by querying the "GroupCreated" events.
   * @returns A promise that resolves to an array of group IDs as strings.
   */
  async getGroupIds() {
    const groups = await getEvents(this._contract, "GroupCreated", [], this._options.startBlock);
    return groups.map((event) => event[0].toString());
  }
  /**
   * Retrieves detailed information about a specific group by its ID. This method queries the Semaphore contract
   * to get the group's admin, Merkle tree root, depth, and size.
   * @param groupId The unique identifier of the group.
   * @returns A promise that resolves to a GroupResponse object.
   */
  async getGroup(groupId) {
    checkParameter(groupId, "groupId", "string");
    const groupAdmin = await this._contract.getGroupAdmin(groupId);
    if (groupAdmin === ZeroAddress2) {
      throw new Error(`Group '${groupId}' not found`);
    }
    const merkleTreeRoot = await this._contract.getMerkleTreeRoot(groupId);
    const merkleTreeDepth = await this._contract.getMerkleTreeDepth(groupId);
    const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
    const group = {
      id: groupId,
      admin: groupAdmin,
      merkleTree: {
        depth: Number(merkleTreeDepth),
        size: Number(merkleTreeSize),
        root: merkleTreeRoot.toString()
      }
    };
    return group;
  }
  /**
   * Fetches a list of members from a specific group. This method queries the Semaphore contract for events
   * related to member additions and updates, and constructs the list of current group members.
   * @param groupId The unique identifier of the group.
   * @returns A promise that resolves to an array of member identity commitments as strings.
   */
  async getGroupMembers(groupId) {
    checkParameter(groupId, "groupId", "string");
    const groupAdmin = await this._contract.getGroupAdmin(groupId);
    if (groupAdmin === ZeroAddress2) {
      throw new Error(`Group '${groupId}' not found`);
    }
    const memberRemovedEvents = await getEvents(this._contract, "MemberRemoved", [groupId], this._options.startBlock);
    const memberUpdatedEvents = await getEvents(this._contract, "MemberUpdated", [groupId], this._options.startBlock);
    const memberUpdatedEventsMap = /* @__PURE__ */ new Map();
    for (const [, index, , newIdentityCommitment, , blockNumber] of memberUpdatedEvents) {
      memberUpdatedEventsMap.set(index.toString(), [blockNumber, newIdentityCommitment.toString()]);
    }
    for (const [, index, , , blockNumber] of memberRemovedEvents) {
      const groupUpdate = memberUpdatedEventsMap.get(index.toString());
      if (!groupUpdate || groupUpdate && groupUpdate[0] < blockNumber) {
        memberUpdatedEventsMap.set(index.toString(), [blockNumber, "0"]);
      }
    }
    const membersAddedEvents = await getEvents(this._contract, "MembersAdded", [groupId], this._options.startBlock);
    const membersAddedEventsMap = /* @__PURE__ */ new Map();
    for (const [, startIndex, identityCommitments] of membersAddedEvents) {
      membersAddedEventsMap.set(startIndex.toString(), identityCommitments.map((i2) => i2.toString()));
    }
    const memberAddedEvents = await getEvents(this._contract, "MemberAdded", [groupId], this._options.startBlock);
    const members = [];
    const merkleTreeSize = await this._contract.getMerkleTreeSize(groupId);
    let i = 0;
    while (i < Number(merkleTreeSize)) {
      const identityCommitments = membersAddedEventsMap.get(i.toString());
      if (identityCommitments) {
        members.push(...identityCommitments);
        i += identityCommitments.length;
      } else {
        members.push(memberAddedEvents[i][2]);
        i += 1;
      }
    }
    for (let j = 0; j < members.length; j += 1) {
      const groupUpdate = memberUpdatedEventsMap.get(j.toString());
      if (groupUpdate) {
        members[j] = groupUpdate[1].toString();
      }
    }
    return members;
  }
  /**
   * Retrieves a list of validated proofs for a specific group. This method queries the Semaphore contract
   * for "ProofValidated" events and returns details about each proof.
   * @param groupId The unique identifier of the group.
   * @returns A promise that resolves to an array of validated proofs.
   */
  async getGroupValidatedProofs(groupId) {
    checkParameter(groupId, "groupId", "string");
    const groupAdmin = await this._contract.getGroupAdmin(groupId);
    if (groupAdmin === ZeroAddress2) {
      throw new Error(`Group '${groupId}' not found`);
    }
    const proofValidatedEvents = await getEvents(this._contract, "ProofValidated", [groupId], this._options.startBlock);
    return proofValidatedEvents.map((event) => ({
      merkleTreeDepth: Number(event[1]),
      merkleTreeRoot: event[2].toString(),
      nullifier: event[3].toString(),
      message: event[4].toString(),
      scope: event[5].toString(),
      points: event[6].map((p) => p.toString())
    }));
  }
  /**
   * Checks whether a specific member is part of a group. This method queries the Semaphore contract
   * to determine if the provided identity commitment is a member of the specified group.
   * @param groupId The unique identifier of the group.
   * @param member The identity commitment of the member to check.
   * @returns A promise that resolves to true if the member is part of the group, otherwise false.
   */
  async isGroupMember(groupId, member) {
    checkParameter(groupId, "groupId", "string");
    checkParameter(member, "member", "string");
    return this._contract.hasMember(groupId, member);
  }
};

// ../contracts/clients/ethers/semaphore.ts
var ethNetworkProviderUrl = "http://127.0.0.1:8545";
var semaphore = new SemaphoreEthers(ethNetworkProviderUrl, {
  address: SEMAPHORE_CONTRACT_ADDRESS
});

// index.ts
var app = (0, import_fastify.default)();
var evaluationContract;
app.register(import_cors.default, {
  origin: "*"
  //TODO: .env only :9000
});
var s = initServer();
var router = s.router(contract, {
  vote: async ({ body }) => {
    console.log("vote");
    const { vote, identityPk, groupId } = body;
    const _users = await semaphore.getGroupMembers(groupId);
    console.log({ _users });
    const group = new Group(_users);
    const message = encodeBytes32String(vote);
    const _identity = Identity.import(identityPk);
    console.log("received identity", _identity.commitment.toString());
    const proof = await generateProof(_identity, group, message, groupId);
    const txResponse = await evaluationContract.vote(
      groupId,
      proof.merkleTreeDepth,
      proof.merkleTreeRoot,
      proof.nullifier,
      BigInt(message),
      proof.points
    );
    const txReceipt = await txResponse.wait();
    console.log({ txReceipt });
    if (txReceipt?.status !== 1) {
      throw new Error("Transaction failed");
    }
    return {
      status: 200,
      body: null
    };
  }
});
app.register(s.plugin(router));
var start = async () => {
  const { rpcContract } = evaluationContractPlatform.getRpcContract();
  evaluationContract = rpcContract;
  try {
    console.log("Starting server...", { port: 3e3 });
    await app.listen({ port: 3e3 });
  } catch (err) {
    console.error(err);
    app.log.error(err);
    process.exit(1);
  }
};
start();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  router
});
/*! Bundled license information:

forwarded/index.js:
  (*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toad-cache/dist/toad-cache.cjs:
  (**
   * toad-cache
   *
   * @copyright 2024 Igor Savin <kibertoad@gmail.com>
   * @license MIT
   * @version 3.7.0
   *)

light-my-request/lib/form-data.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

ejs/lib/ejs.js:
  (**
   * @file Embedded JavaScript templating engine. {@link http://ejs.co}
   * @author Matthew Eernisse <mde@fleegix.org>
   * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
   * @project EJS
   * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
   *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

aes-js/lib.esm/aes.js:
  (*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. *)

@zk-kit/utils/dist/lib.esm/type-checks.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/utils/dist/lib.esm/error-handlers.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/utils/dist/lib.esm/conversions.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/utils/dist/lib.esm/scalar.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/utils/dist/lib.esm/f1-field.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/baby-jubjub/dist/index.js:
  (**
   * @module @zk-kit/baby-jubjub
   * @version 1.0.3
   * @file A JavaScript library for adding points to the curve.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/baby-jubjub}
  *)

@zk-kit/utils/dist/index.node.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@zk-kit/eddsa-poseidon/dist/index.js:
  (**
   * @module @zk-kit/eddsa-poseidon
   * @version 1.0.4
   * @file A JavaScript EdDSA library for secure signing and verification using Poseidon the Baby Jubjub elliptic curve.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/eddsa-poseidon}
  *)

@semaphore-protocol/identity/dist/index.js:
  (**
   * @module @semaphore-protocol/identity
   * @version 4.7.0
   * @file A library to create Semaphore identities.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/identity}
  *)

@zk-kit/lean-imt/dist/index.js:
  (**
   * @module @zk-kit/lean-imt
   * @version 2.2.1
   * @file Lean Incremental Merkle tree implementation in TypeScript.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/lean-imt}
  *)

@semaphore-protocol/group/dist/index.js:
  (**
   * @module @semaphore-protocol/group
   * @version 4.7.0
   * @file A library to create and manage Semaphore groups.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/group}
  *)

@zk-kit/utils/dist/lib.esm/proof-packing.js:
  (**
   * @module @zk-kit/utils
   * @version 1.2.1
   * @file Essential zero-knowledge utility library for JavaScript developers.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
  *)

@semaphore-protocol/utils/dist/lib.esm/semaphore-interface.json.js:
  (**
   * @module @semaphore-protocol/utils
   * @version 4.7.0
   * @file A library to provide utility functions to the other Semaphore packages.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/utils}
  *)

@semaphore-protocol/utils/dist/lib.esm/constants.js:
  (**
   * @module @semaphore-protocol/utils
   * @version 4.7.0
   * @file A library to provide utility functions to the other Semaphore packages.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/utils}
  *)

@zk-kit/artifacts/dist/index.node.js:
  (**
   * @module @zk-kit/artifacts
   * @version 1.8.0
   * @file Utilities for downloading snark artifacts
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/privacy-scaling-explorations/snark-artifacts/tree/main/packages/artifacts}
  *)

@semaphore-protocol/proof/dist/index.node.js:
  (**
   * @module @semaphore-protocol/proof
   * @version 4.7.0
   * @file A library to generate and verify Semaphore proofs.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/proof}
  *)

@semaphore-protocol/utils/dist/lib.esm/networks/deployed-contracts.json.js:
  (**
   * @module @semaphore-protocol/utils
   * @version 4.7.0
   * @file A library to provide utility functions to the other Semaphore packages.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/utils}
  *)

@semaphore-protocol/utils/dist/lib.esm/networks/supported-networks.js:
  (**
   * @module @semaphore-protocol/utils
   * @version 4.7.0
   * @file A library to provide utility functions to the other Semaphore packages.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/utils}
  *)

@semaphore-protocol/utils/dist/lib.esm/networks/index.js:
  (**
   * @module @semaphore-protocol/utils
   * @version 4.7.0
   * @file A library to provide utility functions to the other Semaphore packages.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/utils}
  *)

@semaphore-protocol/data/dist/index.js:
  (**
   * @module @semaphore-protocol/data
   * @version 4.7.0
   * @file A library for querying Semaphore smart contract.
   * @copyright Ethereum Foundation 2024
   * @license MIT
   * @see [Github]{@link https://github.com/semaphore-protocol/semaphore/tree/main/packages/data}
  *)
*/
